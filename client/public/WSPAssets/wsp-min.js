/*!
  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved. 
  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20221219154059

  Web Sketchpad uses the Alphanum Algorithm by Brian Huisman and David Koelle, which is
  available here:
  http://www.davekoelle.com/files/alphanum.js

  Web Sketchpad uses FastClick, By the Financial Times, which includes this license:

  Copyright (c) 2014 The Financial Times Ltd.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation
  files (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use,
  copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

*/

/**
 * @fileOverview Fragment included at the top of the WSP-library - comments only - no code.
 * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
 * @version 0.0
 * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
 *
 *  Put comments below intended to survive minification / compression,
 *  e.g. copyright notice.
 *
 *  Individual files should have:
 *  Copyright © 2012-2013 KCP Technologies, Inc. All rights reserved.
 *  but it's OK to let those be stripped out in the build process.
 *
 */ function hex_md5(e) {
  return rstr2hex(rstr_md5(str2rstr_utf8(e)));
}
function b64_md5(e) {
  return rstr2b64(rstr_md5(str2rstr_utf8(e)));
}
function any_md5(e, t) {
  return rstr2any(rstr_md5(str2rstr_utf8(e)), t);
}
function hex_hmac_md5(e, t) {
  return rstr2hex(rstr_hmac_md5(str2rstr_utf8(e), str2rstr_utf8(t)));
}
function b64_hmac_md5(e, t) {
  return rstr2b64(rstr_hmac_md5(str2rstr_utf8(e), str2rstr_utf8(t)));
}
function any_hmac_md5(e, t, n) {
  return rstr2any(rstr_hmac_md5(str2rstr_utf8(e), str2rstr_utf8(t)), n);
}
function md5_vm_test() {
  return '900150983cd24fb0d6963f7d28e17f72' === hex_md5('abc').toLowerCase();
}
function rstr_md5(e) {
  return binl2rstr(binl_md5(rstr2binl(e), 8 * e.length));
}
function rstr_hmac_md5(e, t) {
  var n = rstr2binl(e);
  n.length > 16 && (n = binl_md5(n, 8 * e.length));
  for (var i = Array(16), r = Array(16), s = 0; 16 > s; s++)
    (i[s] = 909522486 ^ n[s]), (r[s] = 1549556828 ^ n[s]);
  var o = binl_md5(i.concat(rstr2binl(t)), 512 + 8 * t.length);
  return binl2rstr(binl_md5(r.concat(o), 640));
}
function rstr2hex(e) {
  for (
    var t, n = hexcase ? '0123456789ABCDEF' : '0123456789abcdef', i = '', r = 0;
    r < e.length;
    r++
  )
    (t = e.charCodeAt(r)), (i += n.charAt((t >>> 4) & 15) + n.charAt(15 & t));
  return i;
}
function rstr2b64(e) {
  b64pad = b64pad || '';
  for (
    var t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      n = '',
      i = e.length,
      r = 0;
    i > r;
    r += 3
  )
    for (
      var s =
          (e.charCodeAt(r) << 16) |
          (i > r + 1 ? e.charCodeAt(r + 1) << 8 : 0) |
          (i > r + 2 ? e.charCodeAt(r + 2) : 0),
        o = 0;
      4 > o;
      o++
    )
      n +=
        8 * r + 6 * o > 8 * e.length
          ? b64pad
          : t.charAt((s >>> (6 * (3 - o))) & 63);
  return n;
}
function rstr2any(e, t) {
  var n,
    i,
    r,
    s,
    o,
    a = t.length,
    c = Array(Math.ceil(e.length / 2));
  for (n = 0; n < c.length; n++)
    c[n] = (e.charCodeAt(2 * n) << 8) | e.charCodeAt(2 * n + 1);
  var l = Math.ceil((8 * e.length) / (Math.log(t.length) / Math.log(2))),
    u = Array(l);
  for (i = 0; l > i; i++) {
    for (o = Array(), s = 0, n = 0; n < c.length; n++)
      (s = (s << 16) + c[n]),
        (r = Math.floor(s / a)),
        (s -= r * a),
        (o.length > 0 || r > 0) && (o[o.length] = r);
    (u[i] = s), (c = o);
  }
  var d = '';
  for (n = u.length - 1; n >= 0; n--) d += t.charAt(u[n]);
  return d;
}
function str2rstr_utf8(e) {
  for (var t, n, i = '', r = -1; ++r < e.length; )
    (t = e.charCodeAt(r)),
      (n = r + 1 < e.length ? e.charCodeAt(r + 1) : 0),
      t >= 55296 &&
        56319 >= t &&
        n >= 56320 &&
        57343 >= n &&
        ((t = 65536 + ((1023 & t) << 10) + (1023 & n)), r++),
      127 >= t
        ? (i += String.fromCharCode(t))
        : 2047 >= t
        ? (i += String.fromCharCode(192 | ((t >>> 6) & 31), 128 | (63 & t)))
        : 65535 >= t
        ? (i += String.fromCharCode(
            224 | ((t >>> 12) & 15),
            128 | ((t >>> 6) & 63),
            128 | (63 & t)
          ))
        : 2097151 >= t &&
          (i += String.fromCharCode(
            240 | ((t >>> 18) & 7),
            128 | ((t >>> 12) & 63),
            128 | ((t >>> 6) & 63),
            128 | (63 & t)
          ));
  return i;
}
function str2rstr_utf16le(e) {
  for (var t = '', n = 0; n < e.length; n++)
    t += String.fromCharCode(
      255 & e.charCodeAt(n),
      (e.charCodeAt(n) >>> 8) & 255
    );
  return t;
}
function str2rstr_utf16be(e) {
  for (var t = '', n = 0; n < e.length; n++)
    t += String.fromCharCode(
      (e.charCodeAt(n) >>> 8) & 255,
      255 & e.charCodeAt(n)
    );
  return t;
}
function rstr2binl(e) {
  var t,
    n = Array(e.length >> 2);
  for (t = 0; t < n.length; t++) n[t] = 0;
  for (t = 0; t < 8 * e.length; t += 8)
    n[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
  return n;
}
function binl2rstr(e) {
  for (var t = '', n = 0; n < 32 * e.length; n += 8)
    t += String.fromCharCode((e[n >> 5] >>> n % 32) & 255);
  return t;
}
function binl_md5(e, t) {
  (e[t >> 5] |= 128 << t % 32), (e[(((t + 64) >>> 9) << 4) + 14] = t);
  for (
    var n = 1732584193, i = -271733879, r = -1732584194, s = 271733878, o = 0;
    o < e.length;
    o += 16
  ) {
    var a = n,
      c = i,
      l = r,
      u = s;
    (n = md5_ff(n, i, r, s, e[o + 0], 7, -680876936)),
      (s = md5_ff(s, n, i, r, e[o + 1], 12, -389564586)),
      (r = md5_ff(r, s, n, i, e[o + 2], 17, 606105819)),
      (i = md5_ff(i, r, s, n, e[o + 3], 22, -1044525330)),
      (n = md5_ff(n, i, r, s, e[o + 4], 7, -176418897)),
      (s = md5_ff(s, n, i, r, e[o + 5], 12, 1200080426)),
      (r = md5_ff(r, s, n, i, e[o + 6], 17, -1473231341)),
      (i = md5_ff(i, r, s, n, e[o + 7], 22, -45705983)),
      (n = md5_ff(n, i, r, s, e[o + 8], 7, 1770035416)),
      (s = md5_ff(s, n, i, r, e[o + 9], 12, -1958414417)),
      (r = md5_ff(r, s, n, i, e[o + 10], 17, -42063)),
      (i = md5_ff(i, r, s, n, e[o + 11], 22, -1990404162)),
      (n = md5_ff(n, i, r, s, e[o + 12], 7, 1804603682)),
      (s = md5_ff(s, n, i, r, e[o + 13], 12, -40341101)),
      (r = md5_ff(r, s, n, i, e[o + 14], 17, -1502002290)),
      (i = md5_ff(i, r, s, n, e[o + 15], 22, 1236535329)),
      (n = md5_gg(n, i, r, s, e[o + 1], 5, -165796510)),
      (s = md5_gg(s, n, i, r, e[o + 6], 9, -1069501632)),
      (r = md5_gg(r, s, n, i, e[o + 11], 14, 643717713)),
      (i = md5_gg(i, r, s, n, e[o + 0], 20, -373897302)),
      (n = md5_gg(n, i, r, s, e[o + 5], 5, -701558691)),
      (s = md5_gg(s, n, i, r, e[o + 10], 9, 38016083)),
      (r = md5_gg(r, s, n, i, e[o + 15], 14, -660478335)),
      (i = md5_gg(i, r, s, n, e[o + 4], 20, -405537848)),
      (n = md5_gg(n, i, r, s, e[o + 9], 5, 568446438)),
      (s = md5_gg(s, n, i, r, e[o + 14], 9, -1019803690)),
      (r = md5_gg(r, s, n, i, e[o + 3], 14, -187363961)),
      (i = md5_gg(i, r, s, n, e[o + 8], 20, 1163531501)),
      (n = md5_gg(n, i, r, s, e[o + 13], 5, -1444681467)),
      (s = md5_gg(s, n, i, r, e[o + 2], 9, -51403784)),
      (r = md5_gg(r, s, n, i, e[o + 7], 14, 1735328473)),
      (i = md5_gg(i, r, s, n, e[o + 12], 20, -1926607734)),
      (n = md5_hh(n, i, r, s, e[o + 5], 4, -378558)),
      (s = md5_hh(s, n, i, r, e[o + 8], 11, -2022574463)),
      (r = md5_hh(r, s, n, i, e[o + 11], 16, 1839030562)),
      (i = md5_hh(i, r, s, n, e[o + 14], 23, -35309556)),
      (n = md5_hh(n, i, r, s, e[o + 1], 4, -1530992060)),
      (s = md5_hh(s, n, i, r, e[o + 4], 11, 1272893353)),
      (r = md5_hh(r, s, n, i, e[o + 7], 16, -155497632)),
      (i = md5_hh(i, r, s, n, e[o + 10], 23, -1094730640)),
      (n = md5_hh(n, i, r, s, e[o + 13], 4, 681279174)),
      (s = md5_hh(s, n, i, r, e[o + 0], 11, -358537222)),
      (r = md5_hh(r, s, n, i, e[o + 3], 16, -722521979)),
      (i = md5_hh(i, r, s, n, e[o + 6], 23, 76029189)),
      (n = md5_hh(n, i, r, s, e[o + 9], 4, -640364487)),
      (s = md5_hh(s, n, i, r, e[o + 12], 11, -421815835)),
      (r = md5_hh(r, s, n, i, e[o + 15], 16, 530742520)),
      (i = md5_hh(i, r, s, n, e[o + 2], 23, -995338651)),
      (n = md5_ii(n, i, r, s, e[o + 0], 6, -198630844)),
      (s = md5_ii(s, n, i, r, e[o + 7], 10, 1126891415)),
      (r = md5_ii(r, s, n, i, e[o + 14], 15, -1416354905)),
      (i = md5_ii(i, r, s, n, e[o + 5], 21, -57434055)),
      (n = md5_ii(n, i, r, s, e[o + 12], 6, 1700485571)),
      (s = md5_ii(s, n, i, r, e[o + 3], 10, -1894986606)),
      (r = md5_ii(r, s, n, i, e[o + 10], 15, -1051523)),
      (i = md5_ii(i, r, s, n, e[o + 1], 21, -2054922799)),
      (n = md5_ii(n, i, r, s, e[o + 8], 6, 1873313359)),
      (s = md5_ii(s, n, i, r, e[o + 15], 10, -30611744)),
      (r = md5_ii(r, s, n, i, e[o + 6], 15, -1560198380)),
      (i = md5_ii(i, r, s, n, e[o + 13], 21, 1309151649)),
      (n = md5_ii(n, i, r, s, e[o + 4], 6, -145523070)),
      (s = md5_ii(s, n, i, r, e[o + 11], 10, -1120210379)),
      (r = md5_ii(r, s, n, i, e[o + 2], 15, 718787259)),
      (i = md5_ii(i, r, s, n, e[o + 9], 21, -343485551)),
      (n = safe_add(n, a)),
      (i = safe_add(i, c)),
      (r = safe_add(r, l)),
      (s = safe_add(s, u));
  }
  return Array(n, i, r, s);
}
function md5_cmn(e, t, n, i, r, s) {
  return safe_add(bit_rol(safe_add(safe_add(t, e), safe_add(i, s)), r), n);
}
function md5_ff(e, t, n, i, r, s, o) {
  return md5_cmn((t & n) | (~t & i), e, t, r, s, o);
}
function md5_gg(e, t, n, i, r, s, o) {
  return md5_cmn((t & i) | (n & ~i), e, t, r, s, o);
}
function md5_hh(e, t, n, i, r, s, o) {
  return md5_cmn(t ^ n ^ i, e, t, r, s, o);
}
function md5_ii(e, t, n, i, r, s, o) {
  return md5_cmn(n ^ (t | ~i), e, t, r, s, o);
}
function safe_add(e, t) {
  var n = (65535 & e) + (65535 & t),
    i = (e >> 16) + (t >> 16) + (n >> 16);
  return (i << 16) | (65535 & n);
}
function bit_rol(e, t) {
  return (e << t) | (e >>> (32 - t));
}
!(function() {
  function e() {}
  function t(e) {
    var t = e.length - 1;
    return function() {
      var n = x.call(arguments, 0, t),
        i = x.call(arguments, t);
      return e.apply(this, n.concat([i]));
    };
  }
  function n(e) {
    return t(function(t, n) {
      'function' != typeof t && (t = w(t));
      var i = function(e) {
        return t.apply(e, [e].concat(n));
      };
      return e.call(this, i);
    });
  }
  function i(e) {
    var t = x.call(arguments, 1);
    return function() {
      return e.apply(this, t);
    };
  }
  function r(e, t) {
    if (!t) throw new Error('prayer failed: ' + e);
  }
  function s(e) {
    r('a direction was passed', e === P || e === C);
  }
  function o(e, t, n) {
    r('a parent is always present', e),
      r(
        'leftward is properly set up',
        (function() {
          return t ? t[C] === n && t.parent === e : e.ends[P] === n;
        })()
      ),
      r(
        'rightward is properly set up',
        (function() {
          return n ? n[P] === t && n.parent === e : e.ends[C] === t;
        })()
      );
  }
  function a(e) {
    if (!e || !e.nodeType) return null;
    var t = S(e)
      .children('.mq-root-block')
      .attr(b);
    return t ? T.byId[t].controller.API : null;
  }
  function c(e) {
    function t(t, n) {
      var i = a(t);
      return i instanceof e || !t || !t.nodeType ? i : e(S(t), n);
    }
    return (t.prototype = e.prototype), t;
  }
  function l(e) {
    for (
      var t = 'moveOutOf deleteOutOf selectOutOf upOutOf downOutOf reflow'.split(
          ' '
        ),
        n = 0;
      n < t.length;
      n += 1
    )
      (function(t) {
        e[t] = function(e) {
          this.controller.handle(t, e);
        };
      })(t[n]);
  }
  function u(e, t, n) {
    return k(X, {
      ctrlSeq: e,
      htmlTemplate: '<' + t + ' ' + n + '>&0</' + t + '>',
    });
  }
  function d(e) {
    var t = this.parent,
      n = e;
    do {
      if (n[C]) return e.insLeftOf(t);
      n = n.parent.parent;
    } while (n !== t);
    e.insRightOf(t);
  }
  function h(e, t) {
    (e.jQadd = function() {
      t.jQadd.apply(this, arguments),
        (this.delimjQs = this.jQ
          .children(':first')
          .add(this.jQ.children(':last'))),
        (this.contentjQ = this.jQ.children(':eq(1)'));
    }),
      (e.reflow = function() {
        var e =
          this.contentjQ.outerHeight() /
          parseFloat(this.contentjQ.css('fontSize'));
        he(this.delimjQs, v(1 + 0.2 * (e - 1), 1.2), 1.05 * e);
      });
  }
  function p(e, t) {
    t = t || e;
    var n = Te[e],
      r = Te[t];
    (F[e] = i(Ae, P, e, n, t, r)), (F[n] = i(Ae, C, e, n, t, r));
  }
  var f,
    m = window.jQuery,
    g = 'mathquill-command-id',
    b = 'mathquill-block-id',
    v = Math.min,
    y = Math.max,
    x = [].slice,
    w = t(function(e, n) {
      return t(function(t, i) {
        return e in t ? t[e].apply(t, n.concat(i)) : void 0;
      });
    }),
    k = (function(e, t, n) {
      function i(e) {
        return 'object' == typeof e;
      }
      function r(e) {
        return 'function' == typeof e;
      }
      function s() {}
      return function o(a, c) {
        function l() {
          var e = new u();
          return r(e.init) && e.init.apply(e, arguments), e;
        }
        function u() {}
        c === n && ((c = a), (a = Object)), (l.Bare = u);
        var d,
          h = (s[e] = a[e]),
          p = (u[e] = l[e] = l.p = new s());
        return (
          (p.constructor = l),
          (l.mixin = function(t) {
            return (u[e] = l[e] = o(l, t)[e]), l;
          }),
          (l.open = function(e) {
            if (
              ((d = {}),
              r(e) ? (d = e.call(l, p, h, l, a)) : i(e) && (d = e),
              i(d))
            )
              for (var n in d) t.call(d, n) && (p[n] = d[n]);
            return r(p.init) || (p.init = a), l;
          })(c)
        );
      };
    })('prototype', {}.hasOwnProperty),
    P = (a.L = -1),
    C = (a.R = 1),
    S = k(m, function(e) {
      (e.insDirOf = function(e, t) {
        return e === P
          ? this.insertBefore(t.first())
          : this.insertAfter(t.last());
      }),
        (e.insAtDirEnd = function(e, t) {
          return e === P ? this.prependTo(t) : this.appendTo(t);
        });
    }),
    A = k(function(e) {
      (e.parent = 0),
        (e[P] = 0),
        (e[C] = 0),
        (e.init = function(e, t, n) {
          (this.parent = e), (this[P] = t), (this[C] = n);
        }),
        (this.copy = function(e) {
          return A(e.parent, e[P], e[C]);
        });
    }),
    T = k(function(e) {
      function t() {
        return (i += 1);
      }
      (e[P] = 0), (e[C] = 0), (e.parent = 0);
      var i = 0;
      (this.byId = {}),
        (e.init = function() {
          (this.id = t()),
            (T.byId[this.id] = this),
            (this.ends = {}),
            (this.ends[P] = 0),
            (this.ends[C] = 0);
        }),
        (e.dispose = function() {
          delete T.byId[this.id];
        }),
        (e.toString = function() {
          return '{{ MathQuill Node #' + this.id + ' }}';
        }),
        (e.jQ = S()),
        (e.jQadd = function(e) {
          return (this.jQ = this.jQ.add(e));
        }),
        (e.jQize = function(e) {
          function t(e) {
            if (e.getAttribute) {
              var n = e.getAttribute('mathquill-command-id'),
                i = e.getAttribute('mathquill-block-id');
              n && T.byId[n].jQadd(e), i && T.byId[i].jQadd(e);
            }
            for (e = e.firstChild; e; e = e.nextSibling) t(e);
          }
          e = S(e || this.html());
          for (var n = 0; n < e.length; n += 1) t(e[n]);
          return e;
        }),
        (e.createDir = function(e, t) {
          s(e);
          var n = this;
          return (
            n.jQize(),
            n.jQ.insDirOf(e, t.jQ),
            (t[e] = n.adopt(t.parent, t[P], t[C])),
            n
          );
        }),
        (e.createLeftOf = function(e) {
          return this.createDir(P, e);
        }),
        (e.selectChildren = function(e, t) {
          return j(e, t);
        }),
        (e.bubble = n(function(e) {
          for (var t = this; t; t = t.parent) {
            var n = e(t);
            if (n === !1) break;
          }
          return this;
        })),
        (e.postOrder = n(function(e) {
          return (
            (function t(n) {
              n.eachChild(t), e(n);
            })(this),
            this
          );
        })),
        (e.isEmpty = function() {
          return 0 === this.ends[P] && 0 === this.ends[C];
        }),
        (e.children = function() {
          return M(this.ends[P], this.ends[C]);
        }),
        (e.eachChild = function() {
          var e = this.children();
          return e.each.apply(e, arguments), this;
        }),
        (e.foldChildren = function(e, t) {
          return this.children().fold(e, t);
        }),
        (e.withDirAdopt = function(e, t, n, i) {
          return M(this, this).withDirAdopt(e, t, n, i), this;
        }),
        (e.adopt = function(e, t, n) {
          return M(this, this).adopt(e, t, n), this;
        }),
        (e.disown = function() {
          return M(this, this).disown(), this;
        }),
        (e.remove = function() {
          return this.jQ.remove(), this.postOrder('dispose'), this.disown();
        });
    }),
    M = k(function(e) {
      (e.init = function(e, t, n) {
        n === f && (n = P),
          s(n),
          r('no half-empty fragments', !e == !t),
          (this.ends = {}),
          e &&
            (r('withDir is passed to Fragment', e instanceof T),
            r('oppDir is passed to Fragment', t instanceof T),
            r('withDir and oppDir have the same parent', e.parent === t.parent),
            (this.ends[n] = e),
            (this.ends[-n] = t),
            (this.jQ = this.fold(this.jQ, function(e, t) {
              return e.add(t.jQ);
            })));
      }),
        (e.jQ = S()),
        (e.withDirAdopt = function(e, t, n, i) {
          return e === P ? this.adopt(t, n, i) : this.adopt(t, i, n);
        }),
        (e.adopt = function(e, t, n) {
          o(e, t, n);
          var i = this;
          i.disowned = !1;
          var r = i.ends[P];
          if (!r) return this;
          var s = i.ends[C];
          return (
            t || (e.ends[P] = r),
            n ? (n[P] = s) : (e.ends[C] = s),
            (i.ends[C][C] = n),
            i.each(function(n) {
              (n[P] = t), (n.parent = e), t && (t[C] = n), (t = n);
            }),
            i
          );
        }),
        (e.disown = function() {
          var e = this,
            t = e.ends[P];
          if (!t || e.disowned) return e;
          e.disowned = !0;
          var n = e.ends[C],
            i = t.parent;
          return (
            o(i, t[P], t),
            o(i, n, n[C]),
            t[P] ? (t[P][C] = n[C]) : (i.ends[P] = n[C]),
            n[C] ? (n[C][P] = t[P]) : (i.ends[C] = t[P]),
            e
          );
        }),
        (e.remove = function() {
          return (
            this.jQ.remove(), this.each('postOrder', 'dispose'), this.disown()
          );
        }),
        (e.each = n(function(e) {
          var t = this,
            n = t.ends[P];
          if (!n) return t;
          for (; n !== t.ends[C][C]; n = n[C]) {
            var i = e(n);
            if (i === !1) break;
          }
          return t;
        })),
        (e.fold = function(e, t) {
          return (
            this.each(function(n) {
              e = t.call(this, e, n);
            }),
            e
          );
        });
    }),
    I = {},
    F = {},
    E = k(A, function(e) {
      (e.init = function(e, t) {
        (this.parent = e), (this.options = t);
        var n = (this.jQ = this._jQ = S(
          '<span class="mq-cursor">&#8203;</span>'
        ));
        (this.blink = function() {
          n.toggleClass('mq-blink');
        }),
          (this.upDownCache = {});
      }),
        (e.show = function() {
          return (
            (this.jQ = this._jQ.removeClass('mq-blink')),
            'intervalId' in this
              ? clearInterval(this.intervalId)
              : (this[C]
                  ? this.jQ.insertBefore(
                      this.selection && this.selection.ends[P][P] === this[P]
                        ? this.selection.jQ
                        : this[C].jQ.first()
                    )
                  : this.jQ.appendTo(this.parent.jQ),
                this.parent.focus()),
            (this.intervalId = setInterval(this.blink, 500)),
            this
          );
        }),
        (e.hide = function() {
          return (
            'intervalId' in this && clearInterval(this.intervalId),
            delete this.intervalId,
            this.jQ.detach(),
            (this.jQ = S()),
            this
          );
        }),
        (e.withDirInsertAt = function(e, t, n, i) {
          t !== this.parent && this.parent.blur && this.parent.blur(),
            (this.parent = t),
            (this[e] = n),
            (this[-e] = i);
        }),
        (e.insDirOf = function(e, t) {
          return (
            s(e),
            this.withDirInsertAt(e, t.parent, t[e], t),
            this.parent.jQ.addClass('mq-hasCursor'),
            this.jQ.insDirOf(e, t.jQ),
            this
          );
        }),
        (e.insLeftOf = function(e) {
          return this.insDirOf(P, e);
        }),
        (e.insRightOf = function(e) {
          return this.insDirOf(C, e);
        }),
        (e.insAtDirEnd = function(e, t) {
          return (
            s(e),
            this.withDirInsertAt(e, t, 0, t.ends[e]),
            this.jQ.insAtDirEnd(e, t.jQ),
            t.focus(),
            this
          );
        }),
        (e.insAtLeftEnd = function(e) {
          return this.insAtDirEnd(P, e);
        }),
        (e.insAtRightEnd = function(e) {
          return this.insAtDirEnd(C, e);
        }),
        (e.jumpUpDown = function(e, t) {
          var n = this;
          n.upDownCache[e.id] = A.copy(n);
          var i = n.upDownCache[t.id];
          if (i) i[C] ? n.insLeftOf(i[C]) : n.insAtRightEnd(i.parent);
          else {
            var r = n.offset().left;
            t.seek(r, n);
          }
        }),
        (e.offset = function() {
          var e = this,
            t = e.jQ.removeClass('mq-cursor').offset();
          return e.jQ.addClass('mq-cursor'), t;
        }),
        (e.unwrapGramp = function() {
          var e = this.parent.parent,
            t = e.parent,
            n = e[C],
            i = this,
            r = e[P];
          if (
            (e.disown().eachChild(function(i) {
              i.isEmpty() ||
                (i
                  .children()
                  .adopt(t, r, n)
                  .each(function(t) {
                    t.jQ.insertBefore(e.jQ.first());
                  }),
                (r = i.ends[C]));
            }),
            !this[C])
          )
            if (this[P]) this[C] = this[P][C];
            else
              for (; !this[C]; ) {
                if (((this.parent = this.parent[C]), !this.parent)) {
                  (this[C] = e[C]), (this.parent = t);
                  break;
                }
                this[C] = this.parent.ends[P];
              }
          this[C] ? this.insLeftOf(this[C]) : this.insAtRightEnd(t),
            e.jQ.remove(),
            e[P].siblingDeleted && e[P].siblingDeleted(i.options, C),
            e[C].siblingDeleted && e[C].siblingDeleted(i.options, P);
        }),
        (e.startSelection = function() {
          for (
            var e = (this.anticursor = A.copy(this)),
              t = (e.ancestors = {}),
              n = e;
            n.parent;
            n = n.parent
          )
            t[n.parent.id] = n;
        }),
        (e.endSelection = function() {
          delete this.anticursor;
        }),
        (e.select = function() {
          var e,
            t = this.anticursor;
          if (this[P] === t[P] && this.parent === t.parent) return !1;
          for (var n = this; n.parent; n = n.parent)
            if (n.parent.id in t.ancestors) {
              e = n.parent;
              break;
            }
          r('cursor and anticursor in the same tree', e);
          var i,
            s,
            o = t.ancestors[e.id],
            a = C;
          if (n[P] !== o)
            for (var c = n; c; c = c[C])
              if (c[C] === o[C]) {
                (a = P), (i = n), (s = o);
                break;
              }
          return (
            a === C && ((i = o), (s = n)),
            i instanceof A && (i = i[C]),
            s instanceof A && (s = s[P]),
            (this.hide().selection = e.selectChildren(i, s)),
            this.insDirOf(a, this.selection.ends[a]),
            this.selectionChanged(),
            !0
          );
        }),
        (e.clearSelection = function() {
          return (
            this.selection &&
              (this.selection.clear(),
              delete this.selection,
              this.selectionChanged()),
            this
          );
        }),
        (e.deleteSelection = function() {
          this.selection &&
            ((this[P] = this.selection.ends[P][P]),
            (this[C] = this.selection.ends[C][C]),
            this.selection.remove(),
            this.selectionChanged(),
            delete this.selection);
        }),
        (e.replaceSelection = function() {
          var e = this.selection;
          return (
            e &&
              ((this[P] = e.ends[P][P]),
              (this[C] = e.ends[C][C]),
              delete this.selection),
            e
          );
        });
    }),
    j = k(M, function(e, t) {
      (e.init = function() {
        t.init.apply(this, arguments),
          (this.jQ = this.jQ
            .wrapAll('<span class="mq-selection"></span>')
            .parent());
      }),
        (e.adopt = function() {
          return (
            this.jQ.replaceWith((this.jQ = this.jQ.children())),
            t.adopt.apply(this, arguments)
          );
        }),
        (e.clear = function() {
          return this.jQ.replaceWith(this.jQ[0].childNodes), this;
        }),
        (e.join = function(e) {
          return this.fold('', function(t, n) {
            return t + n[e]();
          });
        });
    }),
    O = k(function(e) {
      (e.init = function(e, t, n) {
        (this.API = e),
          (this.root = t),
          (this.container = n),
          (e.__controller = t.controller = this),
          (this.cursor = t.cursor = E(t, e.__options));
      }),
        (e.handle = function(e, t) {
          var n = this.API.__options.handlers;
          n &&
            n[e] &&
            (t === P || t === C ? n[e](t, this.API) : n[e](this.API));
        });
      var t = [];
      (this.onNotify = function(e) {
        t.push(e);
      }),
        (e.notify = function() {
          for (var e = 0; e < t.length; e += 1)
            t[e].apply(this.cursor, arguments);
          return this;
        });
    });
  a.noConflict = function() {
    return (window.MathQuill = L), a;
  };
  var L = window.MathQuill;
  window.MathQuill = a;
  var G = k(),
    D = {};
  a.__options = G.p;
  var R = k(function(e) {
    (e.init = function() {
      throw "wtf don't call me, I'm 'abstract'";
    }),
      (e.initRoot = function(e, t, n) {
        (this.__options = G()), this.config(n);
        var i = O(this, e, t);
        i.createTextarea();
        var r = t.contents().detach();
        (e.jQ = S('<span class="mq-root-block"/>')
          .attr(b, e.id)
          .appendTo(t)),
          this.latex(r.text()),
          (this.revert = function() {
            return t
              .empty()
              .unbind('.mathquill')
              .removeClass('mq-editable-field mq-math-mode mq-text-mode')
              .append(r);
          });
      }),
      (e.config = a.config = function(e) {
        for (var t in e)
          if (e.hasOwnProperty(t)) {
            var n = e[t],
              i = D[t];
            this.__options[t] = i ? i(n) : n;
          }
        return this;
      }),
      (e.el = function() {
        return this.__controller.container[0];
      }),
      (e.text = function() {
        return this.__controller.exportText();
      }),
      (e.latex = function(e) {
        return arguments.length > 0
          ? (this.__controller.renderLatexMath(e),
            this.__controller.blurred &&
              this.__controller.cursor.hide().parent.blur(),
            this)
          : this.__controller.exportLatex();
      }),
      (e.html = function() {
        return this.__controller.root.jQ
          .html()
          .replace(/ mathquill-(?:command|block)-id="?\d+"?/g, '')
          .replace(/<span class="?mq-cursor( mq-blink)?"?>.?<\/span>/i, '')
          .replace(/ mq-hasCursor|mq-hasCursor ?/, '')
          .replace(/ class=(""|(?= |>))/g, '');
      }),
      (e.reflow = function() {
        return this.__controller.root.postOrder('reflow'), this;
      });
  });
  (a.prototype = R.prototype),
    (a.StaticMath = c(
      k(R, function(e, t) {
        (e.init = function(e) {
          this.initRoot(H(), e.addClass('mq-math-mode')),
            this.__controller.delegateMouseEvents(),
            this.__controller.staticMathTextareaEvents();
        }),
          (e.latex = function() {
            var e = t.latex.apply(this, arguments);
            return (
              arguments.length > 0 &&
                this.__controller.root.postOrder(
                  'registerInnerField',
                  (this.innerFields = [])
                ),
              e
            );
          });
      })
    ));
  var N = (a.EditableField = k(R, function(t) {
      (t.initRootAndEvents = function(e, t, n) {
        this.initRoot(e, t, n),
          (this.__controller.editable = !0),
          this.__controller.delegateMouseEvents(),
          this.__controller.editablesTextareaEvents();
      }),
        (t.focus = function() {
          return this.__controller.textarea.focus(), this;
        }),
        (t.blur = function() {
          return this.__controller.textarea.blur(), this;
        }),
        (t.write = function(e) {
          return (
            this.__controller.writeLatex(e),
            this.__controller.blurred &&
              this.__controller.cursor.hide().parent.blur(),
            this
          );
        }),
        (t.cmd = function(e) {
          var t = this.__controller.notify(),
            n = t.cursor.show();
          if (/^\\[a-z]+$/i.test(e)) {
            e = e.slice(1);
            var i = I[e];
            i &&
              ((e = i(e)),
              n.selection && e.replaces(n.replaceSelection()),
              e.createLeftOf(n));
          } else n.parent.write(n, e, n.replaceSelection());
          return t.blurred && n.hide().parent.blur(), this;
        }),
        (t.select = function() {
          var e = this.__controller;
          for (e.notify('move').cursor.insAtRightEnd(e.root); e.cursor[P]; )
            e.selectLeft();
          return this;
        }),
        (t.clearSelection = function() {
          return this.__controller.cursor.clearSelection(), this;
        }),
        (t.moveToDirEnd = function(e) {
          return (
            this.__controller
              .notify('move')
              .cursor.insAtDirEnd(e, this.__controller.root),
            this
          );
        }),
        (t.moveToLeftEnd = function() {
          return this.moveToDirEnd(P);
        }),
        (t.moveToRightEnd = function() {
          return this.moveToDirEnd(C);
        }),
        (t.keystroke = function(t) {
          t = t.replace(/^\s+|\s+$/g, '').split(/\s+/);
          for (var n = 0; n < t.length; n += 1)
            this.__controller.keystroke(t[n], { preventDefault: e });
          return this;
        }),
        (t.typedText = function(e) {
          for (var t = 0; t < e.length; t += 1)
            this.__controller.typedText(e.charAt(t));
          return this;
        });
    })),
    z = k(function(e, t, n) {
      function i(e, t) {
        throw ((e = e ? "'" + e + "'" : 'EOF'),
        'Parse Error: ' + t + ' at ' + e);
      }
      (e.init = function(e) {
        this._ = e;
      }),
        (e.parse = function(e) {
          function t(e, t) {
            return t;
          }
          return this.skip(a)._(e, t, i);
        }),
        (e.or = function(e) {
          r('or is passed a parser', e instanceof n);
          var t = this;
          return n(function(n, i, r) {
            function s(t) {
              return e._(n, i, r);
            }
            return t._(n, i, s);
          });
        }),
        (e.then = function(e) {
          var t = this;
          return n(function(i, s, o) {
            function a(t, i) {
              var a = e instanceof n ? e : e(i);
              return r('a parser is returned', a instanceof n), a._(t, s, o);
            }
            return t._(i, a, o);
          });
        }),
        (e.many = function() {
          var e = this;
          return n(function(t, n, i) {
            function r(e, n) {
              return (t = e), o.push(n), !0;
            }
            function s() {
              return !1;
            }
            for (var o = []; e._(t, r, s); );
            return n(t, o);
          });
        }),
        (e.times = function(e, t) {
          arguments.length < 2 && (t = e);
          var i = this;
          return n(function(n, r, s) {
            function o(e, t) {
              return u.push(t), (n = e), !0;
            }
            function a(e, t) {
              return (l = t), (n = e), !1;
            }
            function c(e, t) {
              return !1;
            }
            for (var l, u = [], d = !0, h = 0; e > h; h += 1)
              if (((d = i._(n, o, a)), !d)) return s(n, l);
            for (; t > h && d; h += 1) d = i._(n, o, c);
            return r(n, u);
          });
        }),
        (e.result = function(e) {
          return this.then(o(e));
        }),
        (e.atMost = function(e) {
          return this.times(0, e);
        }),
        (e.atLeast = function(e) {
          var t = this;
          return t.times(e).then(function(e) {
            return t.many().map(function(t) {
              return e.concat(t);
            });
          });
        }),
        (e.map = function(e) {
          return this.then(function(t) {
            return o(e(t));
          });
        }),
        (e.skip = function(e) {
          return this.then(function(t) {
            return e.result(t);
          });
        });
      var s =
          ((this.string = function(e) {
            var t = e.length,
              i = "expected '" + e + "'";
            return n(function(n, r, s) {
              var o = n.slice(0, t);
              return o === e ? r(n.slice(t), o) : s(n, i);
            });
          }),
          (this.regex = function(e) {
            r('regexp parser is anchored', '^' === e.toString().charAt(1));
            var t = 'expected ' + e;
            return n(function(n, i, r) {
              var s = e.exec(n);
              if (s) {
                var o = s[0];
                return i(n.slice(o.length), o);
              }
              return r(n, t);
            });
          })),
        o = (n.succeed = function(e) {
          return n(function(t, n) {
            return n(t, e);
          });
        }),
        a =
          ((n.fail = function(e) {
            return n(function(t, n, i) {
              return i(t, e);
            });
          }),
          (n.letter = s(/^[a-z]/i)),
          (n.letters = s(/^[a-z]*/i)),
          (n.digit = s(/^[0-9]/)),
          (n.digits = s(/^[0-9]*/)),
          (n.whitespace = s(/^\s+/)),
          (n.optWhitespace = s(/^\s*/)),
          (n.any = n(function(e, t, n) {
            return e
              ? t(e.slice(1), e.charAt(0))
              : n(e, 'expected any character');
          })),
          (n.all = n(function(e, t, n) {
            return t('', e);
          })),
          (n.eof = n(function(e, t, n) {
            return e ? n(e, 'expected EOF') : t(e, e);
          })));
    }),
    B = (function() {
      return function(t, n) {
        function i(e) {
          (p = e), clearTimeout(c), (c = setTimeout(e));
        }
        function r(t) {
          p(),
            (p = e),
            clearTimeout(c),
            d.val(t),
            t && d[0].select(),
            (f = !!t);
        }
        function s() {
          l = u = null;
        }
        function o(e) {
          d.focus(), i(a);
        }
        function a() {
          d.val();
          d.val('');
        }
        var c,
          l = null,
          u = null,
          d = m(t),
          h = m(n.container || d),
          p = e;
        h.bind('keydown keypress input keyup focusout paste', function() {
          p();
        });
        var f = !1;
        return h.bind({ focusout: s, paste: o }), { select: r };
      };
    })();
  O.open(function(e, t) {
    e.exportText = function() {
      return this.root.foldChildren('', function(e, t) {
        return e + t.text();
      });
    };
  }),
    O.open(function(e) {
      e.focusBlurEvents = function() {
        function e() {
          clearTimeout(n),
            s.selection && s.selection.jQ.addClass('mq-blur'),
            t();
        }
        function t() {
          s.hide().parent.blur(),
            i.container.removeClass('mq-focused'),
            S(window).off('blur', e);
        }
        var n,
          i = this,
          r = i.root,
          s = i.cursor;
        i.textarea
          .focus(function() {
            (i.blurred = !1),
              clearTimeout(n),
              i.container.addClass('mq-focused'),
              s.parent || s.insAtRightEnd(r),
              s.selection
                ? (s.selection.jQ.removeClass('mq-blur'), i.selectionChanged())
                : s.show();
          })
          .blur(function() {
            (i.blurred = !0),
              (n = setTimeout(function() {
                r.postOrder('intentionalBlur'), s.clearSelection(), t();
              })),
              S(window).on('blur', e);
          }),
          (i.blurred = !0),
          s.hide().parent.blur();
      };
    }),
    O.open(function(e) {
      e.keystroke = function(e, t) {
        this.cursor.parent.keystroke(e, t, this);
      };
    }),
    T.open(function(e) {
      (e.keystroke = function(e, t, n) {
        var i = n.cursor;
        switch (e) {
          case 'Ctrl-Shift-Backspace':
          case 'Ctrl-Backspace':
            for (; i[P] || i.selection; ) n.backspace();
            break;
          case 'Shift-Backspace':
          case 'Backspace':
            n.backspace();
            break;
          case 'Esc':
          case 'Tab':
            return void n.escapeDir(C, e, t);
          case 'Shift-Tab':
          case 'Shift-Esc':
            return void n.escapeDir(P, e, t);
          case 'End':
            n.notify('move').cursor.insAtRightEnd(i.parent);
            break;
          case 'Ctrl-End':
            n.notify('move').cursor.insAtRightEnd(n.root);
            break;
          case 'Shift-End':
            for (; i[C]; ) n.selectRight();
            break;
          case 'Ctrl-Shift-End':
            for (; i[C] || i.parent !== n.root; ) n.selectRight();
            break;
          case 'Home':
            n.notify('move').cursor.insAtLeftEnd(i.parent);
            break;
          case 'Ctrl-Home':
            n.notify('move').cursor.insAtLeftEnd(n.root);
            break;
          case 'Shift-Home':
            for (; i[P]; ) n.selectLeft();
            break;
          case 'Ctrl-Shift-Home':
            for (; i[P] || i.parent !== n.root; ) n.selectLeft();
            break;
          case 'Left':
            n.moveLeft();
            break;
          case 'Shift-Left':
            n.selectLeft();
            break;
          case 'Ctrl-Left':
            break;
          case 'Right':
            n.moveRight();
            break;
          case 'Shift-Right':
            n.selectRight();
            break;
          case 'Ctrl-Right':
            break;
          case 'Up':
            n.moveUp();
            break;
          case 'Down':
            n.moveDown();
            break;
          case 'Shift-Up':
            if (i[P]) for (; i[P]; ) n.selectLeft();
            else n.selectLeft();
          case 'Shift-Down':
            if (i[C]) for (; i[C]; ) n.selectRight();
            else n.selectRight();
          case 'Ctrl-Up':
            break;
          case 'Ctrl-Down':
            break;
          case 'Ctrl-Shift-Del':
          case 'Ctrl-Del':
            for (; i[C] || i.selection; ) n.deleteForward();
            break;
          case 'Shift-Del':
          case 'Del':
            n.deleteForward();
            break;
          case 'Meta-A':
          case 'Ctrl-A':
            for (n.notify('move').cursor.insAtRightEnd(n.root); i[P]; )
              n.selectLeft();
            break;
          default:
            return;
        }
        t.preventDefault(), n.scrollHoriz();
      }),
        (e.moveOutOf = e.moveTowards = e.deleteOutOf = e.deleteTowards = e.unselectInto = e.selectOutOf = e.selectTowards = function() {
          r('overridden or never called on this node');
        });
    }),
    O.open(function(e) {
      function t(e, t) {
        var n = e.notify('upDown').cursor,
          i = t + 'Into',
          r = t + 'OutOf';
        return (
          n[C][i]
            ? n.insAtLeftEnd(n[C][i])
            : n[P][i]
            ? n.insAtRightEnd(n[P][i])
            : n.parent.bubble(function(e) {
                var t = e[r];
                return t &&
                  ('function' == typeof t && (t = e[r](n)),
                  t instanceof T && n.jumpUpDown(e, t),
                  t !== !0)
                  ? !1
                  : void 0;
              }),
          e
        );
      }
      this.onNotify(function(e) {
        ('move' === e || 'upDown' === e) && this.show().clearSelection();
      }),
        (e.escapeDir = function(e, t, n) {
          s(e);
          var i = this.cursor;
          return (
            i.parent !== this.root && n.preventDefault(),
            i.parent !== this.root
              ? (i.parent.moveOutOf(e, i), this.notify('move'))
              : void 0
          );
        }),
        (D.leftRightIntoCmdGoes = function(e) {
          if (e && 'up' !== e && 'down' !== e)
            throw '"up" or "down" required for leftRightIntoCmdGoes option, got "' +
              e +
              '"';
          return e;
        }),
        (e.moveDir = function(e) {
          s(e);
          var t = this.cursor,
            n = t.options.leftRightIntoCmdGoes;
          return (
            t.selection
              ? t.insDirOf(e, t.selection.ends[e])
              : t[e]
              ? t[e].moveTowards(e, t, n)
              : t.parent.moveOutOf(e, t, n),
            this.notify('move')
          );
        }),
        (e.moveLeft = function() {
          return this.moveDir(P);
        }),
        (e.moveRight = function() {
          return this.moveDir(C);
        }),
        (e.moveUp = function() {
          return t(this, 'up');
        }),
        (e.moveDown = function() {
          return t(this, 'down');
        }),
        this.onNotify(function(e) {
          'upDown' !== e && (this.upDownCache = {});
        }),
        this.onNotify(function(e) {
          'edit' === e && this.show().deleteSelection();
        }),
        (e.deleteDir = function(e) {
          s(e);
          var t = this.cursor,
            n = t.selection;
          return (
            this.notify('edit'),
            n || (t[e] ? t[e].deleteTowards(e, t) : t.parent.deleteOutOf(e, t)),
            t[P].siblingDeleted && t[P].siblingDeleted(t.options, C),
            t[C].siblingDeleted && t[C].siblingDeleted(t.options, P),
            t.parent.bubble('reflow'),
            this
          );
        }),
        (e.backspace = function() {
          return this.deleteDir(P);
        }),
        (e.deleteForward = function() {
          return this.deleteDir(C);
        }),
        this.onNotify(function(e) {
          'select' !== e && this.endSelection();
        }),
        (e.selectDir = function(e) {
          var t = this.notify('select').cursor,
            n = t.selection;
          s(e), t.anticursor || t.startSelection();
          var i = t[e];
          i
            ? n && n.ends[e] === i && t.anticursor[-e] !== i
              ? i.unselectInto(e, t)
              : i.selectTowards(e, t)
            : t.parent.selectOutOf(e, t),
            t.clearSelection(),
            t.select() || t.show();
        }),
        (e.selectLeft = function() {
          return this.selectDir(P);
        }),
        (e.selectRight = function() {
          return this.selectDir(C);
        });
    });
  var V = (function() {
    function e(e) {
      var t = H();
      return e.adopt(t, 0, 0), t;
    }
    function t(e) {
      for (var t = e[0] || H(), n = 1; n < e.length; n += 1)
        e[n].children().adopt(t, t.ends[C], 0);
      return t;
    }
    var n = z.string,
      i = z.regex,
      r = z.letter,
      s = z.any,
      o = z.optWhitespace,
      a = z.succeed,
      c = z.fail,
      l = r.map(function(e) {
        return ee(e);
      }),
      u = i(/^[^${}\\_^]/).map(function(e) {
        return Q(e);
      }),
      d = i(/^[^\\a-eg-zA-Z]/)
        .or(
          n('\\').then(
            i(/^[a-z]+/i)
              .or(i(/^\s+/).result(' '))
              .or(s)
          )
        )
        .then(function(e) {
          var t = I[e];
          return t ? t(e).parser() : c('unknown command: \\' + e);
        }),
      h = d.or(l).or(u),
      p = n('{')
        .then(function() {
          return m;
        })
        .skip(n('}')),
      f = o.then(p.or(h.map(e))),
      m = f
        .many()
        .map(t)
        .skip(o),
      g = n('[')
        .then(
          f
            .then(function(e) {
              return ']' !== e.join('latex') ? a(e) : c();
            })
            .many()
            .map(t)
            .skip(o)
        )
        .skip(n(']')),
      b = m;
    return (b.block = f), (b.optBlock = g), b;
  })();
  O.open(function(e, t) {
    (e.exportLatex = function() {
      return this.root.latex().replace(/(\\[a-z]+) (?![a-z])/gi, '$1');
    }),
      (e.writeLatex = function(e) {
        var t = this.notify('edit').cursor,
          n = z.all,
          i = z.eof,
          r = V.skip(i)
            .or(n.result(!1))
            .parse(e);
        if (r && !r.isEmpty()) {
          r.children().adopt(t.parent, t[P], t[C]);
          var s = r.jQize();
          s.insertBefore(t.jQ),
            (t[P] = r.ends[C]),
            r.finalizeInsert(t.options, t),
            r.ends[C][C].siblingCreated &&
              r.ends[C][C].siblingCreated(t.options, P),
            r.ends[P][P].siblingCreated &&
              r.ends[P][P].siblingCreated(t.options, C),
            t.parent.bubble('reflow');
        }
        return this;
      }),
      (e.renderLatexMath = function(e) {
        var t = this.root,
          n = this.cursor,
          i = z.all,
          r = z.eof,
          s = V.skip(r)
            .or(i.result(!1))
            .parse(e);
        t.eachChild('postOrder', 'dispose'),
          (t.ends[P] = t.ends[C] = 0),
          s && s.children().adopt(t, 0, 0);
        var o = t.jQ;
        if (s) {
          var a = s.join('html');
          o.html(a), t.jQize(o.children()), t.finalizeInsert(n.options);
        } else o.empty();
        delete n.selection, n.insAtRightEnd(t);
      }),
      (e.renderLatexText = function(e) {
        var t = this.root,
          n = this.cursor;
        t.jQ
          .children()
          .slice(1)
          .remove(),
          t.eachChild('postOrder', 'dispose'),
          (t.ends[P] = t.ends[C] = 0),
          delete n.selection,
          n.show().insAtRightEnd(t);
        var i = z.regex,
          r = z.string,
          s = z.eof,
          o = z.all,
          a = r('$')
            .then(V)
            .skip(r('$').or(s))
            .map(function(e) {
              var t = J(n);
              t.createBlocks();
              var i = t.ends[P];
              return e.children().adopt(i, 0, 0), t;
            }),
          c = r('\\$').result('$'),
          l = c.or(i(/^[^$]/)).map(Q),
          u = a.or(l).many(),
          d = u
            .skip(s)
            .or(o.result(!1))
            .parse(e);
        if (d) {
          for (var h = 0; h < d.length; h += 1) d[h].adopt(t, t.ends[C], 0);
          t.jQize().appendTo(t.jQ), t.finalizeInsert(n.options);
        }
      });
  }),
    O.open(function(t) {
      t.delegateMouseEvents = function() {
        var t = this.root.jQ;
        this.container.bind('mousedown.mathquill', function(n) {
          function i(e) {
            o = S(e.target);
          }
          function r(e) {
            u.anticursor || u.startSelection(),
              l.seek(o, e.pageX, e.pageY).cursor.select(),
              (o = f);
          }
          function s(e) {
            (u.blink = d),
              u.selection || (l.editable ? u.show() : h.detach()),
              a.unbind('mousemove', i),
              S(e.target.ownerDocument)
                .unbind('mousemove', r)
                .unbind('mouseup', s);
          }
          var o,
            a = S(n.target).closest('.mq-root-block'),
            c = T.byId[a.attr(b) || t.attr(b)],
            l = c.controller,
            u = l.cursor,
            d = u.blink,
            h = l.textareaSpan,
            p = l.textarea;
          l.blurred && (l.editable || a.prepend(h), p.focus()),
            n.preventDefault(),
            (n.target.unselectable = !0),
            (u.blink = e),
            l.seek(S(n.target), n.pageX, n.pageY).cursor.startSelection(),
            a.mousemove(i),
            S(n.target.ownerDocument)
              .mousemove(r)
              .mouseup(s);
        });
      };
    }),
    O.open(function(e) {
      e.seek = function(e, t, n) {
        var i,
          s = this.notify('select').cursor;
        if (e && ((i = e.attr(b) || e.attr(g)), !i)) {
          var o = e.parent();
          i = o.attr(b) || o.attr(g);
        }
        var a = i ? T.byId[i] : this.root;
        return (
          r('nodeId is the id of some Node that exists', a),
          s.clearSelection().show(),
          a.seek(t, s),
          this.scrollHoriz(),
          this
        );
      };
    }),
    O.open(function(e) {
      e.scrollHoriz = function() {
        var e,
          t = this.cursor,
          n = t.selection,
          i = this.root.jQ[0].getBoundingClientRect();
        if (n) {
          var r = n.jQ[0].getBoundingClientRect(),
            s = r.left - (i.left + 20),
            o = r.right - (i.right - 20);
          if (n.ends[P] === t[C])
            if (0 > s) e = s;
            else {
              if (!(o > 0)) return;
              e = r.left - o < i.left + 20 ? s : o;
            }
          else if (o > 0) e = o;
          else {
            if (!(0 > s)) return;
            e = r.right - s > i.right - 20 ? o : s;
          }
        } else {
          var a = t.jQ[0].getBoundingClientRect().left;
          if (a > i.right - 20) e = a - (i.right - 20);
          else {
            if (!(a < i.left + 20)) return;
            e = a - (i.left + 20);
          }
        }
        this.root.jQ.stop().animate({ scrollLeft: '+=' + e }, 100);
      };
    }),
    O.open(function(e) {
      (G.p.substituteTextarea = function() {
        return S('<textarea>')[0];
      }),
        (e.createTextarea = function() {
          var e = (this.textareaSpan = S('<span class="mq-textarea"></span>')),
            t = this.API.__options.substituteTextarea();
          if (!t.nodeType)
            throw 'substituteTextarea() must return a DOM element, got ' + t;
          t = this.textarea = S(t).appendTo(e);
          var n = this;
          (n.cursor.selectionChanged = function() {
            n.selectionChanged();
          }),
            n.container.bind('copy', function() {
              n.setTextareaSelection();
            });
        }),
        (e.selectionChanged = function() {
          var e = this;
          fe(e.container[0]),
            e.textareaSelectionTimeout === f &&
              (e.textareaSelectionTimeout = setTimeout(function() {
                e.setTextareaSelection();
              }));
        }),
        (e.setTextareaSelection = function() {
          this.textareaSelectionTimeout = f;
          var e = '';
          this.cursor.selection &&
            ((e = this.cursor.selection.join('latex')),
            this.API.__options.statelessClipboard && (e = '$' + e + '$')),
            this.selectFn(e);
        }),
        (e.staticMathTextareaEvents = function() {
          function e() {
            r.detach(), (t.blurred = !0);
          }
          var t = this,
            n = (t.root, t.cursor),
            i = t.textarea,
            r = t.textareaSpan;
          this.container.prepend(
            '<span class="mq-selectable">$' + t.exportLatex() + '$</span>'
          ),
            (t.blurred = !0),
            i
              .bind('cut paste', !1)
              .focus(function() {
                t.blurred = !1;
              })
              .blur(function() {
                n.selection && n.selection.clear(), setTimeout(e);
              }),
            (t.selectFn = function(e) {
              i.val(e), e && i.select();
            });
        }),
        (e.editablesTextareaEvents = function() {
          var e = this,
            t = (e.root, e.cursor),
            n = e.textarea,
            i = e.textareaSpan,
            r = B(n, this);
          (this.selectFn = function(e) {
            r.select(e);
          }),
            this.container.prepend(i).on('cut', function(n) {
              t.selection &&
                setTimeout(function() {
                  e.notify('edit'), e.notify('cut'), t.parent.bubble('reflow');
                });
            }),
            this.focusBlurEvents();
        }),
        (e.typedText = function(e) {
          if ('\n' === e) return this.handle('enter');
          var t = this.notify().cursor;
          t.parent.write(t, e, t.show().replaceSelection()), this.scrollHoriz();
        }),
        (e.paste = function(e) {
          this.API.__options.statelessClipboard &&
            (e =
              '$' === e.slice(0, 1) && '$' === e.slice(-1)
                ? e.slice(1, -1)
                : '\\text{' + e + '}'),
            this.writeLatex(e).cursor.show();
        });
    });
  var q = k(T, function(e, t) {
      e.finalizeInsert = function(e, t) {
        var n = this;
        n.postOrder('finalizeTree', e),
          n.postOrder('contactWeld', t),
          n.postOrder('blur'),
          n.postOrder('reflow'),
          n[C].siblingCreated && n[C].siblingCreated(e, P),
          n[P].siblingCreated && n[P].siblingCreated(e, C),
          n.bubble('reflow');
      };
    }),
    U = k(q, function(e, t) {
      (e.init = function(e, n, i) {
        var r = this;
        t.init.call(r),
          r.ctrlSeq || (r.ctrlSeq = e),
          n && (r.htmlTemplate = n),
          i && (r.textTemplate = i);
      }),
        (e.replaces = function(e) {
          e.disown(), (this.replacedFragment = e);
        }),
        (e.isEmpty = function() {
          return this.foldChildren(!0, function(e, t) {
            return e && t.isEmpty();
          });
        }),
        (e.parser = function() {
          var e = V.block,
            t = this;
          return e.times(t.numBlocks()).map(function(e) {
            t.blocks = e;
            for (var n = 0; n < e.length; n += 1) e[n].adopt(t, t.ends[C], 0);
            return t;
          });
        }),
        (e.createLeftOf = function(e) {
          var n = this,
            i = n.replacedFragment;
          n.createBlocks(),
            t.createLeftOf.call(n, e),
            i && (i.adopt(n.ends[P], 0, 0), i.jQ.appendTo(n.ends[P].jQ)),
            n.finalizeInsert(e.options),
            n.placeCursor(e);
        }),
        (e.createBlocks = function() {
          for (
            var e = this, t = e.numBlocks(), n = (e.blocks = Array(t)), i = 0;
            t > i;
            i += 1
          ) {
            var r = (n[i] = H());
            r.adopt(e, e.ends[C], 0);
          }
        }),
        (e.placeCursor = function(e) {
          e.insAtRightEnd(
            this.foldChildren(this.ends[P], function(e, t) {
              return e.isEmpty() ? e : t;
            })
          );
        }),
        (e.moveTowards = function(e, t, n) {
          var i = n && this[n + 'Into'];
          t.insAtDirEnd(-e, i || this.ends[-e]);
        }),
        (e.deleteTowards = function(e, t) {
          t.startSelection(), this.selectTowards(e, t), t.select();
        }),
        (e.selectTowards = function(e, t) {
          (t[-e] = this), (t[e] = this[e]);
        }),
        (e.selectChildren = function() {
          return j(this, this);
        }),
        (e.unselectInto = function(e, t) {
          t.insAtDirEnd(-e, t.anticursor.ancestors[this.id]);
        }),
        (e.seek = function(e, t) {
          function n(e) {
            var t = {};
            return (
              (t[P] = e.jQ.offset().left), (t[C] = t[P] + e.jQ.outerWidth()), t
            );
          }
          var i = this,
            r = n(i);
          if (e < r[P]) return t.insLeftOf(i);
          if (e > r[C]) return t.insRightOf(i);
          var s = r[P];
          i.eachChild(function(o) {
            var a = n(o);
            return e < a[P]
              ? (e - s < a[P] - e
                  ? o[P]
                    ? t.insAtRightEnd(o[P])
                    : t.insLeftOf(i)
                  : t.insAtLeftEnd(o),
                !1)
              : e > a[C]
              ? void (o[C]
                  ? (s = a[C])
                  : r[C] - e < e - a[C]
                  ? t.insRightOf(i)
                  : t.insAtRightEnd(o))
              : (o.seek(e, t), !1);
          });
        }),
        (e.numBlocks = function() {
          var e = this.htmlTemplate.match(/&\d+/g);
          return e ? e.length : 0;
        }),
        (e.html = function() {
          var e = this,
            t = e.blocks,
            n = ' mathquill-command-id="' + e.id + '"',
            i = e.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);
          r('no unmatched angle brackets', i.join('') === this.htmlTemplate);
          for (var s = 0, o = i[0]; o; s += 1, o = i[s])
            if ('/>' === o.slice(-2)) i[s] = o.slice(0, -2) + n + '/>';
            else if ('<' === o.charAt(0)) {
              r('not an unmatched top-level close tag', '/' !== o.charAt(1)),
                (i[s] = o.slice(0, -1) + n + '>');
              var a = 1;
              do
                (s += 1),
                  (o = i[s]),
                  r('no missing close tags', o),
                  '</' === o.slice(0, 2)
                    ? (a -= 1)
                    : '<' === o.charAt(0) && '/>' !== o.slice(-2) && (a += 1);
              while (a > 0);
            }
          return i.join('').replace(/>&(\d+)/g, function(e, n) {
            return ' mathquill-block-id="' + t[n].id + '">' + t[n].join('html');
          });
        }),
        (e.latex = function() {
          return this.foldChildren(this.ctrlSeq, function(e, t) {
            return e + '{' + (t.latex() || ' ') + '}';
          });
        }),
        (e.textTemplate = ['']),
        (e.text = function() {
          var e = this,
            t = 0;
          return e.foldChildren(e.textTemplate[t], function(n, i) {
            t += 1;
            var r = i.text();
            return n &&
              '(' === e.textTemplate[t] &&
              '(' === r[0] &&
              ')' === r.slice(-1)
              ? n + r.slice(1, -1) + e.textTemplate[t]
              : n + i.text() + (e.textTemplate[t] || '');
          });
        });
    }),
    _ = k(U, function(t, n) {
      (t.init = function(e, t, i) {
        i || (i = e && e.length > 1 ? e.slice(1) : e),
          n.init.call(this, e, t, [i]);
      }),
        (t.parser = function() {
          return z.succeed(this);
        }),
        (t.numBlocks = function() {
          return 0;
        }),
        (t.replaces = function(e) {
          e.remove();
        }),
        (t.createBlocks = e),
        (t.moveTowards = function(e, t) {
          t.jQ.insDirOf(e, this.jQ), (t[-e] = this), (t[e] = this[e]);
        }),
        (t.deleteTowards = function(e, t) {
          t[e] = this.remove()[e];
        }),
        (t.seek = function(e, t) {
          e - this.jQ.offset().left < this.jQ.outerWidth() / 2
            ? t.insLeftOf(this)
            : t.insRightOf(this);
        }),
        (t.latex = function() {
          return this.ctrlSeq;
        }),
        (t.text = function() {
          return this.textTemplate;
        }),
        (t.placeCursor = e),
        (t.isEmpty = function() {
          return !0;
        });
    }),
    Q = k(_, function(e, t) {
      e.init = function(e, n) {
        t.init.call(this, e, '<span>' + (n || e) + '</span>');
      };
    }),
    Y = k(_, function(e, t) {
      e.init = function(e, n, i) {
        t.init.call(
          this,
          e,
          '<span class="mq-binary-operator">' + n + '</span>',
          i
        );
      };
    }),
    H = k(q, function(e, t) {
      (e.join = function(e) {
        return this.foldChildren('', function(t, n) {
          return t + n[e]();
        });
      }),
        (e.html = function() {
          return this.join('html');
        }),
        (e.latex = function() {
          return this.join('latex');
        }),
        (e.text = function() {
          return this.ends[P] === this.ends[C]
            ? this.ends[P].text()
            : '(' + this.join('text') + ')';
        }),
        (e.keystroke = function(e, n, i) {
          return !i.API.__options.spaceBehavesLikeTab ||
            ('Spacebar' !== e && 'Shift-Spacebar' !== e)
            ? t.keystroke.apply(this, arguments)
            : (n.preventDefault(),
              void i.escapeDir('Shift-Spacebar' === e ? P : C, e, n));
        }),
        (e.moveOutOf = function(e, t, n) {
          var i = n && this.parent[n + 'Into'];
          !i && this[e]
            ? t.insAtDirEnd(-e, this[e])
            : t.insDirOf(e, this.parent);
        }),
        (e.selectOutOf = function(e, t) {
          t.insDirOf(e, this.parent);
        }),
        (e.deleteOutOf = function(e, t) {
          t.unwrapGramp();
        }),
        (e.seek = function(e, t) {
          var n = this.ends[C];
          if (!n || n.jQ.offset().left + n.jQ.outerWidth() < e)
            return t.insAtRightEnd(this);
          if (e < this.ends[P].jQ.offset().left) return t.insAtLeftEnd(this);
          for (; e < n.jQ.offset().left; ) n = n[P];
          return n.seek(e, t);
        }),
        (e.write = function(e, t, n) {
          var i;
          (i = t.match(/^[a-eg-zA-Z]$/)
            ? ee(t)
            : (i = F[t] || I[t])
            ? i(t)
            : Q(t)),
            n && i.replaces(n),
            i.createLeftOf(e);
        }),
        (e.focus = function() {
          return (
            this.jQ.addClass('mq-hasCursor'),
            this.jQ.removeClass('mq-empty'),
            this
          );
        }),
        (e.blur = function() {
          return (
            this.jQ.removeClass('mq-hasCursor'),
            this.isEmpty() && this.jQ.addClass('mq-empty'),
            this
          );
        });
    }),
    W = k(H, l);
  a.MathField = c(
    k(N, function(e, t) {
      e.init = function(e, t) {
        e.addClass('mq-editable-field mq-math-mode'),
          this.initRootAndEvents(W(), e, t);
      };
    })
  );
  var X = k(T, function(e, t) {
      function n(e) {
        e.jQ[0].normalize();
        var t = e.jQ[0].firstChild,
          n = K(t.data);
        return n.jQadd(t), e.children().disown(), n.adopt(e, 0, 0);
      }
      (e.ctrlSeq = '\\text'),
        (e.replaces = function(e) {
          e instanceof M
            ? (this.replacedText = e.remove().jQ.text())
            : 'string' == typeof e && (this.replacedText = e);
        }),
        (e.jQadd = function(e) {
          t.jQadd.call(this, e),
            this.ends[P] && this.ends[P].jQadd(this.jQ[0].firstChild);
        }),
        (e.createLeftOf = function(e) {
          var n = this;
          if (
            (t.createLeftOf.call(this, e),
            n[C].siblingCreated && n[C].siblingCreated(e.options, P),
            n[P].siblingCreated && n[P].siblingCreated(e.options, C),
            n.bubble('reflow'),
            e.insAtRightEnd(n),
            n.replacedText)
          )
            for (var i = 0; i < n.replacedText.length; i += 1)
              n.write(e, n.replacedText.charAt(i));
        }),
        (e.parser = function() {
          var e = this,
            t = z.string,
            n = z.regex,
            i = z.optWhitespace;
          return i
            .then(t('{'))
            .then(n(/^[^}]*/))
            .skip(t('}'))
            .map(function(t) {
              return K(t).adopt(e, 0, 0), e;
            });
        }),
        (e.textContents = function() {
          return this.foldChildren('', function(e, t) {
            return e + t.text;
          });
        }),
        (e.text = function() {
          return '"' + this.textContents() + '"';
        }),
        (e.latex = function() {
          return '\\text{' + this.textContents() + '}';
        }),
        (e.html = function() {
          return (
            '<span class="mq-text-mode" mathquill-command-id=' +
            this.id +
            '>' +
            this.textContents() +
            '</span>'
          );
        }),
        (e.moveTowards = function(e, t) {
          t.insAtDirEnd(-e, this);
        }),
        (e.moveOutOf = function(e, t) {
          t.insDirOf(e, this);
        }),
        (e.unselectInto = e.moveTowards),
        (e.selectTowards = U.prototype.selectTowards),
        (e.deleteTowards = U.prototype.deleteTowards),
        (e.selectOutOf = function(e, t) {
          t.insDirOf(e, this);
        }),
        (e.deleteOutOf = function(e, t) {
          this.isEmpty() && t.insRightOf(this);
        }),
        (e.write = function(e, n, i) {
          if ((i && i.remove(), '$' !== n))
            e[P] ? e[P].appendText(n) : K(n).createLeftOf(e);
          else if (this.isEmpty())
            e.insRightOf(this), Q('\\$', '$').createLeftOf(e);
          else if (e[C])
            if (e[P]) {
              var r = X(),
                s = this.ends[P];
              s.disown(),
                s.adopt(r, 0, 0),
                e.insLeftOf(this),
                t.createLeftOf.call(r, e);
            } else e.insLeftOf(this);
          else e.insRightOf(this);
        }),
        (e.seek = function(e, t) {
          t.hide();
          var i,
            r = n(this),
            s = this.jQ.width() / this.text.length,
            o = Math.round((e - this.jQ.offset().left) / s);
          0 >= o
            ? t.insAtLeftEnd(this)
            : o >= r.text.length
            ? t.insAtRightEnd(this)
            : t.insLeftOf(r.splitRight(o));
          for (
            var a = e - t.show().offset().left, c = a && 0 > a ? P : C, l = c;
            t[c] && a * l > 0;

          )
            t[c].moveTowards(c, t), (l = a), (a = e - t.offset().left);
          if ((-c * l > c * a && t[-c].moveTowards(-c, t), t.anticursor)) {
            if (t.anticursor.parent === this) {
              var u = t[P] && t[P].text.length;
              this.anticursorPosition === u
                ? (t.anticursor = A.copy(t))
                : (this.anticursorPosition < u
                    ? ((i = t[P].splitRight(this.anticursorPosition)),
                      (t[P] = i))
                    : (i = t[C].splitRight(this.anticursorPosition - u)),
                  (t.anticursor = A(this, i[P], i)));
            }
          } else this.anticursorPosition = t[P] && t[P].text.length;
        }),
        (e.blur = function() {
          H.prototype.blur.call(this), n(this);
        }),
        (e.focus = H.prototype.focus);
    }),
    K = k(T, function(e, t) {
      function n(e, t) {
        return t.charAt(e === P ? 0 : -1 + t.length);
      }
      (e.init = function(e) {
        t.init.call(this), (this.text = e);
      }),
        (e.jQadd = function(e) {
          (this.dom = e), (this.jQ = S(e));
        }),
        (e.jQize = function() {
          return this.jQadd(document.createTextNode(this.text));
        }),
        (e.appendText = function(e) {
          (this.text += e), this.dom.appendData(e);
        }),
        (e.prependText = function(e) {
          (this.text = e + this.text), this.dom.insertData(0, e);
        }),
        (e.insTextAtDirEnd = function(e, t) {
          s(t), t === C ? this.appendText(e) : this.prependText(e);
        }),
        (e.splitRight = function(e) {
          var t = K(this.text.slice(e)).adopt(this.parent, this, this[C]);
          return (
            t.jQadd(this.dom.splitText(e)),
            (this.text = this.text.slice(0, e)),
            t
          );
        }),
        (e.moveTowards = function(e, t) {
          s(e);
          var i = n(-e, this.text),
            r = this[-e];
          return (
            r ? r.insTextAtDirEnd(i, e) : K(i).createDir(-e, t),
            this.deleteTowards(e, t)
          );
        }),
        (e.latex = function() {
          return this.text;
        }),
        (e.deleteTowards = function(e, t) {
          this.text.length > 1
            ? e === C
              ? (this.dom.deleteData(0, 1), (this.text = this.text.slice(1)))
              : (this.dom.deleteData(-1 + this.text.length, 1),
                (this.text = this.text.slice(0, -1)))
            : (this.remove(), this.jQ.remove(), (t[e] = this[e]));
        }),
        (e.selectTowards = function(e, t) {
          s(e);
          var i,
            r = t.anticursor,
            o = n(-e, this.text);
          if (r[e] === this)
            (i = K(o).createDir(e, t)), (r[e] = i), t.insDirOf(e, i);
          else {
            var a = this[-e];
            a
              ? a.insTextAtDirEnd(o, e)
              : ((i = K(o).createDir(-e, t)),
                i.jQ.insDirOf(-e, t.selection.jQ)),
              1 === this.text.length && r[-e] === this && (r[-e] = this[-e]);
          }
          return this.deleteTowards(e, t);
        });
    });
  (F.$ = I.text = I.textnormal = I.textrm = I.textup = I.textmd = X),
    (I.em = I.italic = I.italics = I.emph = I.textit = I.textsl = u(
      '\\textit',
      'i',
      'class="mq-text-mode"'
    )),
    (I.strong = I.bold = I.textbf = u('\\textbf', 'b', 'class="mq-text-mode"')),
    (I.sf = I.textsf = u(
      '\\textsf',
      'span',
      'class="mq-sans-serif mq-text-mode"'
    )),
    (I.tt = I.texttt = u(
      '\\texttt',
      'span',
      'class="mq-monospace mq-text-mode"'
    )),
    (I.textsc = u(
      '\\textsc',
      'span',
      'style="font-variant:small-caps" class="mq-text-mode"'
    )),
    (I.uppercase = u(
      '\\uppercase',
      'span',
      'style="text-transform:uppercase" class="mq-text-mode"'
    )),
    (I.lowercase = u(
      '\\lowercase',
      'span',
      'style="text-transform:lowercase" class="mq-text-mode"'
    ));
  var J = k(U, function(e, t) {
      (e.init = function(e) {
        t.init.call(this, '$'), (this.cursor = e);
      }),
        (e.htmlTemplate = '<span class="mq-math-mode">&0</span>'),
        (e.createBlocks = function() {
          t.createBlocks.call(this),
            (this.ends[P].cursor = this.cursor),
            (this.ends[P].write = function(e, t, n) {
              '$' !== t
                ? H.prototype.write.call(this, e, t, n)
                : this.isEmpty()
                ? (e.insRightOf(this.parent),
                  this.parent.deleteTowards(dir, e),
                  Q('\\$', '$').createLeftOf(e.show()))
                : e[C]
                ? e[P]
                  ? H.prototype.write.call(this, e, t, n)
                  : e.insLeftOf(this.parent)
                : e.insRightOf(this.parent);
            });
        }),
        (e.latex = function() {
          return '$' + this.ends[P].latex() + '$';
        });
    }),
    Z = k(W, function(e, t) {
      (e.keystroke = function(e) {
        return 'Spacebar' !== e && 'Shift-Spacebar' !== e
          ? t.keystroke.apply(this, arguments)
          : void 0;
      }),
        (e.write = function(e, t, n) {
          if ((n && n.remove(), '$' === t)) J(e).createLeftOf(e);
          else {
            var i;
            '<' === t ? (i = '&lt;') : '>' === t && (i = '&gt;'),
              Q(t, i).createLeftOf(e);
          }
        });
    });
  a.TextField = c(
    k(N, function(e) {
      (e.init = function(e) {
        e.addClass('mq-editable-field mq-text-mode'),
          this.initRootAndEvents(Z(), e);
      }),
        (e.latex = function(e) {
          return arguments.length > 0
            ? (this.__controller.renderLatexText(e),
              this.__controller.blurred &&
                this.__controller.cursor.hide().parent.blur(),
              this)
            : this.__controller.exportLatex();
        });
    })
  );
  F['\\'] = k(U, function(e, t) {
    (e.ctrlSeq = '\\'),
      (e.replaces = function(e) {
        (this._replacedFragment = e.disown()),
          (this.isEmpty = function() {
            return !1;
          });
      }),
      (e.htmlTemplate =
        '<span class="mq-latex-command-input mq-non-leaf">\\<span>&0</span></span>'),
      (e.textTemplate = ['\\']),
      (e.createBlocks = function() {
        t.createBlocks.call(this),
          (this.ends[P].focus = function() {
            return (
              this.parent.jQ.addClass('mq-hasCursor'),
              this.isEmpty() && this.parent.jQ.removeClass('mq-empty'),
              this
            );
          }),
          (this.ends[P].blur = function() {
            return (
              this.parent.jQ.removeClass('mq-hasCursor'),
              this.isEmpty() && this.parent.jQ.addClass('mq-empty'),
              this
            );
          }),
          (this.ends[P].write = function(e, t, n) {
            n && n.remove(),
              t.match(/[a-z]/i)
                ? Q(t).createLeftOf(e)
                : (this.parent.renderCommand(e),
                  ('\\' === t && this.isEmpty()) ||
                    this.parent.parent.write(e, t));
          }),
          (this.ends[P].keystroke = function(e, n, i) {
            return 'Tab' === e || 'Enter' === e || 'Spacebar' === e
              ? (this.parent.renderCommand(i.cursor), void n.preventDefault())
              : t.keystroke.apply(this, arguments);
          });
      }),
      (e.createLeftOf = function(e) {
        if ((t.createLeftOf.call(this, e), this._replacedFragment)) {
          var n = this.jQ[0];
          this.jQ = this._replacedFragment.jQ
            .addClass('mq-blur')
            .bind('mousedown mousemove', function(e) {
              return S((e.target = n)).trigger(e), !1;
            })
            .insertBefore(this.jQ)
            .add(this.jQ);
        }
      }),
      (e.latex = function() {
        return '\\' + this.ends[P].latex() + ' ';
      }),
      (e.renderCommand = function(e) {
        (this.jQ = this.jQ.last()),
          this.remove(),
          this[C] ? e.insLeftOf(this[C]) : e.insAtRightEnd(this.parent);
        var t = this.ends[P].latex();
        t || (t = ' ');
        var n = I[t];
        n
          ? ((n = n(t)),
            this._replacedFragment && n.replaces(this._replacedFragment),
            n.createLeftOf(e))
          : ((n = X()),
            n.replaces(t),
            n.createLeftOf(e),
            e.insRightOf(n),
            this._replacedFragment && this._replacedFragment.remove());
      });
  });
  (I.notin = I.cong = I.equiv = I.oplus = I.otimes = k(Y, function(e, t) {
    e.init = function(e) {
      t.init.call(this, '\\' + e + ' ', '&' + e + ';');
    };
  })),
    (I['≠'] = I.ne = I.neq = i(Y, '\\ne ', '&#x2260;')),
    (I.ast = I.star = I.loast = I.lowast = i(Y, '\\ast ', '&#x2217;')),
    (I.therefor = I.therefore = i(Y, '\\therefore ', '&#x2234;')),
    (I.cuz = I.because = i(Y, '\\because ', '&#8757;')),
    (I.prop = I.propto = i(Y, '\\propto ', '&#x221D;')),
    (I['≈'] = I.asymp = I.approx = i(Y, '\\approx ', '&#x2248;')),
    (I.isin = I.in = i(Y, '\\in ', '&#x2208;')),
    (I.ni = I.contains = i(Y, '\\ni ', '&#x220B;')),
    (I.notni = I.niton = I.notcontains = I.doesnotcontain = i(
      Y,
      '\\not\\ni ',
      '&#8716;'
    )),
    (I.sub = I.subset = i(Y, '\\subset ', '&#x2282;')),
    (I.sup = I.supset = I.superset = i(Y, '\\supset ', '&#x2283;')),
    (I.nsub = I.notsub = I.nsubset = I.notsubset = i(
      Y,
      '\\not\\subset ',
      '&#8836;'
    )),
    (I.nsup = I.notsup = I.nsupset = I.notsupset = I.nsuperset = I.notsuperset = i(
      Y,
      '\\not\\supset ',
      '&#8837;'
    )),
    (I.sube = I.subeq = I.subsete = I.subseteq = i(
      Y,
      '\\subseteq ',
      '&#x2286;'
    )),
    (I.supe = I.supeq = I.supsete = I.supseteq = I.supersete = I.superseteq = i(
      Y,
      '\\supseteq ',
      '&#x2287;'
    )),
    (I.nsube = I.nsubeq = I.notsube = I.notsubeq = I.nsubsete = I.nsubseteq = I.notsubsete = I.notsubseteq = i(
      Y,
      '\\not\\subseteq ',
      '&#8840;'
    )),
    (I.nsupe = I.nsupeq = I.notsupe = I.notsupeq = I.nsupsete = I.nsupseteq = I.notsupsete = I.notsupseteq = I.nsupersete = I.nsuperseteq = I.notsupersete = I.notsuperseteq = i(
      Y,
      '\\not\\supseteq ',
      '&#8841;'
    )),
    (I.N = I.naturals = I.Naturals = i(Q, '\\mathbb{N}', '&#8469;')),
    (I.P = I.primes = I.Primes = I.projective = I.Projective = I.probability = I.Probability = i(
      Q,
      '\\mathbb{P}',
      '&#8473;'
    )),
    (I.Z = I.integers = I.Integers = i(Q, '\\mathbb{Z}', '&#8484;')),
    (I.Q = I.rationals = I.Rationals = i(Q, '\\mathbb{Q}', '&#8474;')),
    (I.R = I.reals = I.Reals = i(Q, '\\mathbb{R}', '&#8477;')),
    (I.C = I.complex = I.Complex = I.complexes = I.Complexes = I.complexplane = I.Complexplane = I.ComplexPlane = i(
      Q,
      '\\mathbb{C}',
      '&#8450;'
    )),
    (I.H = I.Hamiltonian = I.quaternions = I.Quaternions = i(
      Q,
      '\\mathbb{H}',
      '&#8461;'
    )),
    (I.quad = I.emsp = i(Q, '\\quad ', '    ')),
    (I.qquad = i(Q, '\\qquad ', '        ')),
    (I.diamond = i(Q, '\\diamond ', '&#9671;')),
    (I.bigtriangleup = i(Q, '\\bigtriangleup ', '&#9651;')),
    (I.ominus = i(Q, '\\ominus ', '&#8854;')),
    (I.uplus = i(Q, '\\uplus ', '&#8846;')),
    (I.bigtriangledown = i(Q, '\\bigtriangledown ', '&#9661;')),
    (I.sqcap = i(Q, '\\sqcap ', '&#8851;')),
    (I.triangleleft = i(Q, '\\triangleleft ', '&#8882;')),
    (I.sqcup = i(Q, '\\sqcup ', '&#8852;')),
    (I.triangleright = i(Q, '\\triangleright ', '&#8883;')),
    (I.odot = i(Q, '\\odot ', '&#8857;')),
    (I.bigcirc = i(Q, '\\bigcirc ', '&#9711;')),
    (I.dagger = i(Q, '\\dagger ', '&#0134;')),
    (I.ddagger = i(Q, '\\ddagger ', '&#135;')),
    (I.wr = i(Q, '\\wr ', '&#8768;')),
    (I.amalg = i(Q, '\\amalg ', '&#8720;')),
    (I.models = i(Q, '\\models ', '&#8872;')),
    (I.prec = i(Q, '\\prec ', '&#8826;')),
    (I.succ = i(Q, '\\succ ', '&#8827;')),
    (I.preceq = i(Q, '\\preceq ', '&#8828;')),
    (I.succeq = i(Q, '\\succeq ', '&#8829;')),
    (I.simeq = i(Q, '\\simeq ', '&#8771;')),
    (I.mid = i(Q, '\\mid ', '&#8739;')),
    (I.ll = i(Q, '\\ll ', '&#8810;')),
    (I.gg = i(Q, '\\gg ', '&#8811;')),
    (I.parallel = i(Q, '\\parallel ', '&#8741;')),
    (I.bowtie = i(Q, '\\bowtie ', '&#8904;')),
    (I.sqsubset = i(Q, '\\sqsubset ', '&#8847;')),
    (I.sqsupset = i(Q, '\\sqsupset ', '&#8848;')),
    (I.smile = i(Q, '\\smile ', '&#8995;')),
    (I.sqsubseteq = i(Q, '\\sqsubseteq ', '&#8849;')),
    (I.sqsupseteq = i(Q, '\\sqsupseteq ', '&#8850;')),
    (I.doteq = i(Q, '\\doteq ', '&#8784;')),
    (I.frown = i(Q, '\\frown ', '&#8994;')),
    (I.vdash = i(Q, '\\vdash ', '&#8870;')),
    (I.dashv = i(Q, '\\dashv ', '&#8867;')),
    (I.longleftarrow = i(Q, '\\longleftarrow ', '&#8592;')),
    (I.longrightarrow = i(Q, '\\longrightarrow ', '&#8594;')),
    (I.Longleftarrow = i(Q, '\\Longleftarrow ', '&#8656;')),
    (I.Longrightarrow = i(Q, '\\Longrightarrow ', '&#8658;')),
    (I.longleftrightarrow = i(Q, '\\longleftrightarrow ', '&#8596;')),
    (I.updownarrow = i(Q, '\\updownarrow ', '&#8597;')),
    (I.Longleftrightarrow = i(Q, '\\Longleftrightarrow ', '&#8660;')),
    (I.Updownarrow = i(Q, '\\Updownarrow ', '&#8661;')),
    (I.mapsto = i(Q, '\\mapsto ', '&#8614;')),
    (I.nearrow = i(Q, '\\nearrow ', '&#8599;')),
    (I.hookleftarrow = i(Q, '\\hookleftarrow ', '&#8617;')),
    (I.hookrightarrow = i(Q, '\\hookrightarrow ', '&#8618;')),
    (I.searrow = i(Q, '\\searrow ', '&#8600;')),
    (I.leftharpoonup = i(Q, '\\leftharpoonup ', '&#8636;')),
    (I.rightharpoonup = i(Q, '\\rightharpoonup ', '&#8640;')),
    (I.swarrow = i(Q, '\\swarrow ', '&#8601;')),
    (I.leftharpoondown = i(Q, '\\leftharpoondown ', '&#8637;')),
    (I.rightharpoondown = i(Q, '\\rightharpoondown ', '&#8641;')),
    (I.nwarrow = i(Q, '\\nwarrow ', '&#8598;')),
    (I.ldots = i(Q, '\\ldots ', '&#8230;')),
    (I.cdots = i(Q, '\\cdots ', '&#8943;')),
    (I.vdots = i(Q, '\\vdots ', '&#8942;')),
    (I.ddots = i(Q, '\\ddots ', '&#8944;')),
    (I.surd = i(Q, '\\surd ', '&#8730;')),
    (I.triangle = i(Q, '\\triangle ', '&#9653;')),
    (I.ell = i(Q, '\\ell ', '&#8467;')),
    (I.top = i(Q, '\\top ', '&#8868;')),
    (I.flat = i(Q, '\\flat ', '&#9837;')),
    (I.natural = i(Q, '\\natural ', '&#9838;')),
    (I.sharp = i(Q, '\\sharp ', '&#9839;')),
    (I.wp = i(Q, '\\wp ', '&#8472;')),
    (I.bot = i(Q, '\\bot ', '&#8869;')),
    (I.clubsuit = i(Q, '\\clubsuit ', '&#9827;')),
    (I.diamondsuit = i(Q, '\\diamondsuit ', '&#9826;')),
    (I.heartsuit = i(Q, '\\heartsuit ', '&#9825;')),
    (I.spadesuit = i(Q, '\\spadesuit ', '&#9824;')),
    (I.oint = i(Q, '\\oint ', '&#8750;')),
    (I.bigcap = i(Q, '\\bigcap ', '&#8745;')),
    (I.bigcup = i(Q, '\\bigcup ', '&#8746;')),
    (I.bigsqcup = i(Q, '\\bigsqcup ', '&#8852;')),
    (I.bigvee = i(Q, '\\bigvee ', '&#8744;')),
    (I.bigwedge = i(Q, '\\bigwedge ', '&#8743;')),
    (I.bigodot = i(Q, '\\bigodot ', '&#8857;')),
    (I.bigotimes = i(Q, '\\bigotimes ', '&#8855;')),
    (I.bigoplus = i(Q, '\\bigoplus ', '&#8853;')),
    (I.biguplus = i(Q, '\\biguplus ', '&#8846;')),
    (I.lfloor = i(Q, '\\lfloor ', '&#8970;')),
    (I.rfloor = i(Q, '\\rfloor ', '&#8971;')),
    (I.lceil = i(Q, '\\lceil ', '&#8968;')),
    (I.rceil = i(Q, '\\rceil ', '&#8969;')),
    (I.opencurlybrace = I.lbrace = i(Q, '\\lbrace ', '{')),
    (I.closecurlybrace = I.rbrace = i(Q, '\\rbrace ', '}')),
    (I['∫'] = I.int = I.integral = i(_, '\\int ', '<big>&#x222B;</big>')),
    (I.caret = i(Q, '\\text{^}', '^')),
    (I.underscore = i(Q, '\\_', '_')),
    (I.slash = i(Q, '/')),
    (I.vert = i(Q, '|')),
    (I.perp = I.perpendicular = i(Q, '\\perp ', '&#x22A5;')),
    (I.nabla = I.del = i(Q, '\\nabla ', '&#x2207;')),
    (I.hbar = i(Q, '\\hbar ', '&#8463;')),
    (I.AA = I.Angstrom = I.angstrom = i(Q, '\\text\\AA ', '&#8491;')),
    (I.ring = I.circ = I.circle = i(Q, '\\circ ', '&#8728;')),
    (I.bull = I.bullet = i(Q, '\\bullet ', '&#x2022;')),
    (I.setminus = I.smallsetminus = i(Q, '\\setminus ', '&#8726;')),
    (I.not = I['¬'] = I.neg = i(Q, '\\neg ', '&#x00AC;')),
    (I['…'] = I.dots = I.ellip = I.hellip = I.ellipsis = I.hellipsis = i(
      Q,
      '\\dots ',
      '&#x2026;'
    )),
    (I.converges = I.darr = I.dnarr = I.dnarrow = I.downarrow = i(
      Q,
      '\\downarrow ',
      '&#x2193;'
    )),
    (I.dArr = I.dnArr = I.dnArrow = I.Downarrow = i(
      Q,
      '\\Downarrow ',
      '&#x21D3;'
    )),
    (I.diverges = I.uarr = I.uparrow = i(Q, '\\uparrow ', '&#x2191;')),
    (I.uArr = I.Uparrow = i(Q, '\\Uparrow ', '&#x21D1;')),
    (I.to = i(Y, '\\to ', '&#x2192;')),
    (I.rarr = I.rightarrow = i(Q, '\\rightarrow ', '&#x2192;')),
    (I.implies = i(Y, '\\Rightarrow ', '&#x21D2;')),
    (I.rArr = I.Rightarrow = i(Q, '\\Rightarrow ', '&#x21D2;')),
    (I.gets = i(Y, '\\gets ', '&#x2190;')),
    (I.larr = I.leftarrow = i(Q, '\\leftarrow ', '&#x2190;')),
    (I.impliedby = i(Y, '\\Leftarrow ', '&#x21D0;')),
    (I.lArr = I.Leftarrow = i(Q, '\\Leftarrow ', '&#x21D0;')),
    (I.harr = I.lrarr = I.leftrightarrow = i(
      Q,
      '\\leftrightarrow ',
      '&#x2194;'
    )),
    (I.iff = i(Y, '\\Leftrightarrow ', '&#x21D4;')),
    (I.hArr = I.lrArr = I.Leftrightarrow = i(
      Q,
      '\\Leftrightarrow ',
      '&#x21D4;'
    )),
    (I.Re = I.Real = I.real = i(Q, '\\Re ', '&#x211C;')),
    (I.Im = I.imag = I.image = I.imagin = I.imaginary = I.Imaginary = i(
      Q,
      '\\Im ',
      '&#x2111;'
    )),
    (I.part = I.partial = i(Q, '\\partial ', '&#x2202;')),
    (I.infty = I.infin = I.infinity = i(Q, '\\infty ', '&#x221E;')),
    (I.alef = I.alefsym = I.aleph = I.alephsym = i(Q, '\\aleph ', '&#x2135;')),
    (I.xist = I.xists = I.exist = I.exists = i(Q, '\\exists ', '&#x2203;')),
    (I.and = I.land = I.wedge = i(Q, '\\wedge ', '&#x2227;')),
    (I.or = I.lor = I.vee = i(Q, '\\vee ', '&#x2228;')),
    (I.o = I.O = I.empty = I.emptyset = I.oslash = I.Oslash = I.nothing = I.varnothing = i(
      Y,
      '\\varnothing ',
      '&#x8960;'
    )),
    (I.cup = I.union = i(Y, '\\cup ', '&#x222A;')),
    (I.cap = I.intersect = I.intersection = i(Y, '\\cap ', '&#x2229;')),
    (I.deg = I.degree = i(Q, '^\\circ ', '&#x00B0;')),
    (I.ang = I.angle = i(Q, '\\angle ', '&#x2220;'));
  var $ = k(_, function(e, t) {
    (e.init = function(e, n) {
      t.init.call(this, e, '<var>' + (n || e) + '</var>');
    }),
      (e.text = function() {
        var e = this.ctrlSeq;
        return (
          !this[P] ||
            this[P] instanceof $ ||
            this[P] instanceof Y ||
            (e = '*' + e),
          !this[C] ||
            this[C] instanceof Y ||
            '^' === this[C].ctrlSeq ||
            (e += '*'),
          e
        );
      });
  });
  (G.p.autoCommands = { _maxLength: 0 }),
    (D.autoCommands = function(e) {
      if (!/^[a-z]+(?: [a-z]+)*$/i.test(e))
        throw '"' + e + '" not a space-delimited list of only letters';
      for (var t = e.split(' '), n = {}, i = 0, r = 0; r < t.length; r += 1) {
        var s = t[r];
        if (s.length < 2)
          throw 'autocommand "' + s + '" not minimum length of 2';
        if (I[s] === ie) throw '"' + s + '" is a built-in operator name';
        (n[s] = 1), (i = y(i, s.length));
      }
      return (n._maxLength = i), n;
    });
  var ee = k($, function(e, t) {
      function n(e) {
        return e instanceof _ && !(e instanceof Y);
      }
      (e.init = function(e) {
        return t.init.call(this, (this.letter = e));
      }),
        (e.createLeftOf = function(e) {
          var n = e.options.autoCommands,
            i = n._maxLength;
          if (i > 0) {
            for (
              var r = this.letter, s = e[P], o = 1;
              s instanceof ee && i > o;

            )
              (r = s.letter + r), (s = s[P]), (o += 1);
            for (; r.length; ) {
              if (n.hasOwnProperty(r)) {
                for (o = 2, s = e[P]; o < r.length; o += 1, s = s[P]);
                return (
                  M(s, e[P]).remove(), (e[P] = s[P]), I[r](r).createLeftOf(e)
                );
              }
              r = r.slice(1);
            }
          }
          t.createLeftOf.apply(this, arguments);
        }),
        (e.italicize = function(e) {
          return this.jQ.toggleClass('mq-operator-name', !e), this;
        }),
        (e.finalizeTree = e.siblingDeleted = e.siblingCreated = function(e, t) {
          (t !== P && this[C] instanceof ee) || this.autoUnItalicize(e);
        }),
        (e.autoUnItalicize = function(e) {
          var t = e.autoOperatorNames;
          if (0 !== t._maxLength) {
            for (var i = this.letter, r = this[P]; r instanceof ee; r = r[P])
              i = r.letter + i;
            for (var s = this[C]; s instanceof ee; s = s[C]) i += s.letter;
            M(r[C] || this.parent.ends[P], s[P] || this.parent.ends[C]).each(
              function(e) {
                e.italicize(!0).jQ.removeClass('mq-first mq-last'),
                  (e.ctrlSeq = e.letter);
              }
            );
            e: for (
              var o = 0, a = r[C] || this.parent.ends[P];
              o < i.length;
              o += 1, a = a[C]
            )
              for (var c = v(t._maxLength, i.length - o); c > 0; c -= 1) {
                var l,
                  u = i.slice(o, o + c);
                if (t.hasOwnProperty(u)) {
                  for (var d = 0, h = a; c > d; d += 1, h = h[C])
                    h.italicize(!1), (l = h);
                  var p = te.hasOwnProperty(u);
                  (a.ctrlSeq = (p ? '\\' : '\\operatorname{') + a.ctrlSeq),
                    (l.ctrlSeq += p ? ' ' : '}'),
                    ne.hasOwnProperty(u) && l[P][P][P].jQ.addClass('mq-last'),
                    n(a[P]) && a.jQ.addClass('mq-first'),
                    n(l[C]) && l.jQ.addClass('mq-last'),
                    (o += c - 1),
                    (a = l);
                  continue e;
                }
              }
          }
        });
    }),
    te = {},
    ne = { limsup: 1, liminf: 1, projlim: 1, injlim: 1 };
  !(function() {
    var e,
      t = (G.p.autoOperatorNames = { _maxLength: 9 }),
      n = 'arg deg det dim exp gcd hom inf ker lg lim ln log max min sup limsup liminf injlim projlim Pr'.split(
        ' '
      );
    for (e = 0; e < n.length; e += 1) te[n[e]] = t[n[e]] = 1;
    var i = 'sin cos tan arcsin arccos arctan sinh cosh tanh sec csc cot coth'.split(
      ' '
    );
    for (e = 0; e < i.length; e += 1) te[i[e]] = 1;
    var r = 'sin cos tan sec cosec csc cotan cot ctg'.split(' ');
    for (e = 0; e < r.length; e += 1)
      t[r[e]] = t['arc' + r[e]] = t[r[e] + 'h'] = t['ar' + r[e] + 'h'] = t[
        'arc' + r[e] + 'h'
      ] = 1;
  })(),
    (D.autoOperatorNames = function(e) {
      if (!/^[a-z]+(?: [a-z]+)*$/i.test(e))
        throw '"' + e + '" not a space-delimited list of only letters';
      for (var t = e.split(' '), n = {}, i = 0, r = 0; r < t.length; r += 1) {
        var s = t[r];
        if (s.length < 2) throw '"' + s + '" not minimum length of 2';
        (n[s] = 1), (i = y(i, s.length));
      }
      return (n._maxLength = i), n;
    });
  var ie = k(_, function(e, t) {
    (e.init = function(e) {
      this.ctrlSeq = e;
    }),
      (e.createLeftOf = function(e) {
        for (var t = this.ctrlSeq, n = 0; n < t.length; n += 1)
          ee(t.charAt(n)).createLeftOf(e);
      }),
      (e.parser = function() {
        for (var e = this.ctrlSeq, t = H(), n = 0; n < e.length; n += 1)
          ee(e.charAt(n)).adopt(t, t.ends[C], 0);
        return z.succeed(t.children());
      });
  });
  for (var re in te) te.hasOwnProperty(re) && (I[re] = ie);
  (I.operatorname = k(U, function(t) {
    (t.createLeftOf = e),
      (t.numBlocks = function() {
        return 1;
      }),
      (t.parser = function() {
        return V.block.map(function(e) {
          return e.children();
        });
      });
  })),
    (I.f = k(ee, function(e, t) {
      (e.init = function() {
        _.p.init.call(
          this,
          (this.letter = 'f'),
          '<var class="mq-florin">&#x0192;</var>'
        );
      }),
        (e.italicize = function(e) {
          return (
            this.jQ.html(e ? '&#x0192;' : 'f').toggleClass('mq-florin', e),
            t.italicize.apply(this, arguments)
          );
        });
    })),
    (I[' '] = I.space = i(Q, '\\ ', ' ')),
    (I["'"] = I.prime = i(Q, "'", '&#x2032;')),
    (I.backslash = i(Q, '\\backslash ', '\\')),
    F['\\'] || (F['\\'] = I.backslash),
    (I.$ = i(Q, '\\$', '$'));
  var se = k(_, function(e, t) {
    e.init = function(e, n) {
      t.init.call(
        this,
        e,
        '<span class="mq-nonSymbola">' + (n || e) + '</span>'
      );
    };
  });
  (I['@'] = se),
    (I['&'] = i(se, '\\&', '&amp;')),
    (I['%'] = i(se, '\\%', '%')),
    (I.alpha = I.beta = I.gamma = I.delta = I.zeta = I.eta = I.theta = I.iota = I.kappa = I.mu = I.nu = I.xi = I.rho = I.sigma = I.tau = I.chi = I.psi = I.omega = k(
      $,
      function(e, t) {
        e.init = function(e) {
          t.init.call(this, '\\' + e + ' ', '&' + e + ';');
        };
      }
    )),
    (I.phi = i($, '\\phi ', '&#981;')),
    (I.phiv = I.varphi = i($, '\\varphi ', '&#x03C6;')),
    (I.epsilon = i($, '\\epsilon ', '&#1013;')),
    (I.epsiv = I.varepsilon = i($, '\\varepsilon ', '&#x03B5;')),
    (I.piv = I.varpi = i($, '\\varpi ', '&#x03D6;')),
    (I.sigmaf = I.sigmav = I.varsigma = i($, '\\varsigma ', '&#x03C2;')),
    (I.thetav = I.vartheta = I.thetasym = i($, '\\vartheta ', '&#x03D1;')),
    (I.upsilon = I.upsi = i($, '\\upsilon ', '&#x03C5;')),
    (I.gammad = I.Gammad = I.digamma = i($, '\\digamma ', '&#989;')),
    (I.kappav = I.varkappa = i($, '\\varkappa ', '&#1008;')),
    (I.rhov = I.varrho = i($, '\\varrho ', '&#1009;')),
    (I.pi = I['π'] = i(se, '\\pi ', '&#x03C0;')),
    (I.lambda = i(se, '\\lambda ', '&#x03BB;')),
    (I.Upsilon = I.Upsi = I.upsih = I.Upsih = i(
      _,
      '\\Upsilon ',
      '<var style="font-family: serif">&#x03D2;</var>'
    )),
    (I.Gamma = I.Delta = I.Theta = I.Lambda = I.Xi = I.Pi = I.Sigma = I.Phi = I.Psi = I.Omega = I.forall = k(
      Q,
      function(e, t) {
        e.init = function(e) {
          t.init.call(this, '\\' + e + ' ', '&' + e + ';');
        };
      }
    ));
  var oe = k(U, function(e) {
    (e.init = function(e) {
      this.latex = e;
    }),
      (e.createLeftOf = function(e) {
        var t = V.parse(this.latex);
        t.children().adopt(e.parent, e[P], e[C]),
          (e[P] = t.ends[C]),
          t.jQize().insertBefore(e.jQ),
          t.finalizeInsert(e.options, e),
          t.ends[C][C].siblingCreated &&
            t.ends[C][C].siblingCreated(e.options, P),
          t.ends[P][P].siblingCreated &&
            t.ends[P][P].siblingCreated(e.options, C),
          e.parent.bubble('reflow');
      }),
      (e.parser = function() {
        var e = V.parse(this.latex).children();
        return z.succeed(e);
      });
  });
  (I['¹'] = i(oe, '^1')),
    (I['²'] = i(oe, '^2')),
    (I['³'] = i(oe, '^3')),
    (I['¼'] = i(oe, '\\frac14')),
    (I['½'] = i(oe, '\\frac12')),
    (I['¾'] = i(oe, '\\frac34'));
  var ae = k(Y, function(e) {
    (e.init = Q.prototype.init),
      (e.contactWeld = e.siblingCreated = e.siblingDeleted = function(e, t) {
        return t !== C
          ? ((this.jQ[0].className =
              !this[P] || this[P] instanceof Y ? '' : 'mq-binary-operator'),
            this)
          : void 0;
      });
  });
  (I['+'] = i(ae, '+', '+')),
    (I['–'] = I['-'] = i(ae, '-', '&#x2212;')),
    (I['±'] = I.pm = I.plusmn = I.plusminus = i(ae, '\\pm ', '&#x00B1;')),
    (I.mp = I.mnplus = I.minusplus = i(ae, '\\mp ', '&#8723;')),
    (F['*'] = I.sdot = I.cdot = i(Y, '\\cdot ', '&#x00B7;'));
  var ce = k(Y, function(e, t) {
      (e.init = function(e, n) {
        (this.data = e), (this.strict = n);
        var i = n ? 'Strict' : '';
        t.init.call(this, e['ctrlSeq' + i], e['html' + i], e['text' + i]);
      }),
        (e.swap = function(e) {
          this.strict = e;
          var t = e ? 'Strict' : '';
          (this.ctrlSeq = this.data['ctrlSeq' + t]),
            this.jQ.html(this.data['html' + t]),
            (this.textTemplate = [this.data['text' + t]]);
        }),
        (e.deleteTowards = function(e, n) {
          return e !== P || this.strict
            ? void t.deleteTowards.apply(this, arguments)
            : void this.swap(!0);
        });
    }),
    le = {
      ctrlSeq: '\\le ',
      html: '&#x2264;',
      text: '≤',
      ctrlSeqStrict: '<',
      htmlStrict: '&lt;',
      textStrict: '<',
    },
    ue = {
      ctrlSeq: '\\ge ',
      html: '&#x2265;',
      text: '≥',
      ctrlSeqStrict: '>',
      htmlStrict: '&gt;',
      textStrict: '>',
    };
  (I['<'] = I.lt = i(ce, le, !0)),
    (I['>'] = I.gt = i(ce, ue, !0)),
    (I['≤'] = I.le = I.leq = i(ce, le, !1)),
    (I['≥'] = I.ge = I.geq = i(ce, ue, !1));
  var de = k(Y, function(e, t) {
    (e.init = function() {
      t.init.call(this, '=', '=');
    }),
      (e.createLeftOf = function(e) {
        return e[P] instanceof ce && e[P].strict
          ? void e[P].swap(!1)
          : void t.createLeftOf.apply(this, arguments);
      });
  });
  (I['='] = de),
    (I.times = i(Y, '\\times ', '&#x00D7;', '[x]')),
    (I['÷'] = I.div = I.divide = I.divides = i(Y, '\\div ', '&#x00F7;', '[/]')),
    (F['~'] = I.sim = i(Y, '\\sim ', '&#x223C;', '~'));
  var he,
    pe,
    fe = e,
    me = document.createElement('div'),
    ge = me.style,
    be = {
      transform: 1,
      WebkitTransform: 1,
      MozTransform: 1,
      OTransform: 1,
      msTransform: 1,
    };
  for (var ve in be)
    if (ve in ge) {
      pe = ve;
      break;
    }
  pe
    ? (he = function(e, t, n) {
        e.css(pe, 'scale(' + t + ',' + n + ')');
      })
    : 'filter' in ge
    ? ((fe = function(e) {
        e.className = e.className;
      }),
      (he = function(e, t, n) {
        function i() {
          e.css('marginRight', ((r.width() - 1) * (t - 1)) / t + 'px');
        }
        (t /= 1 + (n - 1) / 2),
          e.css('fontSize', n + 'em'),
          e.hasClass('mq-matrixed-container') ||
            e
              .addClass('mq-matrixed-container')
              .wrapInner('<span class="mq-matrixed"></span>');
        var r = e
          .children()
          .css(
            'filter',
            'progid:DXImageTransform.Microsoft.Matrix(M11=' +
              t +
              ",SizingMethod='auto expand')"
          );
        i();
        var s = setInterval(i);
        S(window).load(function() {
          clearTimeout(s), i();
        });
      }))
    : (he = function(e, t, n) {
        e.css('fontSize', n + 'em');
      });
  var ye = k(U, function(e, t) {
    e.init = function(e, n, i) {
      t.init.call(this, e, '<' + n + ' ' + i + '>&0</' + n + '>');
    };
  });
  (I.mathrm = i(ye, '\\mathrm', 'span', 'class="mq-roman mq-font"')),
    (I.mathit = i(ye, '\\mathit', 'i', 'class="mq-font"')),
    (I.mathbf = i(ye, '\\mathbf', 'b', 'class="mq-font"')),
    (I.mathsf = i(ye, '\\mathsf', 'span', 'class="mq-sans-serif mq-font"')),
    (I.mathtt = i(ye, '\\mathtt', 'span', 'class="mq-monospace mq-font"')),
    (I.underline = i(
      ye,
      '\\underline',
      'span',
      'class="mq-non-leaf mq-underline"'
    )),
    (I.overline = I.bar = i(
      ye,
      '\\overline',
      'span',
      'class="mq-non-leaf mq-overline"'
    ));
  var xe =
      ((I.textcolor = k(U, function(e, t) {
        (e.setColor = function(e) {
          (this.color = e),
            (this.htmlTemplate =
              '<span class="mq-textcolor" style="color:' + e + '">&0</span>');
        }),
          (e.latex = function() {
            return (
              '\\textcolor{' + this.color + '}{' + this.blocks[0].latex() + '}'
            );
          }),
          (e.parser = function() {
            var e = this,
              n = z.optWhitespace,
              i = z.string,
              r = z.regex;
            return n
              .then(i('{'))
              .then(r(/^[#\w\s.,()%-]*/))
              .skip(i('}'))
              .then(function(n) {
                return e.setColor(n), t.parser.call(e);
              });
          });
      })),
      (I.class = k(U, function(e, t) {
        e.parser = function() {
          var e = this,
            n = z.string,
            i = z.regex;
          return z.optWhitespace
            .then(n('{'))
            .then(i(/^[-\w\s\\\xA0-\xFF]*/))
            .skip(n('}'))
            .then(function(n) {
              return (
                (e.htmlTemplate = '<span class="mq-class ' + n + '">&0</span>'),
                t.parser.call(e)
              );
            });
        };
      })),
      k(U, function(e, t) {
        (e.ctrlSeq = '_{...}^{...}'),
          (e.createLeftOf = function(e) {
            return e[P] || !e.options.supSubsRequireOperand
              ? t.createLeftOf.apply(this, arguments)
              : void 0;
          }),
          (e.contactWeld = function(e) {
            var t, n;
            for (t = P; t; t = t === P ? C : !1)
              if (this[t] instanceof xe) {
                for (var i = 'sub'; i; i = 'sub' === i ? 'sup' : !1) {
                  var r = this[i],
                    s = this[t][i];
                  if (r) {
                    if (s)
                      if (r.isEmpty()) n = A(s, 0, s.ends[P]);
                      else {
                        r.jQ.children().insAtDirEnd(-t, s.jQ);
                        var o = r.children().disown();
                        (n = A(s, o.ends[C], s.ends[P])),
                          t === P
                            ? o.adopt(s, s.ends[C], 0)
                            : o.adopt(s, 0, s.ends[P]);
                      }
                    else this[t].addBlock(r.disown());
                    this.placeCursor = (function(e, n) {
                      return function(i) {
                        i.insAtDirEnd(-t, e || n);
                      };
                    })(s, r);
                  }
                }
                this.remove(),
                  e &&
                    e[P] === this &&
                    (t === C && n
                      ? n[P]
                        ? e.insRightOf(n[P])
                        : e.insAtLeftEnd(n.parent)
                      : e.insRightOf(this[t]));
                break;
              }
            this.respace();
          }),
          (G.p.charsThatBreakOutOfSupSub = ''),
          (e.finalizeTree = function() {
            this.ends[P].write = function(e, t) {
              e.options.charsThatBreakOutOfSupSub.indexOf(t) > -1 &&
                e.insRightOf(this.parent),
                H.p.write.apply(this, arguments);
            };
          }),
          (e.latex = function() {
            function e(e, t) {
              var n = t && t.latex();
              return t ? e + (1 === n.length ? n : '{' + (n || ' ') + '}') : '';
            }
            return e('_', this.sub) + e('^', this.sup);
          }),
          (e.respace = e.siblingCreated = e.siblingDeleted = function(e, t) {
            t !== C &&
              this.jQ.toggleClass('mq-limit', '\\int ' === this[P].ctrlSeq);
          }),
          (e.addBlock = function(e) {
            'sub' === this.supsub
              ? ((this.sup = this.upInto = this.sub.upOutOf = e),
                (e.adopt(this, this.sub, 0).downOutOf = this.sub),
                (e.jQ = S('<span class="mq-sup"/>')
                  .append(e.jQ.children())
                  .attr(b, e.id)
                  .prependTo(this.jQ)))
              : ((this.sub = this.downInto = this.sup.downOutOf = e),
                (e.adopt(this, 0, this.sup).upOutOf = this.sup),
                (e.jQ = S('<span class="mq-sub"></span>')
                  .append(e.jQ.children())
                  .attr(b, e.id)
                  .appendTo(this.jQ.removeClass('mq-sup-only'))),
                this.jQ.append(
                  '<span style="display:inline-block;width:0">&#x00A0;</span>'
                ));
            for (var t = 0; 2 > t; t += 1)
              (function(e, t, n, i) {
                e[t].deleteOutOf = function(r, s) {
                  s.insDirOf(r, this.parent),
                    this.isEmpty() ||
                      ((s[-r] = this.ends[r]),
                      this.children()
                        .disown()
                        .withDirAdopt(r, s.parent, s[r], this.parent)
                        .jQ.insDirOf(r, this.parent.jQ)),
                    (e.supsub = n),
                    delete e[t],
                    delete e[i + 'Into'],
                    (e[n][i + 'OutOf'] = d),
                    delete e[n].deleteOutOf,
                    'sub' === t &&
                      S(e.jQ.addClass('mq-sup-only')[0].lastChild).remove(),
                    this.remove();
                };
              })(
                this,
                'sub sup'.split(' ')[t],
                'sup sub'.split(' ')[t],
                'down up'.split(' ')[t]
              );
          });
      })),
    we = k(U, function(e, t) {
      (e.init = function(e, t) {
        var n =
          '<span class="mq-large-operator mq-non-leaf"><span class="mq-to"><span>&1</span></span><big>' +
          t +
          '</big><span class="mq-from"><span>&0</span></span></span>';
        _.prototype.init.call(this, e, n);
      }),
        (e.createLeftOf = function(e) {
          t.createLeftOf.apply(this, arguments),
            e.options.sumStartsWithNEquals &&
              (ee('n').createLeftOf(e), de().createLeftOf(e));
        }),
        (e.latex = function() {
          function e(e) {
            return 1 === e.length ? e : '{' + (e || ' ') + '}';
          }
          return (
            this.ctrlSeq +
            '_' +
            e(this.ends[P].latex()) +
            '^' +
            e(this.ends[C].latex())
          );
        }),
        (e.parser = function() {
          for (
            var e = z.string,
              t = z.optWhitespace,
              n = z.succeed,
              i = V.block,
              r = this,
              s = (r.blocks = [H(), H()]),
              o = 0;
            o < s.length;
            o += 1
          )
            s[o].adopt(r, r.ends[C], 0);
          return t
            .then(e('_').or(e('^')))
            .then(function(e) {
              var t = s['_' === e ? 0 : 1];
              return i.then(function(e) {
                return e.children().adopt(t, t.ends[C], 0), n(r);
              });
            })
            .many()
            .result(r);
        }),
        (e.finalizeTree = function() {
          (this.downInto = this.ends[P]),
            (this.upInto = this.ends[C]),
            (this.ends[P].upOutOf = this.ends[C]),
            (this.ends[C].downOutOf = this.ends[P]);
        });
    });
  (I['∑'] = I.sum = I.summation = i(we, '\\sum ', '&#x2211;')),
    (I['∏'] = I.prod = I.product = i(we, '\\prod ', '&#x220F;')),
    (I.coprod = I.coproduct = i(we, '\\coprod ', '&#8720;')),
    (I.subscript = I._ = k(xe, function(e, t) {
      (e.supsub = 'sub'),
        (e.htmlTemplate =
          '<span class="mq-supsub mq-non-leaf"><span class="mq-sub">&0</span><span style="display:inline-block;width:0">&#x00A0;</span></span>'),
        (e.textTemplate = ['_']),
        (e.finalizeTree = function() {
          (this.downInto = this.sub = this.ends[P]),
            (this.sub.upOutOf = d),
            t.finalizeTree.call(this);
        });
    })),
    (I.superscript = I.supscript = I['^'] = k(xe, function(e, t) {
      (e.supsub = 'sup'),
        (e.htmlTemplate =
          '<span class="mq-supsub mq-non-leaf mq-sup-only"><span class="mq-sup">&0</span></span>'),
        (e.textTemplate = ['**']),
        (e.finalizeTree = function() {
          (this.upInto = this.sup = this.ends[C]),
            (this.sup.downOutOf = d),
            t.finalizeTree.call(this);
        });
    }));
  var ke = (I.frac = I.dfrac = I.cfrac = I.fraction = k(U, function(e, t) {
      (e.ctrlSeq = '\\frac'),
        (e.htmlTemplate =
          '<span class="mq-fraction mq-non-leaf"><span class="mq-numerator">&0</span><span class="mq-denominator">&1</span><span style="display:inline-block;width:0">&#x00A0;</span></span>'),
        (e.textTemplate = ['(', '/', ')']),
        (e.finalizeTree = function() {
          (this.upInto = this.ends[C].upOutOf = this.ends[P]),
            (this.downInto = this.ends[P].downOutOf = this.ends[C]);
        });
    })),
    Pe = (I.over = F['/'] = k(ke, function(t, n) {
      t.createLeftOf = function(t) {
        if (!this.replacedFragment) {
          for (
            var i = t[P];
            i &&
            !(
              i instanceof Y ||
              i instanceof (I.text || e) ||
              i instanceof we ||
              '\\ ' === i.ctrlSeq ||
              /^[,;:]$/.test(i.ctrlSeq)
            );

          )
            i = i[P];
          i instanceof we &&
            i[C] instanceof xe &&
            ((i = i[C]),
            i[C] instanceof xe && i[C].ctrlSeq != i.ctrlSeq && (i = i[C])),
            i !== t[P] &&
              (this.replaces(M(i[C] || t.parent.ends[P], t[P])), (t[P] = i));
        }
        n.createLeftOf.call(this, t);
      };
    })),
    Ce = (I.sqrt = I['√'] = k(U, function(e, t) {
      (e.ctrlSeq = '\\sqrt'),
        (e.htmlTemplate =
          '<span class="mq-non-leaf"><span class="mq-scaled mq-sqrt-prefix">&#x221A;</span><span class="mq-non-leaf mq-sqrt-stem">&0</span></span>'),
        (e.textTemplate = ['sqrt(', ')']),
        (e.parser = function() {
          return V.optBlock
            .then(function(e) {
              return V.block.map(function(t) {
                var n = Se();
                return (
                  (n.blocks = [e, t]), e.adopt(n, 0, 0), t.adopt(n, e, 0), n
                );
              });
            })
            .or(t.parser.call(this));
        }),
        (e.reflow = function() {
          var e = this.ends[C].jQ;
          he(
            e.prev(),
            1,
            e.innerHeight() / +e.css('fontSize').slice(0, -2) + 0.1
          );
        });
    })),
    Se =
      ((I.vec = k(U, function(e, t) {
        (e.ctrlSeq = '\\vec'),
          (e.htmlTemplate =
            '<span class="mq-non-leaf"><span class="mq-vector-prefix">&#x2192;</span><span class="mq-vector-stem">&0</span></span>'),
          (e.textTemplate = ['vec(', ')']);
      })),
      (I.nthroot = k(Ce, function(e, t) {
        (e.htmlTemplate =
          '<sup class="mq-nthroot mq-non-leaf">&0</sup><span class="mq-scaled"><span class="mq-sqrt-prefix mq-scaled">&#x221A;</span><span class="mq-sqrt-stem mq-non-leaf">&1</span></span>'),
          (e.textTemplate = ['sqrt[', '](', ')']),
          (e.latex = function() {
            return (
              '\\sqrt[' +
              this.ends[P].latex() +
              ']{' +
              this.ends[C].latex() +
              '}'
            );
          });
      }))),
    Ae = k(k(U, h), function(t, n) {
      (t.init = function(e, t, i, r, s) {
        n.init.call(this, '\\left' + r, f, [t, i]),
          (this.side = e),
          (this.sides = {}),
          (this.sides[P] = { ch: t, ctrlSeq: r }),
          (this.sides[C] = { ch: i, ctrlSeq: s });
      }),
        (t.numBlocks = function() {
          return 1;
        }),
        (t.html = function() {
          return (
            (this.htmlTemplate =
              '<span class="mq-non-leaf"><span class="mq-scaled mq-paren' +
              (this.side === C ? ' mq-ghost' : '') +
              '">' +
              this.sides[P].ch +
              '</span><span class="mq-non-leaf">&0</span><span class="mq-scaled mq-paren' +
              (this.side === P ? ' mq-ghost' : '') +
              '">' +
              this.sides[C].ch +
              '</span></span>'),
            n.html.call(this)
          );
        }),
        (t.latex = function() {
          return (
            '\\left' +
            this.sides[P].ctrlSeq +
            this.ends[P].latex() +
            '\\right' +
            this.sides[C].ctrlSeq
          );
        }),
        (t.oppBrack = function(e, t) {
          return (
            e instanceof Ae &&
            e.side &&
            e.side !== -t &&
            ('|' === this.sides[this.side].ch || e.side === -this.side) &&
            e
          );
        }),
        (t.closeOpposing = function(e) {
          (e.side = 0),
            (e.sides[this.side] = this.sides[this.side]),
            e.delimjQs
              .eq(this.side === P ? 0 : 1)
              .removeClass('mq-ghost')
              .html(this.sides[this.side].ch);
        }),
        (t.createLeftOf = function(e) {
          var t, i;
          this.replacedFragment ||
            (t =
              this.oppBrack(e[P], P) ||
              this.oppBrack(e[C], C) ||
              this.oppBrack(e.parent.parent)),
            t
              ? ((i = this.side = -t.side),
                this.closeOpposing(t),
                t === e.parent.parent &&
                  e[i] &&
                  (M(e[i], e.parent.ends[i], -i)
                    .disown()
                    .withDirAdopt(-i, t.parent, t, t[i])
                    .jQ.insDirOf(i, t.jQ),
                  t.bubble('reflow')))
              : ((t = this),
                (i = t.side),
                t.replacedFragment
                  ? (t.side = 0)
                  : e[-i] &&
                    (t.replaces(M(e[-i], e.parent.ends[-i], i)), (e[-i] = 0)),
                n.createLeftOf.call(t, e)),
            i === P ? e.insAtLeftEnd(t.ends[P]) : e.insRightOf(t);
        }),
        (t.placeCursor = e),
        (t.unwrap = function() {
          this.ends[P].children()
            .disown()
            .adopt(this.parent, this, this[C])
            .jQ.insertAfter(this.jQ),
            this.remove();
        }),
        (t.deleteSide = function(e, t, n) {
          var i,
            r = this.parent,
            s = this[e],
            o = r.ends[e];
          return e === this.side
            ? (this.unwrap(),
              void (s ? n.insDirOf(-e, s) : n.insAtDirEnd(e, r)))
            : ((this.side = -e),
              void (this.oppBrack(this.ends[P].ends[this.side], e)
                ? (this.closeOpposing(this.ends[P].ends[this.side]),
                  (i = this.ends[P].ends[e]),
                  this.unwrap(),
                  i.siblingCreated && i.siblingCreated(n.options, e),
                  s ? n.insDirOf(-e, s) : n.insAtDirEnd(e, r))
                : (this.oppBrack(this.parent.parent, e)
                    ? (this.parent.parent.closeOpposing(this),
                      this.parent.parent.unwrap())
                    : ((this.sides[e] = {
                        ch: Te[this.sides[this.side].ch],
                        ctrlSeq: Te[this.sides[this.side].ctrlSeq],
                      }),
                      this.delimjQs
                        .removeClass('mq-ghost')
                        .eq(e === P ? 0 : 1)
                        .addClass('mq-ghost')
                        .html(this.sides[e].ch)),
                  s
                    ? ((i = this.ends[P].ends[e]),
                      M(s, o, -e)
                        .disown()
                        .withDirAdopt(-e, this.ends[P], i, 0)
                        .jQ.insAtDirEnd(
                          e,
                          this.ends[P].jQ.removeClass('mq-empty')
                        ),
                      i.siblingCreated && i.siblingCreated(n.options, e),
                      n.insDirOf(-e, s))
                    : t
                    ? n.insDirOf(e, this)
                    : n.insAtDirEnd(e, this.ends[P]))));
        }),
        (t.deleteTowards = function(e, t) {
          this.deleteSide(-e, !1, t);
        }),
        (t.finalizeTree = function() {
          (this.ends[P].deleteOutOf = function(e, t) {
            this.parent.deleteSide(e, !0, t);
          }),
            (this.finalizeTree = this.intentionalBlur = function() {
              this.delimjQs.eq(this.side === P ? 1 : 0).removeClass('mq-ghost'),
                (this.side = 0);
            });
        }),
        (t.siblingCreated = function(e, t) {
          t === -this.side && this.finalizeTree();
        });
    }),
    Te = {
      '(': ')',
      ')': '(',
      '[': ']',
      ']': '[',
      '{': '}',
      '}': '{',
      '\\{': '\\}',
      '\\}': '\\{',
      '&#x2329;': '&#x232A;',
      '&#x232A;': '&#x2329;',
      '\\langle ': '\\rangle ',
      '\\rangle ': '\\langle ',
      '|': '|',
    };
  p('('),
    p('['),
    p('{', '\\{'),
    (I.langle = i(Ae, P, '&#x2329;', '&#x232A;', '\\langle ', '\\rangle ')),
    (I.rangle = i(Ae, C, '&#x2329;', '&#x232A;', '\\langle ', '\\rangle ')),
    (F['|'] = i(Ae, P, '|', '|', '|', '|')),
    (I.left = k(U, function(e) {
      e.parser = function() {
        var e = z.regex,
          t = z.string,
          n = (z.succeed, z.optWhitespace);
        return n.then(e(/^(?:[([|]|\\\{)/)).then(function(i) {
          var r = '\\' === i.charAt(0) ? i.slice(1) : i;
          return V.then(function(s) {
            return t('\\right')
              .skip(n)
              .then(e(/^(?:[\])|]|\\\})/))
              .map(function(e) {
                var t = '\\' === e.charAt(0) ? e.slice(1) : e,
                  n = Ae(0, r, t, i, e);
                return (n.blocks = [s]), s.adopt(n, 0, 0), n;
              });
          });
        });
      };
    })),
    (I.right = k(U, function(e) {
      e.parser = function() {
        return z.fail('unmatched \\right');
      };
    }));
  var Me =
      ((I.blob = k(U, function(t, n) {
        (t.init = function(e) {
          n.init.call(this, '\\blob');
        }),
          (t.parser = function() {
            var e = z.string,
              t = z.succeed,
              n = z.any,
              i = z.fail,
              r =
                (z.skip,
                z.regex,
                function(e) {
                  return e.join('');
                }),
              s = this;
            return e('\\endBlob')
              .or(e('\\\\'))
              .or(n)
              .then(function(e) {
                switch (e) {
                  case '\\endBlob':
                    return i();
                  case '\\\\':
                    return t('\\');
                  default:
                    return t(e);
                }
              })
              .many()
              .map(r)
              .skip(e('\\endBlob'))
              .then(function(e) {
                return (s.htmlBlob = e), t(s);
              });
          }),
          (t.html = function() {
            return (
              '<span class="mq-blob" ' +
              g +
              '= "' +
              this.id +
              '" >' +
              this.htmlBlob +
              '</span>'
            );
          }),
          (t.latex = function() {
            var e = this.htmlBlob.replace(/\\/g, '\\\\');
            return '\\blob' + e + '\\endBlob';
          }),
          (t.replaces = function(e) {
            e.remove();
          }),
          (t.createBlocks = e),
          (t.moveTowards = function(e, t) {
            t.jQ.insDirOf(e, this.jQ), (t[-e] = this), (t[e] = this[e]);
          }),
          (t.deleteTowards = function(e, t) {
            t[e] = this.remove()[e];
          }),
          (t.seek = function(e, t) {
            e - this.jQ.offset().left < this.jQ.outerWidth() / 2
              ? t.insLeftOf(this)
              : t.insRightOf(this);
          }),
          (t.placeCursor = e),
          (t.isEmpty = function() {
            return !0;
          });
      })),
      (I.binom = I.binomial = k(k(U, h), function(e, t) {
        (e.ctrlSeq = '\\binom'),
          (e.htmlTemplate =
            '<span class="mq-non-leaf"><span class="mq-paren mq-scaled">(</span><span class="mq-non-leaf"><span class="mq-array mq-non-leaf"><span>&0</span><span>&1</span></span></span><span class="mq-paren mq-scaled">)</span></span>'),
          (e.textTemplate = ['choose(', ',', ')']);
      }))),
    Ie =
      ((I.choose = k(Me, function(e) {
        e.createLeftOf = Pe.prototype.createLeftOf;
      })),
      k(a.MathField, function(e) {
        e.init = function(e, t) {
          l(e), (this.__options = G());
          var n = O(this, e, t);
          (n.editable = !0),
            n.createTextarea(),
            n.editablesTextareaEvents(),
            n.cursor.insAtRightEnd(e);
        };
      }));
  I.MathQuillMathField = k(U, function(e, t) {
    (e.ctrlSeq = '\\MathQuillMathField'),
      (e.htmlTemplate =
        '<span class="mq-editable-field"><span class="mq-root-block">&0</span></span>'),
      (e.parser = function() {
        var e = this,
          n = z.string,
          i = z.regex,
          r = z.succeed;
        return n('[')
          .then(i(/^[a-z][a-z0-9]*/i))
          .skip(n(']'))
          .map(function(t) {
            e.name = t;
          })
          .or(r())
          .then(t.parser.call(e));
      }),
      (e.finalizeTree = function() {
        Ie(this.ends[P], this.jQ);
      }),
      (e.registerInnerField = function(e) {
        e.push((e[this.name] = this.ends[P].controller.API));
      }),
      (e.latex = function() {
        return this.ends[P].latex();
      }),
      (e.text = function() {
        return this.ends[P].text();
      });
  });
})(),
  +(function(e) {
    'use strict';
    function t(t) {
      (t && 3 === t.which) ||
        (e(r).remove(),
        e(s).each(function() {
          var i = e(this),
            r = n(i),
            s = { relatedTarget: this };
          r.hasClass('open') &&
            (r.trigger((t = e.Event('hide.bs.dropdown', s))),
            t.isDefaultPrevented() ||
              (i.attr('aria-expanded', 'false'),
              r.removeClass('open').trigger('hidden.bs.dropdown', s)));
        }));
    }
    function n(t) {
      var n = t.attr('data-target');
      n ||
        ((n = t.attr('href')),
        (n = n && /#[A-Za-z]/.test(n) && n.replace(/.*(?=#[^\s]*$)/, '')));
      var i = n && e(n);
      return i && i.length ? i : t.parent();
    }
    function i(t) {
      return this.each(function() {
        var n = e(this),
          i = n.data('bs.dropdown');
        i || n.data('bs.dropdown', (i = new o(this))),
          'string' == typeof t && i[t].call(n);
      });
    }
    var r = '.dropdown-backdrop',
      s = '[data-toggle="dropdown"]',
      o = function(t) {
        e(t).on('click.bs.dropdown', this.toggle);
      };
    (o.VERSION = '3.3.1'),
      (o.prototype.toggle = function(i) {
        var r = e(this);
        if (!r.is('.disabled, :disabled')) {
          var s = n(r),
            o = s.hasClass('open');
          if ((t(), !o)) {
            'ontouchstart' in document.documentElement &&
              !s.closest('.navbar-nav').length &&
              e('<div class="dropdown-backdrop"/>')
                .insertAfter(e(this))
                .on('click', t);
            var a = { relatedTarget: this };
            if (
              (s.trigger((i = e.Event('show.bs.dropdown', a))),
              i.isDefaultPrevented())
            )
              return;
            r.attr('aria-expanded', 'true'),
              s.toggleClass('open').trigger('shown.bs.dropdown', a);
          }
          return !1;
        }
      }),
      (o.prototype.keydown = function(t) {
        if (
          /(38|40|27|32)/.test(t.which) &&
          !/input|textarea/i.test(t.target.tagName)
        ) {
          var i = e(this);
          if (
            (t.preventDefault(),
            t.stopPropagation(),
            !i.is('.disabled, :disabled'))
          ) {
            var r = n(i),
              o = r.hasClass('open');
            if ((!o && 27 != t.which) || (o && 27 == t.which))
              return (
                27 == t.which && r.find(s).trigger('focus'), i.trigger('click')
              );
            var a = ' li:not(.divider):visible a',
              c = r.find('[role="menu"]' + a + ', [role="listbox"]' + a);
            if (c.length) {
              var l = c.index(t.target);
              38 == t.which && l > 0 && l--,
                40 == t.which && l < c.length - 1 && l++,
                ~l || (l = 0),
                c.eq(l).trigger('focus');
            }
          }
        }
      });
    var a = e.fn.dropdown;
    (e.fn.dropdown = i),
      (e.fn.dropdown.Constructor = o),
      (e.fn.dropdown.noConflict = function() {
        return (e.fn.dropdown = a), this;
      }),
      e(document)
        .on('click.bs.dropdown.data-api', t)
        .on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
          e.stopPropagation();
        })
        .on('click.bs.dropdown.data-api', s, o.prototype.toggle)
        .on('keydown.bs.dropdown.data-api', s, o.prototype.keydown)
        .on(
          'keydown.bs.dropdown.data-api',
          '[role="menu"]',
          o.prototype.keydown
        )
        .on(
          'keydown.bs.dropdown.data-api',
          '[role="listbox"]',
          o.prototype.keydown
        );
  })(jQuery),
  (function() {
    'use strict';
    function e(t, i) {
      function r(e, t) {
        return function() {
          return e.apply(t, arguments);
        };
      }
      var s;
      if (
        ((i = i || {}),
        (this.trackingClick = !1),
        (this.trackingClickStart = 0),
        (this.targetElement = null),
        (this.touchStartX = 0),
        (this.touchStartY = 0),
        (this.lastTouchIdentifier = 0),
        (this.touchBoundary = i.touchBoundary || 10),
        (this.layer = t),
        (this.tapDelay = i.tapDelay || 200),
        (this.tapTimeout = i.tapTimeout || 700),
        !e.notNeeded(t))
      ) {
        for (
          var o = [
              'onMouse',
              'onClick',
              'onTouchStart',
              'onTouchMove',
              'onTouchEnd',
              'onTouchCancel',
            ],
            a = this,
            c = 0,
            l = o.length;
          l > c;
          c++
        )
          a[o[c]] = r(a[o[c]], a);
        n &&
          (t.addEventListener('mouseover', this.onMouse, !0),
          t.addEventListener('mousedown', this.onMouse, !0),
          t.addEventListener('mouseup', this.onMouse, !0)),
          t.addEventListener('click', this.onClick, !0),
          t.addEventListener('touchstart', this.onTouchStart, !1),
          t.addEventListener('touchmove', this.onTouchMove, !1),
          t.addEventListener('touchend', this.onTouchEnd, !1),
          t.addEventListener('touchcancel', this.onTouchCancel, !1),
          Event.prototype.stopImmediatePropagation ||
            ((t.removeEventListener = function(e, n, i) {
              var r = Node.prototype.removeEventListener;
              'click' === e
                ? r.call(t, e, n.hijacked || n, i)
                : r.call(t, e, n, i);
            }),
            (t.addEventListener = function(e, n, i) {
              var r = Node.prototype.addEventListener;
              'click' === e
                ? r.call(
                    t,
                    e,
                    n.hijacked ||
                      (n.hijacked = function(e) {
                        e.propagationStopped || n(e);
                      }),
                    i
                  )
                : r.call(t, e, n, i);
            })),
          'function' == typeof t.onclick &&
            ((s = t.onclick),
            t.addEventListener(
              'click',
              function(e) {
                s(e);
              },
              !1
            ),
            (t.onclick = null));
      }
    }
    var t = navigator.userAgent.indexOf('Windows Phone') >= 0,
      n = navigator.userAgent.indexOf('Android') > 0 && !t,
      i = /iP(ad|hone|od)/.test(navigator.userAgent) && !t,
      r = i && /OS 4_\d(_\d)?/.test(navigator.userAgent),
      s = i && /OS [6-7]_\d/.test(navigator.userAgent),
      o = navigator.userAgent.indexOf('BB10') > 0;
    (e.prototype.needsClick = function(e) {
      switch (e.nodeName.toLowerCase()) {
        case 'button':
        case 'select':
        case 'textarea':
          if (e.disabled) return !0;
          break;
        case 'input':
          if ((i && 'file' === e.type) || e.disabled) return !0;
          break;
        case 'label':
        case 'iframe':
        case 'video':
          return !0;
      }
      return /\bneedsclick\b/.test(e.className);
    }),
      (e.prototype.needsFocus = function(e) {
        switch (e.nodeName.toLowerCase()) {
          case 'textarea':
            return !0;
          case 'select':
            return !n;
          case 'input':
            switch (e.type) {
              case 'button':
              case 'checkbox':
              case 'file':
              case 'image':
              case 'radio':
              case 'submit':
                return !1;
            }
            return !e.disabled && !e.readOnly;
          default:
            return /\bneedsfocus\b/.test(e.className);
        }
      }),
      (e.prototype.sendClick = function(e, t) {
        var n, i;
        document.activeElement &&
          document.activeElement !== e &&
          document.activeElement.blur(),
          (i = t.changedTouches[0]),
          (n = document.createEvent('MouseEvents')),
          n.initMouseEvent(
            this.determineEventType(e),
            !0,
            !0,
            window,
            1,
            i.screenX,
            i.screenY,
            i.clientX,
            i.clientY,
            !1,
            !1,
            !1,
            !1,
            0,
            null
          ),
          (n.forwardedTouchEvent = !0),
          e.dispatchEvent(n);
      }),
      (e.prototype.determineEventType = function(e) {
        return n && 'select' === e.tagName.toLowerCase()
          ? 'mousedown'
          : 'click';
      }),
      (e.prototype.focus = function(e) {
        var t;
        i &&
        e.setSelectionRange &&
        0 !== e.type.indexOf('date') &&
        'time' !== e.type &&
        'month' !== e.type
          ? ((t = e.value.length), e.setSelectionRange(t, t))
          : e.focus();
      }),
      (e.prototype.updateScrollParent = function(e) {
        var t, n;
        if (((t = e.fastClickScrollParent), !t || !t.contains(e))) {
          n = e;
          do {
            if (n.scrollHeight > n.offsetHeight) {
              (t = n), (e.fastClickScrollParent = n);
              break;
            }
            n = n.parentElement;
          } while (n);
        }
        t && (t.fastClickLastScrollTop = t.scrollTop);
      }),
      (e.prototype.getTargetElementFromEventTarget = function(e) {
        return e.nodeType === Node.TEXT_NODE ? e.parentNode : e;
      }),
      (e.prototype.onTouchStart = function(e) {
        var t, n, s;
        if (e.targetTouches.length > 1) return !0;
        if (
          ((t = this.getTargetElementFromEventTarget(e.target)),
          (n = e.targetTouches[0]),
          i)
        ) {
          if (((s = window.getSelection()), s.rangeCount && !s.isCollapsed))
            return !0;
          if (!r) {
            if (n.identifier && n.identifier === this.lastTouchIdentifier)
              return e.preventDefault(), !1;
            (this.lastTouchIdentifier = n.identifier),
              this.updateScrollParent(t);
          }
        }
        return (
          (this.trackingClick = !0),
          (this.trackingClickStart = e.timeStamp),
          (this.targetElement = t),
          (this.touchStartX = n.pageX),
          (this.touchStartY = n.pageY),
          e.timeStamp - this.lastClickTime < this.tapDelay &&
            e.preventDefault(),
          !0
        );
      }),
      (e.prototype.touchHasMoved = function(e) {
        var t = e.changedTouches[0],
          n = this.touchBoundary;
        return Math.abs(t.pageX - this.touchStartX) > n ||
          Math.abs(t.pageY - this.touchStartY) > n
          ? !0
          : !1;
      }),
      (e.prototype.onTouchMove = function(e) {
        return this.trackingClick
          ? ((this.targetElement !==
              this.getTargetElementFromEventTarget(e.target) ||
              this.touchHasMoved(e)) &&
              ((this.trackingClick = !1), (this.targetElement = null)),
            !0)
          : !0;
      }),
      (e.prototype.findControl = function(e) {
        return void 0 !== e.control
          ? e.control
          : e.htmlFor
          ? document.getElementById(e.htmlFor)
          : e.querySelector(
              'button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea'
            );
      }),
      (e.prototype.onTouchEnd = function(e) {
        var t,
          o,
          a,
          c,
          l,
          u = this.targetElement;
        if (!this.trackingClick) return !0;
        if (e.timeStamp - this.lastClickTime < this.tapDelay)
          return (this.cancelNextClick = !0), !0;
        if (e.timeStamp - this.trackingClickStart > this.tapTimeout) return !0;
        if (
          ((this.cancelNextClick = !1),
          (this.lastClickTime = e.timeStamp),
          (o = this.trackingClickStart),
          (this.trackingClick = !1),
          (this.trackingClickStart = 0),
          s &&
            ((l = e.changedTouches[0]),
            (u =
              document.elementFromPoint(
                l.pageX - window.pageXOffset,
                l.pageY - window.pageYOffset
              ) || u),
            (u.fastClickScrollParent = this.targetElement.fastClickScrollParent)),
          (a = u.tagName.toLowerCase()),
          'label' === a)
        ) {
          if ((t = this.findControl(u))) {
            if ((this.focus(u), n)) return !1;
            u = t;
          }
        } else if (this.needsFocus(u))
          return e.timeStamp - o > 100 ||
            (i && window.top !== window && 'input' === a)
            ? ((this.targetElement = null), !1)
            : (this.focus(u),
              this.sendClick(u, e),
              (i && 'select' === a) ||
                ((this.targetElement = null), e.preventDefault()),
              !1);
        return i &&
          !r &&
          ((c = u.fastClickScrollParent),
          c && c.fastClickLastScrollTop !== c.scrollTop)
          ? !0
          : (this.needsClick(u) || (e.preventDefault(), this.sendClick(u, e)),
            !1);
      }),
      (e.prototype.onTouchCancel = function() {
        (this.trackingClick = !1), (this.targetElement = null);
      }),
      (e.prototype.onMouse = function(e) {
        return this.targetElement
          ? e.forwardedTouchEvent
            ? !0
            : e.cancelable &&
              (!this.needsClick(this.targetElement) || this.cancelNextClick)
            ? (e.stopImmediatePropagation
                ? e.stopImmediatePropagation()
                : (e.propagationStopped = !0),
              e.stopPropagation(),
              e.preventDefault(),
              !1)
            : !0
          : !0;
      }),
      (e.prototype.onClick = function(e) {
        var t;
        return this.trackingClick
          ? ((this.targetElement = null), (this.trackingClick = !1), !0)
          : 'submit' === e.target.type && 0 === e.detail
          ? !0
          : ((t = this.onMouse(e)), t || (this.targetElement = null), t);
      }),
      (e.prototype.destroy = function() {
        var e = this.layer;
        n &&
          (e.removeEventListener('mouseover', this.onMouse, !0),
          e.removeEventListener('mousedown', this.onMouse, !0),
          e.removeEventListener('mouseup', this.onMouse, !0)),
          e.removeEventListener('click', this.onClick, !0),
          e.removeEventListener('touchstart', this.onTouchStart, !1),
          e.removeEventListener('touchmove', this.onTouchMove, !1),
          e.removeEventListener('touchend', this.onTouchEnd, !1),
          e.removeEventListener('touchcancel', this.onTouchCancel, !1);
      }),
      (e.notNeeded = function(e) {
        var t, i, r, s;
        if ('undefined' == typeof window.ontouchstart) return !0;
        if ((i = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1])) {
          if (!n) return !0;
          if ((t = document.querySelector('meta[name=viewport]'))) {
            if (-1 !== t.content.indexOf('user-scalable=no')) return !0;
            if (
              i > 31 &&
              document.documentElement.scrollWidth <= window.outerWidth
            )
              return !0;
          }
        }
        if (
          o &&
          ((r = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/)),
          r[1] >= 10 &&
            r[2] >= 3 &&
            (t = document.querySelector('meta[name=viewport]')))
        ) {
          if (-1 !== t.content.indexOf('user-scalable=no')) return !0;
          if (document.documentElement.scrollWidth <= window.outerWidth)
            return !0;
        }
        return 'none' === e.style.msTouchAction ||
          'manipulation' === e.style.touchAction
          ? !0
          : ((s = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1]),
            s >= 27 &&
            ((t = document.querySelector('meta[name=viewport]')),
            t &&
              (-1 !== t.content.indexOf('user-scalable=no') ||
                document.documentElement.scrollWidth <= window.outerWidth))
              ? !0
              : 'none' === e.style.touchAction ||
                'manipulation' === e.style.touchAction
              ? !0
              : !1);
      }),
      (e.attach = function(t, n) {
        return new e(t, n);
      });
    var a = window.FastClick;
    (e.noConflict = function() {
      return (window.FastClick = a), e;
    }),
      (window.FastClick = e);
  })(),
  (function() {
    var e = window.LZString,
      t = (function() {
        function e(e, t) {
          if (!r[e]) {
            r[e] = {};
            for (var n = 0; n < e.length; n++) r[e][e.charAt(n)] = n;
          }
          return r[e][t];
        }
        var t = String.fromCharCode,
          n =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          i =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$',
          r = {},
          s = {
            compressToBase64: function(e) {
              if (null == e) return '';
              var t = s._compress(e, 6, function(e) {
                return n.charAt(e);
              });
              switch (t.length % 4) {
                default:
                case 0:
                  return t;
                case 1:
                  return t + '===';
                case 2:
                  return t + '==';
                case 3:
                  return t + '=';
              }
            },
            decompressFromBase64: function(t) {
              return null == t
                ? ''
                : '' == t
                ? null
                : s._decompress(t.length, 32, function(i) {
                    return e(n, t.charAt(i));
                  });
            },
            compressToUTF16: function(e) {
              return null == e
                ? ''
                : s._compress(e, 15, function(e) {
                    return t(e + 32);
                  }) + ' ';
            },
            decompressFromUTF16: function(e) {
              return null == e
                ? ''
                : '' == e
                ? null
                : s._decompress(e.length, 16384, function(t) {
                    return e.charCodeAt(t) - 32;
                  });
            },
            compressToUint8Array: function(e) {
              for (
                var t = s.compress(e),
                  n = new Uint8Array(2 * t.length),
                  i = 0,
                  r = t.length;
                r > i;
                i++
              ) {
                var o = t.charCodeAt(i);
                (n[2 * i] = o >>> 8), (n[2 * i + 1] = o % 256);
              }
              return n;
            },
            decompressFromUint8Array: function(e) {
              if (null === e || void 0 === e) return s.decompress(e);
              for (
                var n = new Array(e.length / 2), i = 0, r = n.length;
                r > i;
                i++
              )
                n[i] = 256 * e[2 * i] + e[2 * i + 1];
              var o = [];
              return (
                n.forEach(function(e) {
                  o.push(t(e));
                }),
                s.decompress(o.join(''))
              );
            },
            compressToEncodedURIComponent: function(e) {
              return null == e
                ? ''
                : s._compress(e, 6, function(e) {
                    return i.charAt(e);
                  });
            },
            decompressFromEncodedURIComponent: function(t) {
              return null == t
                ? ''
                : '' == t
                ? null
                : ((t = t.replace(/ /g, '+')),
                  s._decompress(t.length, 32, function(n) {
                    return e(i, t.charAt(n));
                  }));
            },
            compress: function(e) {
              return s._compress(e, 16, function(e) {
                return t(e);
              });
            },
            _compress: function(e, t, n) {
              if (null == e) return '';
              var i,
                r,
                s,
                o = {},
                a = {},
                c = '',
                l = '',
                u = '',
                d = 2,
                h = 3,
                p = 2,
                f = [],
                m = 0,
                g = 0;
              for (s = 0; s < e.length; s += 1)
                if (
                  ((c = e.charAt(s)),
                  Object.prototype.hasOwnProperty.call(o, c) ||
                    ((o[c] = h++), (a[c] = !0)),
                  (l = u + c),
                  Object.prototype.hasOwnProperty.call(o, l))
                )
                  u = l;
                else {
                  if (Object.prototype.hasOwnProperty.call(a, u)) {
                    if (u.charCodeAt(0) < 256) {
                      for (i = 0; p > i; i++)
                        (m <<= 1),
                          g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++;
                      for (r = u.charCodeAt(0), i = 0; 8 > i; i++)
                        (m = (m << 1) | (1 & r)),
                          g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r >>= 1);
                    } else {
                      for (r = 1, i = 0; p > i; i++)
                        (m = (m << 1) | r),
                          g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r = 0);
                      for (r = u.charCodeAt(0), i = 0; 16 > i; i++)
                        (m = (m << 1) | (1 & r)),
                          g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                          (r >>= 1);
                    }
                    d--, 0 == d && ((d = Math.pow(2, p)), p++), delete a[u];
                  } else
                    for (r = o[u], i = 0; p > i; i++)
                      (m = (m << 1) | (1 & r)),
                        g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  d--,
                    0 == d && ((d = Math.pow(2, p)), p++),
                    (o[l] = h++),
                    (u = String(c));
                }
              if ('' !== u) {
                if (Object.prototype.hasOwnProperty.call(a, u)) {
                  if (u.charCodeAt(0) < 256) {
                    for (i = 0; p > i; i++)
                      (m <<= 1),
                        g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++;
                    for (r = u.charCodeAt(0), i = 0; 8 > i; i++)
                      (m = (m << 1) | (1 & r)),
                        g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  } else {
                    for (r = 1, i = 0; p > i; i++)
                      (m = (m << 1) | r),
                        g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r = 0);
                    for (r = u.charCodeAt(0), i = 0; 16 > i; i++)
                      (m = (m << 1) | (1 & r)),
                        g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                        (r >>= 1);
                  }
                  d--, 0 == d && ((d = Math.pow(2, p)), p++), delete a[u];
                } else
                  for (r = o[u], i = 0; p > i; i++)
                    (m = (m << 1) | (1 & r)),
                      g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                      (r >>= 1);
                d--, 0 == d && ((d = Math.pow(2, p)), p++);
              }
              for (r = 2, i = 0; p > i; i++)
                (m = (m << 1) | (1 & r)),
                  g == t - 1 ? ((g = 0), f.push(n(m)), (m = 0)) : g++,
                  (r >>= 1);
              for (;;) {
                if (((m <<= 1), g == t - 1)) {
                  f.push(n(m));
                  break;
                }
                g++;
              }
              return f.join('');
            },
            decompress: function(e) {
              return null == e
                ? ''
                : '' == e
                ? null
                : s._decompress(e.length, 32768, function(t) {
                    return e.charCodeAt(t);
                  });
            },
            _decompress: function(e, n, i) {
              var r,
                s,
                o,
                a,
                c,
                l,
                u,
                d,
                h = [],
                p = 4,
                f = 4,
                m = 3,
                g = '',
                b = [],
                v = { val: i(0), position: n, index: 1 };
              for (s = 0; 3 > s; s += 1) h[s] = s;
              for (a = 0, l = Math.pow(2, 2), u = 1; u != l; )
                (c = v.val & v.position),
                  (v.position >>= 1),
                  0 == v.position && ((v.position = n), (v.val = i(v.index++))),
                  (a |= (c > 0 ? 1 : 0) * u),
                  (u <<= 1);
              switch ((r = a)) {
                case 0:
                  for (a = 0, l = Math.pow(2, 8), u = 1; u != l; )
                    (c = v.val & v.position),
                      (v.position >>= 1),
                      0 == v.position &&
                        ((v.position = n), (v.val = i(v.index++))),
                      (a |= (c > 0 ? 1 : 0) * u),
                      (u <<= 1);
                  d = t(a);
                  break;
                case 1:
                  for (a = 0, l = Math.pow(2, 16), u = 1; u != l; )
                    (c = v.val & v.position),
                      (v.position >>= 1),
                      0 == v.position &&
                        ((v.position = n), (v.val = i(v.index++))),
                      (a |= (c > 0 ? 1 : 0) * u),
                      (u <<= 1);
                  d = t(a);
                  break;
                case 2:
                  return '';
              }
              for (h[3] = d, o = d, b.push(d); ; ) {
                if (v.index > e) return '';
                for (a = 0, l = Math.pow(2, m), u = 1; u != l; )
                  (c = v.val & v.position),
                    (v.position >>= 1),
                    0 == v.position &&
                      ((v.position = n), (v.val = i(v.index++))),
                    (a |= (c > 0 ? 1 : 0) * u),
                    (u <<= 1);
                switch ((d = a)) {
                  case 0:
                    for (a = 0, l = Math.pow(2, 8), u = 1; u != l; )
                      (c = v.val & v.position),
                        (v.position >>= 1),
                        0 == v.position &&
                          ((v.position = n), (v.val = i(v.index++))),
                        (a |= (c > 0 ? 1 : 0) * u),
                        (u <<= 1);
                    (h[f++] = t(a)), (d = f - 1), p--;
                    break;
                  case 1:
                    for (a = 0, l = Math.pow(2, 16), u = 1; u != l; )
                      (c = v.val & v.position),
                        (v.position >>= 1),
                        0 == v.position &&
                          ((v.position = n), (v.val = i(v.index++))),
                        (a |= (c > 0 ? 1 : 0) * u),
                        (u <<= 1);
                    (h[f++] = t(a)), (d = f - 1), p--;
                    break;
                  case 2:
                    return b.join('');
                }
                if ((0 == p && ((p = Math.pow(2, m)), m++), h[d])) g = h[d];
                else {
                  if (d !== f) return null;
                  g = o + o.charAt(0);
                }
                b.push(g),
                  (h[f++] = o + g.charAt(0)),
                  p--,
                  (o = g),
                  0 == p && ((p = Math.pow(2, m)), m++);
              }
            },
          };
        return s;
      })();
    (t.noConflict = function() {
      return (window.LZString = e), t;
    }),
      (window.LZString = t);
  })(),
  'object' != typeof JSONcanonical && (JSONcanonical = {}),
  (function() {
    'use strict';
    function e(e) {
      return 10 > e ? '0' + e : e;
    }
    function t(e) {
      return (
        (o.lastIndex = 0),
        o.test(e)
          ? '"' +
            e.replace(o, function(e) {
              var t = a[e];
              return 'string' == typeof t
                ? t
                : '\\u' + ('0000' + e.charCodeAt(0).toString(16)).slice(-4);
            }) +
            '"'
          : '"' + e + '"'
      );
    }
    function n(e, o) {
      var a,
        c,
        l,
        u,
        d,
        h = i,
        p = o[e];
      switch (
        (p &&
          'object' == typeof p &&
          'function' == typeof p.toJSON &&
          (p = p.toJSON(e)),
        'function' == typeof s && (p = s.call(o, e, p)),
        typeof p)
      ) {
        case 'string':
          return t(p);
        case 'number':
          return isFinite(p) ? String(p) : 'null';
        case 'boolean':
        case 'null':
          return String(p);
        case 'object':
          if (!p) return 'null';
          if (
            ((i += r),
            (d = []),
            '[object Array]' === Object.prototype.toString.apply(p))
          ) {
            for (u = p.length, a = 0; u > a; a += 1) d[a] = n(a, p) || 'null';
            return (
              (l =
                0 === d.length
                  ? '[]'
                  : i
                  ? '[\n' + i + d.join(',\n' + i) + '\n' + h + ']'
                  : '[' + d.join(',') + ']'),
              (i = h),
              l
            );
          }
          if (s && 'object' == typeof s)
            for (u = s.length, a = 0; u > a; a += 1)
              'string' == typeof s[a] &&
                ((c = s[a]),
                (l = n(c, p)),
                l && d.push(t(c) + (i ? ': ' : ':') + l));
          else {
            var f,
              m,
              g = function(e, t) {
                var n = Number(e),
                  i = Number(t),
                  r = isFinite(n),
                  s = isFinite(i);
                return r && s
                  ? i > n
                    ? -1
                    : n > i
                    ? 1
                    : 0
                  : r
                  ? -1
                  : s
                  ? 1
                  : t > e
                  ? -1
                  : e > t
                  ? 1
                  : 0;
              },
              b = [];
            for (c in p)
              Object.prototype.hasOwnProperty.call(p, c) && b.push(c);
            for (b.sort(g), f = b.length, m = 0; f > m; ++m)
              (c = b[m]),
                (l = n(c, p)),
                l && d.push(t(c) + (i ? ': ' : ':') + l);
          }
          return (
            (l =
              0 === d.length
                ? '{}'
                : i
                ? '{\n' + i + d.join(',\n' + i) + '\n' + h + '}'
                : '{' + d.join(',') + '}'),
            (i = h),
            l
          );
      }
    }
    'function' != typeof Date.prototype.toJSON &&
      ((Date.prototype.toJSON = function() {
        return isFinite(this.valueOf())
          ? this.getUTCFullYear() +
              '-' +
              e(this.getUTCMonth() + 1) +
              '-' +
              e(this.getUTCDate()) +
              'T' +
              e(this.getUTCHours()) +
              ':' +
              e(this.getUTCMinutes()) +
              ':' +
              e(this.getUTCSeconds()) +
              'Z'
          : null;
      }),
      (String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
        return this.valueOf();
      }));
    var i,
      r,
      s,
      o = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      a = {
        '\b': '\\b',
        '	': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\',
      };
    'function' != typeof JSONcanonical.stringify &&
      (JSONcanonical.stringify = function(e, t, o) {
        var a;
        if (((i = ''), (r = ''), 'number' == typeof o))
          for (a = 0; o > a; a += 1) r += ' ';
        else 'string' == typeof o && (r = o);
        if (
          ((s = t),
          t &&
            'function' != typeof t &&
            ('object' != typeof t || 'number' != typeof t.length))
        )
          throw new Error('JSON.stringify');
        return n('', { '': e });
      });
  })(),
  !(function(e) {
    if (
      'object disable exports' == typeof exports &&
      'undefined' != typeof module
    )
      module.exports = e();
    else if ('function disable define' == typeof define && define.amd)
      define([], e);
    else {
      var t;
      'undefined' != typeof window
        ? (t = window)
        : 'undefined' != typeof global
        ? (t = global)
        : 'undefined' != typeof self && (t = self),
        (t.jsondiffpatch = e());
    }
  })(function() {
    return (function e(t, n, i) {
      function r(o, a) {
        if (!n[o]) {
          if (!t[o]) {
            var c = 'function' == typeof require && require;
            if (!a && c) return c(o, !0);
            if (s) return s(o, !0);
            var l = new Error("Cannot find module '" + o + "'");
            throw ((l.code = 'MODULE_NOT_FOUND'), l);
          }
          var u = (n[o] = { exports: {} });
          t[o][0].call(
            u.exports,
            function(e) {
              var n = t[o][1][e];
              return r(n ? n : e);
            },
            u,
            u.exports,
            e,
            t,
            n,
            i
          );
        }
        return n[o].exports;
      }
      for (
        var s = 'function' == typeof require && require, o = 0;
        o < i.length;
        o++
      )
        r(i[o]);
      return r;
    })(
      {
        1: [
          function(e, t, n) {
            (function(t) {
              var i = e('./diffpatcher').DiffPatcher;
              (n.DiffPatcher = i),
                (n.create = function(e) {
                  return new i(e);
                }),
                (n.dateReviver = e('./date-reviver'));
              var r;
              if (
                ((n.diff = function() {
                  return r || (r = new i()), r.diff.apply(r, arguments);
                }),
                (n.patch = function() {
                  return r || (r = new i()), r.patch.apply(r, arguments);
                }),
                (n.unpatch = function() {
                  return r || (r = new i()), r.unpatch.apply(r, arguments);
                }),
                (n.reverse = function() {
                  return r || (r = new i()), r.reverse.apply(r, arguments);
                }),
                t.browser)
              )
                (n.homepage = 'https://github.com/benjamine/jsondiffpatch'),
                  (n.version = '0.1.22');
              else {
                var s = '../package.json',
                  o = e(s);
                (n.homepage = o.homepage), (n.version = o.version);
                var a = './formatters',
                  c = e(a);
                (n.formatters = c), (n.console = c.console);
              }
            }.call(this, e('_process')));
          },
          { './date-reviver': 7, './diffpatcher': 8, _process: 2 },
        ],
        2: [
          function(e, t, n) {
            function i() {}
            var r = (t.exports = {});
            (r.nextTick = (function() {
              var e = 'undefined' != typeof window && window.setImmediate,
                t =
                  'undefined' != typeof window &&
                  window.postMessage &&
                  window.addEventListener;
              if (e)
                return function(e) {
                  return window.setImmediate(e);
                };
              if (t) {
                var n = [];
                return (
                  window.addEventListener(
                    'message',
                    function(e) {
                      var t = e.source;
                      if (
                        (t === window || null === t) &&
                        'process-tick' === e.data &&
                        (e.stopPropagation(), n.length > 0)
                      ) {
                        var i = n.shift();
                        i();
                      }
                    },
                    !0
                  ),
                  function(e) {
                    n.push(e), window.postMessage('process-tick', '*');
                  }
                );
              }
              return function(e) {
                setTimeout(e, 0);
              };
            })()),
              (r.title = 'browser'),
              (r.browser = !0),
              (r.env = {}),
              (r.argv = []),
              (r.on = i),
              (r.addListener = i),
              (r.once = i),
              (r.off = i),
              (r.removeListener = i),
              (r.removeAllListeners = i),
              (r.emit = i),
              (r.binding = function() {
                throw new Error('process.binding is not supported');
              }),
              (r.cwd = function() {
                return '/';
              }),
              (r.chdir = function() {
                throw new Error('process.chdir is not supported');
              });
          },
          {},
        ],
        3: [
          function(e, t, n) {
            var i = e('../pipe').Pipe,
              r = function() {};
            (r.prototype.setResult = function(e) {
              return (this.result = e), (this.hasResult = !0), this;
            }),
              (r.prototype.exit = function() {
                return (this.exiting = !0), this;
              }),
              (r.prototype.switchTo = function(e, t) {
                return (
                  'string' == typeof e || e instanceof i
                    ? (this.nextPipe = e)
                    : ((this.next = e), t && (this.nextPipe = t)),
                  this
                );
              }),
              (r.prototype.push = function(e, t) {
                return (
                  (e.parent = this),
                  'undefined' != typeof t && (e.childName = t),
                  (e.root = this.root || this),
                  (e.options = e.options || this.options),
                  this.children
                    ? ((this.children[this.children.length - 1].next = e),
                      this.children.push(e))
                    : ((this.children = [e]),
                      (this.nextAfterChildren = this.next || null),
                      (this.next = e)),
                  (e.next = this),
                  this
                );
              }),
              (n.Context = r);
          },
          { '../pipe': 15 },
        ],
        4: [
          function(e, t, n) {
            var i = e('./context').Context,
              r = function(e, t) {
                (this.left = e), (this.right = t), (this.pipe = 'diff');
              };
            (r.prototype = new i()), (n.DiffContext = r);
          },
          { './context': 3 },
        ],
        5: [
          function(e, t, n) {
            var i = e('./context').Context,
              r = function(e, t) {
                (this.left = e), (this.delta = t), (this.pipe = 'patch');
              };
            (r.prototype = new i()), (n.PatchContext = r);
          },
          { './context': 3 },
        ],
        6: [
          function(e, t, n) {
            var i = e('./context').Context,
              r = function(e) {
                (this.delta = e), (this.pipe = 'reverse');
              };
            (r.prototype = new i()), (n.ReverseContext = r);
          },
          { './context': 3 },
        ],
        7: [
          function(e, t, n) {
            t.exports = function(e, t) {
              var n;
              return 'string' == typeof t &&
                (n = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+\-])(\d{2}):(\d{2}))$/.exec(
                  t
                ))
                ? new Date(
                    Date.UTC(
                      +n[1],
                      +n[2] - 1,
                      +n[3],
                      +n[4],
                      +n[5],
                      +n[6],
                      +(n[7] || 0)
                    )
                  )
                : t;
            };
          },
          {},
        ],
        8: [
          function(e, t, n) {
            var i = e('./processor').Processor,
              r = e('./pipe').Pipe,
              s = e('./contexts/diff').DiffContext,
              o = e('./contexts/patch').PatchContext,
              a = e('./contexts/reverse').ReverseContext,
              c = e('./filters/trivial'),
              l = e('./filters/nested'),
              u = e('./filters/arrays'),
              d = e('./filters/dates'),
              h = e('./filters/texts'),
              p = function(e) {
                (this.processor = new i(e)),
                  this.processor.pipe(
                    new r('diff')
                      .append(
                        l.collectChildrenDiffFilter,
                        c.diffFilter,
                        d.diffFilter,
                        h.diffFilter,
                        l.objectsDiffFilter,
                        u.diffFilter
                      )
                      .shouldHaveResult()
                  ),
                  this.processor.pipe(
                    new r('patch')
                      .append(
                        l.collectChildrenPatchFilter,
                        u.collectChildrenPatchFilter,
                        c.patchFilter,
                        h.patchFilter,
                        l.patchFilter,
                        u.patchFilter
                      )
                      .shouldHaveResult()
                  ),
                  this.processor.pipe(
                    new r('reverse')
                      .append(
                        l.collectChildrenReverseFilter,
                        u.collectChildrenReverseFilter,
                        c.reverseFilter,
                        h.reverseFilter,
                        l.reverseFilter,
                        u.reverseFilter
                      )
                      .shouldHaveResult()
                  );
              };
            (p.prototype.options = function() {
              return this.processor.options.apply(this.processor, arguments);
            }),
              (p.prototype.diff = function(e, t) {
                return this.processor.process(new s(e, t));
              }),
              (p.prototype.patch = function(e, t) {
                return this.processor.process(new o(e, t));
              }),
              (p.prototype.reverse = function(e) {
                return this.processor.process(new a(e));
              }),
              (p.prototype.unpatch = function(e, t) {
                return this.patch(e, this.reverse(t));
              }),
              (n.DiffPatcher = p);
          },
          {
            './contexts/diff': 4,
            './contexts/patch': 5,
            './contexts/reverse': 6,
            './filters/arrays': 9,
            './filters/dates': 10,
            './filters/nested': 12,
            './filters/texts': 13,
            './filters/trivial': 14,
            './pipe': 15,
            './processor': 16,
          },
        ],
        9: [
          function(e, t, n) {
            var i = e('../contexts/diff').DiffContext,
              r = e('../contexts/patch').PatchContext,
              s = e('../contexts/reverse').ReverseContext,
              o = e('./lcs'),
              a = 3,
              c =
                'function' == typeof Array.isArray
                  ? Array.isArray
                  : function(e) {
                      return e instanceof Array;
                    },
              l =
                'function' == typeof Array.prototype.indexOf
                  ? function(e, t) {
                      return e.indexOf(t);
                    }
                  : function(e, t) {
                      for (var n = e.length, i = 0; n > i; i++)
                        if (e[i] === t) return i;
                      return -1;
                    },
              u = function(e) {
                if (e.leftIsArray) {
                  for (
                    var t,
                      n,
                      r,
                      s,
                      c = e.options && e.options.objectHash,
                      u = function(e, t, n, i, r) {
                        var s = e[n],
                          o = t[i];
                        if (s === o) return !0;
                        if ('object' != typeof s || 'object' != typeof o)
                          return !1;
                        if (!c) return !1;
                        var a, l;
                        return (
                          'number' == typeof n
                            ? ((r.hashCache1 = r.hashCache1 || []),
                              (a = r.hashCache1[n]),
                              'undefined' == typeof a &&
                                (r.hashCache1[n] = a = c(s, n)))
                            : (a = c(s)),
                          'undefined' == typeof a
                            ? !1
                            : ('number' == typeof i
                                ? ((r.hashCache2 = r.hashCache2 || []),
                                  (l = r.hashCache2[i]),
                                  'undefined' == typeof l &&
                                    (r.hashCache2[i] = l = c(o, i)))
                                : (l = c(o)),
                              'undefined' == typeof l ? !1 : a === l)
                        );
                      },
                      d = {},
                      h = 0,
                      p = 0,
                      f = e.left,
                      m = e.right,
                      g = f.length,
                      b = m.length;
                    g > h && b > h && u(f, m, h, h, d);

                  )
                    (t = h),
                      (s = new i(e.left[t], e.right[t])),
                      e.push(s, t),
                      h++;
                  for (
                    ;
                    g > p + h && b > p + h && u(f, m, g - 1 - p, b - 1 - p, d);

                  )
                    (n = g - 1 - p),
                      (r = b - 1 - p),
                      (s = new i(e.left[n], e.right[r])),
                      e.push(s, r),
                      p++;
                  var v;
                  if (h + p === g) {
                    if (g === b) return void e.setResult(void 0).exit();
                    for (v = v || { _t: 'a' }, t = h; b - p > t; t++)
                      v[t] = [m[t]];
                    return void e.setResult(v).exit();
                  }
                  if (h + p === b) {
                    for (v = v || { _t: 'a' }, t = h; g - p > t; t++)
                      v['_' + t] = [f[t], 0, 0];
                    return void e.setResult(v).exit();
                  }
                  d = {};
                  var y = f.slice(h, g - p),
                    x = m.slice(h, b - p),
                    w = o.get(y, x, u, d),
                    k = [];
                  for (v = v || { _t: 'a' }, t = h; g - p > t; t++)
                    l(w.indices1, t - h) < 0 &&
                      ((v['_' + t] = [f[t], 0, 0]), k.push(t));
                  var P = !0;
                  e.options &&
                    e.options.arrays &&
                    e.options.arrays.detectMove === !1 &&
                    (P = !1);
                  var C = !1;
                  e.options &&
                    e.options.arrays &&
                    e.options.arrays.includeValueOnMove &&
                    (C = !0);
                  var S = k.length;
                  for (t = h; b - p > t; t++) {
                    var A = l(w.indices2, t - h);
                    if (0 > A) {
                      var T = !1;
                      if (P && S > 0)
                        for (var M = 0; S > M; M++)
                          if (((n = k[M]), u(y, x, n - h, t - h, d))) {
                            v['_' + n].splice(1, 2, t, a),
                              C || (v['_' + n][0] = ''),
                              (r = t),
                              (s = new i(e.left[n], e.right[r])),
                              e.push(s, r),
                              k.splice(M, 1),
                              (T = !0);
                            break;
                          }
                      T || (v[t] = [m[t]]);
                    } else
                      (n = w.indices1[A] + h),
                        (r = w.indices2[A] + h),
                        (s = new i(e.left[n], e.right[r])),
                        e.push(s, r);
                  }
                  e.setResult(v).exit();
                }
              };
            u.filterName = 'arrays';
            var d = {
                numerically: function(e, t) {
                  return e - t;
                },
                numericallyBy: function(e) {
                  return function(t, n) {
                    return t[e] - n[e];
                  };
                },
              },
              h = function(e) {
                if (e.nested && 'a' === e.delta._t) {
                  var t,
                    n,
                    i = e.delta,
                    s = e.left,
                    o = [],
                    c = [],
                    l = [];
                  for (t in i)
                    if ('_t' !== t)
                      if ('_' === t[0]) {
                        if (0 !== i[t][2] && i[t][2] !== a)
                          throw new Error(
                            'only removal or move can be applied at original array indices, invalid diff type: ' +
                              i[t][2]
                          );
                        o.push(parseInt(t.slice(1), 10));
                      } else
                        1 === i[t].length
                          ? c.push({ index: parseInt(t, 10), value: i[t][0] })
                          : l.push({ index: parseInt(t, 10), delta: i[t] });
                  for (
                    o = o.sort(d.numerically), t = o.length - 1;
                    t >= 0;
                    t--
                  ) {
                    n = o[t];
                    var u = i['_' + n],
                      h = s.splice(n, 1)[0];
                    u[2] === a && c.push({ index: u[1], value: h });
                  }
                  c = c.sort(d.numericallyBy('index'));
                  var p = c.length;
                  for (t = 0; p > t; t++) {
                    var f = c[t];
                    s.splice(f.index, 0, f.value);
                  }
                  var m,
                    g = l.length;
                  if (g > 0)
                    for (t = 0; g > t; t++) {
                      var b = l[t];
                      (m = new r(e.left[b.index], b.delta)), e.push(m, b.index);
                    }
                  return e.children
                    ? void e.exit()
                    : void e.setResult(e.left).exit();
                }
              };
            h.filterName = 'arrays';
            var p = function(e) {
              if (e && e.children && 'a' === e.delta._t) {
                for (var t, n = e.children.length, i = 0; n > i; i++)
                  (t = e.children[i]), (e.left[t.childName] = t.result);
                e.setResult(e.left).exit();
              }
            };
            p.filterName = 'arraysCollectChildren';
            var f = function(e) {
              if (!e.nested)
                return void (
                  e.delta[2] === a &&
                  ((e.newName = '_' + e.delta[1]),
                  e
                    .setResult([
                      e.delta[0],
                      parseInt(e.childName.substr(1), 10),
                      a,
                    ])
                    .exit())
                );
              if ('a' === e.delta._t) {
                var t, n;
                for (t in e.delta)
                  '_t' !== t && ((n = new s(e.delta[t])), e.push(n, t));
                e.exit();
              }
            };
            f.filterName = 'arrays';
            var m = function(e, t, n) {
                var i = t;
                if ('string' == typeof t && '_' === t[0])
                  i = parseInt(t.substr(1), 10);
                else {
                  var r = '_' + t;
                  if (c(n) && 0 === n[2]) i = r;
                  else
                    for (var s in e) {
                      var o = e[s];
                      c(o) &&
                        o[2] === a &&
                        o[1].toString() === t &&
                        (i = s.substr(1));
                    }
                }
                return i;
              },
              g = function(e) {
                if (e && e.children && 'a' === e.delta._t) {
                  for (
                    var t, n = e.children.length, i = { _t: 'a' }, r = 0;
                    n > r;
                    r++
                  ) {
                    t = e.children[r];
                    var s = t.newName;
                    'undefined' == typeof s &&
                      (s = m(e.delta, t.childName, t.result)),
                      i[s] !== t.result && (i[s] = t.result);
                  }
                  e.setResult(i).exit();
                }
              };
            (g.filterName = 'arraysCollectChildren'),
              (n.diffFilter = u),
              (n.patchFilter = h),
              (n.collectChildrenPatchFilter = p),
              (n.reverseFilter = f),
              (n.collectChildrenReverseFilter = g);
          },
          {
            '../contexts/diff': 4,
            '../contexts/patch': 5,
            '../contexts/reverse': 6,
            './lcs': 11,
          },
        ],
        10: [
          function(e, t, n) {
            var i = function(e) {
              e.left instanceof Date
                ? (e.setResult(
                    e.right instanceof Date
                      ? e.left.getTime() !== e.right.getTime()
                        ? [e.left, e.right]
                        : void 0
                      : [e.left, e.right]
                  ),
                  e.exit())
                : e.right instanceof Date &&
                  e.setResult([e.left, e.right]).exit();
            };
            (i.filterName = 'dates'), (n.diffFilter = i);
          },
          {},
        ],
        11: [
          function(e, t, n) {
            var i = function(e, t, n, i) {
                return e[n] === t[i];
              },
              r = function(e, t, n, i) {
                var r,
                  s,
                  o = e.length,
                  a = t.length,
                  c = [o + 1];
                for (r = 0; o + 1 > r; r++)
                  for (c[r] = [a + 1], s = 0; a + 1 > s; s++) c[r][s] = 0;
                for (c.match = n, r = 1; o + 1 > r; r++)
                  for (s = 1; a + 1 > s; s++)
                    c[r][s] = n(e, t, r - 1, s - 1, i)
                      ? c[r - 1][s - 1] + 1
                      : Math.max(c[r - 1][s], c[r][s - 1]);
                return c;
              },
              s = function(e, t, n, i, r, o) {
                if (0 === i || 0 === r)
                  return { sequence: [], indices1: [], indices2: [] };
                if (e.match(t, n, i - 1, r - 1, o)) {
                  var a = s(e, t, n, i - 1, r - 1, o);
                  return (
                    a.sequence.push(t[i - 1]),
                    a.indices1.push(i - 1),
                    a.indices2.push(r - 1),
                    a
                  );
                }
                return e[i][r - 1] > e[i - 1][r]
                  ? s(e, t, n, i, r - 1, o)
                  : s(e, t, n, i - 1, r, o);
              },
              o = function(e, t, n, o) {
                o = o || {};
                var a = r(e, t, n || i, o),
                  c = s(a, e, t, e.length, t.length, o);
                return (
                  'string' == typeof e &&
                    'string' == typeof t &&
                    (c.sequence = c.sequence.join('')),
                  c
                );
              };
            n.get = o;
          },
          {},
        ],
        12: [
          function(e, t, n) {
            var i = e('../contexts/diff').DiffContext,
              r = e('../contexts/patch').PatchContext,
              s = e('../contexts/reverse').ReverseContext,
              o = function(e) {
                if (e && e.children) {
                  for (
                    var t, n = e.children.length, i = e.result, r = 0;
                    n > r;
                    r++
                  )
                    (t = e.children[r]),
                      'undefined' != typeof t.result &&
                        ((i = i || {}), (i[t.childName] = t.result));
                  i && e.leftIsArray && (i._t = 'a'), e.setResult(i).exit();
                }
              };
            o.filterName = 'collectChildren';
            var a = function(e) {
              if (!e.leftIsArray && 'object' === e.leftType) {
                var t, n;
                for (t in e.left)
                  (n = new i(e.left[t], e.right[t])), e.push(n, t);
                for (t in e.right)
                  'undefined' == typeof e.left[t] &&
                    ((n = new i(void 0, e.right[t])), e.push(n, t));
                return e.children && 0 !== e.children.length
                  ? void e.exit()
                  : void e.setResult(void 0).exit();
              }
            };
            a.filterName = 'objects';
            var c = function(e) {
              if (e.nested && !e.delta._t) {
                var t, n;
                for (t in e.delta)
                  (n = new r(e.left[t], e.delta[t])), e.push(n, t);
                e.exit();
              }
            };
            c.filterName = 'objects';
            var l = function(e) {
              if (e && e.children && !e.delta._t) {
                for (var t, n = e.children.length, i = 0; n > i; i++)
                  (t = e.children[i]),
                    e.left.hasOwnProperty(t.childName) && void 0 === t.result
                      ? delete e.left[t.childName]
                      : e.left[t.childName] !== t.result &&
                        (e.left[t.childName] = t.result);
                e.setResult(e.left).exit();
              }
            };
            l.filterName = 'collectChildren';
            var u = function(e) {
              if (e.nested && !e.delta._t) {
                var t, n;
                for (t in e.delta) (n = new s(e.delta[t])), e.push(n, t);
                e.exit();
              }
            };
            u.filterName = 'objects';
            var d = function(e) {
              if (e && e.children && !e.delta._t) {
                for (var t, n = e.children.length, i = {}, r = 0; n > r; r++)
                  (t = e.children[r]),
                    i[t.childName] !== t.result && (i[t.childName] = t.result);
                e.setResult(i).exit();
              }
            };
            (d.filterName = 'collectChildren'),
              (n.collectChildrenDiffFilter = o),
              (n.objectsDiffFilter = a),
              (n.patchFilter = c),
              (n.collectChildrenPatchFilter = l),
              (n.reverseFilter = u),
              (n.collectChildrenReverseFilter = d);
          },
          {
            '../contexts/diff': 4,
            '../contexts/patch': 5,
            '../contexts/reverse': 6,
          },
        ],
        13: [
          function(e, t, n) {
            var i = 2,
              r = 60,
              s = null,
              o = function() {
                if (!s) {
                  var t;
                  if ('undefined' != typeof diff_match_patch)
                    t =
                      'function' == typeof diff_match_patch
                        ? new diff_match_patch()
                        : new diff_match_patch.diff_match_patch();
                  else if ('function' == typeof e)
                    try {
                      var n = 'diff_match_patch_uncompressed',
                        i = e('../../public/external/' + n);
                      t = new i.diff_match_patch();
                    } catch (e) {
                      t = null;
                    }
                  if (!t) {
                    var r = new Error(
                      'text diff_match_patch library not found'
                    );
                    throw ((r.diff_match_patch_not_found = !0), r);
                  }
                  s = {
                    diff: function(e, n) {
                      return t.patch_toText(t.patch_make(e, n));
                    },
                    patch: function(e, n) {
                      for (
                        var i = t.patch_apply(t.patch_fromText(n), e), r = 0;
                        r < i[1].length;
                        r++
                      )
                        if (!i[1][r]) {
                          var s = new Error('text patch failed');
                          s.textPatchFailed = !0;
                        }
                      return i[0];
                    },
                  };
                }
                return s;
              },
              a = function(e) {
                if ('string' === e.leftType) {
                  var t =
                    (e.options &&
                      e.options.textDiff &&
                      e.options.textDiff.minLength) ||
                    r;
                  if (e.left.length < t || e.right.length < t)
                    return void e.setResult([e.left, e.right]).exit();
                  var n = o().diff;
                  e.setResult([n(e.left, e.right), 0, i]).exit();
                }
              };
            a.filterName = 'texts';
            var c = function(e) {
              if (!e.nested && e.delta[2] === i) {
                var t = o().patch;
                e.setResult(t(e.left, e.delta[0])).exit();
              }
            };
            c.filterName = 'texts';
            var l = function(e) {
                var t,
                  n,
                  i,
                  r,
                  s,
                  o,
                  a,
                  c,
                  l = null,
                  u = /^@@ +\-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
                for (i = e.split('\n'), t = 0, n = i.length; n > t; t++) {
                  r = i[t];
                  var d = r.slice(0, 1);
                  '@' === d
                    ? ((l = u.exec(r)),
                      (o = t),
                      (a = null),
                      (c = null),
                      (i[o] =
                        '@@ -' +
                        l[3] +
                        ',' +
                        l[4] +
                        ' +' +
                        l[1] +
                        ',' +
                        l[2] +
                        ' @@'))
                    : '+' === d
                    ? ((a = t),
                      (i[t] = '-' + i[t].slice(1)),
                      '+' === i[t - 1].slice(0, 1) &&
                        ((s = i[t]), (i[t] = i[t - 1]), (i[t - 1] = s)))
                    : '-' === d && ((c = t), (i[t] = '+' + i[t].slice(1)));
                }
                return i.join('\n');
              },
              u = function(e) {
                e.nested ||
                  (e.delta[2] === i &&
                    e.setResult([l(e.delta[0]), 0, i]).exit());
              };
            (u.filterName = 'texts'),
              (n.diffFilter = a),
              (n.patchFilter = c),
              (n.reverseFilter = u);
          },
          {},
        ],
        14: [
          function(e, t, n) {
            var i =
                'function' == typeof Array.isArray
                  ? Array.isArray
                  : function(e) {
                      return e instanceof Array;
                    },
              r = function(e) {
                if (e.left === e.right) return void e.setResult(void 0).exit();
                if ('undefined' == typeof e.left) {
                  if ('function' == typeof e.right)
                    throw new Error('functions are not supported');
                  return void e.setResult([e.right]).exit();
                }
                if ('undefined' == typeof e.right)
                  return void e.setResult([e.left, 0, 0]).exit();
                if ('function' == typeof e.left || 'function' == typeof e.right)
                  throw new Error('functions are not supported');
                return (
                  (e.leftType = null === e.left ? 'null' : typeof e.left),
                  (e.rightType = null === e.right ? 'null' : typeof e.right),
                  e.leftType !== e.rightType
                    ? void e.setResult([e.left, e.right]).exit()
                    : 'boolean' === e.leftType || 'number' === e.leftType
                    ? void e.setResult([e.left, e.right]).exit()
                    : ('object' === e.leftType && (e.leftIsArray = i(e.left)),
                      'object' === e.rightType && (e.rightIsArray = i(e.right)),
                      e.leftIsArray !== e.rightIsArray
                        ? void e.setResult([e.left, e.right]).exit()
                        : void 0)
                );
              };
            r.filterName = 'trivial';
            var s = function(e) {
              return 'undefined' == typeof e.delta
                ? void e.setResult(e.left).exit()
                : ((e.nested = !i(e.delta)),
                  e.nested
                    ? void 0
                    : 1 === e.delta.length
                    ? void e.setResult(e.delta[0]).exit()
                    : 2 === e.delta.length
                    ? void e.setResult(e.delta[1]).exit()
                    : 3 === e.delta.length && 0 === e.delta[2]
                    ? void e.setResult(void 0).exit()
                    : void 0);
            };
            s.filterName = 'trivial';
            var o = function(e) {
              return 'undefined' == typeof e.delta
                ? void e.setResult(e.delta).exit()
                : ((e.nested = !i(e.delta)),
                  e.nested
                    ? void 0
                    : 1 === e.delta.length
                    ? void e.setResult([e.delta[0], 0, 0]).exit()
                    : 2 === e.delta.length
                    ? void e.setResult([e.delta[1], e.delta[0]]).exit()
                    : 3 === e.delta.length && 0 === e.delta[2]
                    ? void e.setResult([e.delta[0]]).exit()
                    : void 0);
            };
            (o.filterName = 'trivial'),
              (n.diffFilter = r),
              (n.patchFilter = s),
              (n.reverseFilter = o);
          },
          {},
        ],
        15: [
          function(e, t, n) {
            var i = function(e) {
              (this.name = e), (this.filters = []);
            };
            (i.prototype.process = function(e) {
              if (!this.processor)
                throw new Error('add this pipe to a processor before using it');
              for (
                var t = this.debug, n = this.filters.length, i = e, r = 0;
                n > r;
                r++
              ) {
                var s = this.filters[r];
                if (
                  (t && this.log('filter: ' + s.filterName),
                  s(i),
                  'object' == typeof i && i.exiting)
                ) {
                  i.exiting = !1;
                  break;
                }
              }
              !i.next && this.resultCheck && this.resultCheck(i);
            }),
              (i.prototype.log = function(e) {
                console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + e);
              }),
              (i.prototype.append = function() {
                return this.filters.push.apply(this.filters, arguments), this;
              }),
              (i.prototype.prepend = function() {
                return (
                  this.filters.unshift.apply(this.filters, arguments), this
                );
              }),
              (i.prototype.indexOf = function(e) {
                if (!e) throw new Error('a filter name is required');
                for (var t = 0; t < this.filters.length; t++) {
                  var n = this.filters[t];
                  if (n.filterName === e) return t;
                }
                throw new Error('filter not found: ' + e);
              }),
              (i.prototype.list = function() {
                for (var e = [], t = 0; t < this.filters.length; t++) {
                  var n = this.filters[t];
                  e.push(n.filterName);
                }
                return e;
              }),
              (i.prototype.after = function(e) {
                var t = this.indexOf(e),
                  n = Array.prototype.slice.call(arguments, 1);
                if (!n.length) throw new Error('a filter is required');
                return (
                  n.unshift(t + 1, 0),
                  Array.prototype.splice.apply(this.filters, n),
                  this
                );
              }),
              (i.prototype.before = function(e) {
                var t = this.indexOf(e),
                  n = Array.prototype.slice.call(arguments, 1);
                if (!n.length) throw new Error('a filter is required');
                return (
                  n.unshift(t, 0),
                  Array.prototype.splice.apply(this.filters, n),
                  this
                );
              }),
              (i.prototype.clear = function() {
                return (this.filters.length = 0), this;
              }),
              (i.prototype.shouldHaveResult = function(e) {
                if (e === !1) return void (this.resultCheck = null);
                if (!this.resultCheck) {
                  var t = this;
                  return (
                    (this.resultCheck = function(e) {
                      if (!e.hasResult) {
                        console.log(e);
                        var n = new Error(t.name + ' failed');
                        throw ((n.noResult = !0), n);
                      }
                    }),
                    this
                  );
                }
              }),
              (n.Pipe = i);
          },
          {},
        ],
        16: [
          function(e, t, n) {
            var i = function(e) {
              (this.selfOptions = e), (this.pipes = {});
            };
            (i.prototype.options = function(e) {
              return e && (this.selfOptions = e), this.selfOptions;
            }),
              (i.prototype.pipe = function(e, t) {
                if ('string' == typeof e) {
                  if ('undefined' == typeof t) return this.pipes[e];
                  this.pipes[e] = t;
                }
                if (e && e.name) {
                  if (((t = e), t.processor === this)) return t;
                  this.pipes[t.name] = t;
                }
                return (t.processor = this), t;
              }),
              (i.prototype.process = function(e, t) {
                var n = e;
                n.options = this.options();
                for (var i, r, s = t || e.pipe || 'default'; s; )
                  'undefined' != typeof n.nextAfterChildren &&
                    ((n.next = n.nextAfterChildren),
                    (n.nextAfterChildren = null)),
                    'string' == typeof s && (s = this.pipe(s)),
                    s.process(n),
                    (r = n),
                    (i = s),
                    (s = null),
                    n &&
                      n.next &&
                      ((n = n.next), (s = r.nextPipe || n.pipe || i));
                return n.hasResult ? n.result : void 0;
              }),
              (n.Processor = i);
          },
          {},
        ],
      },
      {},
      [1]
    )(1);
  });
var hexcase = 0,
  b64pad = '';
'function' != typeof Object.create &&
  (Object.create = function(e) {
    var t = function() {};
    return (t.prototype = e), new t();
  }),
  (function(e, t, n) {
    var i = e.document,
      r = (e.location, e.navigator),
      s = e.GSP,
      o = (function() {
        function r(e, n, i, r) {
          var s = n[i],
            o = typeof s;
          'object' === o
            ? (e[i] || (e[i] = t.isArray(s) ? [] : {}), t.extend(!0, e[i], s))
            : 'function' === o
            ? r && (r[i] = s)
            : (e[i] = s);
        }
        function s(e, t) {
          var n,
            i,
            s,
            a = {};
          for (i = 0; i < e.length; i++) {
            if (((s = e[i]), !s))
              throw o.createError('copyData() from undefined source!');
            for (n in s) r(a, s, n, t);
          }
          return a;
        }
        function a(e, t) {
          var n = {},
            i = [];
          return (
            e.forEach(function(e) {
              n[e] = !0;
            }),
            t.forEach(function(e) {
              n[e] = !0;
            }),
            o.eachKeyValue(n, function(e) {
              i.push(e);
            }),
            i
          );
        }
        function c(e, t) {
          var i = {},
            r = [];
          return (
            e.forEach(function(e) {
              i[e] = !0;
            }),
            t.forEach(function(e) {
              i[e] !== n && delete i[e];
            }),
            o.eachKeyValue(i, function(e) {
              r.push(e);
            }),
            r
          );
        }
        return {
          version: {
            number: '4.8.0',
            major: '4',
            minor: '8',
            patch: '0',
            build: '1077',
            release: '2020Q3',
          },
          kNormalSpeedRate: 3,
          kIdealFrameRate: 60,
          kWebSpeedMultiplier: 0.5,
          gOptions: {
            'debug-geom-bounds': !1,
            'graphics-engine': 'standard',
            instantiateUnsupportedObjects: !1,
            perfTestMode: !1,
          },
          gObjects: {},
          mixins: {},
          gConstraints: {},
          genera: {},
          signal: function(e) {
            return (
              e.localize && e.message
                ? (e.message = o.Strings.loc(e.message))
                : e.code && !e.message && (e.message = o.Strings.loc(e.code)),
              t(i).trigger('gLog', e),
              e
            );
          },
          log: function(e) {
            if (e.indexOf('%@') >= 0) {
              var t = Array.prototype.slice.call(arguments, 1);
              e = o.Strings.format(e, t);
            }
            return o.signal({
              code: 'GSP.Debug.log',
              message: e,
              logType: 'debug',
            });
          },
          logPerf: function(e) {
            return o.signal({
              code: 'GSP.Debug.log',
              message: e,
              logType: 'perf',
            });
          },
          caseData: function(e, t, n) {
            return o.signal({ message: t, logType: 'data', gobj: e, data: n });
          },
          _get: function(e, t) {
            var i = t.split && t.split('.');
            if (e && i) {
              for (; e && i.length; ) e = e[i.shift()];
              return e && 0 === i.length ? e : n;
            }
          },
          _put: function(e, t, n) {
            var i,
              r = t.split && t.split('.');
            if (e && r) {
              for (; e && r.length; )
                (i = r.shift()),
                  e[i] || (e[i] = {}),
                  r.length ? (e = e[i]) : (e[i] = n);
              return e[i];
            }
          },
          makeClass: function(e, i) {
            function r(e) {
              var t,
                n,
                i = [];
              for (t = 0; t < e.length; ++t)
                (n = e[t]),
                  n.baseKinds && (i = a(i, n.baseKinds)),
                  n.kind && (i = a(i, [n.kind]));
              return i;
            }
            function l(e) {
              var t,
                n,
                i = [];
              for (t = 0; t < e.length; ++t)
                (n = e[t]),
                  n.baseGenera && (i = a(i, n.baseGenera)),
                  n.genus && (i = a(i, [n.genus]));
              return i;
            }
            function u(e) {
              var t,
                n,
                i,
                r,
                s = [];
              for (t = 0; t < e.length; ++t)
                (n = e[t]),
                  (i = n && n.doc && n.doc.usage),
                  (r = i && i.kinds),
                  r && (s = a(s, r));
              return s;
            }
            function d(e, n) {
              var i = [],
                r = n && n.doc && n.doc.usage;
              return r && r.kinds
                ? t.merge([], r.kinds)
                : ((i = u(e)),
                  r && r.addKinds
                    ? a(i, r.addKinds)
                    : r && r.subKinds
                    ? c(i, r.subKinds)
                    : i);
            }
            function h(t) {
              var i,
                r = 0;
              for (i = 0; i < e.length; i++) n !== e[i][t] && r++;
              return r;
            }
            var p,
              f,
              m,
              g,
              b,
              v,
              y,
              x = {};
            e || (e = {}),
              t.isArray(e) || (e = [e]),
              (b = r(e)),
              (y = l(e)),
              (v = d(e, i)),
              (g = s(e, x)),
              t.extend(!0, g, i),
              b && b.length && (g.baseKinds = b),
              y && y.length && (g.baseGenera = y),
              g.doc && g.doc.usage && v.length && (g.doc.usage.kinds = v);
            for (p in x)
              if (((m = h(p)), n !== i[p]))
                if (((g[p] = i[p]), 1 === m)) g[p].base = x[p];
                else
                  for (g[p].base = {}, f = 0; f < e.length; f++)
                    g[p].base[f] = e[f][p];
              else {
                if (m > 1)
                  throw o.createError(
                    'Ambiguous multiple inheritance for ' + p
                  );
                g[p] = x[p];
              }
            return g;
          },
          makeInstance: function(e, n, i) {
            var s,
              o = Object.create(e),
              a = {};
            for (s in e) (i && i[s]) || r(a, e, s);
            t.extend(!0, a, n);
            for (s in a) o[s] = a[s];
            return o;
          },
          stringify: function(t, n) {
            return e.JSON && e.JSON.stringify
              ? e.JSON.stringify(t, n)
              : 'JSON.stringify not supported';
          },
          eachKeyValue: function(e, t) {
            var n, i;
            for (n in e) if (((i = t.call(e[n], n, e[n])), i === !1)) break;
          },
          isParameter: function(e) {
            return e.isParameter && e.isParameter();
          },
          isFunction: function(e) {
            return e.isFunction && e.isFunction();
          },
          isCalculation: function(e) {
            return (
              e.isOfKind('Expression') && !o.isParameter(e) && !o.isFunction(e)
            );
          },
          isAPath: function(e) {
            return e.isAPath();
          },
          generateUUID: function() {
            function e() {
              return Math.floor(65536 * (1 + Math.random()))
                .toString(16)
                .substring(1);
            }
            return (
              e() +
              e() +
              '-' +
              e() +
              '-' +
              e() +
              '-' +
              e() +
              '-' +
              e() +
              e() +
              e()
            );
          },
          compare: function(e, t) {
            return t > e ? -1 : e > t ? 1 : 0;
          },
          isString: function(e) {
            return 'string' == typeof e;
          },
          isNumber: function(e) {
            return 'number' == typeof e;
          },
          FastClick: e.FastClick.noConflict(),
          LZString: e.LZString.noConflict(),
        };
      })();
    if (
      ((function() {
        var e;
        o.naturalSortCaseInsensitive = function(t, n) {
          function i(e) {
            for (
              var t, n, i = new Array(), r = 0, s = -1, o = 0;
              (t = (n = e.charAt(r++)).charCodeAt(0));

            ) {
              var a = 46 == t || (t >= 48 && 57 >= t);
              a !== o && ((i[++s] = ''), (o = a)), (i[s] += n);
            }
            return i;
          }
          var r = i(t.toLowerCase()),
            s = i(n.toLowerCase());
          for (e = 0; r[e] && s[e]; e++)
            if (r[e] !== s[e]) {
              var o = Number(r[e]),
                a = Number(s[e]);
              return o == r[e] && a == s[e] ? o - a : r[e] > s[e] ? 1 : -1;
            }
          return r.length - s.length;
        };
      })(),
      (o.ConfigDefaults = {
        NumberpadManager: {
          delegates: {
            registerElement: function(e) {
              o.NumberpadManager.register(e);
            },
            registerCalculatorElement: function(e) {
              o.NumberpadManager.register(e);
            },
            blurAllNumberpads: function() {
              o.NumberpadManager.blurNumpads();
            },
          },
          options: {
            keyOrder: [
              ['1', '2', '3'],
              ['4', '5', '6'],
              ['7', '8', '9'],
              ['dot', '0', 'opposite'],
              ['', '', 'backspace'],
            ],
            keyOrderCalculator: [
              ['1', '2', '3', 'plus', 'lparen'],
              ['4', '5', '6', 'minus', 'rparen'],
              ['7', '8', '9', 'star', 'exponent'],
              ['dot', '0', 'clear', 'slash', 'backspace'],
            ],
          },
        },
        Fonts: { fallbacks: {} },
        compatibilityVersionPath: function(e) {
          return 'js/wsp-compat-' + e + '.js';
        },
      }),
      (o.getConfigValue = function(t) {
        function n(e) {
          for (var n = 0; n < t.length; n++) {
            if (!(e && 'object' == typeof e && t[n] in e)) return { found: !1 };
            e = e[t[n]];
          }
          return { found: !0, value: e };
        }
        'string' == typeof t && (t = t.split('.'));
        var i = n(e.GSPConfig);
        return i.found ? i.value : n(o.ConfigDefaults).value;
      }),
      (function(e) {
        !(function() {
          function t(t) {
            -1 === e.event.props.indexOf(t) && e.event.props.push(t);
          }
          t('touches'), t('targetTouches'), t('changedTouches');
        })();
        var t = function(t, n) {
          var r = {};
          return t.each(function() {
            var t = e(this);
            n && e.extend(r, n),
              (this.style['-webkit-user-select'] = 'none'),
              (this.style['-webkit-touch-callout'] = 'none'),
              (this.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)'),
              t.css({ 'touch-action': 'none' }),
              t.on('MSGestureHold contextmenu', !1),
              t.on('mousedown.mousetouch-mousedown', function(n) {
                r.sketch &&
                  (r.sketch.toggleKeyPressClass(!1),
                  r.sketch.focusedGobj && (r.sketch.focusedGobj = ''));
                var s = function(n) {
                  var i,
                    r = 'touchmove';
                  if (
                    (!n.which &&
                      n.button &&
                      (1 & n.button
                        ? (n.which = 1)
                        : 4 & n.button
                        ? (n.which = 2)
                        : 2 & n.button && (n.which = 3)),
                    n.which > 1)
                  )
                    return !1;
                  'mousedown' === n.type
                    ? (r = 'touchstart')
                    : 'mouseup' === n.type && (r = 'touchend'),
                    (i = e.Event(r));
                  var s = [
                    {
                      identifier: 'mouse0',
                      target: n.target,
                      clientX: n.clientX,
                      clientY: n.clientY,
                      screenX: n.screenX,
                      screenY: n.screenY,
                      pageX: n.pageX,
                      pageY: n.pageY,
                      mouseEvent: n,
                    },
                  ];
                  return (
                    (i.touches = 'touchend' === r ? [] : s),
                    (i.targetTouches = i.touches),
                    (i.changedTouches = s),
                    t.trigger(i),
                    !i.isDefaultPrevented()
                  );
                };
                return (
                  e(i).on('mouseup.mousetouch mousemove.mousetouch', function(
                    t
                  ) {
                    return (
                      'mouseup' === t.type && e(i).off('.mousetouch'), s(t)
                    );
                  }),
                  s(n)
                );
              });
          });
        };
        o.mouseTouch = t;
      })(jQuery),
      (function(t) {
        var i, r, s, a, c, l, u, d, h, p;
        e.convertPointFromPageToNode &&
          (i = function(t, n, i) {
            var r = e.convertPointFromPageToNode(t.get(0), new Point(n, i));
            return { x: r.x, y: r.y };
          }),
          i ||
            ((s = function(e, t) {
              var n,
                i,
                r,
                s,
                o = e.length,
                a = e[0].length,
                c = t[0].length,
                l = [];
              for (n = 0; o > n; n++) l[n] = [];
              for (n = 0; o > n; n++)
                for (i = 0; c > i; i++) {
                  for (s = 0, r = 0; a > r; r++) s += e[n][r] * t[r][i];
                  l[n][i] = s;
                }
              return l;
            }),
            (a = function(e, t) {
              var n,
                i = [];
              for (n = 0; n < e.length; n++)
                (i[n] = e[n].slice(0)), (i[n][e[n].length - 1] += +t[n] || 0);
              return i;
            }),
            (c = function(e) {
              (e = e.match(/matrix3?d?\(([^\)]+)\)/i)[1].split(',')),
                6 === e.length &&
                  (e = [
                    e[0],
                    e[1],
                    0,
                    0,
                    e[2],
                    e[3],
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    e[4],
                    e[5],
                    0,
                    1,
                  ]);
              var t,
                n,
                i = [];
              for (t = 0; 4 > t; t++)
                for (n = 0; 4 > n; n++)
                  (i[t] = i[t] || []), (i[t][n] = parseFloat(e[4 * n + t]));
              return i;
            }),
            (l = function(e, t) {
              var n = e.outerWidth(!1),
                i = e.outerHeight(!1),
                r = s(t, [
                  [0, n, 0, n],
                  [0, 0, i, 0, i],
                  [0, 0, 0, 0],
                  [1, 1, 1, 1],
                ]);
              return {
                left: Math.min.apply(Math, r[0]),
                top: Math.min.apply(Math, r[1]),
                right: Math.max.apply(Math, r[0]),
                bottom: Math.max.apply(Math, r[1]),
              };
            }),
            (p = c('matrix(1,0,0,1,0,0)')),
            (u = function(t) {
              function i(e) {
                var t,
                  i = 1;
                return 'number' == typeof e
                  ? e
                  : (e !== n &&
                      '' !== e &&
                      'normal' !== e &&
                      ((t = e.match(/(\d+|\d+\.\d*)(%?)$/)),
                      t &&
                        ((i = parseFloat(t[1], 10)),
                        '%' === t[2] && (i /= 100))),
                    i);
              }
              function r(e) {
                var t =
                  e.currentStyle && e.currentStyle.getAttribute
                    ? e.currentStyle.getAttribute('zoom')
                    : n;
                return i(t);
              }
              var s,
                o,
                a = e.getComputedStyle ? e.getComputedStyle(t, null) || {} : {},
                c = 1;
              return (
                (s =
                  a.msTransform ||
                  a.MozTransform ||
                  a.OTransform ||
                  a.WebkitTransform ||
                  'none'),
                (c = r(t)),
                'none' === s && (s = 'matrix(1,0,0,1,0,0)'),
                (o =
                  a.msTransformOrigin ||
                  a.MozTransformOrigin ||
                  a.OTransformOrigin ||
                  a.WebkitTransformOrigin ||
                  ''),
                (o = -1 !== o.indexOf('%') ? '' : o),
                (o = o.replace(/px/g, '')),
                { origin: o, transform: s, zoom: c }
              );
            }),
            (h = function(e) {
              var t, n, i, r, o;
              return (
                (i = u(e)),
                null === i
                  ? null
                  : ((t = c(i.transform)),
                    (n = i.origin),
                    (n = c(
                      'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,' +
                        ((n || '0 0') + ' 0').split(' ').slice(0, 3) +
                        ',1)'
                    )),
                    (n[0][0] *= i.zoom),
                    (n[1][1] *= i.zoom),
                    (r = a(p, [-n[0][3], -n[1][3], -n[2][3]])),
                    (o = s(s(n, t), r)))
              );
            }),
            (d = function(e) {
              function n(e) {
                var n,
                  i,
                  r = e.offset(),
                  s = e[0],
                  o = s.ownerDocument;
                return (
                  o &&
                    o.documentElement.msContentZoomFactor &&
                    1 !== o.documentElement.msContentZoomFactor &&
                    ((n = o.defaultView),
                    (r.left -= n.pageXOffset),
                    (r.top -= n.pageYOffset),
                    (i = t('html')),
                    (r.left += i.scrollLeft()),
                    (r.top += i.scrollTop())),
                  r
                );
              }
              var i,
                r,
                o = p;
              return (
                e.parents().each(function() {
                  var e = h(this);
                  null !== e && (o = s(e, o));
                }),
                (i = l(e, o)),
                (r = n(e)),
                (o = a(o, [r.left - i.left, r.top - i.top, 0]))
              );
            }),
            (i = function(e, t, n) {
              var i = d(e);
              return {
                x:
                  ((t - i[0][3]) * i[1][1] - (n - i[1][3]) * i[0][1]) /
                  (i[0][0] * i[1][1] - i[0][1] * i[1][0]),
                y:
                  (i[0][0] * (n - i[1][3]) - i[1][0] * (t - i[0][3])) /
                  (i[0][0] * i[1][1] - i[0][1] * i[1][0]),
              };
            }),
            (r = function(e, t, n) {
              var i = d(e),
                r = {
                  x: t * i[0][0] + n * i[0][1] + i[0][3],
                  y: t * i[1][0] + n * i[1][1] + i[1][3],
                };
              return r;
            })),
          (o.convertPointFromPage = i),
          (o.convertPageFromPoint = r);
      })(jQuery),
      (o.NumberpadManager = (function(t) {
        function s(e) {
          var t = e.altKey ? '-A' : '',
            n = e.ctrlKey ? '-C' : '',
            i = e.metaKey ? '-M' : '',
            r = e.shiftKey ? '-S' : '',
            s = String(e.which);
          return [s, t, n, i, r].join('');
        }
        function a(e) {
          t.each(y, function() {
            (e && this.isModalController) || this.vBlur();
          });
        }
        function c() {
          a(),
            t.each(y, function() {
              this.numpad &&
                (t(this.numpad.numpadEl).remove(), (this.numpad = null));
            }),
            (x = 0);
        }
        function l() {
          var e = null;
          return (
            t.each(y, function() {
              var t = this;
              return t.hasVFocus ? void (e = t) : void 0;
            }),
            e
          );
        }
        function u(e, t) {
          var n = this;
          (this.editorEl = e),
            (this.gobj = t),
            this.mq().__controller.constructor.onNotify(function(e) {
              'cut' === e && n.performEdit(function() {});
            });
        }
        function d() {
          return this instanceof d ? void 0 : new d();
        }
        function h(e, n) {
          var i = n ? t(n, e[0]) : e;
          i.length > 0 && o.FastClick.attach(i[0]);
        }
        function p() {
          d.apply(this, arguments);
        }
        function f(e) {
          return e.closest('.wsp-Calculator').length;
        }
        function m(e, n) {
          return this instanceof m
            ? (t(e).css({ 'user-select': 'none' }),
              (this.editedEl = e),
              (this.numpadParent = n),
              (this.hasVFocus = !1),
              (this.numpad = null),
              void y.push(this))
            : new m(e);
        }
        function g() {
          m.apply(this, arguments);
        }
        function b() {
          function e() {
            var e = t('body > .wsp-Numpads.wsp-version-4-8-0');
            return e.length
              ? e
              : t('<div/>')
                  .addClass('wsp-Numpads wsp-version-4-8-0')
                  .appendTo(t('body'));
          }
          function n() {}
          return (
            t(i).on('paste', function(e) {
              var t = l();
              return t ? (t.paste(e.originalEvent.clipboardData), !1) : !0;
            }),
            t(i).on('focus', '*', function(e) {
              return (e.currentTarget &&
                t(e.currentTarget).is('.wsp-Numberpad')) ||
                t(e.currentTarget).is('.wsp-Numberpad *')
                ? !1
                : void a(!0);
            }),
            t(i).on('StopCurrentPage.WSP', function() {
              c();
            }),
            t(i).on('keydown keyup', function(e) {
              var n,
                i,
                r,
                o = l(),
                a = f(t(e.target));
              o &&
                (!o.isModalController || a) &&
                ((n = o.numpad),
                (i = s(e)),
                (r = w[i]),
                !r && a && '13' === i && (r = 'submit'),
                r &&
                  (e.preventDefault(),
                  'keydown' === e.type
                    ? (t('.wsp-Numberpad-key-' + r, n.numpadEl).addClass(
                        'wsp-Numberpad-key-down'
                      ),
                      n.keyPressed(r))
                    : t('.wsp-Numberpad-key-' + r, n.numpadEl).removeClass(
                        'wsp-Numberpad-key-down'
                      )));
            }),
            (n.prototype.register = function(t) {
              var n,
                i = e();
              (n = t.hasClass('mfs-input') ? new m(t[0], i) : new g(t[0], i)),
                t.data('wsp-numfield-ctl', n);
            }),
            (n.prototype.blurNumpads = function() {
              a();
            }),
            new n()
          );
        }
        var v,
          y = [],
          x = 0,
          w = {
            8: 'backspace',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            '37-S': 'selectleft',
            38: 'up',
            39: 'right',
            '39-S': 'selectright',
            40: 'down',
            45: 'insert',
            46: 'delete',
            48: '0',
            '48-S': 'rparen',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            '54-S': 'exponent',
            55: '7',
            56: '8',
            '56-S': 'star',
            57: '9',
            '57-S': 'lparen',
            '61-S': 'plus',
            80: 'pi',
            82: 'r',
            84: 't',
            88: 'x',
            89: 'y',
            96: '0',
            97: '1',
            98: '2',
            99: '3',
            100: '4',
            101: '5',
            102: '6',
            103: '7',
            104: '8',
            105: '9',
            106: 'star',
            107: 'plus',
            109: 'minus',
            110: 'dot',
            111: 'slash',
            173: 'minus',
            '187-S': 'plus',
            188: 'comma',
            '188-S': 'lessthan',
            189: 'minus',
            190: 'dot',
            '190-S': 'greaterthan',
            191: 'slash',
          },
          k = e.MathQuill.noConflict();
        v = (function() {
          function e(e, t) {
            return t >= e ? e : t;
          }
          function i(e, t) {
            return e > t ? e : t;
          }
          function r(e, n) {
            (this.textNode = e),
              (this.text = t(e).text() || ''),
              (this.gobj = n),
              (this.cursor = 0),
              (this.rangeEnd = this.cursor),
              (this.collapsed = this.cursor === this.rangeEnd),
              (this.startWidth = t(e).width());
          }
          return (
            (r.prototype.adjustFieldWidth = function(e) {
              if (e) t(this.textNode).width('auto');
              else {
                var n = this.getTextWidth(),
                  i = t(this.textNode).width(),
                  r = Math.max(n + 1, this.startWidth);
                i !== r && t(this.textNode).width(r);
              }
            }),
            (r.prototype.setCursor = function(e) {
              (this.cursor = e),
                (this.rangeEnd = e),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.unsetCursor = function() {
              (this.cursor = n),
                (this.rangeEnd = n),
                (this.collapsed = n),
                this.render();
            }),
            (r.prototype.getTextWidth = function() {
              var e = t('.wsp-numfield-text', this.textNode).width();
              return e;
            }),
            (r.prototype.toString = function() {
              return (
                'text/cursor/rangeEnd/collapsed = ' +
                [this.text, this.cursor, this.rangeEnd, this.collapsed].join(
                  '/'
                )
              );
            }),
            (r.prototype.render = function() {
              function r(n) {
                var r = e(this.cursor, this.rangeEnd),
                  s = i(this.cursor, this.rangeEnd),
                  o = this.text.substring(0, r),
                  a = this.text.substring(r, s),
                  c = this.text.substring(s),
                  l = t('<span>'),
                  u = t('<span>').addClass('wsp-numfield-text');
                this.collapsed
                  ? l.addClass('wsp-blink').html('&#124;')
                  : l.addClass('wsp-selected').text(a),
                  o && u.append(o),
                  u.append(l),
                  c && u.append(c),
                  u.appendTo(n);
              }
              var s = t(this.textNode);
              s.empty(),
                this.cursor !== n &&
                this.cursor >= 0 &&
                this.cursor <= this.text.length
                  ? (r.call(this, s), this.adjustFieldWidth(!1))
                  : (t('<span>')
                      .addClass('wsp-numfield-text')
                      .html(this.text)
                      .appendTo(s),
                    this.adjustFieldWidth(!0));
            }),
            (r.prototype.moveLeft = function(e) {
              var t = e || 1;
              this.collapsed
                ? ((this.cursor = Math.max(0, this.cursor - t)),
                  (this.rangeEnd = this.cursor))
                : this.collapseToStart(),
                this.render();
            }),
            (r.prototype.moveRight = function(e) {
              var t = e || 1;
              this.collapsed
                ? ((this.cursor = Math.min(this.text.length, this.cursor + t)),
                  (this.rangeEnd = this.cursor))
                : this.collapseToEnd(),
                this.render();
            }),
            (r.prototype.selectAll = function() {
              (this.rangeEnd = 0),
                (this.cursor = this.text.length),
                (this.collapsed = this.cursor === this.rangeEnd),
                this.render();
            }),
            (r.prototype.selectLeft = function(e) {
              var t = e || 1;
              (this.rangeEnd = Math.max(0, this.rangeEnd - t)),
                (this.collapsed = this.cursor === this.rangeEnd),
                this.render();
            }),
            (r.prototype.selectRight = function(e) {
              var t = e || 1;
              (this.rangeEnd = Math.min(this.text.length, this.rangeEnd + t)),
                (this.collapsed = this.cursor === this.rangeEnd),
                this.render();
            }),
            (r.prototype.collapse = function(e) {
              var t = e || this.text.length;
              (this.cursor = t),
                (this.rangeEnd = t),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.collapseToStart = function() {
              (this.cursor = e(this.cursor, this.rangeEnd)),
                (this.rangeEnd = this.cursor),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.collapseToEnd = function() {
              (this.cursor = i(this.cursor, this.rangeEnd)),
                (this.rangeEnd = this.cursor),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.deleteAtCursor = function(e) {
              var t = e || 1;
              this.collapsed && this.selectLeft(t), this.insertAtCursor('');
            }),
            (r.prototype.deleteRight = function(e) {
              var t = e || 1;
              this.collapsed && this.selectRight(t), this.insertAtCursor('');
            }),
            (r.prototype.insertAtCursor = function(t) {
              var n = this.text,
                r = e(this.cursor, this.rangeEnd),
                s = i(this.cursor, this.rangeEnd),
                o = [];
              r > 0 && o.push(n.substring(0, r)),
                o.push(t),
                s < n.length && o.push(n.substring(s)),
                (this.text = o.join('')),
                (this.cursor = r + t.length),
                (this.rangeEnd = this.cursor),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.paste = function(e) {
              this.insertAtCursor(e);
            }),
            (r.prototype.isValueNegative = function() {
              return '-' === this.text.substring(0, 1) ? !0 : !1;
            }),
            (r.prototype.makeValueNegative = function() {
              var e;
              0 === this.text.length
                ? this.insertAtCursor('-')
                : '-' !== this.text.substring(0, 1) &&
                  ((e = this.cursor),
                  this.setCursor(0),
                  this.insertAtCursor('-'),
                  this.setCursor(e + 1),
                  this.render());
            }),
            (r.prototype.makeValuePositive = function() {
              var e;
              '-' === this.text.substring(0, 1) &&
                ((e = this.cursor),
                this.setCursor(1),
                this.deleteAtCursor(),
                this.setCursor(e - 1),
                this.render());
            }),
            (r.prototype.prepare = function() {
              function e(e) {
                var t,
                  n = '';
                return (
                  0 === e.numerator
                    ? (n = '0')
                    : (e.numerator < 0 && (n = '-'),
                      (t = Math.abs(e.numerator)),
                      1 !== t && ((n += t), (n += '*')),
                      (n += 'π'),
                      1 !== e.denominator &&
                        ((n += '/'), (n += e.denominator))),
                  n
                );
              }
              function n(e, t) {
                var n = Math.pow(10, t);
                return String(Math.round(e * n) / n);
              }
              function i(t, i) {
                var r,
                  s = o.math.getSimplePiFraction(t);
                return (r = s ? e(s) : n(t, i));
              }
              var r = this.gobj,
                s = Math.max(3, r.style.precision),
                a = r.blank ? '' : i(r.uValue, s);
              t(this.textNode).html(a), (this.text = a), this.selectAll();
              var c = o.NumpadEditRegime.createWithGObj(r);
              r.sQuery.sketch.event(
                'EditExpression',
                { gobj: r },
                { action: 'Started', value: r.value, expression: this.text }
              ),
                this.gobj.sQuery.sketch.pushTouchRegime(c),
                (this.touchRegime = c);
            }),
            (r.prototype.reset = function() {
              (this.text = ''),
                (this.cursor = 0),
                (this.rangeEnd = 0),
                (this.collapsed = !0),
                this.render();
            }),
            (r.prototype.moveUp = function() {}),
            (r.prototype.moveDown = function() {}),
            (r.prototype.tab = function() {}),
            (r.prototype.positionCursorByOffset = function(e) {
              var n,
                i,
                r,
                s = this.text,
                o = s.length;
              (r = e - t(this.textNode).offset().left),
                (n = this.getTextWidth()),
                (i = o ? n / o : 0),
                this.setCursor(r > n ? s.length : Math.round(r / i));
            }),
            (r.prototype.submit = function() {
              a();
            }),
            (r.prototype.cleanupCalculatorState = function() {
              delete this.sessionID,
                this.touchRegime &&
                  this.gobj.sQuery.sketch.popAllTouchRegimesIncluding(
                    this.touchRegime
                  ),
                (this.touchRegime = null);
            }),
            (r.prototype.finishEditing = function() {
              function e() {
                return t.sQuery().get(t.id) === t;
              }
              var t = this.gobj,
                n = t.value,
                i = this.closeReason,
                r = 'changesNotAccepted' === i;
              this.cleanupCalculatorState(),
                e() &&
                  (r && (this.text = n.toString()),
                  t.setEditedValue(this.text),
                  (t.state.selected = !1),
                  t.value === n
                    ? this.gobj.sQuery.sketch.event(
                        'EditExpression',
                        { gobj: this.gobj },
                        { action: 'Canceled' }
                      )
                    : this.gobj.sQuery.sketch.event(
                        'EditExpression',
                        { gobj: this.gobj },
                        {
                          action: 'Confirmed',
                          oldValue: n,
                          expression: this.text,
                          newValue: this.gobj.value,
                        }
                      ),
                  this.calculatorDidClose && this.calculatorDidClose(i),
                  delete this.closeReason);
            }),
            r
          );
        })(t);
        var P = -1,
          C = 1;
        return (
          (u.prototype = Object.create(v.prototype)),
          (u.prototype.mq = function() {
            var e = k;
            return e(this.editorEl[0]);
          }),
          (u.prototype.withCursor = function(e) {
            return e(this.mq().__controller.cursor);
          }),
          (u.prototype.showCursor = function() {
            this.withCursor(function(e) {
              e.show();
            });
          }),
          (u.prototype.moveToFarRight = function() {
            this.mq().moveToRightEnd();
          }),
          (u.prototype.tab = function() {
            this.mq().keystroke('Tab');
          }),
          (u.prototype.selectLeft = function(e) {
            this.mq().keystroke('Shift-Left');
          }),
          (u.prototype.paste = function(e) {
            '$' === e.slice(0, 1) &&
              '$' === e.slice(-1) &&
              (e = e.slice(1, -1));
            var t = this;
            this.performEdit(function() {
              t.writeLatex(e);
            });
          }),
          (u.prototype.selectRight = function(e) {
            this.mq().keystroke('Shift-Right');
          }),
          (u.prototype.insertAtCursor = function(e, t) {
            this.mq().cmd(e), t || this.showCursor();
          }),
          (u.prototype.writeLatex = function(e) {
            this.mq().write(e);
          }),
          (u.prototype.ascendTwo = function() {
            this.withCursor(function(e) {
              e.insRightOf(e.parent.parent);
            });
          }),
          (u.prototype.insertFunction = function(e) {
            this.insertAtCursor('('), this.moveLeft(), e(), this.moveRight();
          }),
          (u.prototype.writeLiteral = function(e) {
            var t = o.Strings.format('\\blob<span>%@</span>\\endBlob', [e]);
            this.writeLatex(t);
          }),
          (u.prototype.insertSimpleFunction = function(e) {
            var t = this;
            this.insertFunction(function() {
              t.writeLiteral(e);
            });
          }),
          (u.prototype.insertParentFunction = function(e) {
            var t = this;
            this.insertFunction(function() {
              o.mfs.renderMathquillFromParsedInfix(e, t, t.parents);
            });
          }),
          (u.prototype.deleteAtCursor = function(e) {
            this.mq().keystroke('Backspace');
          }),
          (u.prototype.deleteRight = function(e) {
            this.mq().keystroke('Right Backspace');
          }),
          (u.prototype.moveLeft = function(e) {
            this.mq().keystroke('Left');
          }),
          (u.prototype.moveRight = function(e) {
            this.mq().keystroke('Right');
          }),
          (u.prototype.moveUp = function(e) {
            this.mq().keystroke('Up');
          }),
          (u.prototype.moveDown = function(e) {
            this.mq().keystroke('Down');
          }),
          (u.prototype.insertParent = function(e) {
            function t() {
              for (var t, i = 0; ; ) {
                if (
                  (n.parents[i] ||
                    ((n.parents[i] = e),
                    e.label ||
                      'noVisibleName' !== e.style.nameOrigin ||
                      ((e.label = e.sQuery.sketch.labelPool.generateLabel(
                        e.kind,
                        e.genus,
                        e.id
                      )),
                      (e.style.nameOrigin = 'namedFromLabel'),
                      e.updateLabel({ show: !0 }),
                      e.invalidateGeom())),
                  n.parents[i] === e)
                )
                  return (
                    (t = {
                      type: 'reference',
                      name: String(i),
                      kind: 'reference:' + i,
                      children: {},
                      refCount: 1,
                      index: 0,
                    }),
                    void (e.isFunction && e.isFunction()
                      ? n.insertParentFunction(t)
                      : o.mfs.renderMathquillFromParsedInfix(t, n, n.parents))
                  );
                i++;
              }
            }
            var n = this;
            n.performEdit(t);
          }),
          (u.prototype.coalesceParents = function() {
            var e = 0,
              n = {},
              i = this,
              r = 'wsp-ref',
              s = {};
            t('*[wsp-ref]', this.editorEl).each(function() {
              var o = t(this),
                a = o.attr(r);
              n[a] || ((n[a] = e), (s[e] = i.parents[a]), e++), o.attr(r, n[a]);
            }),
              i.labelParents.forEach(function(t) {
                var n,
                  i = !1,
                  r = !1;
                for (n = 0; e > n; n++)
                  if (
                    (s[n] === t.valueGObj && (i = !0), s[n] === t.labelGObj)
                  ) {
                    r = !0;
                    break;
                  }
                i && !r && ((s[e] = t.labelGObj), e++);
              }),
              (i.parents = s);
          }),
          (u.prototype.prepare = function() {
            var e = this,
              t = this.gobj,
              n = t.sQuery.sketch;
            (e.finishEditing = function() {
              console.log('finishEditing called for ', t, e);
              var i = [];
              e.cleanupCalculatorState(),
                'changesAccepted' === e.closeReason
                  ? (t.parentsList.forEach(function(e) {
                      i.push(e.id);
                    }),
                    n.event(
                      'EditExpression',
                      { gobj: t },
                      {
                        action: 'Confirmed',
                        infix: t.parsedInfix,
                        expressionType: t.expressionType,
                        expression: t.expression,
                        functionExpr: t.functionExpr,
                        parentIds: i,
                      }
                    ))
                  : n.event(
                      'EditExpression',
                      { gobj: t },
                      { action: 'Canceled' }
                    ),
                e.calculatorDidClose &&
                  e.calculatorDidClose(e.closeReason || 'changesNotAccepted'),
                (e.closeReason = null);
            }),
              e.reset();
            try {
              o.mfs.renderMathquillFromParsedInfix(
                e.gobj.parsedInfix,
                e,
                e.gobj.parentsList
              ),
                e.showCursor();
            } catch (e) {
              o.signalCaughtError(e);
            }
            var i = o.BackClickRegime.createWithEditor(e);
            (i.delegate = e),
              e.gobj.sQuery.sketch.pushTouchRegime(i),
              (e.touchRegime = i),
              e.gobj.sQuery().sketch.document.changedUIMode(),
              e.gobj.sQuery.sketch.event(
                'EditExpression',
                { gobj: e.gobj },
                { action: 'Started' }
              );
          }),
          (u.prototype.regimeDidPop = function(e) {
            a(), this.gobj.sQuery().sketch.document.changedUIMode();
          }),
          (u.prototype.reset = function() {
            function e(e) {
              var i;
              return (
                t.each(e.MFSValues, function(e, t) {
                  return e.match(/byValue/)
                    ? ((i = n.gobj.sQuery('#' + t.referenceId)), !1)
                    : void 0;
                }),
                i
              );
            }
            var n = this,
              i = this.gobj,
              r = 0;
            (n.parents = {}),
              (n.labelParents = []),
              t.each(i.parents, function(t, i) {
                'CompositeText' === i.constraint
                  ? n.labelParents.push({ labelGObj: i, valueGObj: e(i) })
                  : (n.parents[r++] = i);
              }),
              i.isFunction() &&
                ((n.notation = i.functionExpr.notation),
                (n.independentVar = i.functionExpr.independentVar),
                n.generateEquationOptions()),
              n.hideErrorNotice(),
              n.mq().latex('');
          }),
          (u.prototype.setIndependentVar = function(e) {
            (this.independentVar = e),
              t('.wsp-independent-variable', this.editorEl).each(function() {
                t(this).text(e);
              });
          }),
          (u.prototype.registerIndependentVariable = function() {
            this.withCursor(function(e) {
              var t = e[P];
              t.jQ.eq(0).addClass('wsp-independent-variable');
            });
          }),
          (u.prototype.renderAndSelect = function(e) {
            var t = this;
            this.withCursor(function(n) {
              var i = n[P];
              for (e(); n[P] !== i; ) t.selectLeft();
            });
          }),
          (u.prototype.renderOnLeft = function(e) {
            var t, n;
            this.withCursor(function(i) {
              i[C]
                ? ((t = i[C]), e(), i.insLeftOf(t))
                : ((n = i.parent), e(), i.insAtRightEnd(n));
            });
          }),
          (u.prototype.submit = function() {
            function e() {
              if (
                (n.coalesceParents(),
                (t = n.translateMathQuillToInfix()),
                i.isFunction())
              ) {
                switch (
                  ((i.functionExpr.notation = n.notation), n.independentVar)
                ) {
                  case 'x':
                    (i.expressionType = 'YofX_FunctionExprType'),
                      (i.functionExpr.dependentVar = 'y');
                    break;
                  case 'y':
                    (i.expressionType = 'XofY_FunctionExprType'),
                      (i.functionExpr.dependentVar = 'x');
                    break;
                  case 'r':
                    (i.expressionType = 'TofR_FunctionExprType'),
                      (i.functionExpr.dependentVar = 'θ');
                    break;
                  case 'θ':
                    (i.expressionType = 'RofT_FunctionExprType'),
                      (i.functionExpr.dependentVar = 'r');
                    break;
                  case 't':
                    (i.expressionType = 'YofX_FunctionExprType'),
                      (i.functionExpr.dependentVar =
                        i.functionExpr.dependentVar);
                }
                i.functionExpr.independentVar = n.independentVar;
              }
              try {
                o.mfs.getParsedInfixAndFunction(t);
              } catch (e) {
                return;
              }
              (i.parents = n.parents),
                (i.expression = t),
                i.expressionAndParentsWereUpdated();
            }
            var t,
              n = this,
              i = this.gobj;
            if (!this.errorNoticeIsVisible()) {
              try {
                e();
              } catch (e) {
                o.signalCaughtError(e);
              }
              (this.closeReason = 'changesAccepted'), a();
            }
          }),
          (u.prototype.getCalculatorElement = function() {
            return this.editorEl.closest('.wsp-Calculator');
          }),
          (u.prototype.showErrorNotice = function() {
            this.getCalculatorElement().addClass('wsp-syntax-error'),
              t('.wsp-Calculator-ok-button', this.getCalculatorElement()).attr(
                'disabled',
                'true'
              );
          }),
          (u.prototype.hideErrorNotice = function() {
            this.getCalculatorElement().removeClass('wsp-syntax-error'),
              t(
                '.wsp-Calculator-ok-button',
                this.getCalculatorElement()
              ).removeAttr('disabled');
          }),
          (u.prototype.errorNoticeIsVisible = function() {
            return this.getCalculatorElement().hasClass('wsp-syntax-error');
          }),
          (u.prototype.performEdit = function(e) {
            var t;
            e();
            try {
              (t = this.translateMathQuillToInfix()),
                o.mfs.getParsedInfixAndFunction(t),
                this.hideErrorNotice();
            } catch (e) {
              this.showErrorNotice();
            }
          }),
          (u.prototype.getSessionID = function() {
            return (
              this.sessionID === n && (this.sessionID = o.generateUUID()),
              this.sessionID
            );
          }),
          (u.prototype.translateMathQuillToInfix = function() {
            function e(t) {
              function n(t) {
                function n(e) {
                  switch (e) {
                    case 'x':
                    case 'y':
                    case 'r':
                    case 'θ':
                    case 't':
                      return !0;
                  }
                  return !1;
                }
                function r(e) {
                  return i.gobj.isFunction() && e === i.independentVar;
                }
                function s(e, n) {
                  return n || (n = t), n.children().eq(e);
                }
                function a() {
                  if (s(0).hasClass('wsp-ref')) {
                    if (s(0).attr('wsp-sessionID') === i.getSessionID())
                      return '@' + s(0).attr('wsp-ref') + ' ';
                    s(0).html('<span class="wsp-missing">??</span>');
                  }
                  return s(0).text();
                }
                var c;
                if (t.hasClass('mq-non-leaf')) {
                  var l,
                    u = s(0);
                  if (t.hasClass('mq-supsub')) return e(t.children());
                  if (u.hasClass('mq-sqrt-prefix'))
                    return (l = s(1)), 'sqrt(' + e(l.children()) + ')';
                  if (u.hasClass('mq-paren'))
                    switch (((l = s(1)), (c = e(l.children())), u.text())) {
                      case '(':
                        return '(' + c + ')';
                      case '|':
                        return 'abs(' + c + ')';
                      default:
                        return (
                          o.log('unrecognized delimiter: ' + u.text()),
                          '(' + c + ')'
                        );
                    }
                  else {
                    if (u.hasClass('mq-numerator'))
                      return (
                        (l = s(1)),
                        '((' + e(u.children()) + ')/(' + e(l.children()) + '))'
                      );
                    u.hasClass('mq-cursor') ||
                      o.log(
                        'unrecognized child of non-leaf: ' + u[0].outerHTML
                      );
                  }
                  return '';
                }
                if (
                  t.hasClass('mq-root-block') ||
                  t.hasClass('mq-selection') ||
                  t.hasClass('mq-text')
                )
                  return e(t.children());
                if (t.hasClass('mq-sup')) return '^(' + e(t.children()) + ')';
                if (t.hasClass('mq-blob')) return a();
                if (t.hasClass('mq-cursor')) return '';
                if (0 === t.children().length) {
                  var d = t.text() || '';
                  return (
                    n(d) && !r(d) && (t.addClass('wsp-missing'), t.text('??')),
                    t.text() || ''
                  );
                }
                return (
                  o.log('unrecognized mathquill node: ' + t[0].outerHTML), ''
                );
              }
              function r(e) {
                return e
                  .replace('⋅', '*')
                  .replace('·', '*')
                  .replace('−', '-')
                  .replace('ƒ', 'f')
                  .replace(' ', '');
              }
              for (var s = [], a = 0; a < t.length; a++) s.push(r(n(t.eq(a))));
              return s.join('');
            }
            function n(e) {
              return t('> :not(:first-child)', e);
            }
            var i = this;
            return e(n(this.editorEl));
          }),
          (d.prototype = {
            attachFastClick: function() {
              h(this.numpadEl);
            },
            init: function(e, n, r, s) {
              function a(e) {
                function n(e) {
                  var t,
                    n,
                    i = e.data;
                  e.preventDefault(),
                    (t = e.pageX - i.touch.dx),
                    (n = e.pageY - i.touch.dy),
                    i.numpadEl.offset({ left: t, top: n });
                }
                function r(e) {
                  t(i).off('mousemove', n), t(i).off('mouseup', r);
                }
                var s = e.data;
                e.preventDefault(),
                  s.focus(),
                  (s.touch = {
                    dx: e.pageX - t(this).offset().left,
                    dy: e.pageY - t(this).offset().top,
                  }),
                  t(i).on('mousemove', s, n),
                  t(i).on('mouseup', s, r);
              }
              function c(e) {
                function n(e) {
                  var t,
                    n,
                    i,
                    r = e.originalEvent,
                    s = e.data,
                    o = r.touches.length;
                  o >= 1 &&
                    (e.preventDefault(),
                    (t = r.touches[0]),
                    (n = t.pageX - s.touch.dx),
                    (i = t.pageY - s.touch.dy),
                    s.numpadEl.offset({ left: n, top: i }));
                }
                function i(e) {
                  t(this).off('touchmove', n), t(this).off('touchend', i);
                }
                var r,
                  s = e.originalEvent,
                  o = e.data,
                  a = s.touches.length;
                1 === a &&
                  (e.preventDefault(),
                  (r = s.touches[0]),
                  (o.touch = {
                    dx: r.pageX - t(this).offset().left,
                    dy: r.pageY - t(this).offset().top,
                  })),
                  t(this).on('touchmove', o, n),
                  t(this).on('touchend', o, i);
              }
              var l, u, d, h;
              (this.decimalSeparator =
                s.sQuery.sketch.document.formatOptions.decimalSeparator),
                (this.editedEl = e),
                (x += 1),
                (this.numpadHome = n),
                (this.numpadEl = t('<div>')
                  .addClass(this.cssClass)
                  .prop({ tabIndex: -1, id: 'numpad' + x })
                  .css({ position: 'absolute' })
                  .attr({
                    role: 'dialog',
                    'aria-labelledby': 'numpadLabel' + x,
                  })
                  .append(
                    t(
                      '<h2 style="display: none;" id="numpadLabel' +
                        x +
                        '">Number Pad</h2>'
                    )
                  )),
                this.initializeEventHandlers();
              var p = this.addHeader(s);
              (this.dragHandle = p.dragHandle),
                (this.editor = this.createEditor(p.editorElt, s)),
                (d = this.addBody());
              var f = o.getConfigValue(this.getConfigKey());
              for (l = 0; l < f.length; l += 1) {
                for (
                  h = t('<div>').addClass('wsp-Numberpad-row'), u = 0;
                  u < f[l].length;
                  u += 1
                )
                  h.append(this.makeKey(f[l][u]));
                d.append(h);
              }
              this.initializeKeys(this.numpadEl),
                this.addElementForAccessibility(),
                this.attachFastClick(),
                r || this.hide(),
                this.numpadEl.css('visibility', 'hidden'),
                this.numpadHome.append(this.numpadEl),
                this.position(),
                this.numpadEl.css('visibility', 'visible'),
                t(this.dragHandle).on('mousedown', this, a),
                t(this.dragHandle).on('touchstart', this, c);
            },
            createEditor: function(e, t) {
              return new v(e, t);
            },
            addHeader: function() {
              var e = t('<div>').addClass('wsp-Numberpad-header'),
                n = t('<button aria-label="Close"></button>').addClass(
                  'wsp-Numberpad-cancel'
                );
              return (
                n.appendTo(e),
                n
                  .on('touchstart mousedown', function() {
                    a();
                  })
                  .on('keydown', function(e) {
                    (32 === e.which || 13 === e.which) && a();
                  }),
                this.numpadEl.append(e),
                { dragHandle: e, editorElt: this.editedEl }
              );
            },
            addBody: function() {
              var e = t('<div></div>').addClass('wsp-Numberpad-body');
              return this.numpadEl.append(e), e;
            },
            addElementForAccessibility: function() {
              var e = t(
                  '<button id="firstElement" aria-label="blank" class="wsp-sr-only" type="button"></button>'
                ),
                n = t(
                  '<button id="lastElement" aria-label="blank" class="wsp-sr-only" type="button"></button>'
                );
              e.focusin(function(e) {
                t('.wsp-Numberpad-key-backspace').focus();
              }),
                n.focusin(function(e) {
                  t('.wsp-Numberpad-cancel').focus();
                }),
                this.numpadEl.append(n).prepend(e);
            },
            getConfigKey: function() {
              return 'NumberpadManager.options.keyOrder';
            },
            cssClass: 'wsp-Numberpad',
            keySpecs: {
              1: { clss: 'wsp-Numberpad-numkey', ent: '1' },
              2: { clss: 'wsp-Numberpad-numkey', ent: '2' },
              3: { clss: 'wsp-Numberpad-numkey', ent: '3' },
              4: { clss: 'wsp-Numberpad-numkey', ent: '4' },
              5: { clss: 'wsp-Numberpad-numkey', ent: '5' },
              6: { clss: 'wsp-Numberpad-numkey', ent: '6' },
              7: { clss: 'wsp-Numberpad-numkey', ent: '7' },
              8: { clss: 'wsp-Numberpad-numkey', ent: '8' },
              9: { clss: 'wsp-Numberpad-numkey', ent: '9' },
              0: { clss: 'wsp-Numberpad-numkey', ent: '0' },
              dot: { clss: 'wsp-Numberpad-numkey', ent: '.' },
              pi: { clss: 'wsp-Numberpad-numkey', ent: '&#x003C0;' },
              plus: { clss: 'wsp-Numberpad-control-key', ent: '+' },
              minus: { clss: 'wsp-Numberpad-control-key', ent: '-' },
              exponent: { clss: 'wsp-Numberpad-control-key', ent: '^' },
              opposite: {
                clss: 'wsp-Numberpad-control-key',
                ent: '&#177;',
                op: 'opposite',
              },
              star: {
                clss: 'wsp-Numberpad-control-key',
                ent: '*',
                op: 'insertStar',
              },
              slash: { clss: 'wsp-Numberpad-control-key', ent: '/' },
              lparen: { clss: 'wsp-Numberpad-control-key', ent: '(' },
              rparen: { clss: 'wsp-Numberpad-control-key', ent: ')' },
              backspace: {
                clss: 'wsp-Numberpad-control-key wsp-Numberpad-erase-to-left',
                ent: '',
                op: 'backspace',
              },
              clear: {
                clss: 'wsp-Numberpad-control-key wsp-Numberpad-clear',
                ent: '',
                op: 'reset',
              },
              submit: {
                clss: 'wsp-Numberpad-control-key',
                ent: '&#10003;',
                op: 'submit',
              },
              left: { op: 'moveLeft' },
              right: { op: 'moveRight' },
              up: { op: 'moveUp' },
              down: { op: 'moveDown' },
              tab: { op: 'tab' },
              selectleft: { op: 'selectLeft' },
              selectright: { op: 'selectRight' },
              x: { op: 'xPressed' },
              y: { op: 'yPressed' },
              r: { op: 'rPressed' },
              t: { op: 'tPressed' },
              esc: { op: 'doCancel' },
              delete: { op: 'deleteRight' },
            },
            makeKey: function(e) {
              var n,
                i = this.keySpecs[e];
              if (i) {
                var r,
                  s = i.ent,
                  o = e;
                'dot' === e &&
                  ((s = this.decimalSeparator), (o = 'decimal point')),
                  (r = t('<div/>')
                    .html(s)
                    .text()),
                  (n = t('<button aria-label="' + o + '"></button>')
                    .addClass('wsp-Numberpad-key wsp-Numberpad-element')
                    .addClass(i.clss)
                    .addClass('wsp-Numberpad-key-' + e)
                    .attr('data-keyText', r)
                    .data('wsp-key-name', e)),
                  (i.value = r);
              } else
                n =
                  '' === e
                    ? t('<div></div>').addClass('wsp-Numberpad-element')
                    : t('<div></div>').text('?');
              return n;
            },
            getKeyValue: function(e) {
              return this.keySpecs[e].value;
            },
            initializeKeys: function(e) {
              t('.wsp-Numberpad-key', e).on('click', this, function(e) {
                return e.data.keyPressed(t(this).data('wsp-key-name')), !1;
              });
            },
            initializeEventHandlers: function() {},
            hide: function() {
              t(this.numpadEl).hide();
            },
            focus: function() {
              var e = this;
              setTimeout(function() {
                t(e.numpadEl)
                  .find('.wsp-Numberpad-cancel')
                  .focus();
              }, 100);
            },
            position: function() {
              var n = this.numpadEl.outerWidth(),
                r = this.numpadEl.outerHeight(),
                s = t(this.editedEl).outerHeight(),
                o = t(this.editedEl).offset(),
                a = t(i).scrollTop(),
                c = o.top - t(i).scrollTop(),
                l = a + t(e).height() - (o.top + s),
                u = o.left,
                d = r > l,
                h = r > c && d;
              h ? (o.top = a) : d ? (o.top -= r) : (o.top += s),
                n > u ? h && (o.left += n / 2) : (o.left -= n),
                this.numpadEl.offset(o);
            },
            show: function() {
              t(this.numpadEl).show(), this.position();
            },
            keyPressed: function(e) {
              var t = this.keySpecs[e];
              t &&
                (t.op
                  ? this[t.op]
                    ? this[t.op]()
                    : this.editor[t.op] && this.editor[t.op]()
                  : t.value !== n && this.editor.insertAtCursor(t.value),
                this.editor.gobj.sQuery.sketch.setSpeakabletext(
                  'Display is ' + this.editor.text
                ));
            },
            backspace: function() {
              this.editor.deleteAtCursor();
            },
            opposite: function() {
              this.editor.isValueNegative()
                ? this.editor.makeValuePositive()
                : this.editor.makeValueNegative();
            },
            unpressAllKeys: function() {
              t('.wsp-Numberpad-key', this.numpadEl).removeClass(
                'wsp-Numberpad-key-down'
              );
            },
            submit: function() {
              (this.editor.closeReason = 'changesAccepted'),
                this.editor.submit(),
                this.unpressAllKeys();
            },
            insertStar: function() {
              this.keySpecs.star.value && this.editor.insertAtCursor('*');
            },
            doCancel: function() {
              (this.editor.closeReason = 'changesNotAccepted'), a();
            },
          }),
          (p.prototype = Object.create(d.prototype)),
          (p.prototype.keySpecs = t.extend(!0, {}, d.prototype.keySpecs)),
          (p.prototype.attachFastClick = function() {
            h(this.numpadEl, '.wsp-Calculator-body-wrapper'),
              h(this.numpadEl, '.wsp-Calculator-bottom');
          }),
          (p.prototype.createEditor = function(e, t) {
            return new u(e, t);
          }),
          (p.prototype.keyPressed = function(e) {
            var t = this;
            this.editor.performEdit(function() {
              d.prototype.keyPressed.call(t, e);
            });
          }),
          (p.prototype.initMathQuill = function(e) {
            var n = /(Mobi)|(Android)/.test(r.userAgent);
            k.MathField(e[0], {
              substituteTextarea: function() {
                var e = t(
                  n ? '<span tabindex="0"></span>>' : '<textarea></textarea>'
                );
                return e[0];
              },
            });
          }),
          (p.prototype.initializeEventHandlers = function(e) {
            var n = this;
            this.numpadEl.on('click', function(e) {
              var i = t(e.target).closest('.wsp-calculator-edited').length,
                r = t(e.target).closest('.wsp-Calculator-display').length;
              r && !i && n.editor.moveToFarRight(),
                n.editor.showCursor(),
                n.focus();
            }),
              this.numpadEl.on('mousedown', function(e) {
                f(t(i.activeElement)) && e.preventDefault();
              });
          }),
          (p.prototype.addHeader = function(e) {
            var n,
              i,
              r,
              s,
              o = t('<span>').addClass('wsp-syntax-error-notice');
            return (
              (n = t('<div/>').addClass('wsp-Calculator-title')),
              n.text('Edit ' + (e.isFunction() ? 'Function' : 'Calculation')),
              (r = t('<span/>').css('border', 'none')),
              this.initMathQuill(r),
              r.addClass('wsp-calculator-edited'),
              (i = t('<div/>')
                .addClass('wsp-Calculator-display')
                .append(r)),
              (s = t('<div>')
                .addClass('wsp-Calculator-display-wrapper')
                .append(i)
                .append(o)),
              this.numpadEl.append(n).append(s),
              { dragHandle: n, editorElt: r }
            );
          }),
          (p.prototype.insertIndependentVariable = function(e) {
            this.editor.gobj.isFunction() &&
              e === this.editor.independentVar &&
              (this.editor.insertAtCursor(e),
              this.editor.registerIndependentVariable());
          }),
          (p.prototype.xPressed = function() {
            this.insertIndependentVariable('x');
          }),
          (p.prototype.yPressed = function() {
            this.insertIndependentVariable('y');
          }),
          (p.prototype.rPressed = function() {
            this.insertIndependentVariable('r');
          }),
          (p.prototype.tPressed = function() {
            this.insertIndependentVariable('θ');
          }),
          (p.prototype.addBody = function() {
            function e(e, n) {
              var i = t('.dropdown-menu', e);
              i.empty();
              for (var r = 0; r < n.length; r++) i.append(n[r]);
            }
            function n() {
              var e = t('.wsp-independent-variable-option', v).parent();
              p(e, 'value', i.editor.independentVar),
                f(e, i.editor.independentVar);
            }
            var i = this,
              r = t('<div/>').addClass('wsp-Calculator-body-wrapper'),
              s = t('<div/>').addClass('wsp-Calculator-left'),
              a = t('<p/>')
                .addClass('wsp-Calculator-label-insert')
                .text('Insert:'),
              c = function(e, n, i) {
                var r = t('<div/>').addClass('dropdown'),
                  s = t('<ul/>').addClass('dropdown-menu'),
                  o = t('<button/>')
                    .addClass('dropdown-toggle')
                    .attr('data-toggle', 'dropdown')
                    .addClass('wsp-Calculator-textual')
                    .text(n)
                    .append(t('<span/>').addClass('caret'));
                if ((r.append(o).append(s), i))
                  for (var a = 0; a < i.length; a++) s.append(i[a]);
                return r;
              },
              l = function() {
                return t('<button/>')
                  .addClass('wsp-Calculator-textual')
                  .addClass('wsp-Calculator-bottom-button');
              },
              u = function(e) {
                return e.addClass('wsp-Calculator-select-for-insert');
              },
              d = function() {
                return t('<li/>').addClass('divider');
              },
              h = function(e, n, i) {
                var r = t('<a/>')
                  .data('value', e)
                  .text(n ? n : e);
                return i && r.css('font-style', 'italic'), t('<li/>').append(r);
              },
              p = function(e, n, i) {
                return t('a', e).data(n, i), e;
              },
              f = function(e, n) {
                return t('a', e).text(n), e;
              },
              m = function(e, n) {
                return t('a', e).addClass(n), e;
              },
              g = function() {
                return m(h('', '', !0), 'wsp-independent-variable-option');
              },
              b = function(e) {
                return e.addClass('selected');
              },
              v = c('values', 'Values', [
                d(),
                g(),
                d(),
                h('pi', 'π', !0),
                h('e', 'e', !0),
              ]).addClass('wsp-Calculator-topmost-select-for-insert'),
              y = u(
                c('functions', 'Functions', [
                  d(),
                  h('function', 'sin'),
                  h('function', 'cos'),
                  h('function', 'tan'),
                  h('function', 'Arcsin'),
                  h('function', 'Arccos'),
                  h('function', 'Arctan'),
                  d(),
                  h('|', 'abs'),
                  h('\\sqrt', 'sqrt'),
                  h('function', 'ln'),
                  h('function', 'log'),
                  h('function', 'sgn'),
                  h('function', 'round'),
                  h('function', 'trunc'),
                ])
              ).addClass('wsp-select-function'),
              x = u(
                c('units', 'Units', [
                  d(),
                  h(' pixels'),
                  h(' cm'),
                  h(' in.', ' inches'),
                  d(),
                  h(' radians'),
                  h(' degrees'),
                ])
              ).addClass('wsp-select-units'),
              w = t('<div/>').addClass('wsp-Calculator-body'),
              k = t('<div/>').addClass('wsp-Calculator-bottom'),
              P = c('equation', 'Equation', []).addClass(
                'wsp-Calculator-select-equation'
              ),
              C = l().text('Cancel'),
              S = l()
                .addClass('wsp-Calculator-ok-button')
                .append(
                  t('<span/>')
                    .addClass('wsp-Calculator-ok-button-inner')
                    .text('OK')
                );
            return (
              t(C).on('click', function() {
                return i.doCancel(), !1;
              }),
              t(S).on('click', function() {
                return i.editor.submit(), !1;
              }),
              s
                .append(a)
                .append(v)
                .append(y)
                .append(x),
              t('a', s).on('click', function(e) {
                var n = t(this),
                  r = n.data('value');
                i.editor.performEdit(function() {
                  'function' === r
                    ? i.editor.insertSimpleFunction(n.text())
                    : (i.editor.insertAtCursor(r),
                      n.hasClass('wsp-independent-variable-option') &&
                        i.editor.registerIndependentVariable());
                });
              }),
              r.append(s).append(w),
              i.editor.gobj.isFunction() || P.css('visibility', 'hidden'),
              (i.editor.generateEquationOptions = function() {
                function r() {
                  switch (l) {
                    case 'x':
                      return 'y';
                    case 'y':
                      return 'x';
                    case 'r':
                      return 'θ';
                    case 'θ':
                      return 'r';
                    case 't':
                      return i.editor.gobj.functionExpr.dependentVar;
                  }
                  throw o.createError('unrecognized independent variable');
                }
                function s(e, t) {
                  var n = h(t);
                  return p(n, 'independentVar', e), l === e ? b(n) : n;
                }
                function a() {
                  var e = h(r() + '= notation'),
                    t = h('f(' + l + ') notation');
                  return (
                    p(e, 'notation', 'dependentVariable'),
                    p(t, 'notation', 'function'),
                    'function' === i.editor.notation ? (t = b(t)) : (e = b(e)),
                    [d(), e, t, d()]
                  );
                }
                var c,
                  l = i.editor.independentVar;
                (c = a().concat([
                  s('x', 'y = f(x)'),
                  s('y', 'x = f(y)'),
                  s('θ', 'r = f(θ)'),
                  s('r', 'θ = f(r)'),
                  s('t', i.editor.gobj.functionExpr.dependentVar + ' = f(t)'),
                ])),
                  e(P, c),
                  n(),
                  t('a', P).on('click', function(e) {
                    var n,
                      r = t(this),
                      s = r.data('independentVar');
                    s
                      ? i.editor.setIndependentVar(s)
                      : ((n = r.data('notation')),
                        n && (i.editor.notation = n)),
                      i.editor.generateEquationOptions();
                  });
              }),
              k
                .append(P)
                .append(C)
                .append(S),
              this.numpadEl.append(r).append(k),
              t('.dropdown-toggle', this.numpadEl).dropdown(),
              w
            );
          }),
          (p.prototype.getConfigKey = function() {
            return 'NumberpadManager.options.keyOrderCalculator';
          }),
          (p.prototype.focus = function() {
            this.editor.editorEl.find('.mq-textarea *').focus();
          }),
          (p.prototype.cssClass = 'wsp-Calculator'),
          (m.prototype = {
            createAndInitNumpad: function(e) {
              (this.numpad = this.createNumpad()),
                this.numpad.init(this.editedEl, this.numpadParent, !0, e),
                this.numpad.numpadEl.css('z-index', 2);
            },
            isModalController: !1,
            createNumpad: function() {
              return new d();
            },
            vFocus: function(t) {
              var n = this;
              a(),
                e.setTimeout(function() {
                  (n.hasVFocus = !0),
                    n.numpad ? n.numpad.show() : n.createAndInitNumpad(t),
                    n.numpad.editor.prepare(),
                    n.numpad.focus(),
                    n.futureDidCloseCallback &&
                      ((n.numpad.editor.calculatorDidClose =
                        n.futureDidCloseCallback),
                      (n.futureDidCloseCallback = null));
                }, 0);
            },
            vBlur: function() {
              var e = this;
              this.hasVFocus &&
                (this.numpad.editor.unsetCursor(),
                (this.hasVFocus = !1),
                this.numpad.editor.finishEditing(),
                setTimeout(function() {
                  e.editedEl.focus(), e.numpad.hide();
                }, 100));
            },
            click: function(e, t) {
              this.hasVFocus
                ? this.numpad.editor.positionCursorByOffset(e.pageX)
                : this.vFocus(t);
            },
            paste: function(e) {
              var t = e.getData('text/plain');
              this.numpad.editor.paste(t);
            },
            setListener: function(e) {
              this.numpad && this.numpad.editor
                ? (this.numpad.editor.calculatorDidClose = e)
                : (this.futureDidCloseCallback = e);
            },
            clearListener: function() {
              this.numpad &&
                this.numpad.editor &&
                (this.numpad.editor.calculatorDidClose = null),
                (this.futureDidCloseCallback = null);
            },
          }),
          (g.prototype = Object.create(m.prototype)),
          (g.prototype.createNumpad = function() {
            return new p();
          }),
          (g.prototype.isModalController = !0),
          b()
        );
      })(jQuery)),
      (o.EventEmitter = (function() {
        var e = {
            events: [
              'StartCurrentPage',
              'StopCurrentPage',
              'LoadDocument',
              'UnloadDocument',
              'DownloadDocument',
              'WillChangeCurrentPage',
              'DidChangeCurrentPage',
              'LoadPage',
              'UnloadPage',
              'WillUndoRedo',
              'UndoRedo',
              'WillPlayTool',
              'ToolPlayBegan',
              'ToolPlayed',
              'ToolAborted',
              'StartSketchFrame',
              'EndSketchFrame',
              'StartDrag',
              'StartDragConfirmed',
              'MoveDrag',
              'EndDrag',
              'EndLabelDrag',
              'MergeGobjs',
              'StartAnimate',
              'EndAnimate',
              'StartMove',
              'EndMove',
              'StartSequence',
              'EndSequence',
              'StartCase',
              'EndCase',
              'Tap',
              'StartScroll',
              'MoveScroll',
              'EndScroll',
              'PressButton',
              'EditExpression',
              'ClearTraces',
              'StyleWidget',
              'TraceWidget',
              'LabelWidget',
              'VisibilityWidget',
              'DeleteWidget',
              'PrefChanged',
            ],
            trigger: function(e, n, i) {
              var r,
                s = e + '.WSP';
              if (this.events.indexOf(e) < 0)
                throw o.createError('Unregistered event triggered: ' + e);
              (i.timeStamp = new Date().toISOString()),
                t(this.canvasNode).trigger(s, [n, i]);
              try {
                (r = new CustomEvent(s, {
                  detail: { context: n, attributes: i },
                })),
                  this.canvasNode[0].dispatchEvent(r);
              } catch (e) {}
            },
            getAvailableEvents: function() {
              var e = this.events;
              return e.map(function(e) {
                return e + '.WSP';
              });
            },
          },
          n = function(t) {
            var n = Object.create(e);
            return (n.canvasNode = t), n;
          };
        return n;
      })()),
      (o.createError = function(e, t) {
        var n = new Error(e);
        return (n.code = t), n;
      }),
      (o.signalCaughtError = function(e) {
        return o.signal({
          message: e.message,
          error: e,
          stack: e.stack,
          logType: 'error',
          code: e.code || 'GSP.Error.uncodedError',
        });
      }),
      (o.signalErrorWithCode = function(e, t) {
        var n = [e].concat(t),
          i = o.Strings.loc.apply(o.Strings, n),
          r = o.createError(i, e);
        this.signalCaughtError(r);
      }),
      (o.signalErrorWithMessage = function(e, t) {
        var n = o.createError(e, t);
        this.signalCaughtError(n);
      }),
      (o.Prefs = (function() {
        var e = {
          units: { length: 'cm', angle: 'deg' },
          precision: { length: 2, angle: 2, scalar: 2 },
          fadeTraces: !1,
          fadeHalfLife: 5,
          fadeSaturationFloor: 0.0625,
          colorableComponents: {
            Points: { color: 'red' },
            Straights: { color: 'navy' },
            Curves: { color: 'green' },
            Interior: { color: 'rgb(138,102,217)' },
            Plot: { color: 'purple' },
            PointLocus: { color: 'maroon' },
            Selection: { color: 'rgb(195,0,195)' },
            Background: { color: 'white' },
            CoordSys: { color: 'silver' },
            TextGObject_BackgroundContrast: { color: 'black' },
            ActionButton: { color: 'rgb(255,165,0)' },
            LabelText_BackgroundContrast: { color: 'black' },
            Axis: { color: 'rgb(96,96,96)' },
            AngleMarker: { color: 'rgb(64,64,64)' },
            Picture: { color: 'red' },
          },
          text: {
            mathItalicization: !0,
            textTypes: {
              Label: {
                'font-family': 'Times',
                'font-size': 24,
                'font-weight': 'bold',
                'font-style': 'normal',
                'text-decoration': 'none',
                'letter-spacing': 'none',
                color: 'black',
              },
              Caption: {
                'font-family': 'Times',
                'font-size': 16,
                'font-weight': 'normal',
                'font-style': 'normal',
                'text-decoration': 'none',
                'letter-spacing': 'none',
                color: 'black',
                padding: '2px 4px',
              },
              Measurement: {
                'font-family': 'Times',
                'font-size': 18,
                'font-weight': 'normal',
                'font-style': 'normal',
                'text-decoration': 'none',
                'letter-spacing': 'none',
                color: 'black',
              },
              Action: {
                label: {
                  'font-family': 'Arial',
                  'font-size': 16,
                  'font-weight': 'normal',
                  'font-style': 'normal',
                  'text-decoration': 'none',
                  'letter-spacing': 'none',
                  color: 'black',
                },
              },
              Table: {
                'font-family': 'Arial',
                'font-size': 14,
                'font-weight': 'normal',
                'font-style': 'normal',
                'text-decoration': 'none',
                'letter-spacing': 'none',
                color: 'black',
              },
              AxisTicksAndOptionalLabel: {
                'font-family': 'Geneva',
                'font-size': 14,
                'font-weight': 'normal',
                'font-style': 'normal',
                'text-decoration': 'none',
                'letter-spacing': 'none',
                color: 'black',
                label: {
                  'font-family': 'Geneva',
                  'font-size': 14,
                  'font-weight': 'normal',
                  'font-style': 'normal',
                  'text-decoration': 'none',
                  'letter-spacing': 'none',
                  color: 'black',
                },
              },
            },
          },
        };
        return e;
      })()),
      (o.SketchEvent = function(e, n) {
        return this instanceof o.SketchEvent
          ? ((this.type = e),
            n && t.extend(this, n),
            void (this.timeStamp = this.timeStamp || t.now()))
          : new o.SketchEvent(e, n);
      }),
      (o.SketchEventHandler = (function() {
        function e(e, t) {
          var n, i;
          for (i = 0; i < t.length; i++)
            (n = t[i]), e[n] || (e[n] = {}), (e = e[n]);
          return e;
        }
        function i(e, t) {
          var i, r;
          for (r = 0; r < t.length && ((i = t[r]), (e = e[i]), e !== n); r++);
          return e;
        }
        function r(e) {
          var n;
          return t.isArray(e) ? ((n = e.slice()), n.sort()) : (n = [e]), n;
        }
        function s(e) {
          (this.sketchEventPreprocessor = e),
            (this.targetsIDMap = {}),
            (this.triggers = {}),
            (this.emitters = {}),
            (this.handlers = {}),
            (this.sketchEventList = {}),
            (this.frameIndex = 0);
        }
        var a = function() {},
          c = 1,
          l = 1;
        return (
          t.extend(a, {
            emitterIDFromTargetList: function(t, i) {
              var r = e(this.targetsIDMap, [i]),
                s = e(r, t);
              return s.result === n && (s.result = l++), s.result;
            },
            addHandler: function(t, n, i) {
              var s,
                o,
                a = r(t),
                l = this.emitterIDFromTargetList(a, n);
              for (
                i.wspguid || (i.wspguid = c++),
                  s = e(this.handlers, [i.wspguid]),
                  s.refCount
                    ? s.refCount++
                    : ((s.refCount = 1), (s.handler = i)),
                  this.emitters[l] ||
                    (this.emitters[l] = { type: n, targets: a, handlerID: [] }),
                  this.emitters[l].handlerID.push(i.wspguid),
                  o = 0;
                o < a.length;
                o++
              )
                e(this.triggers, [a[o], n])[l] = !0;
            },
            removeHandler: function(e, t, n) {
              function i(e) {
                var t, n;
                if (
                  (1 === l.handlers[e].refCount
                    ? delete l.handlers[e]
                    : l.handlers[e].refCount--,
                  c.handlerID.splice(c.handlerID.lastIndexOf(e), 1),
                  0 === c.handlerID.length)
                ) {
                  for (t in l.triggers)
                    for (n in l.triggers[t]) delete l.triggers[t][n][a];
                  delete l.emitters[a], delete l.sketchEventList[a];
                }
              }
              function s(e) {
                var t,
                  n = e.slice();
                for (t = 0; t < n.length; t++) i(n[t]);
              }
              var a = this.emitterIDFromTargetList(r(e), t),
                c = this.emitters[a],
                l = this;
              return c
                ? void (n ? i(n.wspguid) : s(c.handlerID))
                : void o.signalErrorWithMessage(
                    'removeHandler called on unknown target ' + e
                  );
            },
            raiseSketchEvent: function(t, n) {
              var r,
                s = i(this.triggers, [t, n]);
              if (s) for (r in s) e(this.sketchEventList, [r, n])[t] = !0;
            },
            processOneSketchEvent: function(e) {
              var t,
                n,
                r,
                s,
                a,
                c = {};
              for (
                t = this.emitters[e], n = this.handlers[t.handlerID], s = 0;
                s < t.targets.length;
                s++
              )
                (a = t.targets[s]),
                  (c[a] = i(this.sketchEventList, [e, t.type, a]) ? !0 : !1);
              for (
                r = new o.SketchEvent(t.type, { targetMap: c }),
                  this.sketchEventPreprocessor &&
                    this.sketchEventPreprocessor(r),
                  s = 0;
                s < t.handlerID.length;
                s++
              )
                (n = this.handlers[t.handlerID[s]].handler)(r);
            },
            processSketchEvents: function() {
              var e;
              for (e in this.sketchEventList) this.processOneSketchEvent(e);
              (this.sketchEventList = {}), this.frameIndex++;
            },
            getFrameIndex: function() {
              return this.frameIndex;
            },
            hasSketchEvents: function() {
              return !t.isEmptyObject(this.sketchEventList);
            },
          }),
          (s.prototype = a),
          s
        );
      })()),
      (function(t) {
        var n = (function() {
            function t(t, n) {
              var i = new Date().getTime(),
                s = Math.max(0, 16 - (i - r)),
                o = e.setTimeout(function() {
                  t(i + s);
                }, s);
              return (r = i + s), o;
            }
            function n(e) {
              clearTimeout(e);
            }
            var i = /iP(ad|hone|od).*OS 6/.test(e.navigator.userAgent),
              r = 0,
              s = e.requestAnimationFrame || null,
              o = e.cancelAnimationFrame || null,
              a = {};
            return (
              ['webkit', 'moz'].forEach(function(t) {
                (s = s || e[t + 'RequestAnimationFrame'] || null),
                  (o =
                    o ||
                    e[t + 'CancelAnimationFrame'] ||
                    e[t + 'CancelRequestAnimationFrame'] ||
                    null);
              }),
              (a.nextFrame = i || null == s ? t : s),
              (a.cancelFrame = i || null == o ? n : o),
              a
            );
          })(),
          i = n.nextFrame,
          r = n.cancelFrame,
          s = {
            _preprocessJobs: null,
            _modelJobs: null,
            _renderJobs: null,
            _tick: function() {
              function e(e) {
                if (e.scheduledFireTime <= o) {
                  try {
                    e.callback() === !1 && (e.isActive = !1);
                  } catch (n) {
                    (n.message = 'Error executing job: ' + n.message),
                      (e.isActive = !1),
                      t.signalCaughtError(n);
                  }
                  e.repeat
                    ? (e.scheduledFireTime = o + e.delay)
                    : (e.isActive = !1),
                    !e.isActive && e.doneCallback && e.doneCallback('finished');
                }
              }
              function n(e) {
                return e.isActive;
              }
              var i,
                r,
                s,
                o = new Date().getTime();
              (i = this._preprocessJobs.slice()),
                i.forEach(e),
                (o = new Date().getTime()),
                (r = this._modelJobs.slice()),
                r.forEach(e),
                (o = new Date().getTime()),
                (s = this._renderJobs.slice()),
                s.forEach(e),
                (this._preprocessJobs = this._preprocessJobs.filter(n)),
                (this._modelJobs = this._modelJobs.filter(n)),
                (this._renderJobs = this._renderJobs.filter(n)),
                this._preprocessJobs.length +
                  this._modelJobs.length +
                  this._renderJobs >
                  0 && this._requestAnimFrameIfNeeded();
            },
            _animFrameHandle: null,
            _requestAnimFrameIfNeeded: function() {
              var e = this;
              null === this._animFrameHandle &&
                (this._animFrameHandle = i(function() {
                  (e._animFrameHandle = null), e._tick();
                }));
            },
            addJob: function(e, t) {
              t = t || {};
              var n,
                i = t.delay || 0;
              n = i > 0 ? new Date().getTime() + i : 0;
              var r = {
                callback: e,
                delay: i,
                scheduledFireTime: n,
                repeat: t.repeat,
                doneCallback: t.done,
                queue: t.priority || 'model',
                isActive: !0,
              };
              return (
                'preprocess' === r.queue
                  ? this._preprocessJobs.push(r)
                  : 'render' === r.queue
                  ? this._renderJobs.push(r)
                  : this._modelJobs.push(r),
                this._requestAnimFrameIfNeeded(),
                r
              );
            },
            clearJob: function(e) {
              var n;
              n =
                'preprocess' === e.queue
                  ? this._preprocessJobs
                  : 'render' === e.queue
                  ? this._renderJobs
                  : this._modelJobs;
              var i = n.indexOf(e);
              if (-1 === i)
                throw t.createError(
                  'Job Scheduler.clearJob() called on a unscheduled job'
                );
              n.splice(i, 1),
                (e.isActive = !1),
                e.doneCallback && e.doneCallback('cancelled'),
                this._preprocessJobs.length +
                  this._renderJobs.length +
                  this._modelJobs.length ===
                  0 &&
                  (r(this._animFrameHandle), (this._animFrameHandle = null));
            },
            clearAllJobs: function() {
              function e(e) {
                (e.isActive = !1),
                  e.doneCallback && e.doneCallback('cancelled');
              }
              this._preprocessJobs.forEach(e),
                this._modelJobs.forEach(e),
                this._renderJobs.forEach(e),
                (this._preprocessJobs = []),
                (this._modelJobs = []),
                (this._renderJobs = []),
                null !== this._animFrameHandle &&
                  (r(this._animFrameHandle), (this._animFrameHandle = null));
            },
          };
        t.JobScheduler = {
          create: function() {
            var e = Object.create(s);
            return (
              (e._preprocessJobs = []),
              (e._modelJobs = []),
              (e._renderJobs = []),
              e
            );
          },
          isActive: function(e) {
            return !(!e || !e.isActive);
          },
        };
      })(o),
      (function(e) {
        e.ObjectGraph = {
          convertObjectSpec: function(i, r, s) {
            var o = [],
              a = {},
              c = s || 0,
              l = {};
            return (
              t.extend(a, r),
              e.eachKeyValue(i, function r(s, u) {
                if (!a[s]) {
                  if (((l[s] = !0), u.parents)) {
                    var d = {};
                    t.each(u.parents, function(t, s) {
                      var o = a[s];
                      if (!o) {
                        if (l[s])
                          throw e.createError(
                            'Circular reference in object graph'
                          );
                        if (!i[s])
                          throw e.createError(
                            'Unknown parent id encountered building object graph: ' +
                              s
                          );
                        r(s, i[s]), (o = a[s]);
                      }
                      o.children === n && (o.children = []),
                        o.children.push(u),
                        (d[t] = o);
                    }),
                      (u.parents = d);
                  }
                  (u.id = s),
                    (u.topologicalIndex = c++),
                    o.push(u),
                    (a[s] = u),
                    (l[s] = !1);
                }
              }),
              o
            );
          },
          subgraphFromNode: function(e, n) {
            function i(e) {
              (s[e.id] = e),
                e.children &&
                  e.children.forEach(function(e) {
                    s[e.id] || i(e);
                  });
            }
            function r(e) {
              if (o[e.id]) return !0;
              if (a[e.id]) return !1;
              var n = !!s[e.id];
              return (
                n &&
                  e.parents &&
                  t.each(e.parents, function(e, t) {
                    return r(t) ? void 0 : ((n = !1), !1);
                  }),
                n ? ((o[e.id] = e), c.push(e), !0) : ((a[e.id] = e), !1)
              );
            }
            var s = {},
              o = n ? t.extend({}, n) : {},
              a = {},
              c = [e];
            return (
              (o[e.id] = e),
              t.extend(s, o),
              i(e),
              t.each(s, function(e, t) {
                r(t);
              }),
              c
            );
          },
          getNextFreeIdNumber: function(e) {
            var t = 0,
              n = !1;
            return (
              e.forEach(function(e) {
                var i = parseInt(e.id, 10);
                return isNaN(i) ? ((n = !0), !1) : void (i > t && (t = i));
              }),
              n ? void 0 : t + 1
            );
          },
          normalizeTopologicalIndices: function(e, t) {
            function n(e) {
              var t;
              e.children &&
                ((t = e.topologicalIndex),
                e.children.forEach(function(e) {
                  e.topologicalIndex <= t &&
                    ((e.topologicalIndex = t + 1), n(e), (i = !0));
                }));
            }
            var i = !1;
            n(t),
              i &&
                e.sort(function(e, t) {
                  return (
                    Number(e.topologicalIndex) - Number(t.topologicalIndex)
                  );
                });
          },
          setParents: function(e, i, r) {
            var s;
            (i.parents = {}),
              r === n ||
                t.isEmptyObject(r) ||
                (t.each(r, function(e, t) {
                  (i.parents[e] = t),
                    t.children === n && (t.children = []),
                    -1 === t.children.indexOf(i) && t.children.push(i);
                  var r = t.topologicalIndex;
                  (s === n || r > s) && (s = r);
                }),
                i.topologicalIndex <= s && (i.topologicalIndex = s + 1),
                this.normalizeTopologicalIndices(e, i));
          },
          createSpecFromGraph: function(e) {
            var i = {};
            return (
              e.forEach(function(e) {
                var r = t.extend({}, e);
                if (
                  ((i[r.id] = r),
                  (r.id = n),
                  (r.topologicalIndex = n),
                  (r.children = n),
                  r.parents)
                ) {
                  var s = {};
                  t.each(r.parents, function(e, t) {
                    s[e] = t.id;
                  }),
                    (r.parents = s);
                }
              }),
              i
            );
          },
          copy: function(e) {
            return this.convertObjectSpec(this.createSpecFromGraph(e));
          },
          mergeToNode: function(e, n, i) {
            var r,
              s,
              o = i.parents;
            if (o)
              for (var a in o)
                o.hasOwnProperty(a) &&
                  ((r = o[a]),
                  (s = r.children.indexOf(i)),
                  s >= 0 && r.children.splice(s, 1));
            n.children || (n.children = []),
              i.children &&
                i.children.forEach(function(e) {
                  n.sQuery.sketch.gobjList.gobjects[e.id] &&
                    (n.children.push(e),
                    t.each(e.parents, function(t, r) {
                      r === i && (e.parents[t] = n);
                    })),
                    t.each(e.parentsList, function(t, r) {
                      r === i && (e.parentsList[t] = n);
                    });
                });
            var c,
              l,
              u,
              d = e.length;
            for (c = 0; d > c; ++c)
              e[c] === i && (l = c), e[c] === n && (u = c);
            e.splice(l, 1), this.normalizeTopologicalIndices(e, n);
          },
          deleteNode: function(t, i) {
            function r(e) {
              return l[e.id] !== n;
            }
            function s(e) {
              l[e.id] = e;
            }
            function o(e) {
              var n,
                i,
                s = e.parents,
                o = t.indexOf(e);
              if (s)
                for (var a in s)
                  s.hasOwnProperty(a) &&
                    ((n = s[a]),
                    r(n) ||
                      ((i = n.children.indexOf(e)), n.children.splice(i, 1)));
              -1 !== o && t.splice(o, 1);
            }
            function a(e) {
              s(e),
                e.children &&
                  e.children.forEach(function(e) {
                    r(e) || a(e);
                  });
            }
            var c,
              l = {};
            if (-1 === t.indexOf(i))
              throw e.createError(
                'ObjectGraph.deleteNode() called on node not in graph'
              );
            a(i);
            for (var u in l) l.hasOwnProperty(u) && ((c = l[u]), o(c));
            return Object.keys(l);
          },
        };
      })(o),
      (o.GObjList = (function() {
        function e(e) {
          (this.gobjects = {}),
            e
              ? this.addGObjects(e)
              : (this.constraintList = o.ObjectGraph.convertObjectSpec({}));
        }
        var i = function() {};
        return (
          t.extend(i, {
            createCanonicalParentReferences: function(e) {
              function i(t) {
                var i,
                  r = [];
                for (
                  t.sort(function(t, i) {
                    var r,
                      s,
                      a = o.BapEdgeInfo[e.constraint];
                    return (
                      a && a[t.name] && (r = a[t.name].sortIndex),
                      a && a[i.name] && (s = a[i.name].sortIndex),
                      n === r &&
                        n === s &&
                        ((r = parseInt(t.name, 10)),
                        (s = parseInt(i.name, 10))),
                      n === r && n === s
                        ? t.name < i.name
                          ? -1
                          : t.name > i.name
                          ? 1
                          : 0
                        : n === r
                        ? 1
                        : n === s
                        ? -1
                        : r - s
                    );
                  }),
                    i = 0;
                  i < t.length;
                  i++
                )
                  r.push(t[i].gobj);
                return r;
              }
              var r = [];
              return e.parents
                ? (t.each(e.parents, function(e, t) {
                    r.push({ name: e, gobj: t });
                  }),
                  i(r))
                : [];
            },
            mergeToGObj: function(e, t, n) {
              var i = t.sQuery.sketch,
                r = this;
              i.gobjList.gobjects[e.id] &&
                (delete this.gobjects[e.id],
                e.parentsList &&
                  e.parentsList.forEach(function(t) {
                    var n = t.children.indexOf(e);
                    n >= 0 && t.children.splice(n, 1);
                  }),
                o.ObjectGraph.mergeToNode(this.constraintList, t, e),
                t.children &&
                  t.children.forEach(function(e) {
                    e.parentsList = r.createCanonicalParentReferences(e);
                  }),
                t.label ||
                  ((t.label = e.label),
                  (t.style.label.showLabel = e.style.label.showLabel)),
                !t.style.hidden ||
                  e.style.hidden ||
                  (e.toolRole && 'givenParent' === e.toolRole) ||
                  (t.style = e.style),
                e.destroy && e.destroy(),
                i.renderCleanupGObj(e),
                (n && n.skipDescendantUpdate) ||
                  (t.descendantGraphHasChanged(),
                  t.descendantLabelGraphHasChanged()),
                (this.renderList = o.createRenderList(this.constraintList)));
            },
            mergeGObjsInList: function(e, t) {
              var n = this.gobjects;
              n[e] && ((n[t] = n[e]), (n[t].id = t), delete n[e]);
            },
            addGObjects: function(e, t, n) {
              function i(e) {
                e.toDelete = !0;
                for (var t = 0; t < e.children.length; ++t)
                  e.children[t].toDelete = !0;
              }
              var r = this,
                s = 0;
              this.constraintList.length > 0 &&
                (s =
                  this.constraintList[this.constraintList.length - 1]
                    .topologicalIndex + 1);
              var a,
                c,
                l = o.ObjectGraph.convertObjectSpec(e, this.gobjects, s);
              for (
                this.constraintList = this.constraintList || [],
                  this.renderList = this.renderList || [],
                  c = 0;
                c < l.length;
                ++c
              ) {
                a = l[c];
                try {
                  a.state.supported && !a.toDelete
                    ? ((r.gobjects[a.id] = a),
                      this.constraintList.push(a),
                      n && (a.state.renderState = 'speculative'),
                      (a.parentsList = r.createCanonicalParentReferences(a)),
                      a.doPostReadFromSpec(),
                      a.init(),
                      t && (o.addToRenderList(this.renderList, a), t(a)))
                    : i(a);
                } catch (e) {
                  (e.message =
                    'Initializing "' +
                    (a ? a.id : 'Unknown GObject') +
                    '": ' +
                    e.message),
                    o.signalCaughtError(e),
                    (a.toDelete = !0);
                }
              }
              for (
                t ||
                  (this.renderList = o.createRenderList(this.constraintList)),
                  c = l.length - 1;
                c >= 0;
                --c
              )
                (a = l[c]), a.toDelete && o.ObjectGraph.deleteNode(l, a);
            },
            compileDescendants: function(e) {
              function t(e) {
                n[e.id] &&
                  alert(
                    'addGobj in compileDescendants called for an already-listed gobj!'
                  ),
                  (n[e.id] = e),
                  e.children.forEach(function(e) {
                    n[e.id] || t(e);
                  });
              }
              var n = {};
              return t(e), n;
            },
            removeGObjAndDescendants: function(e) {
              var t = this.compileDescendants(e);
              this.removeGObjects(t, e.sQuery.sketch);
            },
            removeGObjects: function(e, t) {
              var n = this,
                i = Object.keys(e),
                r = [];
              i.forEach(function(e) {
                var t,
                  i = n.gobjects[e];
                -1 === r.indexOf(e) &&
                  i &&
                  ((t = o.ObjectGraph.deleteNode(n.constraintList, i)),
                  (r = r.concat(t)));
              }),
                r.forEach(function(e) {
                  var i = n.gobjects[e];
                  i &&
                    (t.invalidateAppearance(i),
                    i.destroy && i.destroy(),
                    t.renderCleanupGObj(i)),
                    delete n.gobjects[e];
                }),
                (this.renderList = o.createRenderList(this.constraintList));
            },
          }),
          (e.prototype = i),
          e
        );
      })()),
      (o.SQuery = (function(e) {
        function t(t, n, i) {
          var r = this.getSketch(),
            s = r.getPageId(),
            o = t.split(' ');
          this.each(function(t, a) {
            e.each(o, function(e, t) {
              i.call(r.document, s, a.id, t, n);
            });
          });
        }
        function i(t, n, i) {
          var r = this.getSketch(),
            s = r.getPageId(),
            o = t.split(' '),
            a = [];
          this.each(function(e, t) {
            a.push(t.id);
          }),
            e.each(o, function(e, t) {
              i.call(r.document, s, a, t, n);
            });
        }
        function r(e, t, n) {
          var i;
          for (i in t) t.hasOwnProperty(i) && (n[i] = t[i]);
        }
        function s(e, t, n, i) {
          var r, s;
          for (r in n)
            n.hasOwnProperty(r) &&
              ((s = f.findDottedProperty(n[r], e)),
              'undefined' == typeof s &&
                (s = f.findDottedProperty(n[r], 'style.' + e)),
              t === s && (i[r] = n[r]));
        }
        function a(e, t, n) {
          n[e.name] = t[e.name];
        }
        function c(e, t, n) {
          var i,
            r = new RegExp('\\b' + e.name + '\\b');
          for (i in t)
            t.hasOwnProperty(i) &&
              t[i].class &&
              r.test(t[i].class) &&
              (n[i] = t[i]);
        }
        function l(e, t, n) {
          s('kind', e.name, t, n);
        }
        function u(e, t, n) {
          var i = e.name,
            r = e.value;
          s(i, r, t, n), s('style.' + i, r, t, n);
        }
        function d(e, t, n) {
          var i,
            r,
            s,
            o = e.parts,
            a = t;
          for (r = 0; r < o.length; r += 1)
            (i = m[o[r].type]),
              (s = r === o.length - 1 ? n : {}),
              i(o[r], a, s),
              (a = s);
        }
        function h(e, t, n) {
          var i, s;
          for (i = 0; i < e.length; i += 1)
            (s = e[i]),
              'global' === s.type
                ? r(s, t, n)
                : 'id' === s.type
                ? a(s, t, n)
                : 'class' === s.type
                ? c(s, t, n)
                : 'kind' === s.type
                ? l(s, t, n)
                : 'attr' === s.type
                ? u(s, t, n)
                : 'selectorAnd' === s.type
                ? d(s, t, n)
                : o.log('Unclassified squery selector: ' + s);
        }
        function p(t) {
          var i = function i(r) {
            if (!(this instanceof i)) return new i(r);
            var s,
              a,
              c = t.getFocusPage ? t.getFocusPage() : t,
              l = (c.gobjList && c.gobjList.gobjects) || {},
              u = {};
            if (((this.sketch = t), r !== n)) {
              (s = e.isArray(r)
                ? r
                : 'string' === e.type(r)
                ? o.sQueryParser.parse(r)
                : []),
                h(s, l, u);
              for (a in u) u.hasOwnProperty(a) && this.push(u[a]);
            }
          };
          return (i.sketch = t), (i.prototype = f), i;
        }
        var f = [];
        (f.getSketch = function() {
          return this.sketch;
        }),
          (f.findDottedProperty = function(e, t, n) {
            var i,
              r = t.split('.'),
              s = e;
            for (i = 0; i < r.length; i += 1) {
              if ('object' != typeof s) return;
              s = s[r[i]];
            }
            return 'undefined' == typeof n
              ? s
              : 'undefined' != typeof s
              ? n(s)
              : void 0;
          }),
          (f.each = function(e) {
            var t;
            for (t = 0; t < this.length; t += 1) e.call(this[t], t, this[t]);
            return this;
          }),
          (f.hide = function() {
            return (
              this.each(function(e, t) {
                t.hide();
              }),
              this
            );
          }),
          (f.show = function() {
            return (
              this.each(function(e, t) {
                t.show();
              }),
              this
            );
          }),
          (f.invalidateGeom = function(e) {
            this.getSketch().invalidateGeom(e);
          }),
          (f.showLabel = function() {
            var e = this.getSketch();
            return (
              this.each(function(t, n) {
                n.style || (n.style = {}),
                  n.style.label || (n.style.label = {}),
                  (n.style.label.showLabel = !0),
                  e.invalidateAppearance(n);
              }),
              this
            );
          }),
          (f.hideLabel = function() {
            var e = this.getSketch();
            return (
              this.each(function(t, n) {
                n.style || (n.style = {}),
                  n.style.label || (n.style.label = {}),
                  (n.style.label.showLabel = !1),
                  e.invalidateAppearance(n);
              }),
              this
            );
          }),
          (f.get = function(e) {
            var t = this.getSketch();
            return t.gobjList.gobjects[e];
          }),
          (f.dirty = function() {
            this.getSketch().isDirty = !0;
          }),
          (f.eraseTraces = function() {
            this.getSketch().clearTraces();
          }),
          (f.stopMotions = function() {}),
          (f.attr = function(t, i) {
            function r(t, n, i, r) {
              var s,
                o,
                a = i.split('.'),
                c = n;
              for (s = 0; s < a.length - 1; s += 1)
                (o = e.trim(a[s])), c[o] || (c[o] = {}), (c = c[o]);
              'function' === e.type(r)
                ? (c[e.trim(a[a.length - 1])] = r.call(n, s, n))
                : (c[e.trim(a[a.length - 1])] = r);
            }
            function s(t, n) {
              var i,
                r,
                s = n.split('.'),
                o = t;
              for (i = 0; i < s.length; i += 1) {
                if (((r = e.trim(s[i])), 'undefined' == typeof o[r])) return;
                o = o[r];
              }
              return o;
            }
            var o,
              a,
              c = this.getSketch(),
              l = '';
            if (
              (i !== n &&
                0 !== i.length &&
                this.each(function(e, o) {
                  var a;
                  this &&
                    ((a = s(this, t)),
                    a !== n
                      ? (r(e, o, t, i), c.invalidateGeom(o))
                      : this.style &&
                        ((a = s(this, 'style.' + t)),
                        a !== n &&
                          (r(e, o, 'style.' + t, i), c.invalidateGeom(o))));
                }),
              'object' === e.type(t))
            ) {
              o = t;
              for (a in o) o.hasOwnProperty(a) && (l = this.attr(a, o[a]));
            } else
              'string' === e.type(t) &&
                (this[0] && (l = s(this[0], t)),
                l === n && this[0].style && (l = s(this[0], 'style.' + t)));
            return l;
          }),
          (f.parents = function() {
            var e, t, n, i, r;
            for (
              i = this.getSketch(), r = new i.sQuery(), e = 0;
              e < this.length;
              e += 1
            )
              if (((n = this[e]), n.parents))
                for (t in n.parents)
                  n.parents.hasOwnProperty(t) && r.push(n.parents[t]);
            return r;
          }),
          (f.press = function(e) {
            var t = this.getSketch().document;
            return (
              this.each(function(i, r) {
                r.press &&
                  (n === e || e !== r.state.isActive) &&
                  (t.getFocusPage().constrain(),
                  r.press(t.getFocusPage()),
                  t.getFocusPage().constrainAndRedraw());
              }),
              this
            );
          }),
          (f.value = function(e) {
            var t = this.getSketch();
            return n === e
              ? this[0].uValue !== n
                ? this[0].uValue
                : this[0].value !== n
                ? this[0].value
                : this[0].geom && this[0].geom.loc
                ? this[0].geom.loc
                : n
              : (this.each(function(n, i) {
                  i.updateValue
                    ? i.updateValue(e)
                    : i.geom &&
                      i.geom.loc &&
                      jQuery.isPlainObject(e) &&
                      ((i.geom.loc.x = e.x),
                      (i.geom.loc.y = e.y),
                      t.invalidateGeom(i));
                }),
                this);
          }),
          (f.prefs = function() {
            return this.getSketch().preferences;
          }),
          (f.getResource = function(e, t) {
            var n = this.getSketch().document.resources[e];
            return n && n[t];
          }),
          (f.getSketchDelta = function() {
            var e = this.getSketch(),
              t = e.document.getPageDeltaObj(e.metadata.id);
            return JSONcanonical.stringify(t);
          }),
          (f.applySketchDelta = function(e) {
            var t,
              n = this.getSketch();
            (t = 'string' == typeof e ? JSON.parse(e) : e),
              n.document.applyDeltaToActivePage(t);
          }),
          (f.getSketchJSON = function() {
            return this.getSketch().document.getDocumentJSON();
          }),
          (f.toString = f.getSketchJSON),
          (f.on = function(e, n) {
            t.call(this, e, n, this.getSketch().document.bindGObjEvent);
          }),
          (f.off = function(e, n) {
            t.call(this, e, n, this.getSketch().document.unbindGObjEvent);
          }),
          (f.onGroup = function(e, t) {
            i.call(this, e, t, this.getSketch().document.bindGObjEvent);
          }),
          (f.offGroup = function(e, t) {
            i.call(this, e, t, this.getSketch().document.unbindGObjEvent);
          });
        var m = { attr: u, class: c, global: r, id: a, kind: l };
        return p;
      })(jQuery)),
      (o.PerfMonitor = (function(t) {
        var i,
          r,
          s,
          a,
          c = 1e3 / 60;
        return (
          (r = {
            clear: function() {
              this.data = {};
            },
            set: function(e, t) {
              this.data[e] = t;
            },
            get: function(e) {
              return this.data[e];
            },
            increment: function(e, t) {
              var n = t || 1;
              'number' != typeof this.data[e]
                ? (this.data[e] = n)
                : (this.data[e] += n);
            },
            log: function(e, t) {
              'undefined' == typeof this.logs[e] && (this.logs[e] = []),
                this.logs[e].push(t);
            },
          }),
          (i = function() {
            var e = Object.create(r);
            return (e.data = {}), (e.logs = {}), e;
          }),
          (a = function() {
            var e = Object.create(s);
            return (
              (e.stats = new i()),
              e.stats.set('Start', e.now()),
              (e.times = {
                idle: n,
                active: n,
                constrain: n,
                render: n,
                fade: n,
              }),
              e
            );
          }),
          (s = {
            now: function() {
              return e.performance && e.performance.now
                ? e.performance.now()
                : t.now();
            },
            getFrameCount: function() {
              return this.stats.get('Activation Count');
            },
            animFrameHandler: function() {
              var e = this.times.idle,
                t = this.times.active,
                i = this.now(),
                r = i - e,
                s = i - t,
                o = r,
                a = Math.max(0, r / c - 1);
              (this.times.last = e),
                (this.times.frame = s),
                (this.times.active = i),
                (this.times.constrain = this.times.render = this.times.fade = n),
                this.stats.increment('Activation Count'),
                this.stats.increment('Idle Accum', o),
                a > 0 &&
                  this.stats.increment('Activation Missed', Math.round(a));
            },
            constrainHandler: function() {
              (this.times.constrain = this.now()),
                this.stats.increment('Constrain Count'),
                this.stats.increment(
                  'Touch Accum',
                  this.times.constrain - this.times.active
                );
            },
            renderHandler: function() {
              (this.times.render = this.now()),
                this.stats.increment('Render Count'),
                this.stats.increment(
                  'Constrain Accum',
                  this.times.render - this.times.constrain
                );
            },
            fadeHandler: function() {
              (this.times.fade = this.now()),
                this.stats.increment('Fade Count'),
                'undefined' != typeof this.times.render &&
                  this.stats.increment(
                    'Render Accum',
                    this.times.fade - this.times.render
                  );
            },
            idleHandler: function() {
              var e = this.now(),
                t = e - this.times.active;
              this.stats.increment('Idle Count'),
                (this.times.idle = e),
                this.stats.increment('Active Accum', t),
                t > this.FRAME_INTERVAL && this.stats.increment('Late Frames'),
                'undefined' != typeof this.times.fade
                  ? this.stats.increment(
                      'Fade Accum',
                      this.times.idle - this.times.fade
                    )
                  : 'undefined' != typeof this.times.render &&
                    this.stats.increment(
                      'Render Accum',
                      this.times.idle - this.times.render
                    );
            },
            unknownStateHandler: function() {
              o.signalErrorWithMessage('PerfMonitor: unknown state');
            },
            stateChange: function(e) {
              var t = this[e + 'Handler'] || this.unknownStateHandler;
              t.call(this);
            },
            report: function(e, t, n) {
              function i(e, t) {
                return t ? e / t : 0;
              }
              var r = 'undefined' == typeof n ? !0 : n,
                s = o.stringify({
                  name: e,
                  phase: t,
                  frames: this.stats.get('Activation Count'),
                  frameTime: i(
                    this.now() - this.stats.get('Start'),
                    this.stats.get('Activation Count')
                  ),
                  active: i(
                    this.stats.get('Active Accum'),
                    this.stats.get('Activation Count')
                  ),
                  missedFrames: this.stats.get('Activation Missed'),
                  lateFrames: this.stats.get('Late Frames'),
                  idle: i(
                    this.stats.get('Idle Accum'),
                    this.stats.get('Idle Count')
                  ),
                  touch: i(
                    this.stats.get('Touch Accum'),
                    this.stats.get('Activation Count')
                  ),
                  constrainCt: this.stats.get('Constrain Count'),
                  constrain: i(
                    this.stats.get('Constrain Accum'),
                    this.stats.get('Constrain Count')
                  ),
                  renderCt: this.stats.get('Render Count'),
                  render: i(
                    this.stats.get('Render Accum'),
                    this.stats.get('Render Count')
                  ),
                  fadeCt: this.stats.get('Fade Count'),
                  fade: i(
                    this.stats.get('Fade Accum'),
                    this.stats.get('Fade Count')
                  ),
                });
              return (
                r && (this.stats.clear(), this.stats.set('Start', this.now())),
                s
              );
            },
          }),
          a
        );
      })(jQuery)),
      (o.speculativeOpacity = 0.5),
      (o.speculativeColor = '#888888'),
      (o.targetHighlightColor = 'red'),
      (o.targetHighlightPathBolding = 2),
      (o.targetFocusColor = 'red'),
      (o.targetFocusPathBolding = 2),
      (o.radiusExpansionOnFocus = 4),
      (o.diffPatch = jsondiffpatch.create({
        objectHash: function(e) {
          return e.id !== n ? e.id : JSONcanonical.stringify(e);
        },
        textDiff: { minLength: 8e4 },
      })),
      (o.getKindObj = function(e) {
        var t = o.gObjects[e],
          n = t && t.doc,
          i = n && n.supported,
          r = i || (n && o.gOptions.instantiateUnsupportedObjects);
        return r ? t : null;
      }),
      (o.getConstraintObj = function(e) {
        var t = o.gConstraints[e],
          n = t && t.doc,
          i = n && n.supported,
          r = i || (n && o.gOptions.instantiateUnsupportedObjects);
        return r ? t : null;
      }),
      (o.gobjIdMapFromArray = function(e) {
        var t = {};
        return (
          e.forEach(function(e) {
            t[e.id] = e;
          }),
          t
        );
      }),
      (o.getFontFamilyFromStyle = function(e, n) {
        var i,
          r,
          s = e['font-family'];
        return (
          'number' === t.type(s) &&
            ((r = n.getResource('fontList', s)),
            r || ((i = n.prefs().fontList), i && i[s] && (r = i[s])),
            r || (r = n.getResource('fontList', 0))),
          r || (r = s),
          r
        );
      }),
      (o.modifyRenderAttrsForLineStyle = function(e, t) {
        var n,
          i = t.width || 1;
        switch (e) {
          case 'dashed':
            (n = Math.round(8 * (1 + (i - 1) / 4))), (t.lineDash = [n, 6]);
            break;
          case 'dotted':
            t.lineDash = [i, Math.max(2, Math.round(1.2 * i))];
            break;
          default:
            t.lineDash = [];
        }
      }),
      (o.gobjPrototype = (function() {
        var e = {};
        return function(t, n) {
          var i = [t, n].join(':'),
            r = e[i];
          return (
            r ||
              ((r = o.makeClass(o.gObjects[t], o.gConstraints[n])), (e[i] = r)),
            r
          );
        };
      })()),
      (o.gobjFromSpec = function(e, t, n, i) {
        var r,
          s,
          a = e.kind,
          c = o.getKindObj(a),
          l = e.constraint,
          u = o.getConstraintObj(l),
          d = c && c.kindSupportsSpecObj(e, i),
          h = u && u.constraintSupportsSpecObj(e, i);
        return (
          d
            ? h ||
              (o.log(
                'GObject ' +
                  t +
                  ' has undefined constraint: "' +
                  e.constraint +
                  '"'
              ),
              c.doc.defaultConstraint
                ? (l = c.doc.defaultConstraint)
                : ((a = 'Unknown'), (l = 'Unknown')))
            : (o.log('GObject ' + t + ' has undefined kind: "' + e.kind + '"'),
              (a = 'Unknown'),
              (l = 'Unknown')),
          (s = o.gobjPrototype(a, l)),
          (r = o.makeInstance(s, e, { doc: !0 })),
          (r.id = t),
          (r.sQuery = n),
          (d && h) || (r.state.supported = !1),
          r
        );
      }),
      (o.gobjectsFromSpec = function(e, t) {
        var n,
          i,
          r,
          s = e,
          a = {};
        for (n in s)
          s.hasOwnProperty(n) &&
            ((i = s[n]),
            i
              ? ((r = o.gobjFromSpec(i, n, t, s)), (a[n] = r))
              : o.signalErrorWithMessage(
                  'Undefined gobject in sketch document: "' + n + '"'
                ));
        return a;
      }),
      (o.generateChecksum = function(e) {
        return b64_md5(JSONcanonical.stringify(e));
      }),
      (o.getSketchDiff = function(e, i) {
        function r(e) {
          return !0;
        }
        function s(e) {
          var i,
            s = t.extend(!0, {}, e),
            o = s.objects;
          for (var a in o)
            o.hasOwnProperty(a) &&
              ((i = o[a]), (i.debug = n), r(i) || (i.geom && (i.geom = n)));
          return s;
        }
        var a = {};
        return (
          (a.diff = o.diffPatch.diff(s(e), s(i))),
          (a.checksum = o.generateChecksum(e)),
          a
        );
      }),
      (o.applySketchDiff = function(e, t) {
        t.checksum !== o.generateChecksum(e) &&
          o.log('Applying sketch diff to the wrong source spec');
        try {
          o.diffPatch.patch(e, t.diff);
        } catch (e) {
          o.log('applySketchDiff() aborted: ' + e.message);
        }
      }),
      (o.getDocumentDiff = function(e, t) {
        var n = {};
        return (
          (n.checksum = o.generateChecksum(e)),
          (n.metadataDiff = o.diffPatch.diff(e.metadata, t.metadata)),
          (n.pageDiffs = []),
          e.pages &&
            e.pages.forEach(function(e, i) {
              var r = t.pages[i];
              n.pageDiffs[i] = o.getSketchDiff(e, r);
            }),
          n
        );
      }),
      (o.layerInfo = (function() {
        var e = {
            NeverVisible: { z_index: 0, engine: null, construction_sort: 1 },
            ExternalImagesAndInteriors: {
              z_index: 1,
              engine: 'standard',
              construction_sort: -1,
            },
            LineLoci: { z_index: 2, engine: 'standard', construction_sort: 1 },
            CoordinateSystem: {
              z_index: 3,
              engine: 'standard',
              construction_sort: 1,
            },
            Axes: { z_index: 4, engine: 'standard', construction_sort: 1 },
            LinesCurves: {
              z_index: 5,
              engine: 'standard',
              construction_sort: 1,
            },
            Rays: { z_index: 5.1, engine: 'standard', construction_sort: -1 },
            Segments: {
              z_index: 5.2,
              engine: 'standard',
              construction_sort: -1,
            },
            PathMarkers: {
              z_index: 6,
              engine: 'standard',
              construction_sort: 1,
            },
            Tables: { z_index: 7, engine: 'html', construction_sort: 1 },
            Text: { z_index: 8, engine: 'html', construction_sort: 1 },
            Buttons: { z_index: 9, engine: 'html', construction_sort: 1 },
            DiscretePointVectors: {
              z_index: 10,
              engine: 'canvasTop',
              construction_sort: 1,
            },
            Points: { z_index: 11, engine: 'canvasTop', construction_sort: 1 },
            PointsFree: {
              z_index: 11.1,
              engine: 'canvasTop',
              construction_sort: -1,
            },
            PointsSemiFree: {
              z_index: 11.2,
              engine: 'canvasTop',
              construction_sort: -1,
            },
          },
          t = {
            AngleMarker: e.LineLoci,
            Arc: e.LinesCurves,
            ArcInterior: e.ExternalImagesAndInteriors,
            Axis: e.Axes,
            Button: e.Buttons,
            Circle: e.LinesCurves,
            CircleInterior: e.ExternalImagesAndInteriors,
            CoordSys: e.CoordinateSystem,
            Expression: e.Text,
            Measure: e.Text,
            Param: e.Text,
            Picture: e.ExternalImagesAndInteriors,
            Point: e.Points,
            PointFree: e.PointsFree,
            PointSemiFree: e.PointsSemiFree,
            Polygon: e.ExternalImagesAndInteriors,
            Straight: e.LinesCurves,
            Segment: e.Segments,
            Ray: e.Rays,
            Text: e.Text,
            Table: e.Tables,
          };
        return function(i) {
          var r = i.kind;
          return i.getRenderingLayer
            ? e[i.getRenderingLayer()]
            : ('Point' === i.kind
                ? 'Free' === i.constraint
                  ? (r += i.constraint)
                  : i.value !== n && (r += 'SemiFree')
                : 'Straight' === i.kind &&
                  ('Segment' === i.genus || 'Ray' === i.genus) &&
                  (r = i.genus),
              t.hasOwnProperty(r)
                ? t[r]
                : { z_index: 6, engine: 'standard', construction_sort: 1 });
        };
      })()),
      (function() {
        function e(e) {
          var t = o.layerInfo(e).z_index;
          return n === t && (t = 0), t;
        }
        function r(t, i, r) {
          r[t.id] === n && (r[t.id] = { kindLayerCache: e(t) }),
            r[i.id] === n && (r[i.id] = { kindLayerCache: e(i) });
          var s;
          if (((s = r[t.id].kindLayerCache - r[i.id].kindLayerCache), 0 !== s))
            return s;
          if (
            t.style.layerOrder !== n &&
            i.style.layerOrder !== n &&
            ((s = t.style.layerOrder - i.style.layerOrder), 0 !== s)
          )
            return s;
          if (t.style.selectable !== i.style.selectable)
            return t.style.selectable ? 1 : -1;
          var a = r[t.id].constructionOrder,
            c = r[i.id].constructionOrder;
          return a !== n && c !== n ? a - c : o.layerInfo(i).construction_sort;
        }
        (o.createRenderList = function(t) {
          var n,
            i = t.slice(),
            s = {};
          for (n = 0; n < i.length; n++)
            s[i[n].id] = {
              constructionOrder: n * o.layerInfo(i[n]).construction_sort,
              kindLayerCache: e(i[n]),
            };
          return (
            i.sort(function(e, t) {
              return r(e, t, s);
            }),
            i
          );
        }),
          (o.positionInElement = function(e, t) {
            var n;
            return t && 0 !== t.length
              ? ((n = o.convertPointFromPage(
                  t,
                  e.pageX,
                  e.pageY,
                  e.mouseEvent
                )),
                n.x >= 0 &&
                  n.y >= 0 &&
                  n.x <= t.outerWidth() &&
                  n.y <= t.outerHeight())
              : !1;
          }),
          (o.blurDocumentActiveElement = function(e) {
            try {
              i.activeElement &&
                'body' !== i.activeElement.nodeName.toLowerCase() &&
                t(i.activeElement).blur();
            } catch (e) {}
            var n = o.getConfigValue(
              'NumberpadManager.delegates.blurAllNumberpads'
            );
            n(e);
          }),
          (o.addToRenderList = function(e, t) {
            for (var n, i, s = 0, o = e.length, a = s, c = {}; o > s; )
              (a = s + ((o - s) >> 1)),
                (n = r(e[a], t, c)),
                0 >= n ? (s = a + 1) : (o = a);
            (i = 0 >= n ? s : o), e.splice(i, 0, t);
          }),
          (o.AutoplacementMetrics = {
            Measurement: {
              sketchLeftMargin: 10,
              sketchTopMargin: 5,
              gObjTopMargin: 1,
              rightIsolation: 60,
              bottomIsolation: 20,
            },
            Button: {
              sketchLeftMargin: 10,
              sketchTopMargin: 5,
              gObjTopMargin: 3,
              rightIsolation: 50,
              bottomIsolation: 15,
            },
            Table: {
              sketchLeftMargin: 10,
              sketchTopMargin: 5,
              gObjTopMargin: 3,
              rightIsolation: 100,
              bottomIsolation: 120,
            },
          });
      })(),
      (o.Document = (function() {
        function i() {
          var e = Object.create(l);
          return (e.current = { delta: null, prev: null, next: null }), e;
        }
        function r(e) {
          function t(t) {
            return o.signal({
              code: 'GSP.Error.incompatibleSketchVersion',
              message: o.Strings.loc(
                'GSP.Error.incompatibleSketchVersion',
                o.version.number,
                s
              ),
              logType: t,
              sketchData: e,
            });
          }
          var n = Number(o.version.major),
            i = Number(o.version.minor),
            r = Number('4'),
            s = e && e['wsp-version'],
            a = s && s.split('.'),
            c = a && a.length > 0 ? Number(a[0]) : null,
            l = a && a.length > 1 ? Number(a[1]) : 0;
          if (c > n) return t('error');
          if (n > c) return t(r > c ? 'error' : 'warning');
          {
            if (n !== c)
              return o.signal({
                code: 'GSP.Error.invalidSketchVersion',
                message: o.Strings.loc(
                  'GSP.Error.invalidSketchVersion',
                  o.version.number,
                  s
                ),
                logType: 'error',
                sketchData: e,
              });
            if (l > i) return t('debug');
          }
        }
        function s(e, n) {
          return t.extend(
            !0,
            { sizeParentToContent: n, responsiveSizing: n },
            e
          );
        }
        var a,
          c = 1,
          l = {
            pushDelta: function(e) {
              (this.current.next = {
                delta: e,
                prev: this.current,
                next: null,
              }),
                (this.current = this.current.next);
            },
            replaceCurrentDelta: function(e) {
              this.current.delta = e;
            },
            undo: function(e) {
              if (
                ((this.current = this.current.prev || this.current),
                'all' === e)
              )
                for (; this.current.prev; ) this.current = this.current.prev;
            },
            redo: function() {
              this.current = this.current.next || this.current;
            },
            canUndo: function() {
              return null !== this.current.prev;
            },
            canRedo: function() {
              return null !== this.current.next;
            },
            getCurrentDelta: function() {
              return this.current.delta;
            },
          },
          u = {
            parse: function(e) {
              return 'string' == typeof e
                ? 'true' === e.toLowerCase()
                : 'boolean' == typeof e && e;
            },
          },
          d = {
            parse: function(e) {
              var t, n;
              if ('boolean' == typeof e) return e ? ['all'] : ['none'];
              if (Array.isArray(e)) return e;
              if ('string' != typeof e) return null;
              if ('all' === e.toLowerCase() || 'true' === e.toLowerCase())
                return ['all'];
              if ('none' === e.toLowerCase() || 'false' === e.toLowerCase())
                return ['none'];
              for (t = e.split(','), n = 0; n < t.length; n += 1)
                t[n] = parseInt(t[n], 10);
              return t;
            },
          },
          h = {
            parse: function(e) {
              switch ((e = e.toLowerCase())) {
                case 'classic':
                case 'new':
                case 'compact':
                  return e;
              }
              return 'Invalid toolLook pref.';
            },
          },
          p = {
            tool: { type: d, defaultValue: ['all'] },
            disablescrolling: { type: u, defaultValue: !1 },
            sequentialsnapping: { type: u, defaultValue: !0 },
            toolplaynewlook: { type: u, defaultValue: !1 },
            removeinaccessibleobjects: { type: u, defaultValue: !1 },
            pagecontrol: { type: u, defaultValue: !0 },
            enablelabeldragging: { type: u, defaultValue: !0 },
            enablelabelediting: { type: d, defaultValue: ['none'] },
            enabletracing: { type: d, defaultValue: ['all'] },
            stylewidget: { type: d, defaultValue: ['all'] },
            visibilitywidget: { type: d, defaultValue: ['all'] },
            labelwidget: { type: d, defaultValue: ['all'] },
            tracewidget: { type: d, defaultValue: ['all'] },
            deletewidget: { type: d, defaultValue: ['none'] },
            showwidgetpanelonpagestart: { type: u, defaultValue: !0 },
            uploadutil: { type: u, defaultValue: !1 },
            downloadutil: { type: u, defaultValue: !1 },
            resetbutton: { type: d, defaultValue: ['all'] },
            wsplogo: { type: u, defaultValue: !0 },
            animatetoolmatching: { type: u, defaultValue: !0 },
            toollook: { type: h, defaultValue: 'compact' },
            enabledragmerging: { type: u, defaultValue: !0 },
            undoredoinbuttonbar: { type: u, defaultValue: !1 },
          };
        a = {
          attachToNode: function(e) {
            var n,
              i = 'wsp-version-4-8-0',
              r = t(e),
              s = this,
              a = s.docSpec.metadata.width,
              c = s.docSpec.metadata.height,
              l = t(
                '<div class="wsp-base-node ' +
                  i +
                  '"><div class="wsp-transform-node"><div class="wsp-main-row wsp-clearfix-group"></div></div><div class="wsp-transform-large"></div><div class="wsp-transform-medium"></div><div class="wsp-transform-small"></div></div>'
              ),
              u = r.parent().find('.button_area'),
              d = {},
              h = this.focusPage.getAuthorPreference('undoRedoInButtonBar');
            r.empty().append(l),
              r.append(
                t(
                  '<div class="wsp-live-node wsp-sr-only" role="log" aria-live="polite"></div>'
                )
              ),
              (n = t('.wsp-main-row', l[0])),
              this.hasTools()
                ? (s.removeUndoRedo(u),
                  s.attachToolsToNode(n, a, c, !0),
                  (a += n.outerWidth()))
                : this.focusPage.getAuthorPreference('enableDragMerging') &&
                  h &&
                  u &&
                  u.length &&
                  s.attachUndoRedo(u),
              n.append(
                t(
                  '<div role="application" class="wsp-sketch-container" aria-label="Use arrow keys to move all objects in 4 directions."></div>'
                )
              ),
              t('.wsp-transform-large', l[0]).css({ width: a, height: c }),
              t('.wsp-transform-medium', l[0]).css({
                width: 0.75 * a,
                height: 0.75 * c,
              }),
              t('.wsp-transform-small', l[0]).css({
                width: 0.5 * a,
                height: 0.5 * c,
              }),
              this.docOptions.responsiveSizing === !0 &&
                (l.addClass('wsp-responsiveSizing'),
                a > 400
                  ? (l.addClass('wsp-responsiveSizing-medium-break'),
                    l.addClass('wsp-responsiveSizing-medium-size'),
                    l.addClass('wsp-responsiveSizing-small-break'),
                    l.addClass('wsp-responsiveSizing-small-size'))
                  : a > 300 &&
                    (l.addClass('wsp-responsiveSizing-medium-size'),
                    l.addClass('wsp-responsiveSizing-small-break'))),
              this.docOptions.sizeParentToContent &&
                'div' === r.prop('nodeName').toLowerCase() &&
                'block' === r.css('display') &&
                (d.display = 'inline-block'),
              r.css(d),
              (this.canvasNode = r),
              (this.eventEmitter = o.EventEmitter(this.canvasNode));
          },
          event: function(e, t, n) {
            (t = t || {}),
              (t.document = this),
              this.eventEmitter.trigger(e, t, n);
          },
          getFocusPage: function() {
            return this.focusPage;
          },
          getPageCount: function() {
            return this.docSpec.pages.length;
          },
          getCurrentPageSpec: function(e) {
            var n = t.extend(!0, {}, this.getOrigPageSpec(e)),
              i = this.getPageDeltaObj(e);
            return i && !t.isEmptyObject(n) && o.applySketchDiff(n, i), n;
          },
          getOrigPageSpec: function(e) {
            return (
              n === e &&
                ((e = this.docSpec.metadata['start-page']),
                (n === e || null === this.getIndexForPageId(e)) &&
                  (e = this.docSpec.pages[0].metadata.id)),
              this.pageData[e] === n
                ? (o.signalErrorWithCode('GSP.Error.invalidSwitchPage'), null)
                : this.pageData[e].spec
            );
          },
          getPageIdAtIndex: function(e) {
            if (0 > e || e >= this.docSpec.pages.length) return null;
            var t = this.docSpec.pages[e],
              n =
                t && t.metadata && null !== t.metadata.id
                  ? t.metadata.id
                  : String(e + 1);
            return n;
          },
          getIndexForPageId: function(e) {
            if (this.docSpec.pages) {
              var t, n, i;
              for (n = 0; n < this.docSpec.pages.length; n++)
                if (
                  ((t = this.docSpec.pages[n]),
                  (i =
                    t && t.metadata && null != t.metadata.id
                      ? t.metadata.id
                      : String(n + 1)),
                  i === e)
                )
                  return n;
            }
            return null;
          },
          createSketchEventHandlersForPage: function(e) {
            var t = e.getPageId(),
              i = this;
            this.gobjectEventHandlers[t] = new o.SketchEventHandler(function(
              e
            ) {
              function r(e) {
                var t,
                  i,
                  r = 0;
                for (t in e)
                  if (e.hasOwnProperty(t)) {
                    if (0 !== r) {
                      i = n;
                      break;
                    }
                    r++, (i = t);
                  }
                return i;
              }
              var s,
                a = i.getFocusPage();
              if (a.getPageId() !== t)
                throw o.createError('Event generated by an unexpected page');
              (s = r(e.targetMap)), s && (e.target = a.gobjList.gobjects[s]);
            });
          },
          bindGObjEvent: function(e, t, n, i) {
            this.gobjectEventHandlers[e].addHandler(t, n, i);
          },
          unbindGObjEvent: function(e, t, n, i) {
            this.gobjectEventHandlers[e].removeHandler(t, n, i);
          },
          raiseSketchEvent: function(e, t, n) {
            var i = this.gobjectEventHandlers[e],
              r = this,
              s = this.focusPage;
            if (e !== s.metadata.id)
              throw o.createError(
                'Document.raiseSketchEvent() can only raise events for the active page'
              );
            i.raiseSketchEvent(t, n),
              o.JobScheduler.isActive(i.processEventsJob) ||
                (i.processEventsJob = s.jobScheduler.addJob(
                  function() {
                    r.processSketchEvents(e), (i.processEventsJob = null);
                  },
                  { priority: 'preprocess' }
                ));
          },
          processSketchEvents: function(e) {
            var t = this.gobjectEventHandlers[e],
              n = t.getFrameIndex();
            t.hasSketchEvents() &&
              (this.focusPage.event('StartSketchFrame', {}, { frameIndex: n }),
              t.processSketchEvents(),
              this.focusPage.event('EndSketchFrame', {}, { frameIndex: n }));
          },
          triggerLoadPage: function() {
            var e = this.getActivePageId();
            this.cacheSketchPagesLoaded[e] ||
              this.event(
                'LoadPage',
                { document: this, sQuery: this.focusPage.sQuery },
                { pageId: e }
              ),
              (this.cacheSketchPagesLoaded[e] = !0);
          },
          triggerDidChangeCurrentPage: function(e) {
            this.event(
              'DidChangeCurrentPage',
              { document: this, sQuery: this.focusPage.sQuery },
              { oldPageId: e, pageId: this.getActivePageId() }
            );
          },
          triggerWillChangeCurrentPage: function(e) {
            var t = this.focusPage ? this.getActivePageId() : null;
            this.event(
              'WillChangeCurrentPage',
              { document: this },
              { pageId: t, newPageId: e }
            );
          },
          resetPageSessions: function() {
            var e;
            for (e in this.pageData)
              this.pageData.hasOwnProperty(e) && this.resetSession(e);
          },
          getInitialPageId: function() {
            return this.docSpec.metadata['start-page'];
          },
          isInitialPage: function(e) {
            return e === this.getInitialPageId();
          },
          getActivePageId: function() {
            return this.focusPage.metadata.id;
          },
          isOnInitialPage: function() {
            return this.isInitialPage(this.getActivePageId());
          },
          resetDocument: function() {
            this.resetPageSessions(),
              this.isOnInitialPage()
                ? this.applyDeltaToActivePage(null)
                : this.switchPage(this.getInitialPageId(), !0);
          },
          resetActivePage: function() {
            this.resetSession(this.getActivePageId()),
              this.applyDeltaToActivePage(null);
          },
          applyDeltaToActivePage: function(e, t) {
            var n = this.getActivePageId();
            this.stopCurrentFocusedSketch(),
              this.setPageDeltaObj(n, e),
              (this.focusPage = null);
            var i = this.getCurrentPageSpec(n);
            (this.focusPage = o.Sketch(this, i, this.docOptions)),
              this.focusPage.attachToNode(this.canvasNode),
              this.triggerLoadPage(n),
              this.startCurrentFocusedSketch(t),
              (this.sQuery = this.focusPage.sQuery);
          },
          switchPage: function(e, t) {
            var n,
              i = this.focusPage,
              r = i.metadata.id,
              s = e;
            if (s !== r) {
              for (; i.hasTouchRegimes(); ) i.popTouchRegime();
              this.triggerWillChangeCurrentPage(s),
                t || this.recordActivePageDelta(),
                (n = this.getCurrentPageSpec(s)),
                this.stopCurrentFocusedSketch(),
                (this.focusPage = o.Sketch(this, n, this.docOptions)),
                this.focusPage.attachToNode(this.canvasNode),
                this.triggerLoadPage(e),
                (this.metadata['start-page'] = s),
                this.startCurrentFocusedSketch('pageSwitch'),
                (this.sQuery = this.focusPage.sQuery),
                this.triggerDidChangeCurrentPage(r);
            }
          },
          startCurrentFocusedSketch: function(e) {
            this.focusPage.start(e),
              this.setUndoButtonStates(),
              this.event(
                'StartCurrentPage',
                { document: this, sQuery: this.focusPage.sQuery },
                { pageId: this.getActivePageId() }
              );
          },
          stopCurrentFocusedSketch: function() {
            this.event(
              'StopCurrentPage',
              { document: this },
              { pageId: this.getActivePageId() }
            ),
              this.focusPage.stop();
          },
          start: function() {
            this.startCurrentFocusedSketch();
          },
          stop: function() {
            this.stopCurrentFocusedSketch(), this.cleanUp();
          },
          cleanUp: function() {
            this.event('UnloadDocument', { document: this }, {});
          },
          recordActivePageDelta: function() {
            var e = this.getFocusPage(),
              t = e && e.metadata.id,
              n = this.getOrigPageSpec(t),
              i = o.getSketchDiff(n, e.toSpecObj());
            this.setCurrentPageDelta(i);
          },
          getPageDeltaObj: function(e) {
            var t,
              n,
              i = this.getFocusPage(),
              r = i && i.metadata.id;
            return (
              e === r
                ? ((n = this.getOrigPageSpec(r)),
                  (t = o.getSketchDiff(n, i.toSpecObj())))
                : (t = this._getPageDeltaObj(e) || null),
              t
            );
          },
          getCurrentSpecObject: function() {
            var e,
              n = t.extend(!0, {}, this.docSpec);
            for (
              t.extend(!0, n.metadata, this.metadata), e = 0;
              e < n.pages.length;
              ++e
            )
              n.pages[e] = this.getCurrentPageSpec(this.getPageIdAtIndex(e));
            return n;
          },
          getDocumentJSON: function() {
            return JSONcanonical.stringify(this.getCurrentSpecObject());
          },
          getDocumentDelta: function() {
            var e = o.getDocumentDiff(
              this.docSpec,
              this.getCurrentSpecObject()
            );
            return JSONcanonical.stringify(e);
          },
          _applyDocumentDelta: function(e) {
            var t, n, i, r;
            try {
              switch (typeof e) {
                case 'string':
                  t = JSON.parse(e);
                  break;
                case 'object':
                  t = e;
                  break;
                default:
                  throw o.createError('invalid doc delta');
              }
            } catch (e) {
              (e.code = 'GSP.Error.invalidDocDelta'), o.signalCaughtError(e);
            }
            if (t && t.pageDiffs)
              for (
                this.initMetadata(),
                  o.diffPatch.patch(this.metadata, t.metadataDiff),
                  n = 0;
                n < t.pageDiffs.length;
                n++
              )
                (r = t.pageDiffs[n]),
                  (i = this.getPageIdAtIndex(n)),
                  this.setPageDeltaObj(i, r || null);
          },
          applyDocumentDelta: function(e) {
            var t,
              n = this.getFocusPage().metadata.id;
            this._applyDocumentDelta(e),
              (t = this.metadata['start-page']),
              t !== n
                ? this.switchPage(t, !0)
                : this.applyDeltaToActivePage(this._getPageDeltaObj(t));
          },
          initMetadata: function() {
            this.metadata = t.extend(!0, {}, this.docSpec.metadata);
          },
          getAuthorPreference: function(e) {
            var t,
              i,
              r,
              s = e.toLowerCase(),
              a = s.match(/tool$/),
              c = p[a ? 'tool' : s];
            if (!c) throw o.createError('unknown author preference');
            if (((t = c.type), !t))
              throw o.createError('Bad author preference type');
            if (((i = c.defaultValue), i === n))
              throw o.createError('Bad author preference default');
            return (r = this.getExplicitPref(s, c)), r.exists ? r.value : i;
          },
          getExplicitPref: function(e, t) {
            var n,
              i,
              r = this.metadata.authorPreferences;
            for (n in r)
              if (
                ((i = n.toLowerCase()),
                i !== e && (i = i.replace(/\s/g, '')),
                i === e)
              )
                return { exists: !0, value: t.type.parse(r[n]) };
            return { exists: !1 };
          },
          authorPreferenceIsExplicitlySet: function(e) {
            var t = this.metadata.authorPreferences;
            return t && t[e.toLowerCase()] !== n;
          },
          setLocale: function(t) {
            function n(t) {
              return e.Intl
                ? e.Intl.NumberFormat(t)
                    .formatToParts(s)
                    .find(function(e) {
                      return 'decimal' === e.type;
                    }).value
                : '.';
            }
            function i() {
              return /^1(.+)1$/.exec(s.toLocaleString())[1];
            }
            var r,
              s = 1.1;
            (r = t ? n(t) : i()),
              (this.formatOptions.decimalSeparator = r),
              (this.formatOptions.listSeparator = '.' === r ? ',' : ';');
          },
          initModel: function(e, t) {
            var n, i, r;
            if (
              ((this.docSpec = e),
              this.initMetadata(),
              (this.resources = e.resources || {}),
              (this.docOptions = t || {}),
              (this.formatOptions = {
                decimalSeparator: '.',
                listSeparator: ',',
              }),
              this.setLocale(this.docOptions.locale),
              (this.pageData = {}),
              e.pages)
            )
              for (n = 0; n < e.pages.length; n++)
                (r = e.pages[n]),
                  (i =
                    r && r.metadata && null != r.metadata.id
                      ? r.metadata.id
                      : String(n + 1)),
                  (r.metadata.id = i),
                  (this.pageData[i] = { spec: r }),
                  this.resetSession(i);
            e.tools && this.addTools(e.tools);
          },
          addTools: function(e) {
            var t = this;
            t.tools || (t.tools = []),
              e.forEach(function(e) {
                t.tools.push(o.Tool.createWithSpec(e));
              });
          },
          hasTools: function() {
            return this.tools && this.tools.length > 0;
          },
          getPageData: function(e) {
            return this.pageData[e];
          },
          getPageSession: function(e) {
            return this.getPageData(e).session;
          },
          _getPageDeltaObj: function(e) {
            return this.getPageSession(e).delta;
          },
          setPageDeltaObj: function(e, t) {
            this.getPageSession(e).delta = t;
          },
          getCurrentPageData: function() {
            var e = this.getFocusPage().metadata.id;
            return this.getPageData(e);
          },
          getCurrentPageSession: function() {
            return this.getCurrentPageData().session;
          },
          getCurrentPageHistory: function() {
            return this.getCurrentPageSession().history;
          },
          getCurrentPageDelta: function() {
            return this.getCurrentPageSession().delta;
          },
          setCurrentPageDelta: function(e) {
            this.getCurrentPageSession().delta = e;
          },
          resetSession: function(e) {
            this.pageData[e].session = { delta: null, history: i() };
          },
          getRecentChangesDelta: function() {
            var e,
              n,
              i = this.getFocusPage().metadata.id;
            return (
              (n = t.extend(!0, {}, this.getOrigPageSpec(i))),
              (e = this.getCurrentPageHistory().getCurrentDelta()),
              e && o.applySketchDiff(n, e),
              (e = o.getSketchDiff(n, this.getFocusPage().toSpecObj())),
              e && e.diff ? this.getPageDeltaObj(i) : null
            );
          },
          updateCurrentDelta: function() {
            var e = this.getRecentChangesDelta();
            e && this.getCurrentPageHistory().replaceCurrentDelta(e);
          },
          pushConfirmedSketchOpDelta: function(e) {
            var t = this.getFocusPage().metadata.id,
              n = this.getCurrentPageHistory();
            e && n.current.prev && (n.undo(), n.pushDelta(e));
            var i = this.getPageDeltaObj(t);
            return n.pushDelta(i), i;
          },
          undo: function(e) {
            var t, n;
            ('all' === e || this.canUndo()) &&
              (this.getFocusPage().event(
                'WillUndoRedo',
                {},
                { type: 'undo', context: 'toolplay' }
              ),
              this.updateCurrentDelta(),
              (t = this.getCurrentPageHistory()),
              t.undo(e),
              (n = 'all' === e ? null : t.getCurrentDelta()),
              this.applyDeltaToActivePage(n, 'undoRedo'),
              this.setUndoButtonStates(),
              this.getFocusPage().event(
                'UndoRedo',
                {},
                { type: 'undo', context: 'toolplay', delta: n }
              ));
          },
          isCurrentlyInToolplay: function() {
            var e = this.focusPage && this.focusPage.toolController;
            return Boolean(e && e.activeTool);
          },
          changedUIMode: function() {
            this.setUndoButtonStates();
          },
          undoRedoAllowedByRegime: function() {
            return (
              !this.isCurrentlyInToolplay() &&
              !this.focusPage.touchRegimeBlocksOtherButtons()
            );
          },
          canUndo: function() {
            return (
              this.undoRedoAllowedByRegime() &&
              this.getCurrentPageHistory().canUndo()
            );
          },
          canRedo: function() {
            return (
              this.undoRedoAllowedByRegime() &&
              this.getCurrentPageHistory().canRedo()
            );
          },
          redo: function() {
            var e, t;
            this.canRedo() &&
              (this.getFocusPage().event(
                'WillUndoRedo',
                {},
                { type: 'redo', context: 'toolplay' }
              ),
              this.updateCurrentDelta(),
              (e = this.getCurrentPageHistory()),
              e.redo(),
              (t = e.getCurrentDelta()),
              this.applyDeltaToActivePage(t, 'undoRedo'),
              this.setUndoButtonStates(),
              this.getFocusPage().event(
                'UndoRedo',
                {},
                { type: 'redo', context: 'toolplay', delta: t }
              ));
          },
          setUndoButtonStates: function() {
            var e,
              n = this.canUndo(),
              i = this.canRedo();
            this.hasTools()
              ? ((e = t('.wsp-undo-redo', this.canvasNode)),
                e.toggleClass('wsp-undo-disabled', !n),
                e.toggleClass('wsp-redo-disabled', !i))
              : this.focusPage.getAuthorPreference('undoRedoInButtonBar') &&
                ((e = this.canvasNode
                  .parent()
                  .find('.wsp-undo-redo-container')),
                e.find('.wsp-undo-button').css('opacity', n ? 1 : 0.3),
                e.find('.wsp-redo-button').css('opacity', i ? 1 : 0.3));
          },
          attachUndoRedo: function(e) {
            var n,
              i =
                '<img width="20" height="20" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAACEZVhJZk1NACoAAAAIAAYBBgADAAAAAQACAAABEgADAAAAAQABAAABGgAFAAAAAQAAAFYBGwAFAAAAAQAAAF4BKAADAAAAAQACAACHaQAEAAAAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQACoAIABAAAAAEAAAAWoAMABAAAAAEAAAAWAAAAAI8BckgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAK0aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KEb7JgwAAAe9JREFUOBHtVMtKw1AQTZqkIS12IVUqdCUIoriQ7sSFgiDqrujKvxDcuNGdIIJf4g/4AYK/oCtBcFGwahDamIfnpHeSW9q0uO/AdObO49yZuZMaxozUBEzIEjieMBHG6JzgTJ6Uk8FZmZYrvNDOjyMaL6OfcoQsz/O2wzB8hYdBrEISIp5brZbj+/6q4zibpVJpHfFLYLPf73dVPESWS31Apml2Lcs6VEdX7LVabcW27Tv4X8ARONHYR86T67pn9Xp9TuUMd43gbyYAZF9Ay+XyFWyhBhRD72nn9BLEU36hg2OVy/Glo4Hd7OBQB8cIaKPF0yiKTmBnbAjmQzk8gD7Bj6j2GbKXJMkieCeO42UUcxsEwTnsg2UAwAdYb5M6q2WVUnWAxItGo7GAxBGqVqt7iH1D19fKaRswCDDnKCzglO9I3NDQOEs+tHDmQux9pVI5Sg0aMCuUykX3NVA+bDqfDClXZFQGNuey2Wx6esUCRvBfXoLWblRuJcco1NiBwW3CW20VAcslP9q2ZFUVQquO8B5rBO6oEbBKPpZwoOwhwHcV2PCujt6QjgpVzxNYAGS+YyVWrK1wuE4TiV+ria/nALtYxgXyOUsS95cUwe/B72PHHwamqb9Fjzw1cWoAkTk3SqlwXJL4+cc0o/9N4A+1LqEMpkN8awAAAABJRU5ErkJggg==">',
              r =
                '<img width="20" height="20" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAACEZVhJZk1NACoAAAAIAAYBBgADAAAAAQACAAABEgADAAAAAQABAAABGgAFAAAAAQAAAFYBGwAFAAAAAQAAAF4BKAADAAAAAQACAACHaQAEAAAAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQACoAIABAAAAAEAAAAWoAMABAAAAAEAAAAWAAAAAI8BckgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAK0aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KEb7JgwAAAdtJREFUOBHtU7tKA0EUnX3ksRuTgCSQIiAWNkpESCcWCqKgnfglljbaCVroj4hg5ycI/oGtsoUQH0E0m2zWc4a5OIa8wE68cPbe2Xvn3MfMKPUvZgLOFJNwEcM4Ih0AlkOFe4YKSXxgXGL6hxF4ZNQfGpZwQ99Alcvl+Uwms+I4znI+n5/LQRqNxksURT3EsAPGU1NoJ0EQrOmV9dGJKpVKEfsPPM+7BWEbSC0ksO993z8vlUoL1t4cbezZgf9Z/rNl3Ray7cPxirVNJvYnfH1A1r1sNnssJEi2bXxvMgqS9hF01ul0LlzXfQSugBvgLk3TFvxVYAZgEV1AjyFJknVUuYSCYsi18beh9VwUsp0g20OhUNjkz0Gp1WpVJD5ETGyq6kGzemrpQDQLUSoMw104LwfIeBAC6UwhcQOxkSETUs5dQPKWqtfrAdo9skgzlm2bHIE+IEMuh2rPXOyWwmxWrdNlhZMkZABGd2qq7hrNSr+JMbdFwzTuMUgy3Y05/XdDKGQ/iVHt7JTEes4g3QChzJYHSVsg1T+pZrM5aqZSJbW+47hWeyCRkx+nY7ZPyJMkyUjBa9zCnS6C/ANBclPsEcKduvDHI0l+67CzTcPFKid1OMk/TZ6/FPMFReeRA2gpjDMAAAAASUVORK5CYII=">',
              s = this;
            (n =
              "<button class='wsp-undo-button'>" +
              i +
              "</button><button class='wsp-redo-button'>" +
              r +
              '</button>'),
              e.find('.wsp-undo-redo-container').length &&
                this.removeUndoRedo(e),
              e.prepend(
                t(
                  '<div class="wsp-undo-redo-container wsp-undo-disabled wsp-redo-disabled" style="float: left">' +
                    n +
                    '</div.'
                )
              ),
              e.find('.wsp-undo-button').on('click', function(e) {
                s.undo(), e.preventDefault();
              }),
              e.find('.wsp-redo-button').on('click', function(e) {
                s.redo(), e.preventDefault();
              });
          },
          removeUndoRedo: function(e) {
            var t = e.find('.wsp-undo-redo-container');
            t.length && t.remove();
          },
          attachToolsToNode: function(e, i, r, s) {
            function a(n) {
              return t(n, e[0]).outerWidth();
            }
            function c(n, i) {
              var r = t(n, e[0]);
              r.on('click', function(e) {
                i.call(M), e.preventDefault();
              });
            }
            function l() {
              return L;
            }
            function u(e, t) {
              L = { draggable: e, liveTouchId: t.identifier };
            }
            function d() {
              if (l() === n) throw o.createError('No drag in progress');
            }
            function h() {
              return d(), l().draggable;
            }
            function p() {
              h().css('visibility', 'hidden');
            }
            function f() {
              h().css('visibility', 'visible');
            }
            function m() {
              h().remove(), (L = n);
            }
            function g() {
              return l() !== n;
            }
            function b(e) {
              return g() && l().liveTouchId === e.identifier;
            }
            function v(i) {
              function r(e) {
                return e.attr(P), e.attr('title', i.metadata.name), e;
              }
              function s(e, t) {
                var n = t.pageX,
                  i = t.pageY,
                  r = o.convertPointFromPage(e, n, i);
                return (
                  r.y >= 0 &&
                  r.x >= 0 &&
                  r.x <= e[0].offsetWidth &&
                  r.y <= e[0].offsetHeight
                );
              }
              function a(n, r) {
                var o = M.focusPage && M.focusPage.toolController,
                  a = t('.wsp-clip-node', e);
                o && (s(w, n) || s(a, n)) && o.toggleTool(i, r);
              }
              function c(n) {
                var i = t('.wsp-clip-node', e);
                s(i, n)
                  ? i.addClass('wsp-drop-target')
                  : i.removeClass('wsp-drop-target');
              }
              function l() {
                return M.getFocusPage().touchRegimeBlocksOtherButtons();
              }
              function d(e) {
                var t = w.clone();
                return (
                  u(t, e),
                  t.addClass('wsp-draggable-toolButton'),
                  E.setDraggableDimensions(t),
                  p(),
                  t.prependTo(w.parent()),
                  v(e),
                  t
                );
              }
              function v(e) {
                var t = e.pageX,
                  n = e.pageY,
                  i = h(),
                  r = i.offsetParent(),
                  s = o.convertPointFromPage(r, t, n),
                  a = s.x - i.width() / 2,
                  c = s.y - i.height() / 2;
                i.css({ left: a + 'px', top: c + 'px' });
              }
              function x(e, t) {
                for (var n = 0; n < e.changedTouches.length; n++)
                  t(e.changedTouches[n]);
              }
              var w,
                k = i.metadata.image !== n,
                P = I.getResource('pictures', i.metadata.image) || {},
                C = function() {
                  var e = t('<div class="wsp-tool-text"></div>');
                  e.text(i.metadata.name), w.append(e);
                },
                S = {
                  addImage: function() {
                    if (k) {
                      var e = r(t('<img class="wsp-tool-image"/>'));
                      w.append(e);
                    }
                  },
                  addText: function() {
                    k || C();
                  },
                  finishAddingTool: function() {
                    k && (T.hasIcons = !0);
                  },
                  setDraggableDimensions: function(e) {
                    var t = w.find('img');
                    k
                      ? (e.width(Math.max(t.width(), w.width())),
                        e.height(Math.max(t.height(), w.height())))
                      : (e.width(w.width()), e.height(w.height()));
                  },
                },
                F = {
                  addImage: function() {
                    var e, n;
                    P.src || (P.src = o.Resources.defaultToolImage),
                      (P.height = '40px'),
                      (P.width = '40px'),
                      (n = r(t('<img/>'))),
                      (e = t('<div class="wsp-tool-media"></div>')),
                      e.append(n),
                      w.append(e);
                  },
                  addText: C,
                  setDraggableDimensions: function(e) {
                    e.width(w.width()), e.height(w.height());
                  },
                },
                E = 'new' === j ? F : S;
              (w = t('<div class="wsp-tool"></div>')),
                E.addImage(),
                E.addText(),
                o.mouseTouch(w),
                w.on('touchstart', function(e) {
                  return (
                    x(e, function(e) {
                      var t = l() || g();
                      t || (w.addClass('wsp-tool-active'), d(e));
                    }),
                    !1
                  );
                }),
                w.on('touchmove', function(e) {
                  return (
                    x(e, function(e) {
                      !l() && b(e) && (c(e), v(e), f());
                    }),
                    !1
                  );
                }),
                w.on('touchend', function(n) {
                  return (
                    x(n, function(i) {
                      if (b(i)) {
                        var r = t('.wsp-clip-node', e);
                        w.removeClass('wsp-tool-active'),
                          a(i, n.timeStamp),
                          r.removeClass('wsp-drop-target'),
                          m();
                      }
                    }),
                    !1
                  );
                }),
                (i.$element = w),
                y.append(w),
                E.finishAddingTool && E.finishAddingTool(),
                (A = Math.max(A, w.outerWidth()));
            }
            var y,
              x,
              w,
              k,
              P,
              C,
              S,
              A,
              T,
              M = this,
              I = M.focusPage.sQuery(),
              F = '',
              E = this.getAuthorPreference('toolplayNewLook'),
              j = this.getAuthorPreference('toollook'),
              O =
                E || 'new' === j
                  ? 'new'
                  : 'classic' === j
                  ? 'classic'
                  : 'compact';
            switch (O) {
              case 'new':
                T = { toolsLookClass: 'wsp-tools-newLook', hasIcons: !0 };
                break;
              case 'classic':
                T = { toolsLookClass: 'wsp-tools-classicLook', hasIcons: !1 };
                break;
              case 'compact':
                T = { toolsLookClass: 'wsp-tools-compactLook', hasIcons: !1 };
            }
            s &&
              ((k =
                '<div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
                o.Strings.loc('GSP.UI.undo') +
                '</div>'),
              (P =
                '<div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
                o.Strings.loc('GSP.UI.redo') +
                '</div>'),
              (F =
                '<button class="wsp-undo-button">' +
                k +
                '</button><button class="wsp-redo-button">' +
                P +
                '</button>')),
              (C =
                '<div class="wsp-tool-container ' +
                T.toolsLookClass +
                '"><div class="wsp-tool-column"><div class="wsp-tool-logo wsp-fixed-tool"></div><div class="wsp-ok-cancel-container wsp-undo-redo wsp-undo-redo-top wsp-fixed-tool">' +
                F +
                '</div><div class="wsp-user-tools"><div class="wsp-tools-inner"></div></div><div class="wsp-ok-cancel-container wsp-undo-redo wsp-undo-redo-bottom wsp-fixed-tool">' +
                F +
                '</div></div></div>'),
              (S = e.find('.wsp-tool-container')),
              S.length
                ? S.replaceWith(C)
                : (e.prepend(C),
                  t('.wsp-base-node').css({
                    width: i + t('.wsp-tool-container').outerWidth(),
                  })),
              (y = t('.wsp-tools-inner', e[0])),
              t('.wsp-undo-redo', e[0]).each(function(e, t) {
                o.FastClick.attach(t);
              }),
              c('.wsp-undo-button', M.undo),
              c('.wsp-redo-button', M.redo),
              (A = Math.max(A, a('.wsp-undo-redo')));
            var L;
            M.tools.forEach(v),
              (x = 0),
              t('.wsp-fixed-tool', e[0])
                .filter(':visible')
                .each(function(e) {
                  x += t(this).outerHeight();
                }),
              T.hasIcons
                ? A > 0 && t('.wsp-tool-column', e[0]).outerWidth(A)
                : t('.wsp-tool-column', e[0]).addClass('wsp-no-tool-icons'),
              (w = t('.wsp-tools-inner', e[0]).outerHeight()),
              t('.wsp-user-tools', e[0]).outerHeight(r - x - 2),
              x + w > r &&
                t('.wsp-user-tools', e[0]).addClass('wsp-tool-overflow-y');
          },
        };
        var f = function(e, n, i) {
          var l, u, d, h, p;
          if (((u = r(n.metadata)), u && 'error' === u.logType))
            throw (e &&
              ((d = t('<div class="wsp-error-message"></div>')),
              d.text(u.message),
              t(e)
                .empty()
                .append(d)),
            o.createError(u.message, u.code));
          return (
            (l = Object.create(a)),
            l.initModel(n, s(i, t(e).hasClass('wsp-responsiveSizing'))),
            (l.id = c++),
            (l.gobjectEventHandlers = {}),
            (l.cacheSketchPagesLoaded = {}),
            (l.pictureCache = {}),
            l.docOptions.documentDelta &&
              l._applyDocumentDelta(l.docOptions.documentDelta),
            (p = l.getCurrentPageSpec(l.metadata['start-page'])),
            (h = o.Sketch(l, p, i)),
            (l.focusPage = h),
            (l.sQuery = h.sQuery),
            e &&
              (l.attachToNode(e),
              t(e).data('document', l),
              h.attachToNode(e),
              l.event('LoadDocument', { document: l }, {}),
              l.triggerLoadPage(),
              l.triggerDidChangeCurrentPage(null)),
            l
          );
        };
        return f;
      })()),
      (o.Resources = {
        defaultToolImage:
          'data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIiB2aWV3Qm94PSIwIDAgODAgODAiIHZlcnNpb249IjEuMSIgeD0iMHB4IiB5PSIwcHgiPjxwYXRoIHN0eWxlPSIiIGQ9Im0gMTEuOTU4MzQ3LDE1LjUzNjQzMiBjIC0wLjQxNzU2NiwwLjA1MjQ1IC0wLjY5OTA3MiwwLjQxNjQ1NSAtMS4zMzMyMDgsMS41NzMxODYgLTAuMzEyMzE4LDAuNTM5MzQgLTAuNjc0MDkzLDEuMjMyMjAxIC0xLjA2NjU2NywyLjAyNjQ3NiAtMC4wNTI1OCwwLjEwMDY2MyAtMC4wNzc2OSwwLjEzMzYxOSAtMC4xMzMzMjEsMC4yMzk5NzggLTMuMTA1MTE5NSw1LjkzNjY2MyAtOC4xODU4OTg4LDE5LjQ3MDg1NyAtOC4xODU4OTg4LDIxLjgxMTI4NyAwLDAuMTQ2ODY1IDAuMDQ2MzE2LDAuMjk2NjkyIDAuMTMzMzIwOSwwLjQ1MzI5MSAwLjAwMTk1LDAuMDA3NCAtMC4wMDIxMiwwLjAxOTQ1IDAsMC4wMjY2NiAwLjAyNjMwNCwwLjA0NTQgMC4wNDU5OCwwLjA4Njc4IDAuMDc5OTkyLDAuMTMzMzIxIDAuMDY5NTMxLDAuMTI1ODA4IDAuMTUzNTc5NywwLjIzMzY5MiAwLjI5MzMwNTgsMC4zNDY2MzQgMC4xMDM1NDEyLDAuMDgzNjkgMC4yMDU3NTAyLDAuMTg1NDMyIDAuMzQ2NjM0MSwwLjI5MzMwNiAwLjAyNDg4NywwLjAxOTA2IDAuMDc5MDc1LDAuMDMzNSAwLjEwNjY1NjcsMC4wNTMzMyAwLjEwNjg3NiwwLjA3NjgzIDAuMjI4NTg4MSwwLjE3OTE4NCAwLjM3MzI5ODMsMC4yNjY2NDIgMC42NTgyNzMyLDAuNDM1OTM0IDEuNTY4ODUyOCwwLjkyOTM3NSAyLjc5OTczNzMsMS41MTk4NTcgMy43OTkwNjk3LDEuODIyNTA1IDguMTM5MjMwNywzLjIzMjYyOSAxMC4wNzkwNTQ3LDMuMzU5Njg1IDAuMDI0NCwwLjAwMzYgMC4wNTY3MywwLjAyMzYgMC4wNzk5OSwwLjAyNjY2IDAuMDE1MDMsNy41NWUtNCAwLjAzODYxLC01Ljg2ZS00IDAuMDUzMzMsMCAwLjEzNzI3NywwLjAxNTY4IDAuMjU3MTUsMC4wMzM1IDAuMzQ2NjM1LDAuMDI2NjYgMC41OTU5MzUsLTAuMDQ1NTEgMC43MTYwMTksLTAuMTQ4MTA0IDEuNDEzMiwtMS4yNTMyMTYgMC40MTU0NDcsLTAuNjU4NTMyIDEuMDQxODM1LC0xLjc2Mjg3NyAxLjM4NjUzNywtMi40NTMxMDMgMS42NDk4MSwtMy4zMDM1NzkgMi40MjE4NTksLTQuODg3ODAzIDMuMDEzMDUsLTUuNTQ2MTQ2IDAuMjMxNDI4LDAuMDkyMDggMS40Nzc5MTksMC41ODI0NzkgMi45NTk3MjMsMS4xNzMyMjMgMS41MzcxMSwwLjYxMjc5NCAzLjA1MjI2MiwxLjIxMTQ4MiAzLjM1OTY4NSwxLjMwNjU0NCAwLjMwNzQyMSwwLjA5NTA2IDEuNzA1NTY1LDAuNzE2MTAzIDMuMTE5NzA3LDEuMzg2NTM3IDEuNDE0MTQyLDAuNjcwNDM1IDMuNjQxNjk4LDEuNjU4NDMxIDQuOTMyODcsMi4yMTMxMjUgMS4yOTExNzMsMC41NTQ2OTcgMi42ODc0MiwxLjE5Mjg4NiAzLjExOTcwOCwxLjQxMzIwMSAwLjQzMjI4MywwLjIyMDMxMyAyLjE1NDc4OSwwLjk1MDQwNyAzLjgxMjk3NSwxLjYyNjUxNCAxLjY1ODE4NCwwLjY3NjEwNSA0LjgyNTg5OSwxLjk4MzEzNSA3LjAzOTM0MSwyLjkwNjM5NCAyLjIxMzQzOCwwLjkyMzI1OSA1LjM3OTI1OCwyLjE3MDExIDcuMDM5MzM5LDIuNzQ2NDA5IDMuOTEyNjI0LDEuMzU4Mjc2IDguNzg1MjEsMy4yNzE2MTUgMTEuMTE4OTU3LDQuMzcyOTIzIDEuMDE2ODczLDAuNDc5ODcgMS44OTM0MjIsMC44Nzk5MTggMS45NDY0ODQsMC44Nzk5MTggMC4wNTMwNiwwIDEuMDQyOTYyLDAuNDIxMTc3IDIuMTg2NDYyLDAuOTU5OTEgMS4xNDM1LDAuNTM4NzM0IDIuMjE1MzIxLDEuMDM3MTQxIDIuMzk5Nzc1LDEuMDkzMjMgMC4xNzY2MywwLjA1MzcyIDAuMzYyMDA0LDAuMDU2NzMgMC41MzMyODMsMC4wMjY2NyAwLjAwMTQsMC4wMjU5NiAtOS41NmUtNCwwLjA1Mzc1IDAuMDI2NjYsMC4wNzk5OSAwLjI0NTc5NiwwLjIzMzUyOSAxLjA3MTc2MywtMC4zNTkxNTIgMS44MTMxNjMsLTEuMzA2NTQ0IDAuNTc5NDgyLC0wLjc0MDQ4OSAxLjA4NTUxMywtMS45MzM2MjggMS4zNTk4NzMsLTMuMDkzMDQzIDAuMDA0NSwtMC4wMTg3NCAwLjAyMjM2LC0wLjAzNDYgMC4wMjY2NiwtMC4wNTMzMyAwLjAzMDY5LC0wLjEwMTYwMiAwLjAyNzg4LC0wLjE5Mzk3MiAwLjA1MzMzLC0wLjI5MzMwNiAwLjA3Mjk1LC0wLjI4NDgxNCAwLjEzNTU0LC0wLjU0NTU0MyAwLjE1OTk4NSwtMC43OTk5MjUgMC4xMTA3NDcsLTEuMTUyNTg0IC0wLjA1ODA3LC0yLjExNTAxMSAtMC4zNzMyOTgsLTIuMTg2NDYyIC0wLjAwNzksLTAuMDA5MSAtMC4wMTg0OCwtMC4wMTc5NSAtMC4wMjY2NiwtMC4wMjY2NiAtMC4wODk5OCwtMC4wOTU4MiAtMC4xOTI5NTYsLTAuMTc2MzIzIC0wLjMxOTk3LC0wLjIzOTk3NyAtMC4xNzIzNTcsLTAuMDg2MzggLTEuMzA2MzYxLC0wLjQ4Mjg1MiAtMi41MDY0MzIsLTAuODc5OTE4IC0xLjIwMDA2OCwtMC4zOTcwNjYgLTIuMjAxMzE4LC0wLjc2MzM3MiAtMi4yMzk3OSwtMC43OTk5MjUgLTAuMDM4NDcsLTAuMDM2NTUgLTAuOTMyMDg4LC0wLjM0MDc0OCAtMS45OTk4MTIsLTAuNjkzMjY4IC0yLjQ1MDQ1LC0wLjgwOTA0MiAtNy4zMjAyMTgsLTIuNzY5MzIgLTExLjA5MjI5MywtNC40Nzk1OCAtMS42MDA0NDcsLTAuNzI1NjQ1IC00Ljc0NTQxOSwtMi4wMjQ0NzIgLTYuOTg2MDExLC0yLjg3OTczIC0yLjI0MDU5MywtMC44NTUyNTUgLTUuNDUxNTE2LC0yLjA5NDQyNyAtNy4xMTkzMzIsLTIuNzQ2NDA5IC0xLjY2NzgyLC0wLjY1MTk4MiAtMy40MDExNjYsLTEuMzAxODMyIC0zLjg2NjMwNCwtMS40Mzk4NjQgLTAuNDY1MTQzLC0wLjEzODAzMiAtMS45MzQ5MDUsLTAuNjU5MzUzIC0zLjI1MzAyOCwtMS4xNDY1NiAtMS4zMTgxMjIsLTAuNDg3MjA4IC0zLjYwNTg2NiwtMS4yNzE4MzQgLTUuMDkyODU1LC0xLjc1OTgzNCAtMS40ODY5OTEsLTAuNDg4MDAxIC0yLjkzODAxMywtMS4wMDM3MzMgLTMuMjI2MzY0LC0xLjE0NjU2IC0wLjI4ODM0OSwtMC4xNDI4MyAtMS43Njk5MjQsLTAuNzcyMDUgLTMuMzA2MzU3LC0xLjM4NjUzNiAtMS41MzY0MzYsLTAuNjE0NDg2IC0yLjk0MDI5MywtMS4xNjUyNjEgLTMuMDkzMDQzLC0xLjIyNjU1MiAtMC4wMzYzMiwtMC4wMTQ1NyAtMC4wMzAzNCwtMC4wOTY1NiAtMC4wMjY2NiwtMC4yMTMzMTMgMC4wMDMyLC0wLjEwMTg0NiAwLjA0NzA4LC0wLjI3Njc3MiAwLjA3OTk5LC0wLjQ1MzI5MSAwLjAxODc5LC0wLjEwNDYxOSAwLjAyNzA4LC0wLjIwMDI1OSAwLjA1MzMzLC0wLjMxOTk3IDAuMDcxNjcsLTAuMzEwNjgxIDAuMTY1NzEsLTAuNjk5NTY5IDAuMjkzMzA1LC0xLjE0NjU1OSAwLjAwMzMsLTAuMDExODggLTAuMDAzNCwtMC4wNDEzNCAwLC0wLjA1MzMzIDAuMTMwODc3LC0wLjQ1NTg2MyAwLjI5NDMyMSwtMC45NjA4MSAwLjQ3OTk1NSwtMS41NDY1MjIgMC4wOTM3NSwtMC4yOTU4MTUgMC4xNTUyMDgsLTAuNDc1ODM0IDAuMjM5OTc4LC0wLjc0NjU5NiAwLjE3MjkzNywtMC41Njg5MjcgMC4yNjI4MTksLTAuOTE2MTQyIDAuNDc5OTU1LC0xLjYyNjUxNCAwLjgzNjM2NCwtMi43ODM2MzIgMS4wNDc4OCwtMy44OTEzNTEgMC44MjY1ODksLTQuMjkyOTMxIC0wLjYxOTk0MSwtMS4xMjUwMDkgLTUuNDgzMDcyLC0zLjU1NTM1NiAtMTAuMTU5MDQ3LC01LjA2NjE5MSAtMC45MzU5MDIsLTAuMzAyMzk3IC0xLjcxNTU5MiwtMC41MTE2ODcgLTIuMzczMTExLC0wLjY2NjYwNCAtMC4wNjQ2MiwtMC4wMTUyMyAtMC4xMjQ1MDIsLTAuMDM5NTEgLTAuMTg2NjQ5LC0wLjA1MzMzIC0wLjEwNjkyMSwtMC4wMjk5OCAtMC4xOTQzMjYsLTAuMDI3NzMgLTAuMjkzMzA1LC0wLjA1MzMzIC0wLjM3Mzk5OCwtMC4wOTY3MyAtMC42OTI5NSwtMC4xODc2NjEgLTAuOTMzMjQ2LC0wLjIxMzMxMyAtMC4zMzQzMDMsLTAuMDM1NjkgLTAuNTY3NzEsLTAuMDc5MTUgLTAuNzczMjYxLC0wLjA1MzMzIHoiIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAuODUzMjUzMyI+PC9wYXRoPjwvc3ZnPg==',
      }),
      (o.Sketch = (function() {
        var s = {
          EventToSketch: function(e) {
            var t = o.convertPointFromPage(this.canvasNode, e.pageX, e.pageY),
              n = o.GeometricPoint(Math.round(t.x), Math.round(t.y));
            return (
              this.viewToPrimalTransform().transform(n),
              (t.x = n.x),
              (t.y = n.y),
              (t.pageX = e.pageX),
              (t.pageY = e.pageY),
              (t.mouseEvent = e.mouseEvent),
              t
            );
          },
          avoidableGObject: function(e) {
            return (
              e.state &&
              e.state.exists &&
              (!e.style.hidden || e.latentVisibility)
            );
          },
          getCenterPoint: function() {
            var e = this.sketchRect(),
              t = e.bottom - e.top,
              n = e.right - e.left,
              i = e.right - n / 2,
              r = e.bottom - t / 2;
            return o.GeometricPoint(i, r);
          },
          findPositionForBoundingBox: function(e) {
            function t() {
              var e,
                t = {};
              do
                if (
                  ((e = !0),
                  (t.left = n.x),
                  (t.right = t.left + r.width),
                  (t.top = n.y),
                  (t.bottom = t.top + r.height),
                  t.bottom > d.bottom)
                ) {
                  if (
                    ((n.x += (d.right - d.left) / 8), n.x + r.width > d.right)
                  )
                    return !1;
                  (e = !1), (n.y = d.top + a.sketchTopMargin);
                } else
                  for (
                    var i, c, h = u.gobjList.constraintList, p = h.length - 1;
                    p >= 0;
                    --p
                  )
                    if (
                      ((i = h[p]),
                      s(i) &&
                        u.avoidableGObject(i) &&
                        (c = u.getGObjGeomBounds(i)) &&
                        o.Geom.isFiniteRect(c) &&
                        o.Geom.isIntersectRects(c, t))
                    ) {
                      (e = !1),
                        l && (n.x = Math.max(n.x, c.left)),
                        (n.y = c.bottom + a.gObjTopMargin);
                      break;
                    }
              while (!e);
              return !0;
            }
            var n,
              i,
              r = e.boxDimensions,
              s = e.mustAvoid,
              a = e.metrics,
              c = e.start,
              l = e.placingOneGobjOnly,
              u = this,
              d = this.sketchRect();
            return (
              (n = o.GeometricPoint(c.x, c.y)),
              (i = t()),
              i ||
                ((n = o.GeometricPoint(d.left, d.top)),
                (n.x += a.sketchLeftMargin),
                (n.y += a.sketchTopMargin)),
              { success: i, position: n }
            );
          },
          autoplaceGObj: function(e, t) {
            var n = this.sketchRect(),
              i = e.getAutoplacementMetrics(),
              r = t && t.ignoreConflictIf;
            if (!i) return !1;
            for (
              var s,
                a,
                c,
                l = o.GeometricPoint(
                  n.left + i.sketchLeftMargin,
                  n.top + i.sketchTopMargin
                ),
                u = this.gobjList.constraintList,
                d = { width: i.rightIsolation, height: i.bottomIsolation },
                h = u.length - 1;
              h >= 0;
              --h
            )
              if (
                ((s = u[h]),
                s !== e &&
                  ((c = s.getAutoplacementMetrics()),
                  c &&
                    s.autoplacementType === e.autoplacementType &&
                    this.avoidableGObject(s) &&
                    (a = this.getGObjGeomBounds(s)) &&
                    o.Geom.isFiniteRect(a) &&
                    o.Geom.isIntersectRects(a, n) &&
                    a.left + d.width < n.right &&
                    a.bottom + d.height < n.bottom))
              ) {
                (l.x = a.left), (l.y = a.bottom + i.gObjTopMargin);
                break;
              }
            return (
              (e.geom = {
                loc: this.findPositionForBoundingBox({
                  boxDimensions: d,
                  mustAvoid: function(t) {
                    return r && r(t) ? !1 : t.autoplacementType && t !== e;
                  },
                  metrics: i,
                  start: l,
                  placingOneGobjOnly: !0,
                }).position,
              }),
              !0
            );
          },
          initGObjects: function(e, t) {
            function i(e) {
              var n;
              c && (n = s.autoplaceGObj(e)),
                e.postInit && e.postInit(t),
                e.invalidateGeom(),
                n && (s.renderPrepare(), s.constrainAndRedraw());
            }
            var r = o.gobjectsFromSpec(e, this.sQuery),
              s = this,
              a = this.gobjList,
              c = t && t.autoplace,
              l = t && t.speculative,
              u = t && t.forceConstrain;
            return a.addGObjects(r, c || l || u ? i : n, l), r;
          },
          constructGObjects: function(e, t) {
            var n = this.initGObjects(e, t);
            return this.renderPrepare(), n;
          },
          constrainDriveChain: function(e) {
            var t, n;
            for (t = 0; t < e.length; t++)
              (n = e[t]),
                n.checkParentsExist() && n.constrain(this),
                n.state && (n.state.constraintCache = {});
          },
          getGObjGeomBounds: function(e) {
            var t =
              (e.getGeomBounds && e.getGeomBounds()) || o.Geom.kInfiniteRect;
            return (
              o.Geom.isValidRect(t) ||
                (o.signalErrorWithCode('GSP.Error.invalidGeomBounds', [
                  e.id,
                  e.kind,
                ]),
                (t = o.Geom.kInfiniteRect)),
              t
            );
          },
          getGObjLabelBounds: function(e) {
            var t = this.renderRefCon.dcForGObjLabel || this.dcForGObjLabel(e);
            return (
              (e.getLabelBounds && e.getLabelBounds(t)) || o.Geom.kInfiniteRect
            );
          },
          updateSignificantBoundsWithGObj: function(e) {
            if (!e.style.hidden) {
              var t = this.renderRefCon.gobj[e.id];
              this.significantBounds = o.Geom.unionRects(
                this.significantBounds,
                e.getSignificantBounds(t)
              );
            }
          },
          constrain: function() {
            function e(e, t, n) {
              var i, r;
              for (i = 0; i < t.numParents(); i++)
                (r = t.parentsList[i]),
                  r.state.constraintFrame > t.state.constraintFrame &&
                    ((t.state.constraintFrame = r.state.constraintFrame),
                    n.invalidateRect(n.renderRefCon.renderBounds[t.id]),
                    n.invalidateRect(n.renderRefCon.labelBounds[t.id]),
                    (n.isDirty = !0));
            }
            function t(e, t, n) {
              var i, r;
              try {
                t.state.constraintFrame >= n.constraintFrame &&
                  t.checkParentsExist() &&
                  (t.constrain(n),
                  t.style.hidden ||
                    ((r = n.dcForGObj(t)),
                    r && r.preclear && n.invalidateRect(n.getGObjGeomBounds(t)),
                    (r = n.dcForGObjLabel(t)),
                    r &&
                      r.preclear &&
                      n.invalidateRect(n.getGObjLabelBounds(t)),
                    (n.isDirty = !0)),
                  t.state && (t.state.constraintCache = {}),
                  t.hasLabel && t.constrainLabel && t.constrainLabel(),
                  n.document.raiseSketchEvent(n.getPageId(), t.id, 'update'));
              } catch (n) {
                (i = t.id ? t.id : '#' + e),
                  (n.code = 'GSP.Error.constraintException'),
                  (n.message =
                    o.Strings.loc('GSP.Error.touchStartException', i) +
                    ': ' +
                    n.message),
                  o.signalCaughtError(n);
              }
            }
            'stopped' !== this.state &&
              (this.monitor.stateChange('constrain'),
              this.eachGObj(this.gobjList.constraintList, e),
              this.eachGObj(this.gobjList.constraintList, t),
              this.constraintFrame++,
              this.isDirty &&
                ((this.significantBounds = null),
                this.eachGObj(this.gobjList.constraintList, function(e, t, n) {
                  n.updateSignificantBoundsWithGObj(t);
                })),
              this.monitor.stateChange('idle'));
          },
          invalidateRect: function(e) {
            this.dirtyRect = o.Geom.unionRects(this.dirtyRect, e);
          },
          invalidateAppearance: function(e) {
            var t,
              n = e.labelRenderBounds,
              i = this.renderRefCon;
            this.invalidateRect(i.renderBounds[e.id]),
              n &&
                e.style.label &&
                e.style.label.showLabel &&
                i.label[e.id] &&
                ((t = e.measureLabel(i.dcForGObjLabel, i.label[e.id])),
                (n.right = Math.max(n.right, n.left + t.width)),
                (n.bottom = Math.max(n.bottom, n.top + t.height)),
                (i.labelBounds[e.id] = n)),
              this.invalidateRect(i.labelBounds[e.id]),
              (this.isDirty = !0),
              this.setNeedsDisplay();
          },
          invalidateGeom: function(e, t) {
            function n(e) {
              return !(
                o.isParameter(e) ||
                o.isCalculation(e) ||
                e.isOfKind('Measure') ||
                e.isOfKind('Button') ||
                e.isOfKind('Text') ||
                e.isOfKind('Expression')
              );
            }
            return (
              e &&
                (('drag' !== t || n(e)) &&
                  (e.state.constraintFrame = this.constraintFrame),
                this.invalidateAppearance(e)),
              this
            );
          },
          event: function(e, t, n) {
            (t = t || {}),
              (n = n || {}),
              (t.sketch = this),
              (t.sQuery = this.sQuery),
              t.gobj && (n.gobjId = t.gobj.id),
              t.touch && (n.touchIdentifier = t.touch.identifier),
              t.position && (n.position = { x: t.position.x, y: t.position.y }),
              t.sketch.document.focusPage.metadata.id &&
                (n.pageId = t.sketch.document.focusPage.metadata.id),
              this.document.event(e, t, n);
          },
          handleTouchStart: function(e) {
            var t,
              n,
              i,
              r,
              s = !0;
            if (!e || !e.changedTouches)
              return (
                o.signalErrorWithMessage(
                  'sketch.handleTouchStart: missing e.changedTouches'
                ),
                s
              );
            for (t = 0; t < e.changedTouches.length; t += 1)
              try {
                (n = e.changedTouches[t]),
                  (i = this.EventToSketch(n)),
                  (r = this.currentTouchRegime().createTracker(n, i)),
                  r &&
                    (o.TouchManager.registerTouchWithTracker(n.identifier, r),
                    (r.startTime = e.timeStamp || Date.now()),
                    r.touchBegan(i, n),
                    (s = !1));
              } catch (e) {
                (e.code = 'GSP.Error.touchStartException'),
                  (e.message =
                    o.Strings.loc(
                      'GSP.Error.touchStartException',
                      n.identifier
                    ) + e.message),
                  o.signalCaughtError(e);
              }
            return s;
          },
          handleTouchMove: function(e) {
            var t,
              n,
              i,
              r,
              s = !0;
            if (!e || !e.changedTouches)
              return (
                o.signalErrorWithMessage(
                  'sketch.handleTouchMove: missing e.changedTouches'
                ),
                s
              );
            for (t = 0; t < e.changedTouches.length; t += 1)
              try {
                (n = e.changedTouches[t]),
                  (i = o.TouchManager.trackerForTouch(n.identifier)),
                  i &&
                    ((r = this.EventToSketch(n)), i.touchMoved(r, n), (s = !1));
              } catch (e) {
                (e.code = 'GSP.Error.touchMoveException'),
                  (e.message =
                    o.Strings.loc(
                      'GSP.Error.touchMoveException',
                      n.identifier
                    ) + e.message),
                  o.signalCaughtError(e);
              }
            return (this.gObjectUpdate = !0), s;
          },
          handleTouchEnd: function(e) {
            var t,
              n,
              i,
              r,
              s = !0;
            if (!e || !e.changedTouches)
              return (
                o.signalErrorWithMessage(
                  'sketch.handleTouchEnd: missing e.changedTouches'
                ),
                s
              );
            for (t = 0; t < e.changedTouches.length; t += 1)
              try {
                (i = e.changedTouches[t]),
                  (r = o.TouchManager.trackerForTouch(i.identifier)),
                  r &&
                    ((n = this.EventToSketch(i)),
                    (r.endTime = e.timeStamp || Date.now()),
                    r.touchEnded(n, i),
                    (s = !1)),
                  o.TouchManager.deregisterTouch(i.identifier);
              } catch (e) {
                (e.code = 'GSP.Error.touchEndException'),
                  (e.message =
                    o.Strings.loc('GSP.Error.touchEndException', i.identifier) +
                    e.message),
                  o.signalCaughtError(e);
              }
            if (
              (this.setGobjPositionInDocumentBound(), this.gObjectUpdate === !0)
            ) {
              if (
                (this.focusedGobj &&
                  this.focusedGobj.htmlNode &&
                  this.focusedGobj.htmlNode.focus(),
                this.isTouchScreenDevice)
              ) {
                var a = this;
                setTimeout(function() {
                  a.updateSpeakableText();
                }, 300);
              } else this.updateSpeakableText();
              this.gObjectUpdate = !1;
            }
            return s;
          },
          _deferredGObjCalls: null,
          toggleKeyPressClass: function(e) {
            e
              ? t(this.baseNode).hasClass('keypressed') ||
                (t(this.baseNode).addClass('keypressed'),
                t('.wsp-Numpads').addClass('keypressed'))
              : t(this.baseNode).hasClass('keypressed') &&
                (t(this.baseNode).removeClass('keypressed'),
                t('.wsp-Numpads').removeClass('keypressed'));
          },
          isTouchScreen: function() {
            function t() {
              var t = e.navigator.userAgent;
              if (t.indexOf('iPad') > -1) return !0;
              if (t.indexOf('Macintosh') > -1)
                try {
                  return i.createEvent('TouchEvent'), !0;
                } catch (e) {}
              return !1;
            }
            return (
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                r.userAgent
              ) || t()
            );
          },
          gobjAddKeyEvents: function(e) {
            o.KeyTracker.create(e);
          },
          setSpeakabletext: function(e) {
            this.firstLiveNodeHasText
              ? (t('.wsp-live-node.live-node-1').html(''),
                t('.wsp-live-node.live-node-2').html(e),
                (this.firstLiveNodeHasText = !1))
              : (t('.wsp-live-node.live-node-1').html(e),
                t('.wsp-live-node.live-node-2').html(''),
                (this.firstLiveNodeHasText = !0));
          },
          updateSpeakableText: function() {
            this.wspSaysAndTabsObjects.wspSaysExist
              ? this.updateSpeakableTextForSketch()
              : this.updateSpeakableTextForGobjs();
          },
          updateSpeakableTextForGobjs: function() {
            var e = '',
              t = this.renderRefCon.gobj;
            for (var n in t)
              if (t[n]) {
                var i = t[n];
                i.speakableText &&
                  i.visible &&
                  'Button' !== i.kind &&
                  i.lastSpeakableText !== i.speakableText &&
                  ((e += i.speakableText + ' ' || ''),
                  (i.lastSpeakableText = i.speakableText));
              }
            this.setSpeakabletext(e);
          },
          updateSpeakableTextForSketch: function() {
            for (
              var e = '',
                t = !1,
                n = this.wspSaysAndTabsObjects.wspSaysGobjsId,
                i = this.renderRefCon.gobj,
                r = 0;
              r < n.length;
              r++
            )
              if (i[n[r]]) {
                var s = i[n[r]];
                s.lastSpeakableText !== s.speakableText && (t = !0),
                  (e += s.speakableText + ' ' || ''),
                  (s.lastSpeakableText = s.speakableText);
              }
            t && this.setSpeakabletext(e);
          },
          updateWSPButtonSpeakableText: function(e) {
            for (
              var t = '', n = this.renderRefCon.gobj, i = 0;
              i < e.length;
              i++
            )
              if (n[e[i]]) {
                var r = n[e[i]];
                t += r.speakableText + ' ' || '';
              }
            this.setSpeakabletext(t);
          },
          updateWSPButtonDownSpeakableText: function(e) {
            if (
              this.wspSaysAndTabsObjects.wspButtonDownSaysExist &&
              this.wspSaysAndTabsObjects.wspButtonDownSaysGobjId[e.id]
            ) {
              var t = this.wspSaysAndTabsObjects.wspButtonDownSaysGobjId[e.id];
              this.updateWSPButtonSpeakableText(t);
            }
          },
          updateWSPButtonUpSpeakableText: function(e) {
            if (
              this.wspSaysAndTabsObjects.wspButtonUpSaysExist &&
              this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId[e.id]
            ) {
              var t = this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId[e.id];
              this.updateWSPButtonSpeakableText(t);
            }
          },
          setGobjPositionInDocumentBound: function() {
            var e,
              t = this.sQuery.sketch,
              n = t.gobjList.gobjects;
            if (!t.wspSaysAndTabsObjects.wspTabsExist)
              for (var i in n)
                (e = n[i]),
                  e.htmlNode &&
                    (('Text' === e.kind && e.isCompositeText()) ||
                    ('Expression' === e.kind && e.isParameter())
                      ? e.isGobjInsideDocumentBound()
                        ? e.htmlNode
                            .find(
                              '.mfs-input, .mfs-param, .wsp-parameter-sr-only'
                            )
                            .attr('tabindex', '0')
                            .removeAttr('aria-hidden')
                        : (e.htmlNode
                            .find(
                              '.mfs-input, .mfs-param, .wsp-parameter-sr-only'
                            )
                            .attr('aria-hidden', 'true')
                            .removeAttr('tabindex'),
                          e.htmlNode.find('button').attr('tabindex', '-1'))
                      : e.isGobjInsideDocumentBound()
                      ? e.htmlNode
                          .attr('tabindex', '0')
                          .removeAttr('aria-hidden')
                          .find("[role='document']")
                          .attr('tabindex', '0')
                      : e.htmlNode
                          .attr({ 'aria-hidden': 'true', tabindex: '-1' })
                          .find("[role='document']")
                          .removeAttr('tabindex'));
          },
          addDeferredCall: function(e, t) {
            var n = this;
            n._deferredGObjCalls[e.id] || (n._deferredGObjCalls[e.id] = []);
            var i = n.jobScheduler.addJob(
              function() {
                t.apply(e, [n]);
              },
              {
                done: function() {
                  var t,
                    r = n._deferredGObjCalls[e.id];
                  for (t = 0; t < r.length; ++t)
                    if (r[t] === i) {
                      r.splice(t, 1);
                      break;
                    }
                },
              }
            );
            n._deferredGObjCalls[e.id].push(i);
          },
          cancelDeferredCall: function(e) {
            var t = this;
            this._deferredGObjCalls[e.id].forEach(function(i) {
              t.jobScheduler.clearJob(i), (t._deferredGObjCalls[e.id] = n);
            });
          },
          getRenderList: function() {
            return this.gobjList.renderList;
          },
          standardGraphicsEngine: function() {
            var e = this.getOption('graphics-engine');
            return this.draw.engines[e] || this.draw.engines.canvas;
          },
          dcForGObj: function(e, t) {
            var n;
            if ('traced' === t) return this.draw.engines.trace;
            var i = this.renderRefCon.dcForGObj,
              r = i[e.id];
            return r
              ? r
              : ((n = o.layerInfo(e)),
                (r =
                  'standard' === n.engine
                    ? (i[e.id] = this.standardGraphicsEngine())
                    : (i[e.id] = this.draw.engines[n.engine])));
          },
          dcForGObjLabel: function(e) {
            if (this.renderRefCon.dcForGObjLabel)
              return this.renderRefCon.dcForGObjLabel;
            var t = 'canvas',
              n = this.draw.engines[t];
            return (
              (this.renderRefCon.dcForGObjLabel = n),
              this.renderRefCon.dcForGObjLabel
            );
          },
          translateTraceLayer: function(e, t) {
            this.traces.saturation > 0 &&
              (this.traces.translate ||
                (this.traces.translate = { dx: 0, dy: 0 }),
              (this.traces.translate.dx += e),
              (this.traces.translate.dy += t));
          },
          realizeTraceLayerTranslation: function() {
            this.traces.saturation > 0 &&
              this.traces.translate &&
              (this.traces.translate.dx || this.traces.translate.dy) &&
              (this.draw.translate(
                this.traces.translate.dx,
                this.traces.translate.dy
              ),
              (this.traces.translate.dx = 0),
              (this.traces.translate.dy = 0));
          },
          fadeTraces: function() {
            var e,
              t,
              n,
              i = Date.now();
            (e = (i - this.traces.fadeStartTime) / 1e3),
              (t = Math.exp(
                -e * (Math.log(2) / this.preferences.fadeHalfLife)
              )),
              (n = t / this.traces.appliedAlpha),
              (n += 2 * Math.random() * 0.2 - 0.2),
              0 > n && (n = 0),
              1 > n &&
                (this.draw.fade(n),
                (this.traces.saturation *= n),
                (this.traces.appliedAlpha *= n));
          },
          clearTraces: function() {
            this.draw.fade(0),
              (this.traces.saturation = 0),
              (this.traces.appliedAlpha = 1),
              (this.traces.fadeStartTime = 0),
              this.event('ClearTraces', { document: this });
          },
          renderGObj: function(e, t) {
            var n = t.traced ? 'traced' : 'normal',
              i = this.dcForGObj(e, n);
            i && e.render(i, this.renderRefCon.gobj[e.id], t);
          },
          renderBounds: function(e, t, n) {
            try {
              var i = n.getGObjGeomBounds(t),
                r = n.getGObjLabelBounds(t),
                s = { rect: i },
                a = n.standardGraphicsEngine();
              t.style.hidden ||
                (i &&
                  a.drawRectangle &&
                  ((s = { rect: i }),
                  a.drawRectangle(n.renderRefCon.geomBounds[t.id] || this, s)),
                r &&
                  a.drawRectangle &&
                  ((s = { rect: r }),
                  a.drawRectangle(n.renderRefCon.geomBounds[t.id] || this, s)));
            } catch (e) {
              (e.code = 'GSP.Error.renderBoundsException'),
                (e.message =
                  o.Strings.loc(
                    'GSP.Error.renderBoundsException',
                    t.id,
                    t.kind
                  ) + e.message),
                o.signalCaughtError(e);
            }
          },
          renderGObjLabel: function(e, t) {
            var n = t.traced ? 'traced' : 'normal',
              i = this.dcForGObjLabel(e, n);
            e.hasLabel &&
              i &&
              e.renderLabel(i, this.renderRefCon.label[e.id] || this, t);
          },
          _fadeTracesJob: null,
          startFadeJob: function(e) {
            var t = this,
              n = {
                repeat: !0,
                done: function() {
                  t._fadeTracesJob = null;
                },
              };
            (this.traces.saturation = 1),
              (this.traces.appliedAlpha <
                this.preferences.fadeSaturationFloor ||
                e) &&
                ((this.traces.appliedAlpha = 1),
                (this.traces.fadeStartTime = Date.now())),
              this.preferences.fadeTraces &&
                !o.JobScheduler.isActive(this._fadeTracesJob) &&
                (this._fadeTracesJob = this.jobScheduler.addJob(function() {
                  var e = !0;
                  return (
                    t.monitor.stateChange('fade'),
                    t.traces.saturation > t.preferences.fadeSaturationFloor
                      ? t.fadeTraces()
                      : (t.clearTraces(), (e = !1)),
                    t.setNeedsDisplay(),
                    t.monitor.stateChange('idle'),
                    e
                  );
                }, n));
          },
          stopFadeJob: function() {
            this._fadeTracesJob &&
              this.jobScheduler.clearJob(this._fadeTracesJob);
          },
          render: function() {
            function e(e, t, n) {
              var i,
                c,
                l = n.dcForGObj(t),
                u = l && l.preclear;
              try {
                (c =
                  !a &&
                  t.style.traced &&
                  n.preferences.tracesEnabled &&
                  !n.touchRegimeDisablesTracing(t) &&
                  t.state.traceConstraintFrame !== t.state.constraintFrame),
                  c &&
                    (n.renderGObj(t, { traced: !0 }),
                    (s = !0),
                    (t.state.traceConstraintFrame = t.state.constraintFrame)),
                  u &&
                    !t.style.hidden &&
                    ((i = n.getGObjGeomBounds(t)),
                    (n.renderRefCon.renderBounds[t.id] = i)),
                  (!u || o.Geom.isIntersectValidRects(r, i)) &&
                    n.renderGObj(t, { drag: a, zIndex: e });
              } catch (e) {
                (e.code = 'GSP.Error.renderObjectException'),
                  (e.message = o.Strings.loc(
                    'GSP.Error.renderObjectException',
                    t.id,
                    t.kind,
                    e
                  )),
                  o.signalCaughtError(e);
              }
            }
            function t(e, t, n) {
              var i,
                s = n.dcForGObjLabel(t),
                c = s && s.preclear;
              try {
                c &&
                  !t.style.hidden &&
                  ((i = n.getGObjLabelBounds(t)),
                  (n.renderRefCon.labelBounds[t.id] = i)),
                  (!c || o.Geom.isIntersectValidRects(r, i)) &&
                    n.renderGObjLabel(t, { sketch: n, drag: a });
              } catch (e) {
                (e.code = 'GSP.Error.renderLabelException'),
                  (e.message = o.Strings.loc(
                    'GSP.Error.renderLabelException',
                    t.id,
                    t.kind,
                    e.message
                  )),
                  o.signalCaughtError(e);
              }
            }
            function n(e) {
              return (
                'unmatchedGiven' === e.state.renderState ||
                'matchedGiven' === e.state.renderState ||
                'targetHighlit' === e.state.renderState
              );
            }
            var i,
              r,
              s = !1,
              a = !1;
            'stopped' !== this.state &&
              ((i = this.getRenderList()),
              this.monitor.stateChange('render'),
              this.isDirty &&
                (this.realizeTraceLayerTranslation(),
                (r = this.dirtyRect),
                (this.dirtyRect = null),
                (this.isDirty = !1),
                this.draw.prepareFrame(r, this.primalToViewTransform()),
                this.eachGObj(i, function(t, i, r) {
                  n(i) || e(t, i, r);
                }),
                s && this.startFadeJob(),
                this.eachGObj(i, t),
                (a = !0),
                this.eachGObj(i, function(t, i, r) {
                  (i.state.isDragging || n(i)) && e(t, i, r);
                }),
                this.getOption('debug-geom-bounds') &&
                  this.eachGObj(i, this.renderBounds),
                this.draw.cleanupFrame(r)),
              this.monitor.stateChange('idle'));
          },
          renderPrepare: function() {
            function e(e, t, n) {
              var i;
              try {
                (i = n.dcForGObj(t)),
                  i && (n.renderRefCon.gobj[t.id] = t.renderPrepare(i, {})),
                  t.hasLabel &&
                    ((i = n.dcForGObjLabel(t)),
                    i &&
                      (n.renderRefCon.label[t.id] = t.renderLabelPrepare(
                        i,
                        {}
                      ))),
                  (t.needsRenderInit = !1);
              } catch (e) {
                (e.code = 'GSP.Error.renderPrepareException'),
                  (e.message = o.Strings.loc(
                    'GSP.Error.renderPrepareException',
                    t.id,
                    t.kind,
                    e
                  )),
                  o.signalCaughtError(e);
              }
            }
            var n = t.grep(this.gobjList.renderList, function(e) {
              return e.needsRenderInit;
            });
            this.eachGObj(n, e);
          },
          renderCleanupGObj: function(e) {
            var t = this;
            try {
              var n = t.dcForGObj(e);
              n && e.renderCleanup(n, t.renderRefCon.gobj[e.id]),
                e.hasLabel &&
                  ((n = t.dcForGObjLabel(e)),
                  n && e.renderLabelCleanup(n, t.renderRefCon.label[e.id])),
                t.renderRefCon.gobj[e.id] && delete t.renderRefCon.gobj[e.id],
                t.renderRefCon.label[e.id] && delete t.renderRefCon.label[e.id],
                t.renderRefCon.dcForGObj[e.id] &&
                  delete t.renderRefCon.dcForGObj[e.id],
                t.renderRefCon.geomBounds[e.id] &&
                  delete t.renderRefCon.geomBounds[e.id],
                t.renderRefCon.renderBounds[e.id] &&
                  delete t.renderRefCon.renderBounds[e.id],
                t.renderRefCon.labelBounds[e.id] &&
                  delete t.renderRefCon.labelBounds[e.id];
            } catch (t) {
              (t.code = 'GSP.Error.renderCleanupException'),
                (t.message = o.Strings.loc(
                  'GSP.Error.renderCleanupException',
                  e.id,
                  e.kind,
                  t
                )),
                o.signalCaughtError(t);
            }
          },
          renderCleanUp: function() {
            var e = this;
            this.eachGObj(
              this.getRenderList(),
              function(t, n) {
                e.renderCleanupGObj(n);
              },
              { direction: 'reverse' }
            );
          },
          getName: function() {
            var e = this.spec.metadata;
            return e.title;
          },
          toSpecObj: function() {
            var e = {},
              n = this.gobjList.gobjects;
            (e.metadata = t.extend(!0, {}, this.metadata)),
              (e.preferences = t.extend(!0, {}, this.spec.preferences)),
              (e.objects = {});
            for (var i in n)
              n.hasOwnProperty(i) && (e.objects[i] = n[i].toSpecObj());
            return t.isEmptyObject(e.objects) && delete e.objects, e;
          },
          cleanUp: function() {
            null !== this.draw &&
              (this.event('UnloadPage', { document: this }),
              this.eachGObj(
                function(e, t, n) {
                  try {
                    t.destroy && t.destroy();
                  } catch (e) {
                    (e.code = 'GSP.Error.destroyObjectException'),
                      (e.message = o.Strings.loc(
                        'GSP.Error.destroyObjectException',
                        t && t.id,
                        t && t.kind,
                        e
                      )),
                      o.signalCaughtError(e);
                  }
                },
                { direction: 'reverse' }
              ),
              this.canvasNode && this.canvasNode.off(),
              this.renderCleanUp(),
              this.draw && this.draw.destroy(),
              (this.gobjList = null),
              (this.draw = null),
              o.logPerf(this.monitor.report(this.getName(), 'final')));
          },
          getAuthorPreference: function(e) {
            var t = this.document.getAuthorPreference(e);
            return Array.isArray(t)
              ? 'all' === t[0] || t.indexOf(parseInt(this.metadata.id, 10)) >= 0
              : t;
          },
          constrainAndRedraw: function() {
            this.constrain(), this.render();
          },
          _displayJob: null,
          setNeedsDisplay: function() {
            var e = this;
            o.JobScheduler.isActive(e._displayJob) ||
              (e._displayJob = this.jobScheduler.addJob(
                function() {
                  return e.constrain(), e.render(), (e._displayJob = null), !1;
                },
                { priority: 'render' }
              ));
          },
          onLoad: function(e) {
            var t;
            if (this.gobjList.constraintList) {
              for (t = 0; t < this.gobjList.constraintList.length; t += 1)
                this.gobjList.constraintList[t].onLoad(this, e);
              this.sortAllGobj();
            }
            this.setGobjPositionInDocumentBound();
          },
          onUnload: function() {
            var e;
            if (this.gobjList.constraintList)
              for (e = 0; e < this.gobjList.constraintList.length; e += 1)
                this.gobjList.constraintList[e].onUnload();
          },
          sortAllGobj: function() {
            function e(e) {
              var t = e.length - 1;
              return e.every(function(n, i) {
                return t > i ? e[i] <= e[i + 1] : !0;
              });
            }
            var n = 0,
              i = this.wspSaysAndTabsObjects.wspTabsGobjsId,
              r = this.selector('.wsp-text-layer');
            if (this.wspSaysAndTabsObjects.wspTabsExist)
              r.find('.wsp-accessible').each(function() {
                i.indexOf(t(this).attr('wsp-id')) > -1
                  ? (r.append(t('[wsp-id=' + i[n] + ']')), n++)
                  : t(this).attr({ 'aria-hidden': 'true', tabindex: '-1' });
              });
            else {
              var s = [];
              if (
                (this.selector('.wsp-accessible').each(function(e, n) {
                  s.push(t(n).attr('wsp-id'));
                }),
                e(s))
              )
                return;
              r.find('.wsp-accessible')
                .sort(function(e, n) {
                  return t(e).attr('wsp-id') - t(n).attr('wsp-id');
                })
                .appendTo(r);
            }
          },
          start: function(e) {
            var t = this;
            return (
              'started' !== t.state
                ? ((t.state = 'started'),
                  t.constrainAndRedraw(),
                  o.logPerf(t.monitor.report(t.getName(), 'init')),
                  (t.monitor = new o.PerfMonitor()),
                  (e = e ? e : ''),
                  t.onLoad(e),
                  t.getOption('perfTestMode') &&
                    t.jobScheduler.addJob(
                      function() {
                        (t.dirtyRect = o.Geom.kInfiniteRect),
                          (t.isDirty = !0),
                          t.setNeedsDisplay();
                      },
                      { repeat: !0 }
                    ))
                : o.signalErrorWithCode('GSP.Error.invalidSketchStart'),
              this
            );
          },
          getPageId: function() {
            return this.metadata.id;
          },
          stop: function() {
            return (
              'stopped' !== this.state
                ? (this.popAllTouchRegimes(),
                  this.jobScheduler.clearAllJobs(),
                  (this._displayJob = null),
                  this.onUnload(),
                  (this.state = 'stopped'),
                  this.cleanUp())
                : o.signalErrorWithCode('GSP.Error.invalidSketchStop'),
              this
            );
          },
          pause: function() {
            return (
              this.jobScheduler.clearAllJobs(),
              (this._displayJob = null),
              o.log('Paused sketch.'),
              this
            );
          },
          resume: function() {
            return this.setNeedsDisplay(), o.log('Resumed sketch.'), this;
          },
          cloneGObjects: function(e) {
            var t,
              n,
              i,
              r,
              s,
              o = [],
              a = {};
            for (t = 0; t < e.length; t++)
              (i = Object.create(e[t])),
                (a[i.id] = i),
                o.push(i),
                (i.isClone = !0);
            for (t = 0; t < o.length; t++) {
              (i = o[t]), (r = i.parents), (i.parents = {});
              for (n in r) (s = r[n]), (i.parents[n] = a[s.id] ? a[s.id] : s);
              for (
                r = i.parentsList, i.parentsList = [], n = 0;
                n < r.length;
                n++
              )
                (s = r[n]), i.parentsList.push(a[s.id] ? a[s.id] : s);
              i.initializeClone(e[t]);
            }
            return o;
          },
          getDisplayObjForGObj: function(e) {
            return this.renderRefCon.gobj[e.id];
          },
          hitGObj: function(e, t) {
            function i(i, p) {
              if (f && f(p) === !1) return n;
              if (
                r(p) &&
                o.Geom.isIntersectRects(p.getGeomBounds(), e) &&
                ((l = p.hitTest(e, d, g)),
                (c = Math.floor(o.layerInfo(p).z_index)),
                0 === u.length && (a = c),
                l && (!m || m(p)))
              ) {
                if (1 === h && t.assumeArrowSelectable)
                  if (0 === u.length) u.push(p);
                  else {
                    if (a > c) return !1;
                    p.style.selectable
                      ? (!u[0].style.selectable || +p.id > +u[0].id) &&
                        (u[0] = p)
                      : !u[0].style.selectable &&
                        +p.id > +u[0].id &&
                        (u[0] = p);
                  }
                else s(p);
                if (l !== !0) return !1;
                if (h > 1 && u.length === h) return !1;
              }
              return n;
            }
            if (((t = t || {}), this.focusedGobj))
              return { hitArray: [this.focusedGobj] };
            var r,
              s,
              a,
              c,
              l = !1,
              u = [],
              d = t.hotSpot,
              h = t.maxResults || 1,
              p = t.gobjArray || this.gobjList.renderList,
              f = t.filter,
              m = t.postHitFilter,
              g = t.gobjHitTestOptions,
              b = {};
            return (
              t.assumeArrowSelectable || t.unselectableTapOK
                ? ((r = function(e) {
                    var t,
                      n = e.style.selectable;
                    return (
                      (e.style.selectable = !0),
                      (t = e.isHittable()),
                      (e.style.selectable = n),
                      t
                    );
                  }),
                  (s = function(e) {
                    var t,
                      n = u.length,
                      i = Math.floor(o.layerInfo(e).z_index);
                    if (e.style.selectable)
                      for (
                        ;
                        n > 0 &&
                        ((t = u[n - 1]),
                        !(
                          t.style.selectable ||
                          i < Math.floor(o.layerInfo(t).z_index)
                        ));
                        n--
                      );
                    u.splice(n, 0, e);
                  }))
                : ((r = function(e) {
                    return e.isHittable();
                  }),
                  (s = function(e) {
                    u.push(e);
                  })),
              this.eachGObj(p, i, { direction: 'reverse' }),
              t.maxResults === n ? (b.hitGObj = u[0]) : (b.hitArray = u),
              l !== !0 && (1 === u.length || c >= a) && (b.customTracker = l),
              b
            );
          },
          hitLabel: function(e) {
            function t(t, r) {
              return !r.style.hidden &&
                r.labelRenderBounds &&
                r.style.label.showLabel &&
                o.Geom.isIntersectRects(r.labelRenderBounds, e)
                ? ((i = r), !1)
                : n;
            }
            var i;
            return (
              this.eachGObj(this.gobjList.renderList, t, {
                direction: 'reverse',
              }),
              i
            );
          },
          eachGObj: function(e, n, i) {
            var r,
              s,
              o,
              a,
              c,
              l = this;
            for (
              t.isArray(e) ||
                ((i = n), (n = e), (e = l.gobjList.constraintList)),
                r = t.extend({ direction: 'forward' }, i),
                c = 'forward' === r.direction,
                s = 0;
              s < e.length &&
              ((o = c ? e[s] : e[e.length - s - 1]),
              (a = n.call(o, s, o, l)),
              !1 !== a);
              s++
            );
            return this;
          },
          findExistingCoordSys: function(e) {
            var t,
              n,
              i = null,
              r = -1,
              s = 6;
            return (
              e &&
                ((t = e.xAxisTrig ? 'trigonometric' : 'decimal'),
                (n = e.yAxisTrig ? 'trigonometric' : 'decimal')),
              this.eachGObj(function(e, o) {
                var a = 0;
                if ('CoordSys' === o.constraint && o.state.exists) {
                  if (
                    (o.isVisible() && (a += 4),
                    o.getParent('axisX').style.tickNumbering === t && (a += 1),
                    o.getParent('axisY').style.tickNumbering === n && (a += 1),
                    a === s)
                  )
                    return (i = o), !1;
                  a > r && ((i = o), (r = a));
                }
              }),
              i
            );
          },
          verifyFromSpec: function(e) {
            var t = { success: !0, failures: {} },
              n = {};
            return (
              this.eachGObj(function(e, i, r) {
                function s(e) {
                  try {
                    return i.verificationString(e);
                  } catch (e) {
                    return 'Verification Failed: ' + String(e);
                  }
                }
                var o, a;
                i.eachParent(function(e, t) {
                  return n[t.id] ? ((n[i.id] = !0), !1) : void 0;
                }),
                  n[i.id] ||
                    ((a = r.spec.objects[i.id].debug),
                    (o = a ? s(a) : 'no expected data'),
                    'NO_VERIFICATION' === o
                      ? (n[i.id] = !0)
                      : '' !== o &&
                        ((t.success = !1),
                        (t.failures[i.id] = o),
                        (n[i.id] = !0)));
              }),
              t
            );
          },
          selector: function(e) {
            return t(e, this.canvasNode);
          },
          getOption: function(e) {
            var t = this.options[e];
            return t !== n ? t : o.gOptions[e];
          },
          translate: function(e, n, i) {
            var r, s;
            if (i) {
              if (this.preferences.limitScrolling) {
                var a = this.metadata.sketchRect,
                  c = this.spec.metadata.sketchRect,
                  l = a.right - a.left,
                  u = a.bottom - a.top,
                  d = c.right - c.left,
                  h = c.bottom - c.top;
                (s = t.extend(!0, {}, a)),
                  d > l && ((s.left = c.left), (s.right = c.right)),
                  h > u && ((s.top = c.top), (s.bottom = c.bottom));
              } else {
                s = t.extend(!0, {}, this.significantBounds);
                var p =
                    this.metadata.sketchRect.right -
                    this.metadata.sketchRect.left,
                  f =
                    this.metadata.sketchRect.bottom -
                    this.metadata.sketchRect.top;
                s = o.Geom.insetRect(s, -p / 2, -f / 2);
              }
              0 > e
                ? ((r = s.left - this.metadata.sketchRect.left),
                  (e = r > e ? r : e))
                : e > 0 &&
                  ((r = s.right - this.metadata.sketchRect.right),
                  (e = e > r ? r : e)),
                0 > n
                  ? ((r = s.top - this.metadata.sketchRect.top),
                    (n = r > n ? r : n))
                  : n > 0 &&
                    ((r = s.bottom - this.metadata.sketchRect.bottom),
                    (n = n > r ? r : n));
            }
            this.translateTraceLayer(e, n),
              (0 !== e || 0 !== n) &&
                ((this.metadata.sketchRect.left += e),
                (this.metadata.sketchRect.right += e),
                (this.metadata.sketchRect.top += n),
                (this.metadata.sketchRect.bottom += n),
                this.invalidateRect(this.sketchRect()),
                (this.isDirty = !0),
                this.setNeedsDisplay());
          },
          primalToViewTransform: function() {
            return new o.AffineTransform({
              m00: 1,
              m01: 0,
              m10: 0,
              m11: 1,
              m20: -this.metadata.sketchRect.left,
              m21: -this.metadata.sketchRect.top,
            });
          },
          viewToPrimalTransform: function() {
            return new o.AffineTransform({
              m00: 1,
              m01: 0,
              m10: 0,
              m11: 1,
              m20: this.metadata.sketchRect.left,
              m21: this.metadata.sketchRect.top,
            });
          },
          sketchRect: function() {
            return t.extend(!0, {}, this.metadata.sketchRect);
          },
          pushTouchRegime: function(e) {
            this._touchRegimes.push(e), (e.isPushed = !0);
          },
          popTouchRegime: function() {
            var e = this._touchRegimes.pop();
            return (
              (e.isPushed = !1),
              e.delegate &&
                e.delegate.regimeDidPop &&
                e.delegate.regimeDidPop(e),
              e
            );
          },
          popAllTouchRegimesIncluding: function(e) {
            if (e.isPushed) {
              var t;
              do t = this.popTouchRegime();
              while (t !== e);
            }
          },
          popAllTouchRegimes: function() {
            this.hasTouchRegimes() &&
              this.popAllTouchRegimesIncluding(this._touchRegimes[0]);
          },
          hasTouchRegimes: function() {
            return this._touchRegimes.length > 0;
          },
          currentTouchRegime: function() {
            var e = this._touchRegimes.length - 1;
            if (0 > e)
              throw o.createError(
                'currentTouchRegime called with no touch regime active'
              );
            return this._touchRegimes[e];
          },
          touchRegimeBlocksOtherButtons: function() {
            return (
              this.hasTouchRegimes() &&
              this.currentTouchRegime().blocksOtherButtons()
            );
          },
          touchRegimeDisablesTracing: function(e) {
            var t = this.currentTouchRegime();
            return 'ToolRegime' !== t.name
              ? !1
              : t.toolplaySession.constructedObjects[e.id]
              ? !0
              : !1;
          },
          getGivenMatchedToCandidate: function(e) {
            var t,
              i = this.toolController && this.toolController.activeRegime;
            return i &&
              (t = i.toolplaySession.existingMatchedGivenForMergeCandidate(e))
              ? t.given
              : n;
          },
          mergeGobjToCandidate: function(e, n, i) {
            function r(e) {
              ('Point' === e.kind ||
                'Straight' === e.kind ||
                e.genus.match(/Parameter/)) &&
                e.children.forEach(function(t, n) {
                  var s, o;
                  for (s = n + 1; s < e.children.length; s++)
                    (o = e.children[s]),
                      t !== o &&
                        t.constraint === o.constraint &&
                        t.canMergeTo &&
                        t.canMergeTo(o) &&
                        (u.mergeToGObj(o, t, i), r(t));
                });
            }
            function s(e, t) {
              e.children.forEach(function(e, n) {
                t.children.forEach(function(t, n) {
                  e === t && d.push(e);
                });
              });
            }
            function o() {
              d.forEach(function(e, t) {
                e.collapseDoubledParent && e.collapseDoubledParent(n);
              });
            }
            function a(e, t) {
              e.style.traced && (t.style.traced = e.style.traced),
                e.style.label &&
                  e.style.label.showLabel &&
                  (t.style.label.showLabel = !0);
            }
            var c,
              l = this,
              u = l.gobjList,
              d = [];
            return (
              'Pegged' === n.constraint && (n = n.parents.text),
              s(e, n),
              u.mergeToGObj(e, n, i),
              o(),
              r(n),
              u.constraintList.sort(function(e, t) {
                return e.topologicalIndex - t.topologicalIndex;
              }),
              t.each(u.constraintList, function(e, t) {
                t.topologicalIndex = e;
              }),
              l.generatedLabels &&
                l.generatedLabels[e.id] &&
                ((c = l.labelPool.restoreSavedState()),
                l.labelPool.saveState(c),
                (l.generatedLabels[e.id] = !1)),
              u.mergeGObjsInList(e.id, n.id),
              a(e, n),
              n.invalidateGeom(),
              n
            );
          },
          _mergeGObjToSpecGObj: function(e, t) {
            var n,
              i = this.gobjList,
              r = {},
              s = '' + o.ObjectGraph.getNextFreeIdNumber(i.constraintList);
            return (
              (r[s] = t),
              this.constructGObjects(r),
              (n = i.gobjects[s]),
              this.mergeGobjToCandidate(e, n),
              n
            );
          },
          putGivenOnPath: function(e, t, n) {
            var i = {
              kind: 'Point',
              genus: 'PointOnPath',
              parents: { path: t.id },
              value: n,
              constraint: 'PointOnPath',
              label: e.label,
              style: e.style,
            };
            return this._mergeGObjToSpecGObj(e, i);
          },
          findPotentialIntersection: function(e, t, n, i) {
            function r(e) {
              return (
                e.isOfKind('Circle') ||
                e.isOfKind('Straight') ||
                'Arc' === e.kind
              );
            }
            function s(t) {
              var r,
                s,
                l,
                u,
                d,
                h,
                p = e.isOfKind('Straight'),
                f = t.isOfKind('Straight'),
                m = p ? e : e.getGeometricArc(),
                g = f ? t : t.getGeometricArc(),
                b = p || 0 === m.orientation,
                v = f || 0 === g.orientation;
              return (
                b
                  ? v
                    ? ((r = o.Geom.LineLineIntersection(m, g)), (h = !0))
                    : ((u = !0), (s = o.Geom.CircleStraightIntersection(g, m)))
                  : v
                  ? (s = o.Geom.CircleStraightIntersection(m, g))
                  : ((s = o.Geom.CircleCircleIntersection(m, g)), (h = !0)),
                s &&
                  (s[0] && n.distance(s[0]) <= i
                    ? (r = s[0])
                    : s[1] && n.distance(s[1]) <= i && ((r = s[1]), (l = !0))),
                r &&
                  r.isFinite() &&
                  ((d =
                    p && f
                      ? 'Intersection'
                      : l
                      ? 'Intersection2'
                      : 'Intersection1'),
                  (a = {
                    path1: u ? t : e,
                    path2: u ? e : t,
                    location: r,
                    constraint: d,
                  })),
                h && a ? ((c = a), !0) : void (c || (c = a))
              );
            }
            var a, c;
            if (r(e)) {
              i *= 2;
              var l,
                u = {
                  hotSpot: n,
                  assumeArrowSelectable: !0,
                  gobjArray: t.filter(function(t) {
                    return t !== e;
                  }),
                  filter: r,
                  postHitFilter: s,
                };
              return (
                (l = this.hitGObj(
                  {
                    left: n.x - i,
                    top: n.y - i,
                    bottom: n.y + i,
                    right: n.x + i,
                  },
                  u
                )),
                c && n.distance(c.location) < i ? c : void 0
              );
            }
          },
          findIntersections: function(e, t, n) {
            for (var i, r, s, o = e.slice(0), a = []; o.length > 1; )
              for (i = o.shift(), s = 0; s < o.length; s++)
                (r = this.findPotentialIntersection(i, [o[s]], t, n)),
                  r && a.push(r);
            return a.length ? a : void 0;
          },
          putGivenOnIntersection: function(e, t) {
            function n(e, t) {
              var n = {
                kind: 'Point',
                constraint: e.constraint,
                genus: 'Intersection',
                label: t.label,
                style: t.style,
              };
              switch (e.constraint) {
                case 'Intersection':
                  n.parents = { line0: e.path1.id, line1: e.path2.id };
                  break;
                case 'Intersection1':
                case 'Intersection2':
                  n.parents = { circle: e.path1.id, obj: e.path2.id };
                  break;
                default:
                  throw o.createError(
                    'tool.putGivenOnIntersection() asked to create unsupported intersection constraint'
                  );
              }
              return n;
            }
            var i = n(t, e);
            return this._mergeGObjToSpecGObj(e, i);
          },
          init: function(e, n, i) {
            var r = this;
            this.getWSPKeysObjectFromSpecs(n.objects),
              (r.document = e),
              (r.state = 'created'),
              (r.Bap = new o.Bap(r)),
              (r.MotionManager = new o.MotionManager(r)),
              (r.labelPool = o.LabelPool.createInSketch(r)),
              (r.toolController = o.ToolController.createInSketch(r)),
              (r.Scroll = o.Scroll(r)),
              (r.options = t.extend(!0, {}, i, n.options)),
              (r.metadata = t.extend(!0, {}, n.metadata)),
              (r.preferences = t.extend(!0, {}, o.Prefs, n.preferences)),
              r.preferences.colorableComponents.Background['composite-mode'] ||
                (r.preferences.colorableComponents.Background[
                  'composite-mode'
                ] =
                  'white' === r.preferences.colorableComponents.Background.color
                    ? 'destination'
                    : 'source-over'),
              (r.config = {}),
              n.config && t.extend(r.config, n.config),
              (r.preferences.tracesEnabled = r.getAuthorPreference(
                'enabletracing'
              )),
              (r.sQuery = o.SQuery(r)),
              (r.gobjList = new o.GObjList()),
              (r.monitor = new o.PerfMonitor()),
              (r.spec = n),
              (r.jobScheduler = o.JobScheduler.create()),
              (r._deferredGObjCalls = {}),
              o.log('Initializing gobjs'),
              r.initGObjects(r.spec.objects),
              (r.constraintFrame = 0);
          },
          attachToNode: function(e) {
            var i,
              r,
              s,
              a,
              c = this,
              l = c.document,
              u = l.docSpec.metadata.width,
              d = l.docSpec.metadata.height,
              h = {};
            (c._touchRegimes = []),
              c.pushTouchRegime(o.DisplayRegime.createInSketch(c)),
              (a = t('.wsp-sketch-container', e[0])),
              a.empty(),
              a.append('<div class="wsp-clip-node"></div>'),
              (s = c.canvasNode = t('.wsp-clip-node', e[0])),
              s.css({ width: u, height: d }),
              (c.drawRefCon = {}),
              (c.anchorNode = e),
              (c.baseNode = t('.wsp-base-node', e)),
              (h.clip = 'rect(auto, auto, auto, auto)'),
              (i = parseInt(e.css('width'), 10)),
              (r = parseInt(e.css('height'), 10)),
              c.metadata.sketchRect === n
                ? (c.metadata.sketchRect = { top: 0, left: 0 })
                : ((i =
                    c.metadata.sketchRect.right - c.metadata.sketchRect.left),
                  (r =
                    c.metadata.sketchRect.bottom - c.metadata.sketchRect.top)),
              (c.metadata.sketchRect.bottom = c.metadata.sketchRect.top + r),
              (c.metadata.sketchRect.right = c.metadata.sketchRect.left + i),
              'source-over' ===
                c.preferences.colorableComponents.Background[
                  'composite-mode'
                ] &&
                (h['background-color'] =
                  c.preferences.colorableComponents.Background.color),
              s.css(h),
              (c.draw = o.draw.create({ rootNode: s, width: u, height: d })),
              s.append(t('<div class="wsp-effects"></div>')),
              (c.traces = { saturation: 1, appliedAlpha: 1, fadeStartTime: 0 }),
              (c.renderRefCon = {
                gobj: {},
                label: {},
                dcForGObj: {},
                geomBounds: {},
                renderBounds: {},
                labelBounds: {},
              }),
              (c.isDirty = !1),
              (c.dirtyRect = null),
              l.gobjectEventHandlers[c.getPageId()] ||
                l.createSketchEventHandlersForPage(this),
              (c.isTouchScreenDevice = c.isTouchScreen()),
              c.isTouchScreenDevice ||
                o.mouseTouch(c.canvasNode, { sketch: c }),
              c.canvasNode.on('touchstart', function(e) {
                return c.handleTouchStart(e);
              }),
              c.canvasNode.on('touchmove', function(e) {
                return c.handleTouchMove(e);
              }),
              c.canvasNode.on('touchend touchcancel', function(e) {
                return c.handleTouchEnd(e);
              }),
              c.renderPrepare();
          },
          saveTraces: function() {
            var e,
              n,
              i = this.metadata.id;
            if (0 !== this.traces.saturation && !this.preferences.fadeTraces)
              return (
                (e = t(this.baseNode).find(
                  '.wsp-clip-node canvas:first-child'
                )[0]),
                (n = e.toDataURL()),
                (this.document.pageData[i].session.traceData = n),
                n
              );
          },
          restoreTraces: function() {
            var e,
              n,
              i,
              r,
              s = this.metadata.id,
              o = t(this.baseNode).find('.wsp-clip-node canvas:first-child')[0],
              a = this.document.pageData[s].session,
              c = a.traceData;
            c &&
              ((e = o.getContext('2d')),
              (i = o.clientWidth),
              (r = o.clientHeight),
              (n = new Image()),
              (n.onload = function() {
                e.drawImage(n, 0, 0, n.width, n.height, 0, 0, i, r);
              }),
              (n.src = c),
              delete a.traceData);
          },
          getWSPKeysObjectFromSpecs: function(e) {
            this.wspSaysAndTabsObjects = {
              wspSaysExist: !1,
              wspSaysGobjsId: [],
              wspTabsExist: !1,
              wspTabsGobjsId: [],
              wspButtonUpSaysExist: !1,
              wspButtonUpSaysGobjId: {},
              wspButtonDownSaysExist: !1,
              wspButtonDownSaysGobjId: {},
            };
            for (var n in e)
              if (
                'ActionButtonShow' === e[n].constraint ||
                'ActionButtonHide' === e[n].constraint ||
                'ActionButtonToggleHideShow' === e[n].constraint
              ) {
                if ('WSP-SAYS' === e[n].label) {
                  this.wspSaysAndTabsObjects.wspSaysExist = !0;
                  for (var i in e[n].parents)
                    this.wspSaysAndTabsObjects.wspSaysGobjsId.push(
                      e[n].parents[i]
                    );
                }
                if ('WSP-TABS' === e[n].label) {
                  this.wspSaysAndTabsObjects.wspTabsExist = !0;
                  for (var r in e[n].parents)
                    -1 ===
                      this.wspSaysAndTabsObjects.wspTabsGobjsId.indexOf(
                        e[n].parents[r]
                      ) &&
                      this.wspSaysAndTabsObjects.wspTabsGobjsId.push(
                        e[n].parents[r]
                      );
                }
                'WSP-ON-BUTTON-DOWN-SAYS' === e[n].label &&
                  ((this.wspSaysAndTabsObjects.wspButtonDownSaysExist = !0),
                  t.extend(
                    this.wspSaysAndTabsObjects.wspButtonDownSaysGobjId,
                    this.getGobjForButtonEvents(e, n)
                  )),
                  'WSP-ON-BUTTON-UP-SAYS' === e[n].label &&
                    ((this.wspSaysAndTabsObjects.wspButtonUpSaysExist = !0),
                    t.extend(
                      this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId,
                      this.getGobjForButtonEvents(e, n)
                    ));
              }
          },
          getGobjForButtonEvents: function(e, t) {
            var n = {},
              i = [];
            for (var r in e[t].parents)
              'Button' === e[e[t].parents[r]].kind
                ? (n[e[t].parents[r]] = [])
                : i.push(e[t].parents[r]);
            for (var s in n) n[s] = i;
            return n;
          },
        };
        return function(e, t, n) {
          var i = null;
          if ('string' == typeof t)
            try {
              t = JSON.parse(t);
            } catch (e) {
              return o.signalErrorWithCode('GSP.Error.invalidSketch'), null;
            }
          return (i = Object.create(s)), i.init(e, t, n), i;
        };
      })()),
      (o.Sketch.allConstraints = function() {
        var e,
          t,
          n = [];
        for (e in o.gConstraints)
          o.gConstraints.hasOwnProperty(e) &&
            ((t = o.gConstraints[e]),
            t.doc && t.doc.usage && !t.doc.usage.abstract && n.push(e));
        return n;
      }),
      (o.Sketch.supportCheck = function(e, t) {
        var n,
          i,
          r = {
            count: 0,
            supportedCount: 0,
            unsupported: {},
            constraints: {},
            support: 'full',
            message:
              'All Sketch Objects: <span class="expected">Supported</span>',
          },
          s = e.objects;
        for (n in s)
          if (s.hasOwnProperty(n)) {
            var a = s[n],
              c = o.getKindObj(a.kind),
              l = o.getConstraintObj(a.constraint),
              u = c && c.kindSupportsSpecObj(a, s),
              d = l && l.constraintSupportsSpecObj(a, s);
            r.count++,
              u && d
                ? ((r.constraints[a.constraint] =
                    r.constraints[a.constraint] || 0),
                  r.constraints[a.constraint]++,
                  r.supportedCount++)
                : ((i = {}),
                  u || (i.kind = a.kind),
                  d || (i.constraint = a.constraint),
                  (r.unsupported[n] = i));
          }
        return (
          r.supportedCount !== r.count &&
            ((r.support = 'none'),
            (r.message =
              'Some Sketch Objects: <span class="error">Not Supported</span>')),
          r
        );
      }),
      (o.ControlList = (function() {
        function e(e) {
          var t,
            i,
            r = '{';
          for (t = 0; t < n.length; t++)
            (i = e[n[t]]),
              'gobj' === n[t] && 'object' == typeof i && (i = i.id),
              t > 0 && (r += ','),
              (r += '"' + n[t] + '":' + i);
          return (r += '}');
        }
        var n = [
          'gobj',
          'isController',
          'isDragRoot',
          'isTransformParent',
          'controlIndex',
        ];
        return {
          fromExternalList: function(e, n) {
            var i,
              r,
              s = [];
            for (i = 0; i < e.length; i++)
              (r = t.extend(!0, {}, e[i])),
                (r.gobj = n.gobjList.gobjects[r.gobj]),
                s.push(r);
            return s;
          },
          toString: function(t) {
            var n,
              i = '';
            for (n = 0; n < t.length; n++) n > 0 && (i += ','), (i += e(t[n]));
            return i;
          },
        };
      })()),
      (o.BapEdgeInfo = {
        Free: { Default: { edgeType: 'dEdge', sortIndex: 0 } },
        PictureFree: { Default: { edgeType: 'dEdge', sortIndex: 0 } },
        Midpoint: { path: { edgeType: 'dEdge', sortIndex: 0 } },
        Segment: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
        },
        CircleFromTwoPoints: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
        },
        CircleByRadius: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          radius: { edgeType: 'iEdge', sortIndex: 1 },
        },
        Perpendicular: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          line: { edgeType: 'iEdge', sortIndex: 1 },
        },
        Parallel: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          line: { edgeType: 'iEdge', sortIndex: 1 },
        },
        AngleBisector: {
          A: { edgeType: 'dEdge', sortIndex: 0 },
          B: { edgeType: 'dEdge', sortIndex: 1 },
          C: { edgeType: 'dEdge', sortIndex: 2 },
        },
        PolygonFromPoints: { Default: { edgeType: 'dEdge', sortIndex: 0 } },
        Intersection: {
          line0: { edgeType: 'dEdge', sortIndex: 0 },
          line1: { edgeType: 'dEdge', sortIndex: 1 },
        },
        CircleInterior: { circle: { edgeType: 'dEdge', sortIndex: 0 } },
        Intersection1: {
          obj: { edgeType: 'dEdge', sortIndex: 0 },
          circle: { edgeType: 'dEdge', sortIndex: 1 },
        },
        Intersection2: {
          obj: { edgeType: 'dEdge', sortIndex: 0 },
          circle: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PointOnPath: { path: { edgeType: 'iEdge', sortIndex: 0 } },
        PointOnPolygonEdge: { path: { edgeType: 'iEdge', sortIndex: 0 } },
        IterateMap: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        IterateMapByParametricDepth: {
          parameter: { edgeType: 'zEdge', sortIndex: 0 },
          Default: { edgeType: 'zEdge', sortIndex: 1 },
        },
        IterateImage: {
          source: { edgeType: 'dEdge', sortIndex: 0 },
          map: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PointTerminalIteration: { image: { edgeType: 'dEdge', sortIndex: 0 } },
        TranslateVector: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          p0: { edgeType: 'iEdge', sortIndex: 1 },
          p1: { edgeType: 'iEdge', sortIndex: 2 },
        },
        TranslateFixXFixY: { source: { edgeType: 'rEdge', sortIndex: 0 } },
        TranslateFixXMeasureY: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          measure: { edgeType: 'mEdge', sortIndex: 1 },
        },
        TranslateMeasureXFixY: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          measure: { edgeType: 'mEdge', sortIndex: 1 },
        },
        TranslateMeasureXMeasureY: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          measureX: { edgeType: 'mEdge', sortIndex: 1 },
          measureY: { edgeType: 'mEdge', sortIndex: 2 },
        },
        TranslateFixDistFixAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
        },
        TranslateFixDist3PtAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          A: { edgeType: 'iEdge', sortIndex: 1 },
          B: { edgeType: 'iEdge', sortIndex: 2 },
          C: { edgeType: 'iEdge', sortIndex: 3 },
        },
        TranslateFixDistMeasureAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          measure: { edgeType: 'mEdge', sortIndex: 1 },
        },
        TranslateFixDistAngleMarker: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          marker: { edgeType: 'mEdge', sortIndex: 1 },
        },
        TranslateMeasureDistFixAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          distance: { edgeType: 'mEdge', sortIndex: 1 },
        },
        TranslateMeasureDist3PtAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          A: { edgeType: 'iEdge', sortIndex: 1 },
          B: { edgeType: 'iEdge', sortIndex: 2 },
          C: { edgeType: 'iEdge', sortIndex: 3 },
          distance: { edgeType: 'mEdge', sortIndex: 4 },
        },
        TranslateMeasureDistMeasureAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          angle: { edgeType: 'mEdge', sortIndex: 1 },
          distance: { edgeType: 'mEdge', sortIndex: 2 },
        },
        TranslateMeasureDistAngleMarker: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          marker: { edgeType: 'mEdge', sortIndex: 1 },
          distance: { edgeType: 'mEdge', sortIndex: 2 },
        },
        Rotate: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
        },
        Rotate3: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          A: { edgeType: 'iEdge', sortIndex: 2 },
          B: { edgeType: 'iEdge', sortIndex: 3 },
          C: { edgeType: 'iEdge', sortIndex: 4 },
        },
        RotateMeasureAngle: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          angle: { edgeType: 'mEdge', sortIndex: 2 },
        },
        RotateAngleMarker: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          angle: { edgeType: 'tEdge', sortIndex: 2 },
        },
        DilateFixFactor: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
        },
        Dilate2SegRatio: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          seg0: { edgeType: 'mEdge', sortIndex: 2 },
          seg1: { edgeType: 'mEdge', sortIndex: 3 },
        },
        Dilate3PtRatio: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          A: { edgeType: 'iEdge', sortIndex: 2 },
          B: { edgeType: 'iEdge', sortIndex: 3 },
          C: { edgeType: 'iEdge', sortIndex: 4 },
        },
        DilateMeasureFactor: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          center: { edgeType: 'tEdge', sortIndex: 1 },
          measure: { edgeType: 'mEdge', sortIndex: 2 },
        },
        Reflect: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          mirror: { edgeType: 'tEdge', sortIndex: 1 },
        },
        GlideReflect: {
          source: { edgeType: 'rEdge', sortIndex: 0 },
          vector: { edgeType: 'tEdge', sortIndex: 1 },
        },
        GeomLocus: {
          drivenObject: { edgeType: 'dEdge', sortIndex: 0 },
          domainObject: { edgeType: 'iEdge', sortIndex: 1 },
          driverObject: { edgeType: 'iEdge', sortIndex: 2 },
          Default: { edgeType: 'iEdge', sortIndex: 3 },
        },
        MeasurementLength: { path: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementDistance: {
          p0: { edgeType: 'zEdge', sortIndex: 0 },
          obj0: { edgeType: 'zEdge', sortIndex: 1 },
        },
        MeasurementPerimeter: { shape: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementCircumference: {
          shape: { edgeType: 'zEdge', sortIndex: 0 },
        },
        MeasurementAngle: {
          p0: { edgeType: 'zEdge', sortIndex: 0 },
          p1: { edgeType: 'zEdge', sortIndex: 1 },
          p2: { edgeType: 'zEdge', sortIndex: 2 },
        },
        MeasurementAngleMarker: { marker: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementArea: { shape: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementArcAngle: { arc: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementArcOnCircleAngle: {
          circle: { edgeType: 'zEdge', sortIndex: 0 },
          p0: { edgeType: 'zEdge', sortIndex: 1 },
          p1: { edgeType: 'zEdge', sortIndex: 2 },
          p2: { edgeType: 'zEdge', sortIndex: 3 },
        },
        MeasurementArcLength: { arc: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementArcOnCircleLength: {
          circle: { edgeType: 'zEdge', sortIndex: 0 },
          p0: { edgeType: 'zEdge', sortIndex: 1 },
          p1: { edgeType: 'zEdge', sortIndex: 2 },
          p2: { edgeType: 'zEdge', sortIndex: 3 },
        },
        GeometricSlope: { straight: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementRadius: { shape: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementRatio: {
          obj0: { edgeType: 'zEdge', sortIndex: 0 },
          obj1: { edgeType: 'zEdge', sortIndex: 1 },
          obj2: { edgeType: 'zEdge', sortIndex: 2 },
        },
        Calculation: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementRectCoordinates: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        LinearEquation: {
          straight: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        QuadraticEquation: {
          circle: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        HorizontalUnitPoint: { origin: { edgeType: 'iEdge', sortIndex: 0 } },
        VerticalUnitPoint: { origin: { edgeType: 'iEdge', sortIndex: 0 } },
        UnitPointInternalSquare: {
          unitPoint: { edgeType: 'rEdge', sortIndex: 0 },
        },
        UnitPointInternalRectangle: {
          unitPoint: { edgeType: 'iEdge', sortIndex: 0 },
        },
        UnitPointExternalSquare: { axis: { edgeType: 'dEdge', sortIndex: 0 } },
        UnitPointExternalRectangle: {
          axis: { edgeType: 'iEdge', sortIndex: 0 },
        },
        AxisInternalDist: {
          origin: { edgeType: 'dEdge', sortIndex: 0 },
          unitPoint: { edgeType: 'dEdge', sortIndex: 1 },
        },
        AxisExternalDist: {
          origin: { edgeType: 'dEdge', sortIndex: 0 },
          unitDistance: { edgeType: 'mEdge', sortIndex: 1 },
        },
        AxisUnitCircle: { circle: { edgeType: 'dEdge', sortIndex: 0 } },
        CoordSys: {
          axisX: { edgeType: 'dEdge', sortIndex: 0 },
          axisY: { edgeType: 'dEdge', sortIndex: 1 },
        },
        ActionButton: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonToggleHideShow: {
          Default: { edgeType: 'nEdge', sortIndex: 0 },
        },
        ActionButtonHide: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonShow: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonAnimate: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonMove: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonScroll: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonLinkPage: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonLinkURL: { Default: { edgeType: 'nEdge', sortIndex: 0 } },
        ActionButtonPresentSequentially: {
          Default: { edgeType: 'nEdge', sortIndex: 0 },
        },
        ActionButtonPresentSimultaneously: {
          Default: { edgeType: 'nEdge', sortIndex: 0 },
        },
        ActionButtonPresentCase: {
          Default: { edgeType: 'nEdge', sortIndex: 0 },
        },
        Line: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
        },
        Ray: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
        },
        MeasurementAbscissa: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        MeasurementOrdinate: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        MeasurementPolarDistance: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        MeasurementPolarDirection: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        PlotFixedXFixedY: { coordSys: { edgeType: 'dEdge', sortIndex: 0 } },
        PlotFixedXMarkedY: {
          coordY: { edgeType: 'mEdge', sortIndex: 0 },
          coordSys: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PlotMarkedXFixedY: {
          coordX: { edgeType: 'mEdge', sortIndex: 0 },
          coordSys: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PlotMarkedXMarkedY: {
          coordX: { edgeType: 'mEdge', sortIndex: 0 },
          coordY: { edgeType: 'mEdge', sortIndex: 1 },
          coordSys: { edgeType: 'dEdge', sortIndex: 2 },
        },
        PlotFixedRhoFixedTheta: {
          coordSys: { edgeType: 'dEdge', sortIndex: 0 },
        },
        PlotFixedRhoMarkedTheta: {
          coordTheta: { edgeType: 'mEdge', sortIndex: 0 },
          coordSys: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PlotMarkedRhoFixedTheta: {
          coordRho: { edgeType: 'mEdge', sortIndex: 0 },
          coordSys: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PlotMarkedRhoMarkedTheta: {
          coordRho: { edgeType: 'mEdge', sortIndex: 0 },
          coordTheta: { edgeType: 'mEdge', sortIndex: 1 },
          coordSys: { edgeType: 'dEdge', sortIndex: 2 },
        },
        Function: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        FunctionPlot: {
          function: { edgeType: 'mEdge', sortIndex: 0 },
          coordSys: { edgeType: 'dEdge', sortIndex: 1 },
        },
        CompositeText: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementPolarCoordinates: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        ColorizeUnivariate: {
          source: { edgeType: 'dEdge', sortIndex: 0 },
          color: { edgeType: 'oEdge', sortIndex: 1 },
        },
        ColorizeTrivariate: {
          source: { edgeType: 'dEdge', sortIndex: 0 },
          blue: { edgeType: 'oEdge', sortIndex: 1 },
          green: { edgeType: 'oEdge', sortIndex: 2 },
          red: { edgeType: 'oEdge', sortIndex: 3 },
        },
        Derivative_C: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        ArcOnCircle: {
          circle: { edgeType: 'dEdge', sortIndex: 0 },
          p0: { edgeType: 'dEdge', sortIndex: 1 },
          p1: { edgeType: 'dEdge', sortIndex: 2 },
        },
        ArcAroundPoint: {
          center: { edgeType: 'dEdge', sortIndex: 0 },
          p0: { edgeType: 'dEdge', sortIndex: 1 },
          p1: { edgeType: 'dEdge', sortIndex: 2 },
        },
        Arc3Points: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p2: { edgeType: 'dEdge', sortIndex: 2 },
        },
        ArcSector: { arc: { edgeType: 'dEdge', sortIndex: 0 } },
        ArcSegment: { arc: { edgeType: 'dEdge', sortIndex: 0 } },
        PictureHungOnOnePoint: { p0: { edgeType: 'dEdge', sortIndex: 0 } },
        PictureCenteredOnOnePoint: { p0: { edgeType: 'dEdge', sortIndex: 0 } },
        PictureBetweenTwoPoints: {
          p1: { edgeType: 'dEdge', sortIndex: 0 },
          p0: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PictureAcrossThreePoints: {
          p2: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p0: { edgeType: 'dEdge', sortIndex: 2 },
        },
        PictureCroppedByInterior: {
          source: { edgeType: 'dEdge', sortIndex: 0 },
          cropInterior: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PictureFunction_C: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        MeasurementCoordinateDistance: {
          p0: { edgeType: 'zEdge', sortIndex: 0 },
          p1: { edgeType: 'zEdge', sortIndex: 1 },
          coordSys: { edgeType: 'zEdge', sortIndex: 2 },
        },
        MeasurementAnalyticSlope: {
          seg: { edgeType: 'zEdge', sortIndex: 0 },
          coordSys: { edgeType: 'zEdge', sortIndex: 1 },
        },
        Pegged: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          text: { edgeType: 'iEdge', sortIndex: 1 },
        },
        UserTabulation: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        IteratedValuesTable: { Default: { edgeType: 'zEdge', sortIndex: 0 } },
        InterRayPolgon_C: { Default: { edgeType: 'dEdge', sortIndex: 0 } },
        ParametricLocus: {
          drivenObject: { edgeType: 'dEdge', sortIndex: 0 },
          driverObject: { edgeType: 'iEdge', sortIndex: 1 },
          Default: { edgeType: 'iEdge', sortIndex: 2 },
        },
        MeasurementValueOfPointOnPath: {
          point: { edgeType: 'zEdge', sortIndex: 0 },
          path: { edgeType: 'zEdge', sortIndex: 1 },
        },
        PlotValueOnPath: {
          param: { edgeType: 'mEdge', sortIndex: 0 },
          path: { edgeType: 'dEdge', sortIndex: 1 },
        },
        PlotFixedValueOnPath: { path: { edgeType: 'dEdge', sortIndex: 0 } },
        InterApproxPathStitchedPath_C: {
          Default: { edgeType: 'dEdge', sortIndex: 0 },
        },
        CustomTransformedPicture_C: {
          Default: { edgeType: 'iEdge', sortIndex: 0 },
        },
        CustomTransformedPoint: {
          drivenObject: { edgeType: 'iEdge', sortIndex: 0 },
          domainObject: { edgeType: 'dEdge', sortIndex: 1 },
          driverObject: { edgeType: 'iEdge', sortIndex: 2 },
          Default: { edgeType: 'iEdge', sortIndex: 3 },
        },
        CustomTransformedPath: {
          drivenObject: { edgeType: 'iEdge', sortIndex: 0 },
          domainObject: { edgeType: 'dEdge', sortIndex: 1 },
          driverObject: { edgeType: 'iEdge', sortIndex: 2 },
          Default: { edgeType: 'iEdge', sortIndex: 3 },
        },
        AngleMarker_Simple: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p2: { edgeType: 'dEdge', sortIndex: 2 },
        },
        AngleMarker_Reflex: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p2: { edgeType: 'dEdge', sortIndex: 2 },
        },
        AngleMarker_CCW: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p2: { edgeType: 'dEdge', sortIndex: 2 },
        },
        AngleMarker_CW: {
          p0: { edgeType: 'dEdge', sortIndex: 0 },
          p1: { edgeType: 'dEdge', sortIndex: 1 },
          p2: { edgeType: 'dEdge', sortIndex: 2 },
        },
        PathMarker: { path: { edgeType: 'dEdge', sortIndex: 0 } },
        ParametricCartesianCurvePlot: {
          xFunction: { edgeType: 'mEdge', sortIndex: 0 },
          function: { edgeType: 'mEdge', sortIndex: 1 },
          coordSys: { edgeType: 'dEdge', sortIndex: 2 },
        },
        ParametricPolarCurvePlot: {
          function: { edgeType: 'mEdge', sortIndex: 0 },
          xFunction: { edgeType: 'mEdge', sortIndex: 1 },
          coordSys: { edgeType: 'dEdge', sortIndex: 2 },
        },
      }),
      (o.Bap = (function() {
        function e(e, t) {
          var n,
            i,
            r = o.BapEdgeInfo[e.constraint];
          if (!r)
            return void o.signalErrorWithMessage(
              'BAP [getEdgeForParentAtIndex] No edge info for constraint: ' +
                e.constraint
            );
          for (n in r)
            if (r.hasOwnProperty(n) && r[n].sortIndex === t) {
              i = r[n].edgeType;
              break;
            }
          return i || r.Default.edgeType;
        }
        function t(t, i) {
          function r(e) {
            x[e.id] = { gobj: e, action: 'none', transCode: 0 };
          }
          function s(t, i, s, o) {
            var a,
              c = i,
              l = e(t, 0);
            if (
              (n === x[t.id] &&
                (r(t),
                'selected' === c &&
                  ('zEdge' !== l && 'nEdge' !== l
                    ? (c = 'controller')
                    : (x[t.id].isSelectedZ = !0))),
              (a = x[t.id].action),
              'selected' === a &&
                ((x[t.id].action = c), (x[t.id].transCode = s), (a = c)),
              !(
                (c === a && s === x[t.id].transCode) ||
                ('controller' === c && x[t.id].isController)
              ))
            ) {
              if (a && 'none' !== a) {
                if (
                  'constrain' === c &&
                  x[t.id].isLink &&
                  o &&
                  x[t.id].transCode === x[o.id].transCode
                ) {
                  if (x[o.id].isLink) return;
                  x[t.id].isController || (c = 'link');
                }
                var u = {},
                  d = {
                    none: 0,
                    controller: 1,
                    link: 2,
                    constrained: 3,
                    follower: 4,
                    selected: 5,
                  };
                if (
                  ((u[a] = !0),
                  (u[c] = !0),
                  u.hasOwnProperty('link') &&
                  u.hasOwnProperty('constrained') &&
                  (-1 === s || s === x[t.id].transCode)
                    ? (c = 'link')
                    : u.hasOwnProperty('constrained') &&
                      (u.hasOwnProperty('link') ||
                        u.hasOwnProperty('controller')) &&
                      ((c = 'follower'), (s = 0)),
                  d[c] < d[a])
                )
                  return;
              } else w.push(t);
              (x[t.id].action = c), s >= 0 && (x[t.id].transCode = s);
            }
          }
          function o(t, n, i, o, a) {
            var c = function(c, l) {
              var u = e(t, c),
                d = !0;
              return (
                (!n || n[u]) &&
                  ('zEdge' === u
                    ? (x[l.id] && 'Free' !== l.constraint) ||
                      'Expression' !== l.kind
                      ? x[l.id] || ('Expression' !== t.kind && a) || (d = !1)
                      : (d = !1)
                    : 'mEdge' !== u || a || (d = x[l.id] ? !0 : !1),
                  d &&
                    ('link' === i &&
                      (x[l.id] || r(l), (x[l.id].controller = t)),
                    s(l, i, o))),
                !0
              );
            };
            t.eachParent(c, !0);
          }
          function a(t) {
            var i = {},
              r = function(r, s) {
                var o = x[s.id],
                  a = e(t, r);
                if (o && !o.isSelectedZ) {
                  switch (a) {
                    case 'rEdge':
                      x[s.id].controller !== t && (i.incompatibleParent = !0);
                      break;
                    case 'dEdge':
                    case 'iEdge':
                    case 'tEdge':
                      o.transCode !== x[t.id].transCode &&
                        (i.incompatibleParent = !0);
                  }
                  i[a] === n
                    ? (i[a] = 'allAffected')
                    : 'noneAffected' === i[a] && (i[a] = 'someAffected');
                } else
                  i[a] === n
                    ? (i[a] = 'noneAffected')
                    : 'allAffected' === i[a] && (i[a] = 'someAffected');
                return !0;
              };
            return t.eachParent(r, !0), i;
          }
          function c(t) {
            function n(t, n) {
              var i = !0;
              return t.parents.length !== n.parents.length
                ? !1
                : (t.eachParent(function(r, s) {
                    return 'rEdge' !== e(t, r) && s !== n.parentsList[r]
                      ? ((i = !1), !1)
                      : !0;
                  }, !0),
                  i);
            }
            function i(e, t) {
              var n, i, r, s;
              return (
                (n = e.getTransformer()),
                (i = t.getTransformer()),
                (r = n.getAffineTransform()),
                (s = i.getAffineTransform()),
                r.isEqual(s)
              );
            }
            var r, s;
            for (r = 0; r < C.length; r++) {
              if (((s = C[r]), s === t && x[s.id].isLink)) return r + 1;
              if (
                x[s.id].transCode === x[t.id].transCode &&
                x[s.id].isLink &&
                s.constraint === t.constraint &&
                n(s, t) &&
                i(s, t)
              )
                return r + 1;
            }
            return C.push(t), r + 1;
          }
          function l(e, t) {
            var n = { zEdge: !0, dEdge: !0 },
              i = !0;
            t.iEdge &&
              'noneAffected' !== t.iEdge &&
              ((n.iEdge = !0), (n.rEdge = !0), (n.tEdge = !0)),
              ('noneAffected' === t.iEdge ||
                'noneAffected' === t.mEdge ||
                'someAffected' === t.mEdge) &&
                (i = !1),
              ((t.rEdge &&
                'noneAffected' !== t.rEdge &&
                t.incompatibleParent) ||
                (t.tEdge && 'noneAffected' !== t.tEdge)) &&
                ((n.tEdge = !0), (n.rEdge = !0)),
              'noneAffected' === t.tEdge && (i = !1),
              t.mEdge &&
                'noneAffected' !== t.mEdge &&
                ((n.tEdge = !0), (n.mEdge = !0), (n.rEdge = !0)),
              !i ||
                (t.mEdge && 'allAffected' !== t.mEdge) ||
                (x[e.id].completeFollower = !0),
              o(e, n, 'controller', -1, i);
          }
          function u(e, t) {
            x[e.id].isLink &&
              x[e.id].controller &&
              s(x[e.id].controller, 'follower', 0, e),
              (x[e.id].transCode = 0),
              (x[e.id].controller = n),
              (x[e.id].isConstrained = !1),
              (x[e.id].isLink = !1),
              (x[e.id].isDragRoot = !1),
              (x[e.id].isController = !1),
              (x[e.id].isFollower = !0),
              o(e, { zEdge: !0, dEdge: !0 }, 'controller', 0),
              l(e, t);
          }
          function d(t, n) {
            if (x[t.id].isLink) {
              var i = function() {
                var i =
                  'someAffected' === n.iEdge ||
                  'allAffected' === n.iEdge ||
                  'someAffected' === n.mEdge ||
                  'allAffected' === n.mEdge ||
                  'someAffected' === n.tEdge ||
                  'allAffected' === n.tEdge;
                if (!i)
                  if (n.dEdge)
                    t.eachParent(function(n, r) {
                      return 'dEdge' !== e(t, n) ||
                        !x[r.id] ||
                        (x[r.id].transCode === x[t.id].transCode &&
                          x[r.id].isLink)
                        ? !0
                        : ((i = !0), !1);
                    }, !0);
                  else if (n.rEdge) {
                    var r = c(t),
                      s = t.parentsList[0];
                    i = 0 !== r && s && r !== x[s.id].transCode;
                  }
                return i;
              };
              i() && u(t, n);
            } else x[t.id].isFollower && !x[t.id].completeFollower && l(t, n);
            x[t.id].isSelectedZ &&
              !x[t.id].isConstrained &&
              (x[t.id].kidsAreConstrained = !1),
              (x[t.id].isConstrained = !0);
          }
          function h(t, n) {
            if (
              n.incompatibleParent ||
              n.dEdge ||
              n.rEdge ||
              (n.iEdge && 'noneAffected' !== n.iEdge) ||
              (n.tEdge && 'noneAffected' !== n.tEdge) ||
              (n.mEdge && 'noneAffected' !== n.mEdge)
            ) {
              if (
                (n.tEdge && 'noneAffected' !== n.tEdge) ||
                (n.iEdge && 'noneAffected' !== n.iEdge && n.rEdge)
              )
                return u(t, n);
              if (n.incompatibleParent) return u(t, n);
              (x[t.id].isLink = !0),
                x[t.id].transCode || (x[t.id].isFollower = !0),
                o(t, { dEdge: !0 }, 'link', x[t.id].transCode),
                'noneAffected' === n.rEdge && o(t, { rEdge: !0 }, 'link', c(t)),
                n.iEdge && 'noneAffected' !== n.iEdge
                  ? (o(t, { tEdge: !0, iEdge: !0 }, 'link', x[t.id].transCode),
                    0 !== x[t.id].transCode ||
                      (n.mEdge && 'allAffected' !== n.mEdge) ||
                      (x[t.id].completeFollower = !0))
                  : n.tEdge && 'noneAffected' !== n.tEdge
                  ? (o(t, { tEdge: !0 }, 'link', x[t.id].transCode),
                    0 !== x[t.id].transCode ||
                      (n.mEdge && 'allAffected' !== n.mEdge) ||
                      n.iEdge ||
                      (x[t.id].completeFollower = !0))
                  : n.iEdge ||
                    n.tEdge ||
                    (n.mEdge && 'allAffected' !== n.mEdge) ||
                    0 !== x[t.id].transCode ||
                    (x[t.id].completeFollower = !0),
                n.mEdge &&
                  'noneAffected' !== n.mEdge &&
                  o(t, { mEdge: !0 }, 'link', x[t.id].transCode);
            } else
              (x[t.id].isLink = !0),
                'zEdge' !== e(t, 0)
                  ? (x[t.id].isDragRoot = !0)
                  : o(t, { zEdge: !0 }, 'link', x[t.id].transCode);
          }
          function p(t, i) {
            var a,
              l = !0;
            if (
              ('zEdge' === e(t, 0)
                ? (o(t, { zEdge: !0 }, 'controller', 0), (l = !1))
                : (i.iEdge && 'noneAffected' !== i.iEdge) ||
                  (i.tEdge && 'noneAffected' !== i.tEdge) ||
                  (i.mEdge && 'noneAffected' !== i.mEdge)
                ? (l = !1)
                : i.dEdge
                ? (o(t, { dEdge: !0 }, 'controller', 0), (l = !1))
                : 'allAffected' === i.rEdge &&
                  ((a = t.parentsList[0]),
                  a && x[a.id].controller !== t && (l = !1)),
              !l)
            )
              return u(t, i);
            if (
              (x[t.id].controller &&
                (s(x[t.id].controller, 'follower', 0, t),
                (x[t.id].controller = n)),
              (x[t.id].isController = !0),
              (x[t.id].isLink = !0),
              (x[t.id].isFollower = !0),
              i.iEdge || i.tEdge || i.mEdge || (x[t.id].completeFollower = !0),
              (x[t.id].isDragRoot = !i.rEdge || i.dEdge ? !0 : !1),
              i.rEdge)
            ) {
              var d = c(t);
              (a = t.parentsList[0]),
                'noneAffected' !== i.rEdge ||
                  (x[a.id] && x[a.id].transCode === d) ||
                  (x[a.id] || r(a),
                  (x[a.id].transCode = d),
                  (x[a.id].controller = t),
                  o(t, { rEdge: !0 }, 'link', d));
            }
          }
          function f(t) {
            function n(t, n) {
              return (
                n.eachParent(function(r, s) {
                  return s === t ? ((i = e(n, r)), !1) : !0;
                }),
                i
              );
            }
            var i, r, o, a, c;
            for (r = t.children.length - 1; r >= 0; r--)
              (c = -1),
                (a = t.children[r]),
                (o = n(t, a)),
                'nEdge' !== o &&
                  ('dEdge' === o && (c = x[t.id].transCode),
                  s(a, 'constrained', c, t));
            x[t.id].kidsAreConstrained = !0;
          }
          function m() {
            var e, t, n, i;
            for (e = w.shift(); e; ) {
              switch (
                ((t = x[e.id]),
                t.addedToProcessed ||
                  (k.push(e),
                  (x[e.id].addedToProcessed = !0),
                  'selected' !== t.action && (t.isConstrained = !0)),
                (n = a(e)),
                (i = t.action),
                (t.action = 'none'),
                i)
              ) {
                case 'constrained':
                  d(e, n);
                  break;
                case 'link':
                  h(e, n);
                  break;
                case 'controller':
                  p(e, n);
                  break;
                case 'follower':
                  u(e, n);
              }
              t.isSelectedZ ||
                t.kidsAreConstrained ||
                ('Free' === e.constraint && 'Expression' === e.kind) ||
                f(e),
                (e = w.shift());
            }
          }
          function g() {
            function e() {
              function e(e, t) {
                return !x[t.id] ||
                  x[t.id].hasBeenAddedToOrderedList ||
                  x[t.id].isSelectedZ
                  ? !0
                  : ((n = !1), !1);
              }
              for (var t, n, i = 0; k.length > 0; )
                (n = !0),
                  (t = k[i]),
                  t.eachParent(e, !0),
                  n
                    ? (c.push(t),
                      k.splice(i, 1),
                      (x[t.id].hasBeenAddedToOrderedList = !0))
                    : i++,
                  i === k.length && (i = 0);
            }
            function t(e) {
              var t, n;
              for (t = 0; t < a.length; t++) a[t].gobj === e && (n = t);
              return n;
            }
            function n() {
              var e, t, n, i;
              for (e = 0; e < a.length; e++)
                if (0 === a[e].controlRefs && !a[e].isDragRoot) {
                  for (n = a[e].controlIndex, t = e + 1; t < a.length; t++)
                    a[t].controlIndex > e && a[t].controlIndex--;
                  (i = a.slice(e + 1)),
                    a.splice(e),
                    (a = a.concat(i)),
                    n >= 0 ? (a[n].controlRefs--, (e = n - 1)) : e--;
                }
            }
            var i,
              r,
              s,
              o,
              a = [],
              c = [];
            for (e(), r = c.length - 1; r >= 0; r--)
              (i = c[r]),
                (s = x[i.id]),
                (s.isController || s.isLink || s.isDragRoot || s.isSelectedZ) &&
                  (s.isSelectedZ &&
                    ((s.isController = !0), (s.isDragRoot = !0)),
                  (o = {
                    gobj: i,
                    isController: s.isController ? !0 : !1,
                    isDragRoot: s.isDragRoot ? !0 : !1,
                    controlRefs: 0,
                  }),
                  o.isController
                    ? ((o.controlIndex = -1), (o.isTransformParent = !1))
                    : ((o.controlIndex = t(s.controller)),
                      (o.isTransformParent =
                        x[s.controller.id].transCode !== s.transCode),
                      a[o.controlIndex].controlRefs++),
                  a.push(o));
            return n(), a;
          }
          function b() {
            var e,
              n = [];
            for (y = 0; y < t.length; y++)
              (e = t[y].parentsList),
                'GeomLocus' === t[y].constraint &&
                  e[0] === e[e.length - 1] &&
                  n.push({ gobj: t[y], parent: t[y].parentsList.pop() });
            return n;
          }
          function v(e) {
            var t;
            if (e)
              for (t = 0; t < e.length; t++)
                e[t].gobj.parentsList.push(e[t].parent);
          }
          var y,
            x = {},
            w = [],
            k = [],
            P = [],
            C = [],
            S = b();
          for (y = 0; y < t.length; y++) s(t[y], 'selected', 0);
          return m(), (P = g()), v(S), P;
        }
        var i = {
          createControlList: function(e) {
            var n,
              i = e[0];
            return (n =
              this.sketch.getOption('bap-useDebugControlList') &&
              1 === e.length &&
              i.debug &&
              i.debug.controlList
                ? o.ControlList.fromExternalList(
                    i.debug.controlList,
                    this.sketch
                  )
                : t(e, this.sketch));
          },
        };
        return function(e) {
          var t = Object.create(i);
          return (t.sketch = e), t;
        };
      })()),
      'undefined' == typeof e.btoa)
    ) {
      var a = {
        _keyStr:
          'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
        encode: function(e) {
          var t,
            n,
            i,
            r,
            s,
            o,
            c,
            l = '',
            u = 0;
          for (e = a._utf8_encode(e); u < e.length; )
            (t = e.charCodeAt(u++)),
              (n = e.charCodeAt(u++)),
              (i = e.charCodeAt(u++)),
              (r = t >> 2),
              (s = ((3 & t) << 4) | (n >> 4)),
              (o = ((15 & n) << 2) | (i >> 6)),
              (c = 63 & i),
              isNaN(n) ? (o = c = 64) : isNaN(i) && (c = 64),
              (l =
                l +
                this._keyStr.charAt(r) +
                this._keyStr.charAt(s) +
                this._keyStr.charAt(o) +
                this._keyStr.charAt(c));
          return l;
        },
        decode: function(e) {
          var t,
            n,
            i,
            r,
            s,
            o,
            c,
            l = '',
            u = 0;
          for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ''); u < e.length; )
            (r = this._keyStr.indexOf(e.charAt(u++))),
              (s = this._keyStr.indexOf(e.charAt(u++))),
              (o = this._keyStr.indexOf(e.charAt(u++))),
              (c = this._keyStr.indexOf(e.charAt(u++))),
              (t = (r << 2) | (s >> 4)),
              (n = ((15 & s) << 4) | (o >> 2)),
              (i = ((3 & o) << 6) | c),
              (l += String.fromCharCode(t)),
              64 != o && (l += String.fromCharCode(n)),
              64 != c && (l += String.fromCharCode(i));
          return (l = a._utf8_decode(l));
        },
        _utf8_encode: function(e) {
          e = e.replace(/\r\n/g, '\n');
          for (var t = '', n = 0; n < e.length; n++) {
            var i = e.charCodeAt(n);
            128 > i
              ? (t += String.fromCharCode(i))
              : i > 127 && 2048 > i
              ? ((t += String.fromCharCode((i >> 6) | 192)),
                (t += String.fromCharCode((63 & i) | 128)))
              : ((t += String.fromCharCode((i >> 12) | 224)),
                (t += String.fromCharCode(((i >> 6) & 63) | 128)),
                (t += String.fromCharCode((63 & i) | 128)));
          }
          return t;
        },
        _utf8_decode: function(e) {
          for (var t = '', n = 0, i = (c1 = c2 = 0); n < e.length; )
            (i = e.charCodeAt(n)),
              128 > i
                ? ((t += String.fromCharCode(i)), n++)
                : i > 191 && 224 > i
                ? ((c2 = e.charCodeAt(n + 1)),
                  (t += String.fromCharCode(((31 & i) << 6) | (63 & c2))),
                  (n += 2))
                : ((c2 = e.charCodeAt(n + 1)),
                  (c3 = e.charCodeAt(n + 2)),
                  (t += String.fromCharCode(
                    ((15 & i) << 12) | ((63 & c2) << 6) | (63 & c3)
                  )),
                  (n += 3));
          return t;
        },
      };
      o.btoa = function(e) {
        return a.encode(e);
      };
    } else
      o.btoa = function(t) {
        return e.btoa(t);
      };
    (o.Scroll = function(e) {
      var t = o.makeClass(o.TouchTracker, {
        primalLoc: null,
        touchBegan: function(t, n) {
          e.event('StartScroll', { touch: n, position: t }),
            (this.primalLoc = o.GeometricPoint(t.x, t.y));
        },
        touchMoved: function(t, n) {
          var i = o.GeometricPoint(t.x, t.y),
            r = this.primalLoc.subtract(i),
            s = this.primalLoc.copy();
          e.event('MoveScroll', { touch: n, position: t }),
            e.primalToViewTransform().transform(s),
            e.translate(r.x, r.y, !0),
            (this.primalLoc = s.subtract(r)),
            e.viewToPrimalTransform().transform(this.primalLoc);
        },
        touchEnded: function(t) {
          e.event('EndScroll', { touch: t }), (this.primalLoc = null);
        },
      });
      return {
        isScrolling: function() {
          return !!t.primalLoc;
        },
        createTracker: function() {
          return this.isScrolling() ? void 0 : t;
        },
        translate: function(n, i) {
          var r,
            s = this.isScrolling();
          s &&
            ((r = t.primalLoc.copy()), e.primalToViewTransform().transform(r)),
            e.translate(n, i, !1),
            s && (e.viewToPrimalTransform().transform(r), (t.primalLoc = r));
        },
      };
    }),
      (o.MotionManager = (function() {
        function e(e, t) {
          var n,
            i,
            r = [];
          if (e.isValueChangingMotion !== t.isValueChangingMotion) return !1;
          if (!e.controlList || !t.controlList)
            return (
              o.signalErrorWithMessage(
                'motionsConflict finds motion without a control list'
              ),
              !1
            );
          for (n = e.controlList.length - 1; n >= 0; n--)
            e.controlList[n].isDragRoot && r.push(e.controlList[n].gobj);
          for (n = t.controlList.length - 1; n >= 0; n--)
            if (t.controlList[n].isDragRoot)
              for (i = 0; i < r.length; i++)
                if (r[i] === t.controlList[n].gobj) return !0;
          return !1;
        }
        var i = {
          _motionJob: null,
          StartMotion: function(t, n) {
            function i() {
              return a.ApplyCurrent();
            }
            var r,
              s = this.motionID++,
              a = this;
            for (
              this.motionSet[s] = { motion: t, state: 'active', refCon: n },
                r = 0;
              r < this.motionList.length;
              r++
            )
              e(this.motionSet[this.motionList[r]].motion, t) &&
                (o.log(
                  'found conflicting motions, canceling ' +
                    this.motionList[r] +
                    ', keeping ' +
                    s
                ),
                this.EndMotion(this.motionList[r]));
            this.motionList.push(s);
            var c = {
              repeat: !0,
              done: function() {
                a._motionJob = null;
              },
            };
            return (
              o.JobScheduler.isActive(a._motionJob) ||
                (a._motionJob = a.sketch.jobScheduler.addJob(i, c)),
              s
            );
          },
          UpdateRefCon: function(e, t) {
            this.motionSet[e].refCon = t;
          },
          GetRefCon: function(e) {
            return this.motionSet[e].refCon;
          },
          EndMotion: function(e) {
            this.motionSet[e].state = 'cancelled';
          },
          StopAllMotions: function() {
            var e = this.sketch;
            e.sQuery('Button').forEach(function(t) {
              ('ActionButtonMove' !== t.constraint &&
                'ActionButtonAnimate' !== t.constraint) ||
                !t.state.isActive ||
                t.press(e);
            });
          },
          ApplyCurrent: function() {
            var e,
              i,
              r = this;
            for (e = 0; e < this.motionList.length; e++)
              if (
                ((i = this.motionSet[this.motionList[e]]), 'active' === i.state)
              )
                try {
                  i.motion.applyMotion(i.refCon);
                } catch (e) {}
            for (e in this.motionList)
              if (
                ((i = this.motionSet[this.motionList[e]]),
                'cancelled' === i.state)
              ) {
                try {
                  i.motion.completeMotion(i.refCon);
                } catch (e) {}
                delete this.motionSet[this.motionList[e]];
              }
            return (
              (this.motionList = t.grep(this.motionList, function(e) {
                return n !== r.motionSet[e];
              })),
              0 === this.motionList.length ? !1 : void 0
            );
          },
          ApplyTransformToControlList: function(e, t, n, i) {
            var r,
              s,
              a,
              c,
              l,
              u = i && i.snapPoints && e.preferences.snapToGrid;
            for (
              u && (c = e.findExistingCoordSys()), r = 0;
              r < n.length;
              r++
            ) {
              if (
                ((s = n[r]),
                (a = s.gobj),
                (l = c),
                u &&
                  !l &&
                  a.style.snapToGrid &&
                  (l = a.getGObjRef(a.style.snapToGrid)),
                s.isController
                  ? (s.transform = t)
                  : (s.transform = n[s.controlIndex].transform),
                s.isTransformParent)
              ) {
                var d,
                  h = n[s.controlIndex],
                  p = h.gobj.getTransformer(),
                  f = p.getAffineTransform();
                (d = f.inverse()),
                  null !== d &&
                    (s.transform = f.compose(h.transform).compose(d));
              }
              s.isDragRoot &&
                a.state.exists &&
                (i && i.onPathTracksIdealLoc && 'Point' === s.gobj.kind
                  ? (s.idealLocation ||
                      (s.idealLocation = { loc: s.gobj.geom.loc.copy() }),
                    (s.idealLocation.loc = s.transform.transform(
                      s.idealLocation.loc
                    )),
                    a.transform(e, {
                      geom: s.idealLocation,
                      affine: o.AffineTransform.Identity,
                    }))
                  : a.transform(e, { geom: s.gobj.geom, affine: s.transform }),
                'Point' === a.kind &&
                  l &&
                  l.snapPoint &&
                  l.state.exists &&
                  !a.hasDescendant(l) &&
                  l.snapPoint(a.geom.loc),
                a.sQuery.sketch.invalidateGeom(a, 'drag'));
            }
          },
          ApplyTransformToGobjUsingKeys: function(e, t, n) {
            var i, r;
            for (i = 0; i < n.length; i++)
              (r = n[i]),
                r.gobj.transform(e, { geom: r.gobj.geom, affine: t }),
                e.invalidateGeom(r.gobj);
          },
        };
        return function(e) {
          var t = Object.create(i);
          return (
            (t.motionList = []),
            (t.sketch = e),
            (t.motionID = 0),
            (t.motionSet = {}),
            t
          );
        };
      })()),
      (o.GeometricPoint = (function() {
        var e = {
          transformClass: 'GeometricPoint',
          getX: function() {
            return this.x;
          },
          getY: function() {
            return this.y;
          },
          toString: function() {
            return '{ x:' + this.x + ', y:' + this.y + '}';
          },
          equals: function(e, t) {
            return (
              'undefined' == typeof t && (t = 0),
              e
                ? Math.abs(this.x - e.x) <= t && Math.abs(this.y - e.y) <= t
                : !1
            );
          },
          negate: function() {
            return o.GeometricPoint(-this.x, -this.y);
          },
          round: function() {
            return o.GeometricPoint(Math.round(this.x), Math.round(this.y));
          },
          add: function(e) {
            return o.GeometricPoint(this.x + e.getX(), this.y + e.getY());
          },
          subtract: function(e) {
            return o.GeometricPoint(this.x - e.getX(), this.y - e.getY());
          },
          multiply: function(e) {
            return o.GeometricPoint(this.x * e, this.y * e);
          },
          dot: function(e) {
            return this.x * e.getX() + this.y * e.getY();
          },
          vLength: function() {
            return Math.sqrt(this.dot(this));
          },
          distance: function(e) {
            return this.subtract(e).vLength();
          },
          vLength2: function() {
            return this.dot(this);
          },
          l1Norm: function() {
            return Math.abs(this.x) + Math.abs(this.y);
          },
          isZeroLength: function() {
            return 0 === this.x && 0 === this.y;
          },
          isFinite: function() {
            return isFinite(this.x) && isFinite(this.y);
          },
          isDefined: function() {
            return !isNaN(this.x) && !isNaN(this.y);
          },
          rotate: function(e, t) {
            var n = this.subtract(e),
              i = Math.cos(t),
              r = Math.sin(t),
              s = o.GeometricPoint(i * n.x - r * n.y, r * n.x + i * n.y);
            return s.add(e);
          },
          unit: function() {
            return this.multiply(1 / this.vLength());
          },
          scale: function(e, t) {
            return this.subtract(e)
              .multiply(t)
              .add(e);
          },
          copy: function() {
            return this.multiply(1);
          },
        };
        return function(t, i) {
          var r;
          return t && t.x && t.y && i === n
            ? o.GeometricPoint(t.x, t.y)
            : ('string' == typeof t
                ? (t = Number(t))
                : 'number' != typeof t && (t = NaN),
              'string' == typeof i
                ? (i = Number(i))
                : 'number' != typeof i && (i = NaN),
              (r = Object.create(e)),
              (r.x = t),
              (r.y = i),
              r);
        };
      })()),
      (o.GeometricPoint.ORIGIN = o.GeometricPoint(0, 0)),
      (o.GeometricPoint.INFINITY = o.GeometricPoint(1 / 0, 1 / 0)),
      (o.GeometricPoint.UNDEFINED = o.GeometricPoint(n, n)),
      (o.GeometricPoint.FromCenterRadiusAngle = function(e, t, n) {
        return o.GeometricPoint(e.x + t * Math.cos(n), e.y + t * Math.sin(n));
      }),
      (o.GeometricPoint.threePointAngle = function(e, t, i) {
        var r, s, a, c;
        if (
          ((r = e.subtract(t)),
          (a = i.subtract(t)),
          (s = new o.GeometricPoint(a.dot(r), a.y * r.x - a.x * r.y)),
          (r = new o.GeometricPoint(r.dot(r), 0)),
          Math.abs(r.x) < 4e-4)
        )
          return n;
        if (Math.abs(s.x) < 4e-4) {
          if (Math.abs(s.y) < 4e-4) return n;
          c = s.y > 0 ? Math.PI / 2 : -Math.PI / 2;
        } else
          Math.abs(s.y) < 4e-4
            ? (c = s.x >= 0 ? 0 : Math.PI)
            : ((c = Math.atan(s.y / s.x)),
              s.x < 0 && (s.y >= 0 ? (c += Math.PI) : (c -= Math.PI)));
        return c;
      }),
      (o.GeometricPoint.threePointFlippedAngle = function(e, t, n) {
        var i = o.GeometricPoint.threePointAngle(e, t, n);
        return Math.abs(i) > 0 && Math.abs(i) < Math.PI && (i = -i), i;
      }),
      (o.GeometricPoint.expect = function(e, t, i) {
        return (e === n) != (t === n)
          ? !1
          : (null === e) != (null === t)
          ? !1
          : o.math.expect(e.getX(), t.getX(), i, !0) &&
            o.math.expect(e.getY(), t.getY(), i, !0);
      }),
      (o.GeometricPoint.mapPointToLine = function(e, t, n, i) {
        var r,
          s,
          o,
          a = {};
        return (
          (r = n.subtract(e)),
          (s = t.subtract(e)),
          (o = r.dot(s) / s.dot(s)),
          i &&
            (i.clampP0 && 0 > o && (o = 0),
            i.clampP1 && o > 1 && (o = 1),
            i.returnPoint && (a.point = e.add(s.multiply(o)))),
          (a.param = o),
          a
        );
      }),
      (o.GeometricPoint.curryFunction = function(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return function(n) {
          return n[e].apply(n, t);
        };
      }),
      (function() {
        function e(e, t) {
          var i = e,
            r = t;
          return (
            r === n &&
              ((i = e.hasOwnProperty('dx') ? e.dx : e.x),
              (r = e.hasOwnProperty('dy') ? e.dy : e.y)),
            { x: i, y: r }
          );
        }
        var t,
          i,
          r = ['m00', 'm10', 'm20', 'm01', 'm11', 'm21'],
          s = 6;
        (t = {
          transformClass: 'AffineTransform',
          toString: function() {
            var e = '[';
            return (
              (e +=
                '[m00: ' +
                this.m00 +
                ' m10: ' +
                this.m10 +
                ' m20: ' +
                this.m20 +
                ']'),
              (e +=
                '[m01: ' +
                this.m01 +
                ' m11: ' +
                this.m11 +
                ' m21: ' +
                this.m21 +
                ']'),
              (e += ']')
            );
          },
          toStringCSS: function() {
            return (
              'matrix(' +
              this.m00 +
              ',' +
              this.m01 +
              ',' +
              this.m10 +
              ',' +
              this.m11 +
              ',' +
              this.m20 +
              ',' +
              this.m21 +
              ')'
            );
          },
          transform: function(e) {
            var t, n, i;
            if (e.getX && e.getY)
              return (
                (n = this.m00 * e.getX() + this.m10 * e.getY() + this.m20),
                (i = this.m01 * e.getX() + this.m11 * e.getY() + this.m21),
                (e.x = n),
                (e.y = i),
                e
              );
            if ('object' == typeof e) for (t in e) this.transform(e[t]);
          },
          compose: function(e) {
            return new i({
              m00: e.m00 * this.m00 + e.m10 * this.m01,
              m10: e.m00 * this.m10 + e.m10 * this.m11,
              m20: e.m00 * this.m20 + e.m10 * this.m21 + e.m20,
              m01: e.m01 * this.m00 + e.m11 * this.m01,
              m11: e.m01 * this.m10 + e.m11 * this.m11,
              m21: e.m01 * this.m20 + e.m11 * this.m21 + e.m21,
            });
          },
          translate: function(t, n) {
            var r = e(t, n);
            return new i({
              m00: this.m00,
              m10: this.m10,
              m20: this.m20 + r.x,
              m01: this.m01,
              m11: this.m11,
              m21: this.m21 + r.y,
            });
          },
          scale: function(t, n) {
            var r = e(t, n);
            return new i({
              m00: this.m00 * r.x,
              m10: this.m10 * r.x,
              m20: this.m20 * r.x,
              m01: this.m01 * r.y,
              m11: this.m11 * r.y,
              m21: this.m21 * r.y,
            });
          },
          rotate: function(e) {
            var t = Math.cos(e),
              n = Math.sin(e);
            return new i({
              m00: t * this.m00 - n * this.m01,
              m10: t * this.m10 - n * this.m11,
              m20: t * this.m20 - n * this.m21,
              m01: n * this.m00 + t * this.m01,
              m11: n * this.m10 + t * this.m11,
              m21: n * this.m20 + t * this.m21,
            });
          },
          inverse: function() {
            var e = this.m00 * this.m11 - this.m10 * this.m01;
            return e
              ? new i({
                  m00: this.m11 / e,
                  m10: -this.m10 / e,
                  m20: (-this.m11 * this.m20 + this.m10 * this.m21) / e,
                  m01: -this.m01 / e,
                  m11: this.m00 / e,
                  m21: (this.m01 * this.m20 - this.m00 * this.m21) / e,
                })
              : null;
          },
          copy: function() {
            return new i(this);
          },
          isEqual: function(e) {
            return (
              this.m00 === e.m00 &&
              this.m10 === e.m10 &&
              this.m20 === e.m20 &&
              this.m01 === e.m01 &&
              this.m11 === e.m11 &&
              this.m21 === e.m21
            );
          },
          isTranslation: function() {
            return (
              1 === this.m00 &&
              0 === this.m10 &&
              0 === this.m01 &&
              1 === this.m11
            );
          },
          packIntoSampleArray: function(e, t) {
            var n = s * t;
            (e[n] = this.m00),
              (e[n + 1] = this.m10),
              (e[n + 2] = this.m20),
              (e[n + 3] = this.m01),
              (e[n + 4] = this.m11),
              (e[n + 5] = this.m21);
          },
        }),
          (i = function(e) {
            var n,
              i,
              s = Object.create(t);
            for (n in r) (i = r[n]), (s[i] = e.hasOwnProperty(i) ? e[i] : 0);
            return s;
          }),
          (i.Identity = new i({ m00: 1, m11: 1 })),
          (i.KeyNames = r),
          (i.fromPointTransform = function(e) {
            var t = e(o.GeometricPoint(0, 0)),
              n = e(o.GeometricPoint(1, 0)),
              r = e(o.GeometricPoint(0, 1)),
              s = t.getX(),
              a = t.getY();
            return new i({
              m00: n.getX() - s,
              m01: n.getY() - a,
              m10: r.getX() - s,
              m11: r.getY() - a,
              m20: s,
              m21: a,
            });
          }),
          (i.fromPointMapping = function(e, t) {
            var n,
              i = e[2].subtract(e[1]),
              r = e[2].subtract(e[0]),
              s = i.getY() * r.getX() + i.getX() * -r.getY(),
              a = null;
            return (
              0 !== s &&
                ((n = function(n) {
                  var o = n.subtract(e[2]),
                    a = (-i.getY() * o.getX() + i.getX() * o.getY()) / s,
                    c = (r.getY() * o.getX() + -r.getX() * o.getY()) / s,
                    l = 1 - a - c;
                  return t[0]
                    .multiply(a)
                    .add(t[1].multiply(c))
                    .add(t[2].multiply(l));
                }),
                (a = o.AffineTransform.fromPointTransform(n))),
              a
            );
          }),
          (i.fromPackedSampleArray = function(e, t) {
            var n = t * s,
              r = {
                m00: e[n],
                m10: e[n + 1],
                m20: e[n + 2],
                m01: e[n + 3],
                m11: e[n + 4],
                m21: e[n + 5],
              };
            return new i(r);
          }),
          (i.packedSampleSize = s),
          (o.AffineTransform = i);
      })(),
      (function(e) {
        var i,
          r,
          s,
          a = e;
        (i = {
          transformClass: function(e) {
            return 'number' == typeof e ? 'distance' : e.transformClass;
          },
          transformGeometricArc: function(e) {
            function t() {
              var t = i.point ? i.point(e.initialPoint) : e.initialPoint,
                n = i.point ? i.point(e.finalPoint) : e.finalPoint;
              return o.GeometricArc.FromStraightEndpoints(t, n);
            }
            function n() {
              var t = i.point ? i.point(e.initialPoint) : e.initialPoint,
                n = i.point ? i.point(e.middlePoint) : e.middlePoint,
                r = i.point ? i.point(e.finalPoint) : e.finalPoint,
                s = o.Geom.ThreePointCollinear(
                  e.initialPoint,
                  e.finalPoint,
                  e.middlePoint
                ),
                a = o.GeometricArc.FromThreePoints(t, n, r);
              return (
                e.orientation !== s.orientation && (a.orientation *= -1), a
              );
            }
            var i = this;
            return 0 === e.orientation ? t() : n();
          },
          doOneTransform: function(e, t) {
            switch ((t === n && (t = this.transformClass(e)), t)) {
              case 'distance':
                return this.distance ? this.distance(e) : e;
              case 'GeometricPoint':
                return this.point ? this.point(e) : e.copy();
              case 'AffineTransform':
                return e.compose(this.getAffineTransform());
              case 'GeometricArc':
                return this.transformGeometricArc(e);
            }
          },
          getAffineTransform: function() {
            return this.affineTransform
              ? this.affineTransform
              : this.point
              ? o.AffineTransform.fromPointTransform(this.point)
              : o.AffineTransform.Identity;
          },
          transformGeom: function(e, n) {
            var i, r, s, o, a;
            for (r in e)
              if (e.hasOwnProperty(r))
                if (((a = e[r]), (i = this.transformClass(a))))
                  n[r] = this.doOneTransform(a, i);
                else if (t.isArray(a)) {
                  for (o = [], s = 0; s < a.length; s += 1)
                    o.push(this.doOneTransform(a[s]));
                  n[r] = o;
                } else n[r] = e[r];
          },
        }),
          (r = function(e) {
            var r = Object.create(i);
            return (
              (r.distance = null),
              (r.point = n),
              (r.affineTransform = n),
              'function' == typeof e ? (r.point = e) : t.extend(r, e),
              r
            );
          }),
          (s = new r({ distance: 0 })),
          (r.copyGeom = function(e, t) {
            s.transformGeom(e, t);
          }),
          (a.GeomTransformer = r);
      })(o),
      (function() {
        function e(e, t) {
          var n, i, r, s;
          return (
            (n = t.y - e.y),
            (i = e.x - t.x),
            (r = n * t.x + i * t.y),
            (s = function() {
              return '[' + this.a + 'x + ' + this.b + 'y = ' + r + ']';
            }),
            { a: n, b: i, c: r, p0: e, p1: t, toString: s }
          );
        }
        var t = {};
        (t.kInfiniteRect = {
          left: Number.NEGATIVE_INFINITY,
          top: Number.NEGATIVE_INFINITY,
          right: Number.POSITIVE_INFINITY,
          bottom: Number.POSITIVE_INFINITY,
        }),
          (t.isFiniteRect = function(e) {
            return (
              e &&
              isFinite(e.top) &&
              isFinite(e.left) &&
              isFinite(e.bottom) &&
              isFinite(e.right)
            );
          }),
          (t.isValidRect = function(e) {
            return (
              e &&
              null != e.left &&
              e.left === e.left &&
              null != e.top &&
              e.top === e.top &&
              null != e.right &&
              e.right === e.right &&
              null != e.bottom &&
              e.bottom === e.bottom &&
              e.left <= e.right &&
              e.top <= e.bottom
            );
          }),
          (t.isEmptyRect = function(e) {
            return (
              !t.isValidRect(e) || e.left === e.right || e.top === e.bottom
            );
          }),
          (t.containsRect = function(e, n) {
            return (
              t.isValidRect(e) &&
              t.isValidRect(n) &&
              e.left <= n.left &&
              e.top <= n.top &&
              e.right >= n.right &&
              e.bottom >= n.bottom
            );
          }),
          (t.isIntersectRects = function(e, n) {
            return (
              t.isValidRect(e) &&
              t.isValidRect(n) &&
              e.left <= n.right &&
              n.left <= e.right &&
              e.top <= n.bottom &&
              n.top <= e.bottom
            );
          }),
          (t.isIntersectValidRects = function(e, t) {
            return (
              e &&
              t &&
              e.left <= t.right &&
              t.left <= e.right &&
              e.top <= t.bottom &&
              t.top <= e.bottom
            );
          }),
          (t.intersectRects = function(e, n) {
            if (!t.isValidRect(e) || !t.isValidRect(n)) return null;
            var i = {
              left: Math.max(e.left, n.left),
              top: Math.max(e.top, n.top),
              right: Math.min(e.right, n.right),
              bottom: Math.min(e.bottom, n.bottom),
            };
            return t.isValidRect(i) ? i : null;
          }),
          (t.unionRects = function(e, n) {
            var i = t.isValidRect(e),
              r = t.isValidRect(n);
            return !i && r
              ? n
              : i && !r
              ? e
              : i || r
              ? {
                  left: Math.min(e.left, n.left),
                  top: Math.min(e.top, n.top),
                  right: Math.max(e.right, n.right),
                  bottom: Math.max(e.bottom, n.bottom),
                }
              : null;
          }),
          (t.insetRect = function(e, t, n) {
            var i = null != t ? t : 1,
              r = null != n ? n : i;
            return {
              left: e.left + i,
              top: e.top + r,
              right: e.right - i,
              bottom: e.bottom - r,
            };
          }),
          (t.offsetRect = function(e, t, n) {
            var i = t || 0,
              r = n || i;
            return {
              left: e.left + i,
              top: e.top + r,
              right: e.right + i,
              bottom: e.bottom + r,
            };
          }),
          (t.boundingRect = function() {
            var e, t, i, r, s, o, a, c;
            for (
              c = 1 === arguments.length ? arguments[0] : arguments, s = 0;
              s < c.length;
              s++
            )
              (o = c[s].x),
                (a = c[s].y),
                (e > o || e === n) && (e = o),
                (o > t || t === n) && (t = o),
                (i > a || i === n) && (i = a),
                (a > r || r === n) && (r = a);
            return { left: e, right: t, top: i, bottom: r };
          }),
          (t.PointInRect = function(e, t) {
            return (
              e.getX() >= t.left &&
              e.getX() <= t.right &&
              e.getY() >= t.top &&
              e.getY() <= t.bottom
            );
          }),
          (t.OctAngleUtil = function(e, t) {
            var i,
              r = t.copy().subtract(e),
              s = o.GeometricPoint(Math.abs(r.getX()), Math.abs(r.getY()));
            return 0 === r.getX() && 0 === r.getY()
              ? n
              : ((i =
                  s.getX() > s.getY()
                    ? s.getY() / s.getX()
                    : 2 - s.getX() / s.getY()),
                r.getX() < 0
                  ? r.getY() <= 0
                    ? (i += 4)
                    : (i = 4 - i)
                  : r.getY() < 0 && (i = 8 - i),
                i);
          }),
          (t.RectIntersectsCurve = function(e, n) {
            var i,
              r,
              s,
              a,
              c = n.curve.center,
              l = n.curve.radius,
              u = {
                top: e.top - c.getY(),
                bottom: e.bottom - c.getY(),
                left: e.left - c.getX(),
                right: e.right - c.getX(),
              },
              d = l * l,
              h = u.left * u.left,
              p = u.right * u.right,
              f = u.top * u.top,
              m = u.bottom * u.bottom,
              g = o.GeometricPoint(0, 0),
              b = function() {
                var e,
                  t = !('circle' === n.type || 'arc' === n.type);
                return (
                  (e =
                    u.right < 0
                      ? u.top > 0
                        ? d > p + f
                        : u.bottom < 0
                        ? d > p + m
                        : -u.right < l
                      : u.left > 0
                      ? u.top > 0
                        ? d > h + f
                        : u.bottom < 0
                        ? d > h + m
                        : u.left < l
                      : u.top > 0
                      ? u.top < l
                      : u.bottom < 0
                      ? -u.bottom < l
                      : !0),
                  e &&
                    !t &&
                    (e = h + f > d || h + m > d || p + f > d || p + m > d),
                  e
                );
              },
              v = function() {
                var i = function() {
                  var e = t.OctAngleUtil(g, a);
                  return r > e && (e += 8), s >= e ? !0 : !1;
                };
                if (t.PointInRect(n.curve.initialPoint, e)) return !0;
                if (t.PointInRect(n.curve.finalPoint, e)) return !0;
                for (; 0 > r; ) r += 8;
                for (; r > s; ) s += 8;
                if (d >= f) {
                  if (
                    ((a = o.GeometricPoint(Math.sqrt(d - f), u.top)),
                    u.left <= a.getX() && u.right >= a.getX() && i())
                  )
                    return !0;
                  if (
                    ((a = o.GeometricPoint(-1 * a.getX(), a.getY())),
                    u.left <= a.getX() && u.right >= a.getX() && i())
                  )
                    return !0;
                }
                if (d >= m) {
                  if (
                    ((a = o.GeometricPoint(Math.sqrt(d - m), u.bottom)),
                    u.left <= a.getX() && u.right >= a.getX() && i())
                  )
                    return !0;
                  if (
                    ((a = o.GeometricPoint(-1 * a.getX(), a.getY())),
                    u.left <= a.getX() && u.right >= a.getX() && i())
                  )
                    return !0;
                }
                if (d >= h) {
                  if (
                    ((a = o.GeometricPoint(u.left, Math.sqrt(d - h))),
                    u.top <= a.getY() && u.bottom >= a.getY() && i())
                  )
                    return !0;
                  if (
                    ((a = o.GeometricPoint(a.getX(), -1 * a.getY())),
                    u.top <= a.getY() && u.bottom >= a.getY() && i())
                  )
                    return !0;
                }
                if (d >= p) {
                  if (
                    ((a = o.GeometricPoint(u.right, Math.sqrt(d - p))),
                    u.top <= a.getY() && u.bottom >= a.getY() && i())
                  )
                    return !0;
                  if (
                    ((a = o.GeometricPoint(a.getX(), -1 * a.getY())),
                    u.top <= a.getY() && u.bottom >= a.getY() && i())
                  )
                    return !0;
                }
                return !1;
              },
              y = function(i) {
                var c,
                  l,
                  b,
                  v = n.curve.center,
                  y = n.curve.initialPoint,
                  x = n.curve.finalPoint;
                if (d >= f) {
                  if (
                    ((c = o.GeometricPoint(e.left, e.top)),
                    (l = o.GeometricPoint(e.right, e.top)),
                    t.SegmentSectsSegment(c, l, v, y))
                  )
                    return !0;
                  if (t.SegmentSectsSegment(c, l, v, x)) return !0;
                }
                if (d >= m) {
                  if (
                    ((c = o.GeometricPoint(e.left, e.bottom)),
                    (l = o.GeometricPoint(e.right, e.bottom)),
                    t.SegmentSectsSegment(c, l, v, y))
                  )
                    return !0;
                  if (t.SegmentSectsSegment(c, l, v, x)) return !0;
                }
                if (d >= h) {
                  if (
                    ((c = o.GeometricPoint(e.left, e.top)),
                    (l = o.GeometricPoint(e.left, e.bottom)),
                    t.SegmentSectsSegment(c, l, v, y))
                  )
                    return !0;
                  if (t.SegmentSectsSegment(c, l, v, x)) return !0;
                }
                if (d >= p) {
                  if (
                    ((c = o.GeometricPoint(e.right, e.top)),
                    (l = o.GeometricPoint(e.right, e.bottom)),
                    t.SegmentSectsSegment(c, l, v, y))
                  )
                    return !0;
                  if (t.SegmentSectsSegment(c, l, v, x)) return !0;
                }
                return i
                  ? !1
                  : d > f + h
                  ? ((a = o.GeometricPoint(u.left, u.top)),
                    (b = t.OctAngleUtil(g, a)),
                    r > b && (b += 8),
                    s >= b)
                  : !1;
              },
              x = function(i) {
                var r,
                  s,
                  c = n.curve.initialPoint,
                  l = n.curve.finalPoint;
                if (
                  d >= f &&
                  ((r = o.GeometricPoint(e.left, e.top)),
                  (s = o.GeometricPoint(e.right, e.top)),
                  t.SegmentSectsSegment(r, s, c, l))
                )
                  return !0;
                if (
                  d >= m &&
                  ((r = o.GeometricPoint(e.left, e.bottom)),
                  (s = o.GeometricPoint(e.right, e.bottom)),
                  t.SegmentSectsSegment(r, s, c, l))
                )
                  return !0;
                if (
                  d >= h &&
                  ((r = o.GeometricPoint(e.left, e.top)),
                  (s = o.GeometricPoint(e.left, e.bottom)),
                  t.SegmentSectsSegment(r, s, c, l))
                )
                  return !0;
                if (
                  d >= p &&
                  ((r = o.GeometricPoint(e.right, e.top)),
                  (s = o.GeometricPoint(e.right, e.bottom)),
                  t.SegmentSectsSegment(r, s, c, l))
                )
                  return !0;
                if (i) return !1;
                a = o.GeometricPoint(e.left, e.top);
                var u = d >= f + h;
                return u && t.ThreePointCollinear(c, l, a).orientation > 0;
              };
            if (0 === n.curve.orientation)
              return t.SegmentSectsRect(
                e,
                n.curve.initialPoint,
                n.curve.finalPoint
              );
            if (((i = b()), !i)) return !1;
            if ('circle' === n.type || 'circleInterior' === n.type) return i;
            if (
              ((r = t.OctAngleUtil(n.curve.center, n.curve.initialPoint)),
              (s = t.OctAngleUtil(n.curve.center, n.curve.finalPoint)),
              v())
            )
              return !0;
            switch (n.type) {
              case 'arc':
                i = !1;
                break;
              case 'arcSectorPerimeter':
                i = y(!0);
                break;
              case 'arcSector':
                i = y(!1);
                break;
              case 'arcSegmentPerimeter':
                i = x(!0);
                break;
              case 'arcSegment':
                i = x(!1);
                break;
              default:
                o.signalErrorWithMessage(
                  'Unexpected curve type: RectIntersectsCurve should only see arcs here.'
                );
            }
            return i;
          }),
          (t.RectsIntersect = function(e, t) {
            var n, i, r, s;
            return (
              (n = e.left > t.left ? e.left : t.left),
              (s = e.top > t.top ? e.top : t.top),
              (i = e.right > t.right ? e.right : t.right),
              (r = e.bottom > t.bottom ? e.bottom : t.bottom),
              i >= n && r >= s
            );
          }),
          (t.SegmentSectsSegment = function(e, t, n, i) {
            var r,
              s = e.getX(),
              a = e.getY(),
              c = t.getX(),
              l = t.getY(),
              u = n.getX(),
              d = n.getY(),
              h = i.getX(),
              p = i.getY(),
              f = c - s,
              m = l - a,
              g = p - d,
              b = s * g,
              v = b + c * -g + u * -m + h * m;
            return 0 === v || isNaN(v)
              ? null
              : ((b = (b + u * (a - p) + h * (d - a)) / v),
                0 > b || b > 1
                  ? null
                  : ((r = -(s * (d - l) + c * (a - d) + u * m) / v),
                    0 > r || r > 1
                      ? null
                      : o.GeometricPoint(s + f * b, a + m * b)));
          }),
          (t.SegmentSectsRect = function(e, n, i) {
            function r() {
              var t = n.x,
                r = n.y,
                s = i.x,
                o = i.y;
              return t < e.left && s < e.left
                ? !1
                : t > e.right && s > e.right
                ? !1
                : r < e.top && o < e.top
                ? !1
                : r > e.bottom && o > e.bottom
                ? !1
                : !0;
            }
            var s,
              a,
              c,
              l,
              u = t.PointInRect(n, e) || t.PointInRect(i, e);
            return (
              !u &&
                r() &&
                ((s = o.GeometricPoint(e.left, e.top)),
                (a = o.GeometricPoint(e.right, e.top)),
                (c = o.GeometricPoint(e.left, e.bottom)),
                (l = o.GeometricPoint(e.right, e.bottom)),
                (u =
                  t.SegmentSectsSegment(n, i, s, a) ||
                  t.SegmentSectsSegment(n, i, s, c) ||
                  t.SegmentSectsSegment(n, i, a, l) ||
                  t.SegmentSectsSegment(n, i, c, l))),
              !!u
            );
          }),
          (t.IntersectionsOfRectAndSegment = function(e, t, n) {
            var i = o.GeometricPoint(e.left, e.top),
              r = o.GeometricPoint(e.right, e.top),
              s = o.GeometricPoint(e.left, e.bottom),
              a = o.GeometricPoint(e.right, e.bottom),
              c = o.Geom.SegmentSectsSegment(t, n, i, r),
              l = o.Geom.SegmentSectsSegment(t, n, s, a),
              u = o.Geom.SegmentSectsSegment(t, n, i, s),
              d = o.Geom.SegmentSectsSegment(t, n, r, a),
              h = [];
            return (
              c && h.push(c), l && h.push(l), u && h.push(u), d && h.push(d), h
            );
          }),
          (t.PointInParallelogram = function(e, t, n, i) {
            function r(e, t) {
              return e.getX() * t.getY() - e.getY() * t.getX();
            }
            var s,
              o = t.subtract(n),
              a = i.subtract(n),
              c = e.subtract(n),
              l = r(o, a);
            return 0 === l
              ? !1
              : ((s = -r(c, o) / l),
                0 > s || s > 1
                  ? !1
                  : ((s = r(c, a) / l), 0 > s || s > 1 ? !1 : !0));
          }),
          (t.ParallelogramSectsRect = function(e, n, i, r) {
            var s;
            return t.PointInParallelogram(
              o.GeometricPoint(e.left, e.top),
              n,
              i,
              r
            )
              ? !0
              : t.SegmentSectsRect(e, i, n)
              ? !0
              : t.SegmentSectsRect(e, i, r)
              ? !0
              : ((s = i.add(n.subtract(i)).add(r.subtract(i))),
                t.SegmentSectsRect(e, n, s)
                  ? !0
                  : t.SegmentSectsRect(e, r, s)
                  ? !0
                  : !1);
          }),
          (t.ThreePointCollinear = function(e, t, n) {
            function i(e) {
              var t = 4e-4;
              return e > -t && t > e;
            }
            var r,
              s,
              a = e.subtract(t),
              c = n.subtract(t),
              l = o.GeometricPoint(
                c.x * a.x + c.y * a.y,
                c.y * a.x - c.x * a.y
              ),
              u = a.vLength();
            return (
              (r = i(l.y) ? 0 : o.math.sign(l.y)),
              0 === r && (s = a.dot(c) > 0 ? 'fullCircle' : 'halfCircle'),
              { exists: !i(u), orientation: r, isStraight: s }
            );
          }),
          (t.AngleFromPoint = function(e) {
            var t = Math.atan2(e.y, e.x);
            return t <= -Math.PI && (t += 2 * Math.PI), t;
          }),
          (t.CenterFromThreePoints = function(e, t, n) {
            var i = t.subtract(e),
              r = n.subtract(e),
              s = n.subtract(t),
              a = e.add(t),
              c = e.add(n),
              l = i.dot(a),
              u = r.dot(c),
              d = 2 * (i.x * s.y - i.y * s.x),
              h = (r.y * l - i.y * u) / d,
              p = (i.x * u - r.x * l) / d;
            return o.GeometricPoint(h, p);
          }),
          (t.LineLineIntersection = function(t, i, r) {
            var s,
              a,
              c = e(t.getZeroPoint(), t.getUnitPoint()),
              l = e(i.getZeroPoint(), i.getUnitPoint()),
              u = o.GeometricPoint(null, null),
              d = c.a * l.b - l.a * c.b;
            return (
              n === r && (r = 1e-8),
              Math.abs(d) > r &&
                ((s = (l.b * c.c - c.b * l.c) / d),
                (a = (c.a * l.c - l.a * c.c) / d),
                (u = o.GeometricPoint(s, a))),
              !u.isDefined() ||
                (t.pointIsInBounds(u) && i.pointIsInBounds(u)) ||
                (u = o.GeometricPoint(NaN, NaN)),
              u
            );
          }),
          (t.CircleStraightIntersection = function(e, t) {
            var n,
              i,
              r,
              s,
              o,
              a,
              c,
              l,
              u,
              d,
              h,
              p,
              f = t.getP0(),
              m = t.getP1(),
              g = e.center,
              b = e.radius,
              v = 0.001,
              y = 2e-4,
              x = 1e-9,
              w = b - y,
              k = b + y;
            return (
              (n = []),
              (i = m.subtract(f)),
              (r = i.dot(i)),
              Math.abs(r) < v
                ? n
                : ((s = 2 * i.dot(f.subtract(g))),
                  (p = s * s),
                  (u = g.dot(g) + f.dot(f) - 2 * g.dot(f)),
                  (h = u - k * k),
                  (a = p - 4 * r * h),
                  0 > a
                    ? n
                    : ((d = u - w * w),
                      (a = p - 4 * r * d),
                      0 > a ? (a = 0) : ((o = u - b * b), (a = p - 4 * r * o)),
                      (c = f.add(i.multiply((-s - Math.sqrt(a)) / (2 * r)))),
                      c.isDefined() && t.pointIsInBounds(c, x) && n.push(c),
                      (l = f.add(i.multiply((-s + Math.sqrt(a)) / (2 * r)))),
                      l.isDefined() && t.pointIsInBounds(l, x) && n.push(l),
                      1 === n.length && n.push(n[0]),
                      n))
            );
          }),
          (t.CircleCircleIntersection = function(e, t) {
            var n,
              i,
              r,
              s,
              a,
              c,
              l,
              u = e.center,
              d = e.radius,
              h = t.center,
              p = t.radius;
            return (
              (n = []),
              (i = h.subtract(u)),
              (r = i.vLength()),
              r > d + p
                ? n
                : r < Math.abs(d - p)
                ? n
                : ((s = (d * d - p * p + r * r) / (2 * r)),
                  (a = u.add(i.multiply(s / r))),
                  (c = Math.sqrt(d * d - s * s)),
                  (l = o.GeometricPoint(-i.y, i.x).multiply(c / r)),
                  n.push(a.add(l)),
                  n.push(a.add(l.negate())),
                  e.orientation * t.orientation === -1 && n.reverse(),
                  n)
            );
          }),
          (t.RectSectsPolygon = function(e, t) {
            function n(e, t) {
              var n,
                i,
                r = e.x,
                s = e.y,
                o = -1,
                a = t.length;
              for (n = t[0], i = t[t.length - 1]; a--; )
                ((n.y <= s && s < i.y) || (i.y <= s && s < n.y)) &&
                  r - n.x < ((i.x - n.x) * (s - n.y)) / (i.y - n.y) &&
                  (o *= -1),
                  (i = n),
                  (n = t[t.length - a]);
              return 1 === o;
            }
            return n(o.GeometricPoint(e.left, e.top), t)
              ? !0
              : o.Geom.RectSectsPolygonPerimeter(e, t);
          }),
          (t.RectSectsPolygonPerimeter = function(e, t) {
            var n, i, r;
            for (r = 0; r < t.length; r += 1)
              if (
                ((i = t[r]),
                (n = t[(r + 1) % t.length]),
                o.Geom.SegmentSectsRect(e, n, i))
              )
                return !0;
            return !1;
          }),
          (t.unionRectPoint = function(e, t) {
            var n = {};
            return (
              e
                ? ((n.left = Math.min(e.left, t.x)),
                  (n.right = Math.max(e.right, t.x)),
                  (n.top = Math.min(e.top, t.y)),
                  (n.bottom = Math.max(e.bottom, t.y)))
                : ((n.left = n.right = t.x), (n.top = n.bottom = t.y)),
              n
            );
          }),
          (o.Geom = t);
      })(),
      (o.GeometricArc = (function() {
        function e() {
          var e = Object.create(s);
          return e;
        }
        var i = 3e4,
          r = 7,
          s = {
            transformClass: 'GeometricArc',
            center: o.GeometricPoint.UNDEFINED,
            radius: n,
            initialAngle: n,
            finalAngle: n,
            initialPoint: o.GeometricPoint.UNDEFINED,
            middlePoint: o.GeometricPoint.UNDEFINED,
            finalPoint: o.GeometricPoint.UNDEFINED,
            orientation: n,
            exists: !1,
            arcAngle: n,
            getZeroPoint: function() {
              return this.initialPoint;
            },
            getUnitPoint: function() {
              return this.finalPoint;
            },
            getP0: function() {
              return this.initialPoint;
            },
            getP1: function() {
              return this.finalPoint;
            },
            updateSecondaryGeometry: function() {
              var e = [],
                n = this;
              (this.arcAngle = this.finalAngle - this.initialAngle),
                this.arcAngle < 0 && (this.arcAngle += 2 * Math.PI),
                0 === this.orientation
                  ? (this.arcLength = this.finalPoint
                      .subtract(this.initialPoint)
                      .vLength())
                  : (this.arcLength = this.radius * this.arcAngle),
                e.push(
                  this.initialPoint.x,
                  this.initialPoint.y,
                  this.finalPoint.x,
                  this.finalPoint.y
                ),
                0 !== this.orientation &&
                  e.push(this.radius, this.center.x, this.center.y),
                t.each(e, function(e, t) {
                  return Math.abs(t) > i ? ((n.exists = !1), !1) : void 0;
                });
            },
            getCache: function(e) {
              var t;
              return (
                this.cache || (this.cache = {}),
                this.cache[e]
                  ? this.cache[e]
                  : ((t = {
                      halfChordLength: 0,
                      perimeterLength: 0,
                      initialParam: 0,
                      finalParam: 0,
                    }),
                    0 === this.orientation
                      ? ((t.arcLength = this.finalPoint
                          .subtract(this.initialPoint)
                          .vLength()),
                        (t.perimeterLength = t.arcLength))
                      : ('ArcSegment' === e
                          ? (t.halfChordLength =
                              this.finalPoint
                                .subtract(this.initialPoint)
                                .vLength() / 2)
                          : 'ArcSector' === e &&
                            (t.halfChordLength = this.radius),
                        (t.perimeterLength =
                          this.arcLength + 2 * t.halfChordLength)),
                    0 !== t.perimeterLength &&
                      (t.initialParam = t.halfChordLength / t.perimeterLength),
                    (t.finalParam = 1 - t.initialParam),
                    (this.cache[e] = t),
                    t)
              );
            },
            pointIsInBounds: function(e) {
              var t,
                n = 1e-7;
              if (0 === this.orientation) {
                var i = o.GeometricPoint.mapPointToLine(
                  this.initialPoint,
                  this.finalPoint,
                  e
                ).param;
                return i >= -n && 1 + n >= i;
              }
              return this.arcAngle === 2 * Math.PI
                ? !0
                : ((t = o.Geom.AngleFromPoint(e.subtract(this.center))),
                  t < this.initialAngle - n && (t += 2 * Math.PI),
                  t >= this.initialAngle - n &&
                    t <= this.initialAngle + this.arcAngle + n);
            },
            mapPointToArc: function(e, t, n) {
              var i = this.getCache(t),
                r = o.Geom.AngleFromPoint(e.subtract(this.center)),
                s = this.initialAngle + this.arcAngle,
                a = {};
              return (
                r < this.initialAngle && (r += 2 * Math.PI),
                (a.param = i.initialParam),
                n.returnPoint && (a.point = this.initialPoint),
                s >= r
                  ? ((a.param =
                      (r - this.initialAngle) / (s - this.initialAngle)),
                    (a.param =
                      i.initialParam +
                      a.param * (i.finalParam - i.initialParam)),
                    n.returnPoint &&
                      (a.point = o.GeometricPoint.FromCenterRadiusAngle(
                        this.center,
                        this.radius,
                        r
                      )))
                  : r - s < this.initialAngle - (r - 2 * Math.PI) &&
                    ((a.param = i.finalParam),
                    n.returnPoint && (a.point = this.finalPoint)),
                a
              );
            },
            mapPositionToPathValue: function(e, t) {
              function n(e, t) {
                var n,
                  i,
                  r,
                  s = 1 / 0;
                if (1 === e.length) return e[0];
                for (r = 0; r < e.length; r++)
                  (i = e[r].point.subtract(t).vLength2()),
                    s > i && ((s = i), (n = e[r]));
                return n;
              }
              var i,
                r,
                s,
                a,
                c = [];
              return 0 === this.orientation
                ? ((i = o.GeometricPoint.mapPointToLine(
                    this.initialPoint,
                    this.finalPoint,
                    e,
                    { clampP0: !0, clampP1: !0 }
                  )),
                  i.param)
                : (c.push(
                    this.mapPointToArc(e, t, { returnPoint: 'SimpleArc' !== t })
                  ),
                  'SimpleArc' !== t &&
                    ((r = this.getCache(t)),
                    (a =
                      'ArcSector' === t
                        ? this.center
                        : this.initialPoint.add(this.finalPoint).multiply(0.5)),
                    (i = o.GeometricPoint.mapPointToLine(
                      a,
                      this.initialPoint,
                      e,
                      { clampP0: !0, clampP1: !0, returnPoint: !0 }
                    )),
                    (i.param *= r.initialParam),
                    c.push(i),
                    (i = o.GeometricPoint.mapPointToLine(
                      a,
                      this.finalPoint,
                      e,
                      { clampP0: !0, clampP1: !0, returnPoint: !0 }
                    )),
                    (i.param = 1 - i.param * r.initialParam),
                    c.push(i)),
                  (s = n(c, e)),
                  1 === this.orientation ? s.param : 1 - s.param);
            },
            mapPathValueToPosition: function(e, t, n) {
              var i,
                r,
                s,
                a,
                c,
                l,
                u,
                d = 1e-10,
                h = this.orientation;
              return 0 === h
                ? ((i = this.finalPoint.subtract(this.initialPoint)),
                  n && (n.derivative = o.GeometricPoint(i.x, i.y)),
                  this.initialPoint.add(i.multiply(e)))
                : (-1 === h && (e = 1 - e),
                  (r = this.getCache(t)),
                  e >= r.initialParam - d && e <= r.finalParam + d
                    ? (e <= r.initialParam
                        ? ((u = this.initialPoint),
                          (i = u.subtract(this.center)))
                        : e >= r.finalParam
                        ? ((u = this.finalPoint), (i = u.subtract(this.center)))
                        : ((c =
                            this.initialAngle +
                            (this.arcAngle * (e - r.initialParam)) /
                              (r.finalParam - r.initialParam)),
                          (i = o.GeometricPoint(
                            this.radius * Math.cos(c),
                            this.radius * Math.sin(c)
                          )),
                          (u = o.GeometricPoint(
                            this.center.x + i.x,
                            this.center.y + i.y
                          ))),
                      n &&
                        (n.derivative = o
                          .GeometricPoint(-i.y, i.x)
                          .multiply(
                            (h * this.arcAngle) /
                              (r.finalParam - r.initialParam)
                          )))
                    : (1 === e && 1 === h && (e = 0),
                      0 === e && -1 === h && (e = 1),
                      (s =
                        'ArcSector' === t
                          ? this.center
                          : this.initialPoint
                              .add(this.finalPoint)
                              .multiply(0.5)),
                      e < r.initialParam
                        ? ((a = this.initialPoint), (l = r.initialParam))
                        : ((a = this.finalPoint),
                          (e = 1 - e),
                          (l = 1 - r.finalParam),
                          (h *= -1),
                          (l = r.initialParam)),
                      (e /= r.initialParam),
                      (u = s.add(a.subtract(s).multiply(e))),
                      n &&
                        (n.derivative = o.GeometricPoint(
                          (h * (a.x - s.x)) / l,
                          (h * (a.y - s.y)) / l
                        ))),
                  u);
            },
            packIntoSampleArray: function(e, t) {
              var n = r * t;
              (e[n] = this.orientation),
                (e[n + 1] = this.initialPoint.x),
                (e[n + 2] = this.initialPoint.y),
                (e[n + 3] = this.finalPoint.x),
                (e[n + 4] = this.finalPoint.y),
                (e[n + 5] = this.center.x),
                (e[n + 6] = this.center.y);
            },
          };
        return {
          FromStraightEndpoints: function(t, n) {
            var i = new e();
            return (
              (i.orientation = 0),
              (i.initialPoint = t),
              (i.middlePoint = o.GeometricPoint(
                (t.getX() + n.getX()) / 2,
                (t.getY() + n.getY()) / 2
              )),
              (i.finalPoint = n),
              (i.exists = !0),
              i.updateSecondaryGeometry(),
              i
            );
          },
          FromThreePoints: function(t, n, r) {
            var s,
              a,
              c,
              l,
              u = o.Geom.ThreePointCollinear(t, r, n);
            return !u.exists || n.equals(t) || n.equals(r)
              ? new e()
              : 0 === u.orientation
              ? o.GeometricArc.FromStraightEndpoints(t, r)
              : ((l = -1 === u.orientation),
                (s = new e()),
                (s.center = o.Geom.CenterFromThreePoints(t, n, r)),
                (a = t.subtract(s.center)),
                (c = r.subtract(s.center)),
                (s.radius = a.vLength()),
                (s.initialAngle = o.Geom.AngleFromPoint(l ? c : a)),
                (s.finalAngle = o.Geom.AngleFromPoint(l ? a : c)),
                (s.orientation = u.orientation),
                (s.initialPoint = l ? r : t),
                (s.middlePoint = n),
                (s.finalPoint = l ? t : r),
                (s.exists = !0),
                s.radius > i ||
                Math.abs(s.center.x) > i ||
                Math.abs(s.center.y) > i
                  ? o.GeometricArc.FromStraightEndpoints(t, r)
                  : (s.updateSecondaryGeometry(), s));
          },
          FromCenterAndEndpoints: function(t, i, r, s) {
            var a,
              c,
              l = new e(),
              u = i.subtract(t),
              d = r.subtract(t),
              h = 1e-7;
            return i.equals(r, h) || i.equals(t, h) || r.equals(t, h)
              ? ((l.exists = !1), l)
              : (n === s && (s = 1),
                (c = -1 === s),
                (l.center = t),
                (l.radius = u.vLength()),
                (l.initialAngle = o.Geom.AngleFromPoint(c ? d : u)),
                (l.finalAngle = o.Geom.AngleFromPoint(c ? u : d)),
                (l.orientation = s),
                (l.initialPoint = c ? r : i),
                (a = (l.initialAngle + l.finalAngle) / 2),
                l.initialAngle > l.finalAngle && (a += Math.PI),
                (l.middlePoint = o
                  .GeometricPoint(Math.cos(a), Math.sin(a))
                  .multiply(l.radius)
                  .add(l.center)),
                (l.finalPoint = c ? i : r),
                (l.exists = !0),
                l.updateSecondaryGeometry(),
                l);
          },
          FromCenterAndRadius: function(t, n) {
            var i = new e(),
              r = t.add(o.GeometricPoint(t.x + n, t.y));
            return (
              (i.center = t),
              (i.radius = n),
              (i.initialAngle = 0),
              (i.finalAngle = 2 * Math.PI),
              (i.orientation = -1),
              (i.initialPoint = r),
              (i.middlePoint = r),
              (i.finalPoint = r),
              (i.exists = !0),
              i.updateSecondaryGeometry(),
              i
            );
          },
          FromPackedSampleArray: function(e, t) {
            var n,
              i = t * r,
              s = e[i],
              a = e[i + 1],
              c = e[i + 2],
              l = e[i + 3],
              u = e[i + 4],
              d = e[i + 5],
              h = e[i + 6],
              p = o.GeometricPoint(a, c),
              f = o.GeometricPoint(l, u);
            return 0 === s
              ? o.GeometricArc.FromStraightEndpoints(p, f)
              : ((n = o.GeometricPoint(d, h)),
                o.GeometricArc.FromCenterAndEndpoints(n, p, f, 1));
          },
          packedSampleSize: r,
        };
      })()),
      (o.labels = {}),
      (o.labels.parseLabelExpression = function(e, t) {
        function i(e) {
          for (
            var t,
              n = 0,
              i = e.length,
              r = i,
              s = { before: '', inside: '', after: '' };
            n < e.length && '[' !== e[n];

          )
            n += 1;
          for (
            r = n + 1, t = 1;
            i > r &&
            (']' === e[r] ? (t -= 1) : '[' === e[r] && (t += 1), 0 !== t);

          )
            r += 1;
          return (
            r === i || r - n === 1 || (0 === n && r + 1 === i)
              ? (n = i)
              : (i = r),
            (s.before = e.substr(0, n)),
            (s.inside = e.substr(n + 1, i - n - 1)),
            (s.after = e.substr(i + 1)),
            s
          );
        }
        function r(e) {
          e || (e = '');
          var t,
            n = /([()\[\]|<>{},\u2220\s.\/\-]+)/,
            i = e.split(n),
            r = [];
          for (t = 0; t < i.length; t += 1) {
            var s = i[t];
            r.push(o.mfs.makeTextMFS(s, a && /[a-zA-Zα-ω]/.test(s[0])));
          }
          return i.length > 1 ? o.mfs.makeHorizontalMFS.apply(this, r) : r[0];
        }
        function s(e) {
          var t,
            n = [];
          return (
            e &&
              ((t = i(e)),
              t.inside
                ? (n.push({ type: 'sub', value: [s(t.before), s(t.inside)] }),
                  t.after && n.push(s(t.after)))
                : n.push(r(t.before))),
            1 === n.length ? n[0] : o.mfs.makeHorizontalMFS.apply(this, n)
          );
        }
        var a = t || t === n;
        try {
          return s(e);
        } catch (t) {
          throw o.createError('Error parsing label "' + e + '": ' + t);
        }
      }),
      (o.labels.legalNameOrigins = function(e) {
        var t;
        return (
          e
            ? ((t = []),
              e.hasLabel && t.push('namedFromLabel'),
              e.isTransformationConstraint &&
                t.push('namedByPrime', 'namedByShortFn', 'namedByFullFn'),
              'Expression' === e.kind && t.push('namedFromTemplate'))
            : (t = [
                'namedFromLabel',
                'namedByPrime',
                'namedByShortFn',
                'namedByFullFn',
                'namedFromTemplate',
              ]),
          t
        );
      }),
      (function() {
        function e(e, t) {
          if ('Expression' === e.kind) {
            if ('Function' === t) return 'Function';
            if ('ScalarParameter' === t) return 'Parameter';
          }
          for (var n = e.kind, r = e.baseKinds.slice(); n; ) {
            if (i.hasOwnProperty(n)) return n;
            n = r.pop();
          }
        }
        function n() {
          var e = Object.create(r);
          return (e.counters = {}), e;
        }
        var i = {
            Parameter: 't',
            Function: 'fghqrstuvw',
            Point: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            Straight: 'jklmnopqrstuvwxyzabcdefghi',
            Circle: 'c',
            Polygon: 'P',
            CircleInterior: 'C',
            Sampler: 'L',
            Measure: 'm',
            CoordSys: 'S',
            Axis: 'xy',
            Button: '',
            Arc: 'a',
            ArcInterior: 'A',
            Map: '',
            IterateImage: '',
            Picture: '',
            Table: '',
            AngleMarker: '',
            Kind: '',
          },
          r = {
            generate: function(e, t) {
              var n = this.counters[e],
                r = i[e];
              n
                ? r.length
                  ? ((n.index += 1),
                    n.index >= r.length && ((n.index = 0), (n.subscript += 1)))
                  : (n.subscript += 1)
                : ((this.counters[e] = { index: 0, subscript: 0 }),
                  (n = this.counters[e]),
                  r.length <= 1 && (n.subscript = 1));
              var s = '';
              return (
                r.length
                  ? ((s += r[n.index]),
                    n.subscript > 0 &&
                      ((s += '['), (s += n.subscript), (s += ']')))
                  : (s += n.subscript),
                s
              );
            },
            copy: function() {
              var e = Object.create(r);
              return (e.counters = t.extend(!0, {}, this.counters)), e;
            },
          },
          s = {
            curGenerator: function() {
              return this.generators[this.generators.length - 1];
            },
            generateLabel: function(t, n, i) {
              function r(t, n) {
                return c === e(n, n.genus) && s === n.label
                  ? ((l = !0), !1)
                  : void 0;
              }
              for (var s, a = o.gObjects[t], c = e(a, n), l = !0; l; )
                (l = !1),
                  (s = this.curGenerator().generate(c)),
                  this.sketch.eachGObj(r);
              if (this.session) {
                if (!i)
                  throw o.createError(
                    'generateLabel called with a toolplay session but no id.'
                  );
                this.session.generatedLabels ||
                  (this.session.generatedLabels = {}),
                  (this.session.generatedLabels[i] = !0);
              }
              return s;
            },
            saveState: function(e) {
              this.generators.push(this.curGenerator().copy()),
                (this.session = e);
            },
            restoreSavedState: function() {
              var e;
              if (this.generators.length < 2)
                throw o.createError(
                  'LabelPool.restoreSavedState() called without calling saveState()'
                );
              return (
                this.generators.pop(),
                (e = this.session),
                (this.session = null),
                e
              );
            },
            forgetSavedState: function() {
              if (this.generators.length < 2)
                throw o.createError(
                  'LabelPool.forgetSavedState() called without calling saveState()'
                );
              this.generators.splice(this.generators.length - 2, 1),
                (this.session = null);
            },
          };
        o.LabelPool = {
          createInSketch: function(e) {
            var t = Object.create(s);
            return (
              (t.sketch = e), (t.generators = []), t.generators.push(n()), t
            );
          },
        };
      })(),
      (function() {
        function e(e) {
          var t,
            n,
            i = e.length,
            r = 0,
            s = ' +-*/()−⋅',
            o = !1,
            a = !1;
          for (t = 0; i > t; ++t)
            if (
              ((n = e[t]),
              (o = o || s.indexOf(n) >= 0),
              '(' === n ? ++r : r && ')' === n ? --r : r || (a = !0),
              o && a)
            )
              return !0;
          return r > 0;
        }
        function i(e) {
          return 'Expression' === e.kind && 'ScalarParameter' === e.genus;
        }
        function r(e) {
          return 'namedFromLabel' === e.style.nameOrigin;
        }
        function s(t, n) {
          var s;
          if ('reference' !== t.type) return !1;
          if (!n) throw o.createError('reference without parents!');
          if (((s = n[t.name]), i(s) || r(s))) return s.label ? e(s.label) : !1;
          if (s.parsedInfix && 'blank' === s.parsedInfix.type) return !1;
          if (s.parsedInfix)
            throw o.createError(
              'non-blank parsed infix not expected in isTextuallyComplexReference'
            );
          return !0;
        }
        function a(e) {
          return 'reference' === e.type;
        }
        function c(e, t) {
          var n = { expr: e, fnReferences: t };
          if (!a(e)) return n;
          var s = t[e.name];
          if (i(s) || !s.parsedInfix || 'blank' === s.parsedInfix.type || r(s))
            return n;
          if (!s.parsedInfix || !s.parsedInfix.children)
            throw o.createError('expected parsedInfix with children');
          return c(s.parsedInfix.children.expr, s.parentsList);
        }
        function l(e, t) {
          var n =
            'unary-expr' === e.type ||
            ('primary' === e.type && e.children.unit);
          return n || s(e, t);
        }
        function u(e, t) {
          return '^' !== e.operator ? !1 : l(t.expr, t.fnReferences);
        }
        function d(e, t) {
          var n = '/' === e.operator;
          return !n && 'binary-expr' === t.expr.type;
        }
        function h(e, t) {
          var n = '/' === e.operator;
          return !n && 'binary-expr' === t.expr.type;
        }
        function p(e, t) {
          var n = '/' === e.operator;
          return !n && 'unary-expr' === t.expr.type;
        }
        function f(e, t) {
          var n = '/' === e.operator;
          return n && '/' === t.expr.operator;
        }
        function m(e, t) {
          var n = o.mfs.binaryOperatorPrecedence[e.operator],
            i = o.mfs.binaryOperatorPrecedence[t.expr.operator];
          return n > i || (i === n && '^' === e.operator);
        }
        function g(e, t) {
          var n = o.mfs.binaryOperatorPrecedence[e.operator],
            i = o.mfs.binaryOperatorPrecedence[t.expr.operator];
          return e.operator === t.expr.operator && P[e.operator]
            ? !1
            : n >= i && '^' !== e.operator && '/' !== t.expr.operator;
        }
        function b(e, t) {
          return '^' !== e.operator;
        }
        function v(e, t) {
          var n;
          return (n = 'numeric' === e.subtype ? e.value : C[e.value]), t(n);
        }
        function y(e, t, n) {
          return t(
            e.children.declaration && !n
              ? e.children.declaration
              : e.children.expr
          );
        }
        function x(e, t) {
          var n = o.units.findUnit(e.name);
          return t(n.symbol);
        }
        function w(e) {
          if ('number' == typeof e) return T[e];
          var t;
          for (t = 0; t < T.length; t++) if (e === T[t].type) return T[t];
          return null;
        }
        var k = {};
        (o.mfs = {}),
          (o.mfs.binaryOperatorPrecedence = {
            '^': 3,
            '*': 2,
            '/': 2,
            '+': 1,
            '-': 1,
          }),
          (o.mfs.symMap = {
            20: ' ',
            21: '!',
            22: '∀',
            23: '#',
            24: '∃',
            25: '%',
            26: '&',
            27: '∋',
            28: '(',
            29: ')',
            '2A': '∗',
            '2B': '+',
            '2C': ',',
            '2D': '−',
            '2E': '.',
            '2F': '/',
            30: '0',
            31: '1',
            32: '2',
            33: '3',
            34: '4',
            35: '5',
            36: '6',
            37: '7',
            38: '8',
            39: '9',
            '3A': ':',
            '3B': ';',
            '3C': '<',
            '3D': '=',
            '3E': '>',
            '3F': '?',
            40: '≅',
            41: 'Α',
            42: 'Β',
            43: 'Χ',
            44: 'Δ',
            45: 'Ε',
            46: 'Φ',
            47: 'Γ',
            48: 'Η',
            49: 'Ι',
            '4A': 'ϑ',
            '4B': 'Κ',
            '4C': 'Λ',
            '4D': 'Μ',
            '4E': 'Ν',
            '4F': 'Ο',
            50: 'Π',
            51: 'Θ',
            52: 'Ρ',
            53: 'Σ',
            54: 'Τ',
            55: 'Υ',
            56: 'ς',
            57: 'Ω',
            58: 'Ξ',
            59: 'Ψ',
            '5A': 'Ζ',
            '5B': '[',
            '5C': '∴',
            '5D': ']',
            '5E': '⊥',
            '5F': '_',
            61: 'α',
            62: 'β',
            63: 'χ',
            64: 'δ',
            65: 'ε',
            66: 'φ',
            67: 'γ',
            68: 'η',
            69: 'ι',
            '6A': 'ϕ',
            '6B': 'κ',
            '6C': 'λ',
            '6D': 'µ',
            '6E': 'ν',
            '6F': 'ο',
            70: 'π',
            71: 'θ',
            72: 'ρ',
            73: 'σ',
            74: 'τ',
            75: 'υ',
            76: 'ϖ',
            77: 'ω',
            78: 'ξ',
            79: 'ψ',
            '7A': 'ζ',
            '7B': '{',
            '7C': '|',
            '7D': '}',
            '7E': '∼',
            A0: '€',
            A1: 'ϒ',
            A2: '′',
            A3: '≤',
            A4: '⁄',
            A5: '∞',
            A6: 'ƒ',
            A7: '♣',
            A8: '♦',
            A9: '♥',
            AA: '♠',
            AB: '↔',
            AC: '←',
            AD: '↑',
            AE: '→',
            AF: '↓',
            B0: '°',
            B1: '±',
            B2: '″',
            B3: '≥',
            B4: '×',
            B5: '∝',
            B6: '∂',
            B7: '•',
            B8: '÷',
            B9: '≠',
            BA: '≡',
            BB: '≈',
            BC: '…',
            BF: '↵',
            C0: 'ℵ',
            C1: 'ℑ',
            C2: 'ℜ',
            C3: '℘',
            C4: '⊗',
            C5: '⊕',
            C6: '∅',
            C7: '∩',
            C8: '∪',
            C9: '⊃',
            CA: '⊇',
            CB: '⊄',
            CC: '⊂',
            CD: '⊆',
            CE: '∈',
            CF: '∉',
            D0: '∠',
            D1: '∇',
            D5: '∏',
            D6: '√',
            D7: '⋅',
            D8: '¬',
            D9: '∧',
            DA: '∨',
            DB: '⇔',
            DC: '⇐',
            DD: '⇑',
            DE: '⇒',
            DF: '⇓',
            E0: '◊',
            E1: '〈',
            E5: '∑',
            F1: '〉',
            F2: '∫',
            F3: '⌠',
            F5: '⌡',
            100: '⊙',
            101: '∥',
            102: '△',
            103: '−',
            176: '°',
            177: '±',
          }),
          (o.mfs.makeFunctionFromParsedInfix = function(e) {
            function n(e) {
              var t,
                n = '' + e.index,
                i = p[e.type];
              return 1 === e.refCount
                ? i(e)
                : g[n]
                ? g[n]
                : ((t = 'm[' + n + ']'),
                  (g[n] = t),
                  '(' + t + '=' + i(e) + ')');
            }
            function i(e) {
              var t = n(e.children.left);
              'binary-expr' === e.children.left.type && (t = '(' + t + ')');
              var i = n(e.children.right);
              return '^' === e.operator
                ? 'GSP.math.pow(' + t + ',' + i + ')'
                : ('binary-expr' === e.children.right.type &&
                    (i = '(' + i + ')'),
                  t + e.operator + i);
            }
            function r(e) {
              var t = n(e.children.child);
              return (
                ('unary-expr' === e.children.child.type ||
                  'binary-expr' === e.children.child.type) &&
                  (t = '(' + t + ')'),
                '(' + e.operator + t + ')'
              );
            }
            function s(e) {
              var t;
              return 'sys' === e.subtype
                ? ((t = v[e.name]), t + '(' + n(e.children.arg) + ', unitMap)')
                : n(e.children.name) + '(' + n(e.children.arg) + ')';
            }
            function o(e) {
              var t = e.children.value,
                i = e.children.unit;
              return 'undefined' != typeof i
                ? 'GSP.units.convertToDocUnits(unitMap, ' +
                    n(t) +
                    ', ' +
                    n(i) +
                    ')'
                : n(t);
            }
            function a(e) {
              var t = e.value;
              return 'numeric' === e.subtype
                ? t.replace(/^0+(?=[^0])/, '')
                : b[t];
            }
            function c(e) {
              return '"' + e.name + '"';
            }
            function l(e) {
              return 'parentArray["' + e.name + '"].uValue';
            }
            function u(e) {
              return 'parentArray["' + e.name + '"]';
            }
            function d(e) {
              return n(e.children.expr);
            }
            function h(e) {
              return NaN;
            }
            var p,
              f,
              m,
              g = {},
              b = { pi: 'Math.PI', e: 'Math.E' },
              v = {
                sin: 'GSP.math.sin',
                cos: 'GSP.math.cos',
                tan: 'GSP.math.tan',
                Arcsin: 'GSP.math.asin',
                Arccos: 'GSP.math.acos',
                Arctan: 'GSP.math.atan',
                abs: 'GSP.math.abs',
                sqrt: 'GSP.math.sqrt',
                ln: 'GSP.math.ln',
                log: 'GSP.math.log',
                sgn: 'GSP.math.sign',
                round: 'GSP.math.round',
                trunc: 'GSP.math.trunc',
                isDefined: 'GSP.math.isDefined',
              };
            return (
              (p = {
                blank: h,
                equation: d,
                'binary-expr': i,
                'unary-expr': r,
                function: s,
                constant: a,
                primary: o,
                unit: c,
                variable: u,
                reference: l,
              }),
              (f = ''),
              (m = n(e)),
              t.isEmptyObject(g) || (f += 'var m={};'),
              (f += 'return ' + m + ';'),
              new Function('parentArray', 'unitMap', f)
            );
          }),
          (o.mfs.getParsedInfixAndFunction = function(e) {
            var t = k[e] || {};
            return (
              t.parsedInfix ||
                ((t.parsedInfix = o.infixExpressionParser.parse(e)),
                (t.func = o.mfs.makeFunctionFromParsedInfix(t.parsedInfix)),
                (k[e] = t)),
              t
            );
          }),
          (o.mfs.getParsedInfix = function(e) {
            var t = k[e] || {};
            return (
              t.parsedInfix ||
                ((t.parsedInfix = o.infixExpressionParser.parse(
                  this.expression
                )),
                (k[e] = t)),
              t.parsedInfix
            );
          }),
          (o.mfs.makeMathMLFromParseTree = function(e) {
            function t(e) {
              var t = b[e.type];
              return t(e);
            }
            function i(e) {
              var n = t(e.children.left);
              'binary-expr' === e.children.left.type
                ? (n = '<mfenced separators="">' + n + '</mfenced>')
                : ('unary-expr' === e.children.left.type ||
                    'function' === e.children.left.type) &&
                  (n = '<mrow>' + n + '</mrow>');
              var i = t(e.children.right);
              return (
                'binary-expr' === e.children.right.type
                  ? (i = '<mfenced separators="">' + i + '</mfenced>')
                  : ('unary-expr' === e.children.right.type ||
                      'function' === e.children.right.type) &&
                    (i = '<mrow>' + i + '</mrow>'),
                '^' === e.operator
                  ? '<msup>' + n + i + '</msup>'
                  : '/' === e.operator
                  ? '<mfrac>' + n + i + '</mfrac>'
                  : n + '<mo>' + v[e.operator] + '</mo>' + i
              );
            }
            function r(e) {
              var n = t(e.children.child);
              return (
                'binary-expr' === e.children.child.type &&
                  (n = '<mrow>' + n + '</mrow>'),
                '<mo>' + v[e.operator] + '</mo>' + n
              );
            }
            function s(e, t) {
              return (
                '<mi>' + e + '</mi><mfenced><mrow>' + t + '</mrow></mfenced>'
              );
            }
            function o(e, t) {
              return (
                '<mfenced open="|" close="|" separators=""><mrow>' +
                t +
                '</mrow></mfenced>'
              );
            }
            function a(e, t) {
              return '<msqrt><mrow>' + t + '</mrow></msqrt>';
            }
            function c(e) {
              var i = g[e.name];
              return (
                i === n && (i = s),
                'sys' === e.subtype
                  ? i(e.name, t(e.children.arg))
                  : i(t(e.children.name), t(e.children.arg))
              );
            }
            function l(e) {
              return t(e.children.value);
            }
            function u(e) {
              var t;
              return (
                (t = 'numeric' === e.subtype ? e.value : y[e.value]),
                '<mn>' + t + '</mn>'
              );
            }
            function d(e) {
              return '<mi>' + e.name + '</mi>';
            }
            function h(e) {
              return '<mi>' + e.name + '</mi>';
            }
            function p(e) {
              return '<mi>' + e.name + '</mi>';
            }
            function f(e) {
              return t(e.children.expr ? e.children.expr : e.children.expr);
            }
            function m(e) {
              return '<math>' + t(e) + '</math>';
            }
            var g,
              b,
              v = { '+': '+', '-': '&#x02212;', '*': '&#x22c5;' },
              y = { pi: '&#x003C0;', e: 'e' };
            return (
              (g = {
                sin: s,
                cos: s,
                tan: s,
                Arcsin: s,
                Arccos: s,
                Arctan: s,
                abs: o,
                sqrt: a,
                ln: s,
                log: s,
                sgn: s,
                round: s,
                trunc: s,
              }),
              (b = {
                equation: f,
                'binary-expr': i,
                'unary-expr': r,
                function: c,
                constant: u,
                primary: l,
                unit: d,
                variable: p,
                reference: h,
              }),
              m(e)
            );
          });
        var P = { '+': !0, '*': !0 },
          C = { pi: 'π', e: 'e' };
        (o.mfs.makeMFSFromParsedInfix = function(e, t, i, r) {
          function a(e) {
            var t = j[e.type];
            return t(e);
          }
          function l(e) {
            var n = a(e.children.left),
              i = a(e.children.right),
              r = c(e.children.right, t);
            return (
              '/' === r.expr.operator && (i = o.mfs.makeParenthesisMFS(i)),
              { type: 'fraction', value: [n, i] }
            );
          }
          function f(e) {
            var n, i;
            if ('/' === e.operator) return l(e);
            (n = a(e.children.left)),
              (i = c(e.children.left, t)),
              u(e, i)
                ? (n = o.mfs.makeParenthesisMFS(n))
                : d(e, i)
                ? (n = m(e, i)
                    ? o.mfs.makeParenthesisMFS(n)
                    : o.mfs.makeHorizontalMFS(n))
                : ('unary-expr' === e.children.left.type ||
                    'function' === e.children.left.type) &&
                  (n = o.mfs.makeHorizontalMFS(n));
            var r = a(e.children.right),
              s = c(e.children.right, t);
            return (
              h(e, s)
                ? (r = g(e, s)
                    ? o.mfs.makeParenthesisMFS(r)
                    : o.mfs.makeHorizontalMFS(r))
                : p(e, s)
                ? (r = b(e, s)
                    ? o.mfs.makeParenthesisMFS(r)
                    : o.mfs.makeHorizontalMFS(r))
                : 'function' === e.children.right.type &&
                  (r = o.mfs.makeHorizontalMFS(r)),
              '^' === e.operator
                ? { type: 'super', value: [n, r] }
                : '*' === e.operator
                ? o.mfs.makeHorizontalMFS(
                    n,
                    o.mfs.makeTextMFS(O[e.operator]),
                    r
                  )
                : o.mfs.makeHorizontalMFS(
                    n,
                    o.mfs.makeTextMFS(' ' + O[e.operator] + ' '),
                    r
                  )
            );
          }
          function w(e) {
            var n = a(e.children.child),
              i = c(e.children.child, t);
            return (
              ('unary-expr' === i.expr.type ||
                'binary-expr' === i.expr.type ||
                s(i.expr, i.fnReferences)) &&
                (n =
                  '^' === i.expr.operator
                    ? o.mfs.makeHorizontalMFS(n)
                    : { type: 'paren', value: [n] }),
              o.mfs.makeHorizontalMFS(o.mfs.makeTextMFS(O[e.operator]), n)
            );
          }
          function k(e, t) {
            return o.mfs.makeHorizontalMFS(e, { type: 'paren', value: [t] });
          }
          function P(e, t) {
            return { type: 'abs', value: [t] };
          }
          function C(e, t) {
            return { type: 'root', value: [t] };
          }
          function S(e) {
            var t = E[e.name];
            t === n && (t = k);
            var i =
              'sys' === e.subtype
                ? o.mfs.makeTextMFS(e.name)
                : a(e.children.name);
            return t(i, a(e.children.arg));
          }
          function A(e) {
            var t = [a(e.children.value)];
            return (
              e.children.unit && t.push(a(e.children.unit)),
              o.mfs.makeHorizontalMFS.apply(this, t)
            );
          }
          function T(e) {
            var n, i, r;
            return (
              t
                ? ((n = t[e.name]),
                  'Expression' === n.kind && n.isFunction()
                    ? (r = o.mfs.makeTextMFS(n.label, n.getMathItalicization()))
                    : ('noVisibleName' === n.style.nameOrigin &&
                        (i = { force: !0 }),
                      (r = n.getNameMFS(i))))
                : (r = o.mfs.makeTextMFS(e.name)),
              r
            );
          }
          function M(e) {
            return o.mfs.makeTextMFS(e.name, r);
          }
          function I(e) {
            var t = o.mfs.makeTextMFS(e.argument, !0);
            return e.name ? k(o.mfs.makeTextMFS(e.name, !0), t) : t;
          }
          function F() {
            return o.mfs.makeTextMFS(' ');
          }
          var E,
            j,
            O = { '+': '+', '-': '−', '*': '⋅' };
          return (
            (E = { abs: P, sqrt: C }),
            (j = {
              blank: F,
              equation: function(e) {
                return y(e, a, i);
              },
              declaration: I,
              'binary-expr': f,
              'unary-expr': w,
              function: S,
              constant: function(e) {
                return v(e, o.mfs.makeTextMFS);
              },
              primary: A,
              unit: function(e) {
                return x(e, o.mfs.makeTextMFS);
              },
              variable: M,
              reference: T,
            }),
            a(e)
          );
        }),
          (o.mfs.renderMathquillFromParsedInfix = function(e, i, r, a) {
            function l(e) {
              k('('), w(e), i.ascendTwo(), k(')');
            }
            function w(e) {
              var t = G[e.type];
              return t(e);
            }
            function k(e) {
              i.insertAtCursor(e, !0);
            }
            function P(e) {
              for (var t = 0; t < e.length; t++)
                i.insertAtCursor(e.charAt(t), !0);
            }
            function C(e) {
              var t,
                n = c(e.children.left, r);
              u(e, n)
                ? l(e.children.left)
                : d(e, n)
                ? m(e, n)
                  ? l(e.children.left)
                  : w(e.children.left)
                : '/' === e.operator
                ? i.renderAndSelect(function() {
                    w(e.children.left);
                  })
                : w(e.children.left),
                k(e.operator),
                (t = c(e.children.right, r)),
                f(e, t)
                  ? l(e.children.right)
                  : h(e, t)
                  ? g(e, t)
                    ? l(e.children.right)
                    : w(e.children.right)
                  : p(e, t) && b(e, t)
                  ? l(e.children.right)
                  : w(e.children.right),
                ('^' === e.operator || '/' === e.operator) && i.ascendTwo();
            }
            function S(e) {
              var t = c(e.children.child, r),
                n =
                  'unary-expr' === t.expr.type ||
                  'binary-expr' === t.expr.type ||
                  s(t.expr, t.fnReferences);
              k(e.operator),
                n && '^' !== t.expr.operator
                  ? l(e.children.child)
                  : w(e.children.child);
            }
            function A(e) {
              i.renderOnLeft(function() {
                i.renderAndSelect(function() {
                  w(e);
                }),
                  k('|');
              });
            }
            function T(e) {
              k('\\sqrt'), w(e), i.ascendTwo();
            }
            function M(e) {
              var t = L[e.name];
              t === n && ((t = l), e.name && i.writeLiteral(e.name)),
                'sys' !== e.subtype && w(e.children.name),
                t(e.children.arg);
            }
            function I(e) {
              w(e.children.value), e.children.unit && w(e.children.unit);
            }
            function F(e) {
              function n() {
                var e = c[0].outerHTML.replace(/\\/g, '\\\\');
                i.writeLatex('\\blob' + e + '\\endBlob');
              }
              var s,
                a,
                c = t('<span></span>')
                  .addClass('wsp-ref')
                  .attr('wsp-ref', e.name)
                  .attr('wsp-sessionID', i.getSessionID());
              r
                ? ((s = r[e.name]),
                  'Expression' === s.kind && s.isFunction()
                    ? c.text(s.label)
                    : ((a = s.getNameMFS({ force: !0 })),
                      'text' === a.type &&
                        '' === a.value &&
                        s.label &&
                        (a.value = s.label),
                      o.mfs.makeHTMLFromMFSParseTree(a, c, {}, {})),
                  n())
                : k(e.name);
            }
            function E(e) {
              k(e.name), i.registerIndependentVariable();
            }
            function j(e) {
              var t = e.argument;
              e.name ? (k(e.name), l(t)) : k(t);
            }
            function O(e) {}
            var L, G;
            return (
              (L = { abs: A, sqrt: T }),
              (G = {
                blank: O,
                equation: function(e) {
                  return y(e, w, a);
                },
                declaration: j,
                'binary-expr': C,
                'unary-expr': S,
                function: M,
                constant: function(e) {
                  return v(e, P);
                },
                primary: I,
                unit: function(e) {
                  return x(e, k);
                },
                variable: E,
                reference: F,
              }),
              w(e)
            );
          }),
          (o.mfs.makeItalicMFS = function(e) {
            return {
              type: 'style',
              value: [{ code: 'fontStyle', value: '2' }, e],
            };
          }),
          (o.mfs.makeNonItalicMFS = function(e) {
            return {
              type: 'style',
              value: [{ code: 'fontStyle', value: '1' }, e],
            };
          }),
          (o.mfs.makeTextMFS = function(e, t) {
            if ('object' == typeof e)
              throw o.createError("Can't make text from objects");
            var n = { type: 'text', value: String(e) };
            return t ? o.mfs.makeItalicMFS(n) : n;
          }),
          (o.mfs.makeFractionMFS = function(e, t) {
            return { type: 'fraction', value: [e, t] };
          }),
          (o.mfs.isEmptyTextMFS = function(e) {
            return 'text' === e.type && '' === e.value;
          }),
          (o.mfs.makeParenthesisMFS = function(e) {
            return { type: 'paren', value: [e] };
          }),
          (o.mfs.makeHorizontalMFS = function() {
            return {
              type: 'horizontal',
              value: Array.prototype.slice.call(arguments, 0),
            };
          }),
          (o.mfs.parentsHorizontalOverbar = function(e, n) {
            var i = [];
            return (
              t.each(n, function(t, n) {
                var r = e.getParent(n);
                r && i.push(r.getNameMFS());
              }),
              {
                type: 'overbar',
                variant: 5,
                value: o.mfs.makeHorizontalNamesMFS(i),
              }
            );
          }),
          (o.mfs.makeNonvisibleSpokenWordSeparator = function() {
            return o.mfs.makeTextMFS('​');
          }),
          (o.mfs.makeHorizontalNamesMFS = function(e, t) {
            function n(e) {
              function t(e, t) {
                if (0 === e.length) return [];
                var n,
                  i = [];
                for (n = 0; n < e.length - 1; n++) i.push(e[n]), i.push(t);
                return i.push(e[n]), i;
              }
              function n(e) {
                e.value.length > 1 && "'" !== e.value[1] && (i = !0);
              }
              for (var i = !1, r = 0; r < e.length; r++)
                o.mfs.walkNode(e[r], 'text', n);
              return t(
                e,
                i
                  ? o.mfs.makeNonItalicMFS(o.mfs.makeTextMFS('|'))
                  : o.mfs.makeNonvisibleSpokenWordSeparator()
              );
            }
            return (
              (e = n(e)),
              t && e.unshift(t),
              o.mfs.makeHorizontalMFS.apply(this, e)
            );
          }),
          (o.mfs.isSimpleExpression = function(e) {
            function n(e) {
              var n = i[e.type],
                r = t.type(n);
              return 'boolean' === r ? n : 'function' === r ? n(e) : !1;
            }
            var i = {};
            return (
              (i.equation = function(e) {
                return (
                  'undefined' != typeof e.children.declaration ||
                  n(e.children.expr)
                );
              }),
              (i['unary-expr'] = function(e) {
                return n(e.children.child);
              }),
              (i.primary = function(e) {
                return n(e.children.value);
              }),
              (i.constant = !0),
              (i.blank = !0),
              n(e)
            );
          }),
          (o.mfs.determineUnit = function(e, i, r) {
            function s(e) {
              var t = e.index,
                n = l[e.type];
              return n
                ? (d[t] || (d[t] = n(e)), d[t])
                : void o.signalErrorWithMessage(
                    'GSP.mfs.determineUnit: missing typeMap: ' + e.type
                  );
            }
            function a(e, t) {
              var n = !0;
              return (
                o.units.eachUnitDimension(e, function(e, i) {
                  return i !== t[e] ? ((n = !1), !1) : void 0;
                }),
                o.units.eachUnitDimension(t, function(t, i) {
                  return i !== e[t] ? ((n = !1), !1) : void 0;
                }),
                n
              );
            }
            function c(e) {
              var t = s(e);
              return (
                o.units.eachUnitDimension(t, function(e, n) {
                  return n % 2 !== 0 ? ((t = {}), !1) : void (t[e] *= 0.5);
                }),
                t
              );
            }
            var l = {},
              u = o.units,
              d = {};
            return (
              (l.equation = function(e) {
                return s(e.children.expr);
              }),
              (l['binary-expr'] = function(e) {
                var i,
                  r,
                  o,
                  c,
                  l = s(e.children.left),
                  u = s(e.children.right),
                  d = {};
                if ('power' === e.subtype) {
                  if (
                    ((l = s(e.children.left)),
                    'primary' === e.children.right.type &&
                      ((c = Number(e.children.right.children.value.value)),
                      c % 1 === 0))
                  )
                    for (r in l) l.hasOwnProperty(r) && (d[r] = l[r] * c);
                  return d;
                }
                if ('multiplicative' === e.subtype) {
                  (i = 1),
                    '/' === e.operator && (i = -1),
                    (l = t.extend({}, l));
                  for (r in u)
                    u.hasOwnProperty(r) &&
                      ((o = l[r]), o === n && (l[r] = 0), (l[r] += i * u[r]));
                  return l;
                }
                return 'additive' === e.subtype ? (a(l, u) ? l : {}) : void 0;
              }),
              (l['unary-expr'] = function(e) {
                return s(e.children.child);
              }),
              (l.function = function(e) {
                if (
                  'Arcsin' === e.name ||
                  'Arccos' === e.name ||
                  'Arctan' === e.name
                )
                  return { angle: 1 };
                if (
                  'abs' === e.name ||
                  'round' === e.name ||
                  'trunc' === e.name
                )
                  return s(e.children.arg);
                if ('sqrt' === e.name) return c(e.children.arg);
                if ('custom' === e.subtype) {
                  var t = i[e.children.name.name];
                  return t.getUnitPowers(s(e.children.arg));
                }
                return {};
              }),
              (l.primary = function(e) {
                return e.children.unit ? s(e.children.unit) : {};
              }),
              (l.constant = function(e) {
                return {};
              }),
              (l.unit = function(e) {
                var t = {},
                  n = u.getUnitFamily(e.name);
                return (
                  n && 'scalar' !== n && (t[u.getUnitFamily(e.name)] = 1), t
                );
              }),
              (l.reference = function(e) {
                var n, r;
                return (
                  i &&
                    ((n = i[e.name]),
                    n && (r = t.extend(!0, {}, n.unitPowers))),
                  r
                );
              }),
              (l.variable = function(e) {
                var t = r ? r : {};
                return t;
              }),
              (l.blank = function(e) {
                return {};
              }),
              s(e)
            );
          }),
          (o.mfs.findByType = function(e, t) {
            function n(e, t, i) {
              var r;
              if (e.children)
                for (r in e.children)
                  e.children.hasOwnProperty(r) && n(e.children[r], t, i);
              e.type === t && i.push(e);
            }
            var i = [];
            return n(e, t, i), i;
          }),
          (o.mfs.replaceNodes = function e(n, i, r) {
            var s,
              o,
              a = n.type === i ? r(n) : n,
              c = t.isArray(a.value) ? a.value.length : 0;
            for (s = 0; c > s; ++s) (o = a.value[s]), (a.value[s] = e(o, i, r));
            return a;
          }),
          (o.mfs.realizeParamNodes = function(e, t) {
            o.mfs.replaceNodes(e, 'parameter', function(e) {
              return t[e.value];
            });
          }),
          (o.mfs.walkNode = function(e, t, n) {
            o.mfs.replaceNodes(e, t, function(e) {
              return n(e), e;
            });
          }),
          (o.mfs.flattenVerticalNode = function(e) {
            if ('vertical' !== e.type)
              return (
                o.signalErrorWithMessage(
                  'GSP.mfs.flattenVerticalNode should only be called on vertical nodes'
                ),
                e
              );
            e.type = 'horizontal';
            for (var t, n = e.value, i = n.length - 1; i > 0; --i)
              (t = o.mfs.makeTextMFS(' ')), n.splice(i, 0, t);
            return e;
          });
        var S = {
          Times: { default: '1' },
          'Times New Roman': {
            '16px': '1.1',
            '24px': '1.1',
            '36px': '1.1',
            default: 'normal',
          },
          Arial: {
            '16px': '1.1',
            '24px': '1.1',
            '36px': '1.1',
            default: 'normal',
          },
          Geneva: {
            '16px': '1.3',
            '24px': '1.35',
            '36px': '1.35',
            default: 'normal',
          },
          'ReportSchoolRg-Regular': {
            '16px': '1.15',
            '24px': '1.15',
            '36px': '1.15',
            default: 'normal',
          },
          'Report School': {
            '16px': '1.15',
            '24px': '1.15',
            '36px': '1.15',
            default: 'normal',
          },
          'Proxima Nova': {
            '16px': '1.2',
            '24px': '1.2',
            '36px': '1.2',
            default: 'normal',
          },
        };
        (o.mfs.extractFirstFontFamily = function(e) {
          var t = e || '';
          return (
            (t = t.split(',')[0]),
            (t = t.replace(/'/g, '"')),
            t.replace(/^"(.*)"$/, '$1')
          );
        }),
          (o.mfs.getLineHeight = function(e, t) {
            var n = o.mfs.extractFirstFontFamily(e),
              i = S[n];
            return i ? i[t] || i[t + 'px'] || i.default : null;
          });
        var A = {
          'Proxima Nova Bold': {
            fallbackFamilies: ['Proxima Nova'],
            sets: { 'font-weight': 'bold' },
          },
          'Proxima Nova Italic': {
            fallbackFamilies: ['Proxima Nova'],
            sets: { 'font-style': 'italic' },
          },
          'Proxima Nova Bold It': {
            fallbackFamilies: ['Proxima Nova'],
            sets: { 'font-weight': 'bold', 'font-style': 'italic' },
          },
          'ReportSchoolRg-Bold': {
            fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
            sets: { 'font-weight': 'bold' },
          },
          'ReportSchoolRg-Italic': {
            fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
            sets: { 'font-style': 'italic' },
          },
          'ReportSchoolRg-BoldItalic': {
            fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
            sets: { 'font-weight': 'bold', 'font-style': 'italic' },
          },
          'Report School Rg': { fallbackFamilies: ['ReportSchoolRg-Regular'] },
          'ReportSchoolRg-Regular': { fallbackFamilies: ['Report School Rg'] },
          'SRA Sans 1.0 Book': { fallbackFamilies: ['SRA Sans 1.0'] },
          'SRA Sans 1.0 Bold': {
            fallbackFamilies: ['SRA Sans 1.0'],
            sets: { 'font-weight': 'bold' },
          },
          'SRA Sans 1.0 Italic': {
            fallbackFamilies: ['SRA Sans 1.0'],
            sets: { 'font-style': 'italic' },
          },
          'SRA Sans 1.0 Bold Italic': {
            fallbackFamilies: ['SRA Sans 1.0'],
            sets: { 'font-weight': 'bold', 'font-style': 'italic' },
          },
          'SRA Sans 3.0 Book': { fallbackFamilies: ['SRA Sans 3.0'] },
          'SRA Sans 3.0 Bold': {
            fallbackFamilies: ['SRA Sans 3.0'],
            sets: { 'font-weight': 'bold' },
          },
          'SRA Sans 3.0 Italic': {
            fallbackFamilies: ['SRA Sans 3.0'],
            sets: { 'font-style': 'italic' },
          },
          'SRA Sans 3.0 Bold Italic': {
            fallbackFamilies: ['SRA Sans 3.0'],
            sets: { 'font-weight': 'bold', 'font-style': 'italic' },
          },
          'MHEelemsans Regular': { fallbackFamilies: ['MHEelemsans'] },
          'MHEelemsans Bold': {
            fallbackFamilies: ['MHEelemsans'],
            sets: { 'font-weight': 'bold' },
          },
          'MHEelemsans Italic': {
            fallbackFamilies: ['MHEelemsans'],
            sets: { 'font-style': 'italic' },
          },
          'MHEelemsans Bold Italic': {
            fallbackFamilies: ['MHEelemsans'],
            sets: { 'font-weight': 'bold', 'font-style': 'italic' },
          },
          'UniMath2 A': { fallbackFamilies: ['UniMath2-Regular', 'UniMath2'] },
          'UniMath2-Regular': { fallbackFamilies: ['UniMath2 A', 'UniMath2'] },
          'UniMath2-BoldItalic': {
            fallbackFamilies: ['UniMath2 A', 'UniMath2'],
            sets: { 'font-style': 'italic', 'font-weight': 'bold' },
          },
          'UniMath2-Italic': {
            fallbackFamilies: ['UniMath2 A', 'UniMath2'],
            sets: { 'font-style': 'italic' },
          },
          'UniMath2-Bold': {
            fallbackFamilies: ['UniMath2 A', 'UniMath2'],
            sets: { 'font-weight': 'bold' },
          },
          'UniMath2 B': { fallbackFamilies: ['UniMath2-SemiBold', 'UniMath2'] },
          'UniMath2-SemiBold': { fallbackFamilies: ['UniMath2 B', 'UniMath2'] },
          'UniMath2-SemiBoldItalic': {
            fallbackFamilies: ['UniMath2 B', 'UniMath2'],
            sets: { 'font-style': 'italic' },
          },
          'UniMath2-ExtraBoldItalic': {
            fallbackFamilies: ['UniMath2 B', 'UniMath2'],
            sets: { 'font-style': 'italic', 'font-weight': 'bold' },
          },
          'UniMath2-ExtraBold': {
            fallbackFamilies: ['UniMath2 B', 'UniMath2'],
            sets: { 'font-weight': 'bold' },
          },
        };
        t.extend(A, o.getConfigValue('Fonts.fallbacks')),
          (o.mfs.normalizeFont = function(e, t) {
            var n = o.mfs.extractFirstFontFamily(e),
              i = A[n];
            if (i) {
              var r,
                s,
                a = i.fallbackFamilies,
                c = [],
                l = i.sets;
              if (l) for (r in l) l.hasOwnProperty(r) && t(r, l[r]);
              for (var u = e.split(','), d = 0; d < a.length; d++)
                (s = a[d]),
                  (s = s.match(/\s|\d|[?:;!@#$%^&*()<>/+{}]/)
                    ? '"' + s + '"'
                    : s),
                  c.push(s);
              u.splice(1, 0, c.join(',')), t('font-family', u.join(','));
            }
          });
        var T = [
          { type: '', cssClass: '', template: '' },
          { type: '', cssClass: '', template: '' },
          {
            type: 'segment',
            cssClass: 'mfs-overbar-seg',
            template:
              '<svg version="1.1" viewBox="0 0 128 50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"><path d="M 0 7 L 128 7 " stroke="@@color@@" fill="@@color@@" stroke-width="3"/></svg>',
          },
          {
            type: 'ray',
            cssClass: 'mfs-overbar-ray',
            template:
              '<svg version="1.1" viewBox="0 0 128 40" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"><path d="M 7 20 l 114 0M 121 20l -21 -20L 121 20l -21 20" stroke="@@color@@" fill="none" stroke-width="10"/></svg>',
          },
          {
            type: 'line',
            cssClass: 'mfs-overbar-line',
            template:
              '<svg version="1.1" viewBox="0 0 128 40" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"><path d="M 7 20 l 21 -20 L 7 20 l 21 20 M 7 20 l 114 0M 121 20l -21 -20L 121 20l -21 20" stroke="@@color@@" fill="none" stroke-width="8"/></svg>',
          },
          {
            type: 'arc',
            cssClass: 'mfs-overbar-arc',
            template:
              '<svg version="1.1" viewBox="0 0 128 50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"><path d="M 12 50 Q 70 0 128 50 M 128 50 Q 70 9 12 50 " stroke="@@color@@" fill="@@color@@" stroke-width="1"/></svg>',
          },
        ];
        (o.mfs.createOverbarDOM = function(e, n) {
          var i,
            r = w(e);
          return (
            (i = t('<div>')),
            i.addClass('mfs-overbar'),
            r.cssClass && i.addClass(r.cssClass),
            r.factory && i.css('background-image', r.factory(n)),
            i
          );
        }),
          (o.mfs.getNodeText = function(e) {
            var t = e.value,
              n = ' ';
            return 'symbol' === e.type
              ? o.mfs.symMap[t.toUpperCase()] || 'x'
              : ('text' === e.type &&
                  t.match(/ $/) &&
                  (t = t.substring(0, t.length - 1) + n),
                t);
          }),
          (o.mfs.isTextOrSymbolNode = function(e) {
            return 'text' === e.type || 'symbol' === e.type;
          }),
          (o.mfs.mergeTextEls = function(e) {
            var n,
              i = [];
            return (
              t.each(e, function(e, t) {
                n && o.mfs.isTextOrSymbolNode(n) && o.mfs.isTextOrSymbolNode(t)
                  ? (n.value += o.mfs.getNodeText(t))
                  : ('symbol' === t.type &&
                      ((t.value = o.mfs.getNodeText(t)), (t.type = 'text')),
                    i.push(t),
                    (n = t));
              }),
              i
            );
          }),
          (o.mfs.makeHTMLFromMFSParseTree = (function() {
            function e(e) {
              return function(t) {
                var n = o.btoa(e.replace(/@@color@@/g, t));
                return 'url("data:image/svg+xml;base64,' + n + '")';
              };
            }
            function n(e, t, n) {
              for (var i, r, s, o = '', a = 0; a < n.length; a++) {
                (r = n[a]), (i = r[0]), (s = r[1]), (o += i + ' ');
                for (var c = 0; c < s.length; c++)
                  o += Math.round(10 * s[c]) / 10 + ' ';
              }
              var l =
                '<svg version="1.1" viewBox="0 0 ' +
                e +
                ' ' +
                t +
                '" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg"><path d="' +
                o +
                '" stroke="@@color@@" fill="@@color@@" stroke-width="1"/></svg>';
              return l;
            }
            for (var i = 0; i < T.length; i++) {
              var r = T[i].template;
              T[i].factory = r ? e(r) : null;
            }
            var s = (function() {
                function t() {
                  var e = 0,
                    t = e + d,
                    i = r * (1 + u),
                    h = r * (1 + l);
                  return n(r, s, [
                    ['M', [e, a]],
                    ['L', [t, a]],
                    ['Q', [h, c, t, o]],
                    ['M', [t, o]],
                    ['L', [e, o]],
                    ['Q', [i, c, e, a]],
                  ]);
                }
                function i() {
                  var e = r,
                    t = e - d,
                    i = -(r * u),
                    h = -(r * l);
                  return n(r, s, [
                    ['M', [e, a]],
                    ['L', [t, a]],
                    ['Q', [h, c, t, o]],
                    ['M', [t, o]],
                    ['L', [e, o]],
                    ['Q', [i, c, e, a]],
                  ]);
                }
                var r = 40,
                  s = 70,
                  o = 0.9 * s,
                  a = s - o,
                  c = a + (o - a) / 2,
                  l = 0.5,
                  u = 0.2,
                  d = 0.17 * r;
                return { left: e(i()), right: e(t()) };
              })(),
              a = (function() {
                function t() {
                  var e = 0,
                    t = 0,
                    i = r,
                    o = 0.03 * s;
                  return n(r, s, [
                    ['M', [e, t]],
                    ['L', [i, t]],
                    ['L', [i, o]],
                    ['L', [e, o]],
                    ['L', [e, t]],
                  ]);
                }
                function i() {
                  var e = 0,
                    t = 0.06 * s,
                    i = 0.05 * r,
                    o = 0.55 * s,
                    a = o + t / 3,
                    c = 0.25 * r,
                    l = c + 0.2 * r,
                    u = 0.87 * s,
                    d = r - 3 * i,
                    h = r,
                    p = 0,
                    f = p + t / 2,
                    m = u + t;
                  return n(r, s, [
                    ['M', [e, o]],
                    ['L', [c, o]],
                    ['L', [l, u]],
                    ['L', [d, p]],
                    ['L', [h, p]],
                    ['L', [h, f]],
                    ['L', [d + i / 2, f]],
                    ['L', [l, m]],
                    ['L', [c - i, a]],
                    ['L', [e, a]],
                    ['L', [e, o]],
                  ]);
                }
                var r = 40,
                  s = 70;
                return { left: e(i()), right: e(t()) };
              })(),
              c = (function() {
                function t() {
                  var e = 8,
                    t = 4,
                    s = 12,
                    o = r - 4;
                  return n(i, r, [
                    ['M', [e, t]],
                    ['L', [s, t]],
                    ['L', [s, o]],
                    ['L', [e, o]],
                    ['L', [e, t]],
                  ]);
                }
                var i = 20,
                  r = 70;
                return e(t());
              })();
            return function(e, n, i, r) {
              function l() {
                C.push({ type: 'marker' });
              }
              function u(e, t) {
                C.push({ type: 'style', name: e, value: t });
              }
              function d() {
                for (var e = C.pop(); 'marker' !== e.type; ) e = C.pop();
              }
              function h(e) {
                var n = {};
                t.each(C, function(e, t) {
                  'style' === t.type && (n[t.name] = t.value);
                });
                var i = o.mfs.getLineHeight(
                  n.fontFamily || e.css('font-family'),
                  n.fontSize || e.css('font-size')
                );
                return i && (n.lineHeight = i), n;
              }
              function p() {
                var e = [];
                return (
                  t.each(C, function(t, n) {
                    'class' === n.type && e.push(n.name);
                  }),
                  e.join(' ')
                );
              }
              function f(e, n) {
                e.append(n);
                var i = e[0].lastChild;
                return t(i);
              }
              function m(e, t) {
                var n, i;
                return (
                  (i = P[e.type]),
                  i
                    ? (n = i(e, t))
                    : (o.signalErrorWithMessage(
                        'GSP.mfs.makeHTMLFromMFSParseTree: No handler for node:' +
                          e.type
                      ),
                      t)
                );
              }
              function g(e) {
                return String(e)
                  .replace(/&/g, '&amp;')
                  .replace(/"/g, '&quot;')
                  .replace(/'/g, '&#39;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/\//g, '&#47;');
              }
              function b(e, t) {
                var n = h(e),
                  i = p();
                return (
                  n['font-style'] && (i += ' mfs-text-' + n['font-style']),
                  f(e, '<div class="mfs-text"/>')
                    .css(n)
                    .addClass(i)
                    .append(g(t))
                );
              }
              function v(e, t) {
                var n;
                for (
                  t.value.length > 0 && (t.value = o.mfs.mergeTextEls(t.value)),
                    n = 0;
                  n < t.value.length;
                  n += 1
                )
                  m(t.value[n], e);
              }
              function y(e, t, n) {
                var i = f(n, '<div class="' + e + '"></div>');
                return v(i, t), i;
              }
              function x(e) {
                return h(e).color || e.css('color') || 'black';
              }
              function w(e, n, i) {
                var r,
                  s = o.Strings.format('<td class="%@"></td>', [i.leftClass]),
                  a = t(s).append('<span></span>'),
                  c = o.Strings.format(
                    '<table class="%@"><tbody><tr><td></td></tr></tbody></table>',
                    [i.tableClass]
                  ),
                  l = f(n, t(c)),
                  u = t('>tbody >tr', l),
                  d = t('>tbody >tr >td', l);
                i.middleClass && d.addClass(i.middleClass), v(d, e);
                var h = x(n);
                return (
                  a.css('background-image', i.leftSVGFactory(h)),
                  u.prepend(a),
                  i.middleClass &&
                    d.css('background-image', i.middleSVGFactory(h)),
                  i.rightClass &&
                    ((r = t(
                      o.Strings.format('<td class="%@"></td>', [i.rightClass])
                    ).append('<span></span>')),
                    r.css('background-image', i.rightSVGFactory(h)),
                    u.append(r)),
                  l
                );
              }
              var k = {},
                P = {},
                C = [];
              return (
                t.each(r, function(e, t) {
                  'font-size' !== e && 'fontSize' !== e && u(e, t);
                }),
                (P.abs = function(e, t) {
                  return w(e, t, {
                    tableClass: 'mfs-abs',
                    leftClass: 'mfs-abs-bar',
                    rightClass: 'mfs-abs-bar',
                    leftSVGFactory: c,
                    rightSVGFactory: c,
                  });
                }),
                (P.bracket = function(e, t) {
                  return y('mfs-bracket', e, t);
                }),
                (P.curly = function(e, t) {
                  return y('mfs-curly', e, t);
                }),
                (P.fraction = function(e, t) {
                  var n = f(t, '<div class="mfs-frac"/>'),
                    i = m(e.value[0], n);
                  return (
                    i.addClass('mfs-numr mfs-responsive-borderwidth'),
                    i.css(
                      'border-bottom',
                      o.Strings.format('thin %@ solid', [x(i)])
                    ),
                    m(e.value[1], n).addClass('mfs-denm'),
                    n
                  );
                }),
                (P.horizontal = function(e, t) {
                  return (
                    e.value.length > 0 &&
                      (e.value = o.mfs.mergeTextEls(e.value)),
                    1 === e.value.length
                      ? m(e.value[0], t)
                      : y('mfs-horizontal', e, t)
                  );
                }),
                (P.input = function(e, n) {
                  var i,
                    r = t('<button tabindex="0"></button>').addClass(
                      'mfs-input mfs-responsive-borderwidth'
                    );
                  r.append('%' + e.value),
                    n.append(r),
                    (i = k[e.value]),
                    i || ((i = []), (k[e.value] = i)),
                    i.push(r);
                  var s = o.getConfigValue(
                    'NumberpadManager.delegates.registerElement'
                  );
                  return s(r), r;
                }),
                (P.parameter = function(e, t) {
                  var n, i;
                  return (
                    (n = f(t, '<div class="mfs-param"></div>')),
                    n.css(h(t)),
                    n.append('%' + e.value),
                    (i = k[e.value]),
                    i || ((i = []), (k[e.value] = i)),
                    i.push(n),
                    n
                  );
                }),
                (P.paren = function(e, t) {
                  return w(e, t, {
                    tableClass: 'mfs-paren',
                    leftClass: 'mfs-left-paren',
                    rightClass: 'mfs-right-paren',
                    leftSVGFactory: s.left,
                    rightSVGFactory: s.right,
                  });
                }),
                (P.root = function(e, t) {
                  return w(e, t, {
                    tableClass: 'mfs-root',
                    leftClass: 'mfs-left-root',
                    leftSVGFactory: a.left,
                    middleClass: 'mfs-right-root',
                    middleSVGFactory: a.right,
                  });
                }),
                (P.style = function(e, t) {
                  var n,
                    r,
                    s,
                    a,
                    c,
                    h = t,
                    p = {},
                    f = [];
                  for (n = 0; n < e.value.length; n += 1)
                    e.value[n].code
                      ? (p[e.value[n].code] = e.value[n].value)
                      : e.value[n].type && f.push(e.value[n]);
                  if ((l(), p.fontFamily && i)) {
                    c = i[parseInt(p.fontFamily, 16)];
                    var g = function(e, t) {
                      switch (e) {
                        case 'font-family':
                          c = t;
                          break;
                        case 'font-weight':
                          var n = { normal: 1, bold: 2 };
                          p.fontWeight = n[t];
                          break;
                        case 'font-style':
                          var i = { normal: 1, italic: 2 };
                          p.fontStyle = i[t];
                      }
                    };
                    o.mfs.normalizeFont(c, g), c && u('font-family', c);
                  }
                  if (
                    (1 === Number(p.fontWeight) && u('font-weight', 'normal'),
                    2 === Number(p.fontWeight) && u('font-weight', 'bold'),
                    1 === Number(p.fontStyle) && u('font-style', 'normal'),
                    2 === Number(p.fontStyle) && u('font-style', 'italic'),
                    (p.red || p.green || p.blue) &&
                      ((r = p.red ? parseInt(p.red, 16) - 1 : 0),
                      (s = p.green ? parseInt(p.green, 16) - 1 : 0),
                      (a = p.blue ? parseInt(p.blue, 16) - 1 : 0),
                      u('color', 'rgb(' + r + ',' + s + ',' + a + ')')),
                    1 === Number(p.underbar) && u('text-decoration', 'none'),
                    2 === Number(p.underbar) &&
                      u('text-decoration', 'underline'),
                    1 === Number(p.tightness) && u('letter-spacing', 'normal'),
                    2 === Number(p.tightness) && u('letter-spacing', '-1px'),
                    3 === Number(p.tightness) && u('letter-spacing', '1px'),
                    1 !== f.length)
                  )
                    throw o.createError(
                      'Malformed Style Node: Too many children'
                    );
                  return (
                    (h = m(f[0], h)),
                    p.fontSize &&
                      h.css('fontSize', parseInt(p.fontSize, 16) + 'px'),
                    d(),
                    h
                  );
                }),
                (P.sub = function(e, t) {
                  var n = f(t, '<div class="mfs-sub-group"/>');
                  return (
                    m(e.value[0], n),
                    m(e.value[1], n).addClass('mfs-subscript'),
                    n
                  );
                }),
                (P.super = function(e, t) {
                  var n = f(t, '<div class="mfs-super-group"/>');
                  return (
                    m(e.value[0], n),
                    m(e.value[1], n).addClass('mfs-exponent'),
                    n
                  );
                }),
                (P.symbol = function(e, t) {
                  return b(t, o.mfs.getNodeText(e));
                }),
                (P.switch = function(e, t) {
                  var n = e.visibleNode;
                  return n && n > 0 ? m(e.value[n - 1], t) : void 0;
                }),
                (P.text = function(e, t) {
                  return b(t, o.mfs.getNodeText(e));
                }),
                (P.vertical = function(e, t) {
                  var n,
                    i,
                    r = { L: 'left', C: 'center', R: 'right' },
                    s = e.alignment && r[e.alignment],
                    a = s ? 'style="text-align:' + s + ';"' : '';
                  if (e.value.length > 1) {
                    for (
                      i = f(t, '<div class="mfs-vertical-group" ' + a + '/>'),
                        n = 0;
                      n < e.value.length;
                      n += 1
                    )
                      'future' !== e.value[n].type &&
                        (o.mfs.isEmptyTextMFS(e.value[n])
                          ? f(i, '<br />')
                          : m(e.value[n], i));
                    return i;
                  }
                  return m(e.value[0], t);
                }),
                (P.future = function(e, t) {
                  return t;
                }),
                (P.overbar = function(e, t) {
                  var n = x(t),
                    i = f(t, o.mfs.createOverbarDOM(Number(e.variant), n));
                  return m(e.value, i), i;
                }),
                m(e, n),
                k
              );
            };
          })()),
          (o.mfs.makeMFSFromMFSParseTree = function(e) {
            function t(e) {
              var t;
              return (
                (t = i[e.type]),
                t
                  ? t(e)
                  : (o.signalErrorWithMessage(
                      'GSP.mfs.makeMFSFromMFSParseTree: No handler for node:' +
                        e.type
                    ),
                    '')
              );
            }
            function n(e) {
              var n,
                i = e.length,
                r = '';
              for (n = 0; i > n; n++) r += t(e[n]);
              return r;
            }
            var i = {};
            return (
              (i.future = function(e) {}),
              (i.abs = function(e) {
                return '<|' + t(e.value[0]) + '>';
              }),
              (i.bracket = function(e) {
                return '<[' + t(e.value[0]) + '>';
              }),
              (i.curly = function(e) {
                return '<{' + t(e.value[0]) + '>';
              }),
              (i.fraction = function(e) {
                return '</' + t(e.value[0]) + t(e.value[1]) + '>';
              }),
              (i.horizontal = function(e) {
                return '<H' + n(e.value) + '>';
              }),
              (i.parameter = function(e) {
                return '<%' + e.value + '>';
              }),
              (i.paren = function(e) {
                return '<(' + t(e.value[0]) + '>';
              }),
              (i.root = function(e) {
                return '<R' + t(e.value[0]) + '>';
              }),
              (i.style = function(e) {
                for (
                  var n,
                    i = '',
                    r = {
                      green: 'G',
                      blue: 'L',
                      fontFamily: 'P',
                      red: 'R',
                      fontStyle: 'S',
                      tightness: 'T',
                      underbar: 'U',
                      fontWeight: 'W',
                      fontSize: '#',
                      'diminish-size': '+',
                    },
                    s = 0,
                    o = e.value.length - 1;
                  o > s;
                  ++s
                )
                  (n = e.value[s]), (i += r[n.code]), (i += n.value);
                return '<S' + i + t(e.value[e.value.length - 1]) + '>';
              }),
              (i.sub = function(e) {
                return '<-' + t(e.value[0]) + t(e.value[1]) + '>';
              }),
              (i.super = function(e) {
                return '<+' + t(e.value[0]) + t(e.value[1]) + '>';
              }),
              (i.symbol = function(e) {
                return '<!' + e.value + '>';
              }),
              (i.switch = function(e) {
                var t = e.visibleNode ? e.visibleNode.toString(16) : '';
                return (
                  '<?' + t + (e.refCon ? 'x' + e.refCon : '') + n(e.value) + '>'
                );
              }),
              (i.text = function(e) {
                return (
                  "<T'" +
                  e.value.replace(/\\/g, '\\\\').replace(/'/g, "\\'") +
                  "'>"
                );
              }),
              (i.vertical = function(e) {
                var t = e.alignment ? e.alignment : '';
                return '<V' + t + n(e.value) + '>';
              }),
              (i.future = function(e) {
                return '<F' + e.value + '>';
              }),
              (i.overbar = function(e, n) {
                return '<O' + e.variant + t(e.value) + '>';
              }),
              t(e)
            );
          }),
          (o.mfs.makeSpeakableTextFromMFSParseTree = function(e) {
            function t(e) {
              var t;
              return (
                (t = a[e.type]),
                t
                  ? t(e)
                  : (o.signalErrorWithMessage(
                      'GSP.mfs.makeSpeakableTextFromMFSParseTree: No handler for node:' +
                        e.type
                    ),
                    '')
              );
            }
            function n(e, n) {
              var i,
                r = e.length,
                s = '',
                o = !1;
              for (i = 0; r > i; i++) o ? (s += ' ') : (o = n), (s += t(e[i]));
              return s;
            }
            function i(e) {
              switch (e.type) {
                case 'paren':
                case 'curly':
                case 'bracket':
                case 'root':
                case 'abs':
                  return !0;
                case 'switch':
                  var t = e.visibleNode;
                  return t > 0 ? i(e.value[t - 1]) : !1;
                case 'style':
                  return i(e.value[e.value.length - 1]);
              }
              return !1;
            }
            function r(e) {
              return isNaN(e)
                ? 1 === e.length
                  ? !0
                  : '<%cX>' === e ||
                    '<%cY>' === e ||
                    '<%rX>' === e ||
                    '<%rY>' === e
                  ? !0
                  : !1
                : !0;
            }
            function s(e) {
              var n = t(e);
              return r(n) || i(e) ? n : 'the quantity ' + n + ' end quantity';
            }
            if (!e) return '';
            var a = {},
              c = new RegExp(
                '^\\s*([-−–0-9.]+)\\s*,\\s*([-−–0-9.]+\\s*(?:°|radians)?)\\s*$'
              );
            (a.bracket = a.curly = a.paren = function(e) {
              var n = t(e.value[0]);
              if ('paren' === e.type) {
                if ('<%xValue>, <%yValue>' === n)
                  return 'coordinates <%xValue> comma <%yValue> ';
                var i = '<%rValue>, <%thetaValue>';
                if (n.startsWith(i))
                  return (
                    'coordinates <%rValue> comma <%thetaValue> ' +
                    n.substring(i.length)
                  );
                var r = c.exec(n);
                if (null !== r)
                  return 'coordinates ' + r[1] + ' comma ' + r[2] + ' ';
              }
              return 'the quantity ' + n + ' end quantity';
            }),
              (a.root = function(e) {
                return 'the square root of ' + s(e.value[0]);
              }),
              (a.abs = function(e) {
                return 'the absolute value of ' + s(e.value[0]);
              }),
              (a.future = function(e) {
                return '';
              }),
              (a.fraction = function(e) {
                var n = t(e.value[0]),
                  i = t(e.value[1]);
                if ('1' === n) {
                  if ('2' === i) return 'one half ';
                  if ('3' === i) return 'one third ';
                  if ('4' === i) return 'one quarter ';
                }
                return s(e.value[0]) + ' divided by ' + s(e.value[1]);
              }),
              (a.horizontal = function(e) {
                var n,
                  i = e.value,
                  r = i.length,
                  o = '';
                for (n = 0; r > n; n++) {
                  var a = !0;
                  if (
                    n > 0 &&
                    'paren' === i[n].type &&
                    o.length > 0 &&
                    ' ' !== o.charAt(o.length - 1)
                  ) {
                    var c = i[n].value[0];
                    (o += ' of ' + s(c)), (a = !1);
                  }
                  a && (o += t(i[n]));
                }
                return o;
              }),
              (a.vertical = function(e) {
                return n(e.value, !0);
              }),
              (a.parameter = function(e) {
                return '<%' + e.value + '>';
              }),
              (a.input = function(e) {
                return '<%' + e.value + '>';
              }),
              (a.style = function(e) {
                return t(e.value[e.value.length - 1]);
              }),
              (a.sub = function(e) {
                return t(e.value[0]) + ' sub ' + t(e.value[1]);
              }),
              (a.super = function(e) {
                var n = t(e.value[0]),
                  i = t(e.value[1]);
                return '2' === i
                  ? 'cm' === n || ' cm' === n
                    ? ' square centimeters '
                    : 'in.' === n || ' in.' === n
                    ? ' square inches '
                    : s(e.value[0]) + ' squared '
                  : '3' === i
                  ? 'cm' === n || ' cm' === n
                    ? ' cubed centimeters '
                    : 'in.' === n || ' in.' === n
                    ? ' cubed inches '
                    : s(e.value[0]) + ' cubed '
                  : s(e.value[0]) + ' raised to the power ' + s(e.value[1]);
              }),
              (a.symbol = function(e) {
                return 'B4' === e.value
                  ? 'times'
                  : o.mfs.symMap[e.value.toUpperCase()] || e.value;
              }),
              (a.text = function(e) {
                var t = e.value,
                  n = t.trim();
                return '⋅' === n ? ' times ' : t;
              }),
              (a.switch = function(e) {
                var n = e.visibleNode;
                return n > 0 ? t(e.value[n - 1]) : '';
              }),
              (a.overbar = function(e) {
                var n = '';
                switch (e.variant) {
                  case 2:
                    n += 'Segment ';
                    break;
                  case 3:
                    n += 'Ray ';
                    break;
                  case 4:
                    n += 'Line ';
                    break;
                  case 5:
                    n += 'Arc ';
                }
                return n + t(e.value);
              });
            var l = t(e);
            return (
              (l = l.replace(/\bm ?(Segment|Arc|∠|∠)/g, 'measure of $1')),
              (l = l.replace(/⊙/g, 'circle ')),
              (l = l.replace(/△/g, 'triangle ')),
              (l = l.replace(/→/g, 'toward ')),
              (l = l.replace(/\u200B/g, ' ')),
              (l = l.replace(/>\s?in./g, '> inches')),
              (l = l.replace(/(\d)\s?in./g, '$1 inches'))
            );
          }),
          (o.mfs.plurals = {
            Object: 'Objects',
            Text: 'Texts',
            Action: 'Actions',
            IterateMap: 'IterateMaps',
            ImportedObject: 'ImportedObjects',
            Table: 'Tables',
            OrnamentalMarker: 'OrnamentalMarkers',
            TransformableNonPath: 'TransformableNonPaths',
            Path: 'Paths',
            CoordSys: 'CoordSys',
            Envelope: 'Envelopes',
            IterateImage: 'IterateImages',
            CustomTransformedPictureImage: 'CustomTransformedPictureImages',
            Point: 'Points',
            Midpoint: 'Midpoints',
            OriginPoint: 'OriginPoints',
            Intersection: 'Intersections',
            PlottedPoint: 'PlottedPoints',
            CustomTransformedPointImage: 'CustomTransformedPointImages',
            AbstractTransformableGeometry: 'AbstractTransformableGeometrys',
            PointOnPath: 'PointOnPaths',
            UnitPoint: 'UnitPoints',
            TransformablePath: 'TransformablePaths',
            PointLocus: 'PointLoci',
            CustomTransformedPathImage: 'CustomTransformedPathImages',
            ParametricPlot: 'ParametricPlots',
            FunctionPlot: 'FunctionPlots',
            Straight: 'Straights',
            Curved: 'Curveds',
            Interior: 'Interiors',
            Line: 'Lines',
            Parallel: 'Parallels',
            Perpendicular: 'Perpendiculars',
            Ray: 'Rays',
            Bisector: 'Bisectors',
            Segment: 'Segments',
            AbstractSimplePath: 'AbstractSimplePaths',
            Circle: 'Circles',
            MetaArc: 'MetaArcs',
            Polygon: 'Polygons',
            Triangle: 'Triangles',
            Quadrilateral: 'Quadrilaterals',
            Pentagon: 'Pentagons',
            Hexagon: 'Hexagons',
            CircleInt: 'CircleInts',
            AbstractArea1: 'AbstractArea1s',
            Axis: 'Axis',
            AbstractRayOrSegment: 'AbstractRayOrSegments',
            AbstractDistance: 'AbstractDistances',
            AbstractPerimeter: 'AbstractPerimeters',
            AbstractCircle: 'AbstractCircles',
            Measure: 'Measures',
            Caption: 'Captions',
            MultiMeasure: 'MultiMeasures',
            UniMeasure: 'UniMeasures',
            CompositeText: 'CompositeTexts',
            Coordinate: 'Coordinates',
            Equation: 'Equations',
            AbstractCircleOrSimpleArc: 'AbstractCircleOrSimpleArcs',
            SimpleArc: 'SimpleArcs',
            ArcInterior: 'ArcInteriors',
            AbstractRadius: 'AbstractRadiuss',
            ArcSector: 'ArcSectors',
            ArcSegment: 'ArcSegments',
            AbstractArea2: 'AbstractArea2',
            DistanceMeasure: 'DistanceMeasures',
            AngleMeasure: 'AngleMeasures',
            AreaMeasure: 'AreaMeasures',
            ScalarMeasure: 'ScalarMeasures',
            LinearEquation: 'LinearEquations',
            QuadraticEquation: 'QuadraticEquations',
            Function: 'Functions',
            MetaDerivative: 'MetaDerivatives',
            ExactDerivative: 'ExactDerivatives',
            ApproximateDerivative: 'ApproximateDerivatives',
            DataFunction: 'DataFunctions',
            AbstractPlottedPath: 'AbstractPlottedPaths',
            DistanceParameter: 'DistanceParameters',
            AngleParameter: 'AngleParameters',
            ScalarParameter: 'ScalarParameters',
            ImportedPicture: 'ImportedPictures',
            Drawing: 'Drawings',
            AbstractTransformableGeometryAndPictures:
              'AbstractTransformableGeometryAndPictures',
            UserEditableTable: 'UserEditableTables',
            FixedEntryTable: 'FixedEntryTables',
            AngleMarker: 'AngleMarkers',
            PathMarker: 'PathMarkers',
            AbstractSimpleOrPlottedPath: 'AbstractSimpleOrPlottedPaths',
          }),
          (o.mfs.updatedGenus = {
            Object: 'Object',
            Text: 'Text',
            Action: 'Action',
            IterateMap: 'Iterate Map',
            ImportedObject: 'Imported Object',
            Table: 'Table',
            OrnamentalMarker: 'Ornamental Marker',
            TransformableNonPath: 'Transformable NonPath',
            Path: 'Path',
            CoordSys: 'Coordinate System',
            Envelope: 'Envelope',
            IterateImage: 'Iterate Image',
            CustomTransformedPictureImage: 'Custom Transformed Picture Image',
            Point: 'Point',
            Midpoint: 'Mid point',
            OriginPoint: 'Origin Point',
            Intersection: 'Inter section',
            PlottedPoint: 'Plotted Point',
            CustomTransformedPointImage: 'Custom Transformed Point Image',
            AbstractTransformableGeometry: 'Abstract Transformable Geometry',
            PointOnPath: 'Point On Path',
            UnitPoint: 'Unit Point',
            TransformablePath: 'Transformable Path',
            PointLocus: 'Point Locus',
            CustomTransformedPathImage: 'Custom Transformed Path Image',
            ParametricPlot: 'Parametric Plot',
            FunctionPlot: 'Function Plot',
            Straight: 'Straight',
            Curved: 'Curved',
            Interior: 'Interior',
            Line: 'Line',
            Parallel: 'Parallel',
            Perpendicular: 'Perpendicular',
            Ray: 'Ray',
            Bisector: 'Bisector',
            Segment: 'Segment',
            AbstractSimplePath: 'Abstract Simple Path',
            Circle: 'Circle',
            MetaArc: 'Meta Arc',
            Polygon: 'Polygon',
            Triangle: 'Triangle',
            Quadrilateral: 'Quadrilateral',
            Pentagon: 'Pentagon',
            Hexagon: 'Hexagon',
            CircleInt: 'Circle Interior',
            AbstractArea1: 'Abstract Area 1',
            Axis: 'Axis',
            AbstractRayOrSegment: 'Abstract Ray Or Segment',
            AbstractDistance: 'Abstract Distance',
            AbstractPerimeter: 'Abstract Perimeter',
            AbstractCircle: 'Abstract Circle',
            Measure: 'Measure',
            Caption: 'Caption',
            MultiMeasure: 'Multi Measure',
            UniMeasure: 'UniMeasure',
            CompositeText: 'Composite Text',
            Coordinate: 'Coordinate',
            Equation: 'Equation',
            AbstractCircleOrSimpleArc: 'Abstract Circle Or Simple Arc',
            SimpleArc: 'Simple Arc',
            ArcInterior: 'Arc Interior',
            AbstractRadius: 'Abstract Radius',
            ArcSector: 'Arc Sector',
            ArcSegment: 'Arc Segment',
            AbstractArea2: 'Abstract Area',
            DistanceMeasure: 'Distance Measure',
            AngleMeasure: 'Angle Measure',
            AreaMeasure: 'Area Measure',
            ScalarMeasure: 'Scalar Measure',
            LinearEquation: 'Linear Equation',
            QuadraticEquation: 'Quadratic Equation',
            Function: 'Function',
            MetaDerivative: 'Meta Derivative',
            ExactDerivative: 'Exact Derivative',
            ApproximateDerivative: 'Approximate Derivative',
            DataFunction: 'Data Function',
            AbstractPlottedPath: 'Abstract Plotted Path',
            DistanceParameter: 'Distance Parameter',
            AngleParameter: 'Angle Parameter',
            ScalarParameter: 'Scalar Parameter',
            ImportedPicture: 'Imported Picture',
            Drawing: 'Drawing',
            AbstractTransformableGeometryAndPictures:
              'Abstract Transformable Geometry And Picture',
            UserEditableTable: 'User Editable',
            FixedEntryTable: 'Fixed Entry',
            AngleMarker: 'Angle Marker',
            PathMarker: 'Path Marker',
            AbstractSimpleOrPlottedPath: 'Abstract Simple Or Plotted Path',
          }),
          (o.mfs.collectiveGeneraDescription = function(e, t) {
            var n = {},
              i = '';
            e.eachParent(function(e, t) {
              t.genus in n ? (n[t.genus] += 1) : (n[t.genus] = 1);
            });
            for (var r in n)
              i += n[r] > 1 ? n[r] + ' ' + o.mfs.plurals[r] + ', ' : r + ', ';
            return (i = i.substring(0, i.length - 2));
          });
      })(),
      (o.units = {}),
      (o.units.unitFamilies = {
        length: { baseUnit: 'pixels' },
        angle: { baseUnit: 'radians' },
        scalar: { baseUnit: 'scalar' },
      }),
      (o.units.units = [
        {
          unitFamily: 'scalar',
          conversionFromBase: 1,
          pluralName: '',
          singularName: '',
          symbol: '',
        },
        {
          unitFamily: 'length',
          conversionFromBase: 1,
          pluralName: 'pixels',
          singularName: 'pixel',
          shortName: 'pix',
          digraph: 'px',
          symbol: ' pixels',
        },
        {
          unitFamily: 'length',
          conversionFromBase: 1 / 72,
          pluralName: 'inches',
          singularName: 'inch',
          shortName: 'in.',
          digraph: 'in',
          symbol: ' in.',
        },
        {
          unitFamily: 'length',
          conversionFromBase: 0.03527777777777776,
          pluralName: 'centimeter',
          singularName: 'centimeter',
          shortName: 'cm',
          digraph: 'cm',
          symbol: ' cm',
        },
        {
          unitFamily: 'angle',
          conversionFromBase: 1,
          pluralName: 'radians',
          singularName: 'radian',
          shortName: 'rad',
          digraph: 'rd',
          symbol: ' radians',
        },
        {
          unitFamily: 'angle',
          conversionFromBase: 180 / Math.PI,
          pluralName: 'degrees',
          singularName: 'degree',
          shortName: 'deg',
          digraph: 'dg',
          symbol: '°',
        },
        {
          unitFamily: 'angle',
          conversionFromBase: 180 / Math.PI,
          pluralName: 'degrees',
          singularName: 'degree',
          shortName: 'signed deg',
          digraph: 'dg',
          symbol: '°',
        },
      ]),
      (o.units.makeUnitMap = function(e) {
        var t,
          i,
          r = {};
        for (t = 0; t < e.length; t += 1)
          (i = e[t]),
            i.pluralName !== n && (r[i.pluralName] = i),
            i.singularName !== n && (r[i.singularName] = i),
            i.shortName !== n && (r[i.shortName] = i),
            i.digraph !== n && (r[i.digraph] = i),
            i.symbol !== n && (r[i.symbol] = i),
            'scalar' === i.unitFamily && (r.scalar = i);
        return r;
      }),
      (o.units.unitMap = o.units.makeUnitMap(o.units.units)),
      (o.units.findUnit = function(e, t) {
        return 'undefined' == typeof e && (e = 'scalar'), this.unitMap[e];
      }),
      (o.units.convert = function(e, t, i, r) {
        var s,
          a = this.findUnit(t),
          c = this.findUnit(i),
          l = a.unitFamily;
        return (
          r === n && (r = 1),
          a
            ? c
              ? ((l = a.unitFamily),
                c.unitFamily !== l
                  ? (o.signalErrorWithMessage(
                      "GSP.units.convert: can't convert between unit families: " +
                        t +
                        '/' +
                        i
                    ),
                    e)
                  : ((s =
                      a.pluralName === l.baseUnit
                        ? e
                        : e / Math.pow(a.conversionFromBase, r)),
                    s * Math.pow(c.conversionFromBase, r)))
              : (o.signalErrorWithMessage(
                  'GSP.units.convert: unknown toUnit: ' + i
                ),
                e)
            : (o.signalErrorWithMessage(
                'GSP.units.convert: unknown fromUnit: ' + t
              ),
              e)
        );
      }),
      (o.units.eachUnitDimension = function(e, t) {
        var n;
        for (n in e)
          if (
            e.hasOwnProperty(n) &&
            e[n] &&
            'scalar' !== n &&
            !1 === t(n, e[n])
          )
            return;
      }),
      (o.units.makeUnitObjectFromUnitsAndPowers = function(e, t) {
        var n = {};
        return (
          o.units.eachUnitDimension(t, function(t, i) {
            n[t] = { unit: e[t], power: i };
          }),
          n
        );
      }),
      (o.units.convertFromBaseToUnitObject = function(e, t) {
        var n = e;
        return (
          o.units.eachUnitDimension(t, function(e, t) {
            n = o.units.convertFromBaseValue(n, t.unit, t.power);
          }),
          n
        );
      }),
      (o.units.convertToBaseFromUnitObject = function(e, t) {
        var n = e;
        return (
          o.units.eachUnitDimension(t, function(e, t) {
            n = o.units.convertToBaseValue(n, t.unit, t.power);
          }),
          n
        );
      }),
      (o.units.convertFromBaseValue = function(e, t, i) {
        var r,
          s = this.findUnit(t);
        return s === n
          ? (o.signalErrorWithMessage(
              'GSP.units.convert: unknown toUnit: ' + t
            ),
            e)
          : ((r = s.unitFamily),
            this.convert(e, this.unitFamilies[r].baseUnit, t, i));
      }),
      (o.units.convertToBaseValue = function(e, t, i) {
        var r,
          s = this.findUnit(t);
        return s === n
          ? (o.signalErrorWithMessage(
              'GSP.units.convert: unknown toUnit: ' + s
            ),
            e)
          : ((r = s.unitFamily),
            this.convert(e, t, this.unitFamilies[r].baseUnit, i));
      }),
      (o.units.getMFSForUnitObject = function(e) {
        var t = null;
        return (
          o.units.eachUnitDimension(e, function(e, n) {
            if (0 !== n.power) {
              if (t) return null;
              t =
                1 === n.power
                  ? o.mfs.makeTextMFS(o.units.findUnit(n.unit).symbol)
                  : {
                      type: 'super',
                      value: [
                        o.mfs.makeTextMFS(o.units.findUnit(n.unit).symbol),
                        o.mfs.makeTextMFS(n.power),
                      ],
                    };
            }
          }),
          t
        );
      }),
      (o.units.getUnitFamily = function(e) {
        var t = this.findUnit(e);
        return t === n && (t = this.findUnit('scalar')), t.unitFamily;
      }),
      (o.units.convertToDocUnits = function(e, t, n) {
        if ('undefined' == typeof n) return t;
        var i = this.findUnit(n),
          r = e[i.unitFamily];
        return this.convert(t, n, r, 1);
      }),
      (o.math = {
        angleToRadians: function(e, t) {
          return o.units.convert(t, e, 'radians', 1);
        },
        sin: function(e, t) {
          return Math.sin(this.angleToRadians(t.angle, e));
        },
        cos: function(e, t) {
          return Math.cos(this.angleToRadians(t.angle, e));
        },
        tan: function(e, t) {
          return Math.tan(this.angleToRadians(t.angle, e));
        },
        asin: function(e, t) {
          return o.units.convertToDocUnits(t, Math.asin(e), 'radians');
        },
        acos: function(e, t) {
          return o.units.convertToDocUnits(t, Math.acos(e), 'radians');
        },
        atan: function(e, t) {
          return o.units.convertToDocUnits(t, Math.atan(e), 'radians');
        },
        abs: Math.abs,
        sqrt: Math.sqrt,
        ln: Math.log,
        log: function(e) {
          return e >= 1
            ? Math.log(e) * Math.LOG10E
            : Math.log(10 * e) * Math.LOG10E - 1;
        },
        pow: function(e, t) {
          return 0 > e ? o.math.powerOfNegativeBase(e, t) : Math.pow(e, t);
        },
        sign: function(e) {
          return e === e ? (0 === e ? 0 : 0 > e ? -1 : 1) : NaN;
        },
        isDefined: function(e) {
          return isNaN(e) ? 0 : 1;
        },
        round: Math.round,
        trunc: function(e) {
          return Math[e > 0 ? 'floor' : 'ceil'](e);
        },
        mod: function(e, t) {
          return ((e % t) + t) % t;
        },
        powerOfNegativeBase: function(e, t) {
          var n,
            i,
            r,
            s,
            o = 1e-13,
            a = 3;
          for (r = 0; 5 > r; ++r) {
            if (((n = t * a), (i = Math.round(n)), Math.abs(n - i) <= 2 * o))
              return (s = i % 2 !== 0 ? -1 : 1), s * Math.pow(-e, t);
            a += 2;
          }
          return Math.pow(e, t);
        },
        expect: function(e, t, i, r) {
          var s,
            o = isNaN(e) || e === n,
            a = isNaN(t) || t === n,
            c =
              !isFinite(e) &&
              !isNaN(e) &&
              (e > 0 ? 'posInfinity' : 'negInfinity'),
            l =
              ('inf' === t && 'posInfinity') || ('-inf' === t && 'negInfinity');
          return (
            n === i && (i = 1e-5),
            e === t
              ? !0
              : c || l
              ? c === l
              : o || a
              ? o === a
              : ((s = Math.abs(e - t)),
                r && e + i !== e
                  ? i > s
                  : Math.abs(e) + Math.abs(t) < 2e-12
                  ? !0
                  : s <= i * Math.abs(e) && s <= i * Math.abs(t))
          );
        },
        isFiniteScalar: function(e) {
          return null != e && isFinite(e);
        },
        gcd: function(e, t) {
          if (e !== ~~e || t !== ~~t) return 0;
          if (0 === e || 0 === t) return 0;
          for (var n; t; ) (n = e % t), (e = t), (t = n);
          return e;
        },
        reduceFraction: function(e, t) {
          var n = this.gcd(e, t);
          return n > 1
            ? { numerator: e / n, denominator: t / n }
            : { numerator: e, denominator: t };
        },
        getSimplePiFraction: function(e) {
          if (e === Math.floor(e)) return !1;
          var t = (12 * e) / Math.PI,
            n = Math.round(t),
            i = Math.abs(t - n);
          if (0 !== n && 0.001 > i) {
            var r = o.math.reduceFraction(Math.abs(n), 12);
            return 0 > n && (r.numerator = -r.numerator), r;
          }
          return !1;
        },
        parameterDeltaForSecant: function(e, t) {
          var n,
            i,
            r,
            s = 1.05367121e-8;
          return (
            (n = Math.abs(t.x)),
            Math.abs(t.y) > n && (n = Math.abs(t.y)),
            (i = s * n),
            (r = e + i),
            (i = r - e),
            i > 0 ? i : s
          );
        },
        secantApproximationToDerivative: function(e, t, n) {
          var i,
            r = o.math.parameterDeltaForSecant(e, t);
          return (
            (i = n(e + r)),
            i.isDefined()
              ? o.GeometricPoint((i.x - t.x) / r, (i.y - t.y) / r)
              : ((i = n(e - r)),
                i.isDefined()
                  ? o.GeometricPoint((i.x - t.x) / -r, (i.y - t.y) / -r)
                  : o.GeometricPoint.UNDEFINED)
          );
        },
      }),
      (o.math.PI = Math.PI),
      (o.math.TWO_PI = 2 * Math.PI),
      (o.math.SIMPLE_PI_THRESHOLD = 0.9999999999 * Math.PI),
      (o.infixExpressionParser = (function() {
        function e(e, t) {
          function n() {
            this.constructor = e;
          }
          (n.prototype = t.prototype), (e.prototype = new n());
        }
        function t(e, t, n, i, r, s) {
          (this.message = e),
            (this.expected = t),
            (this.found = n),
            (this.offset = i),
            (this.line = r),
            (this.column = s),
            (this.name = 'SyntaxError');
        }
        function i(e) {
          function i(t) {
            function n(t, n, i) {
              var r, s;
              for (r = n; i > r; r++)
                (s = e.charAt(r)),
                  '\n' === s
                    ? (t.seenCR || t.line++, (t.column = 1), (t.seenCR = !1))
                    : '\r' === s || '\u2028' === s || '\u2029' === s
                    ? (t.line++, (t.column = 1), (t.seenCR = !0))
                    : (t.column++, (t.seenCR = !1));
            }
            return (
              ln !== t &&
                (ln > t &&
                  ((ln = 0), (un = { line: 1, column: 1, seenCR: !1 })),
                n(un, ln, t),
                (ln = t)),
              un
            );
          }
          function r(e) {
            dn > an || (an > dn && ((dn = an), (hn = [])), hn.push(e));
          }
          function s(n, r, s) {
            function o(e) {
              var t = 1;
              for (
                e.sort(function(e, t) {
                  return e.description < t.description
                    ? -1
                    : e.description > t.description
                    ? 1
                    : 0;
                });
                t < e.length;

              )
                e[t - 1] === e[t] ? e.splice(t, 1) : t++;
            }
            function a(e, t) {
              function n(e) {
                function t(e) {
                  return e
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
                }
                return e
                  .replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\x08/g, '\\b')
                  .replace(/\t/g, '\\t')
                  .replace(/\n/g, '\\n')
                  .replace(/\f/g, '\\f')
                  .replace(/\r/g, '\\r')
                  .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(e) {
                    return '\\x0' + t(e);
                  })
                  .replace(/[\x10-\x1F\x80-\xFF]/g, function(e) {
                    return '\\x' + t(e);
                  })
                  .replace(/[\u0180-\u0FFF]/g, function(e) {
                    return '\\u0' + t(e);
                  })
                  .replace(/[\u1080-\uFFFF]/g, function(e) {
                    return '\\u' + t(e);
                  });
              }
              var i,
                r,
                s,
                o = new Array(e.length);
              for (s = 0; s < e.length; s++) o[s] = e[s].description;
              return (
                (i =
                  e.length > 1
                    ? o.slice(0, -1).join(', ') + ' or ' + o[e.length - 1]
                    : o[0]),
                (r = t ? '"' + n(t) + '"' : 'end of input'),
                'Expected ' + i + ' but ' + r + ' found.'
              );
            }
            var c = i(s),
              l = s < e.length ? e.charAt(s) : null;
            return (
              null !== r && o(r),
              new t(null !== n ? n : a(r, l), r, l, s, c.line, c.column)
            );
          }
          function o() {
            var e;
            return (e = c()), e === E && (e = a()), e;
          }
          function a() {
            var e, t;
            return (
              (e = an), (t = []), t !== E && ((cn = e), (t = L())), (e = t)
            );
          }
          function c() {
            var t, n, i, s, o, a, c;
            return (
              (t = an),
              (n = an),
              (i = S()),
              i !== E
                ? ((s = l()),
                  s !== E
                    ? ((o = S()),
                      o !== E
                        ? (61 === e.charCodeAt(an)
                            ? ((a = R), an++)
                            : ((a = E), 0 === pn && r(N)),
                          a !== E
                            ? ((c = S()),
                              c !== E
                                ? ((i = [i, s, o, a, c]), (n = i))
                                : ((an = n), (n = G)))
                            : ((an = n), (n = G)))
                        : ((an = n), (n = G)))
                    : ((an = n), (n = G)))
                : ((an = n), (n = G)),
              n === E && (n = D),
              n !== E
                ? ((i = S()),
                  i !== E
                    ? ((s = u()),
                      s !== E
                        ? ((o = S()),
                          o !== E
                            ? ((cn = t), (n = z(n, s)), (t = n))
                            : ((an = t), (t = G)))
                        : ((an = t), (t = G)))
                    : ((an = t), (t = G)))
                : ((an = t), (t = G)),
              t
            );
          }
          function l() {
            var t, n, i, s, o, a, c, l;
            if (
              ((t = an),
              (n = []),
              B.test(e.charAt(an))
                ? ((i = e.charAt(an)), an++)
                : ((i = E), 0 === pn && r(V)),
              i !== E)
            )
              for (; i !== E; )
                n.push(i),
                  B.test(e.charAt(an))
                    ? ((i = e.charAt(an)), an++)
                    : ((i = E), 0 === pn && r(V));
            else n = G;
            return (
              n !== E
                ? ((i = S()),
                  i !== E
                    ? (40 === e.charCodeAt(an)
                        ? ((s = q), an++)
                        : ((s = E), 0 === pn && r(U)),
                      s !== E
                        ? ((o = S()),
                          o !== E
                            ? (_.test(e.charAt(an))
                                ? ((a = e.charAt(an)), an++)
                                : ((a = E), 0 === pn && r(Q)),
                              a !== E
                                ? ((c = S()),
                                  c !== E
                                    ? (41 === e.charCodeAt(an)
                                        ? ((l = Y), an++)
                                        : ((l = E), 0 === pn && r(H)),
                                      l !== E
                                        ? ((cn = t), (n = W(n, a)), (t = n))
                                        : ((an = t), (t = G)))
                                    : ((an = t), (t = G)))
                                : ((an = t), (t = G)))
                            : ((an = t), (t = G)))
                        : ((an = t), (t = G)))
                    : ((an = t), (t = G)))
                : ((an = t), (t = G)),
              t === E &&
                ((t = an),
                _.test(e.charAt(an))
                  ? ((n = e.charAt(an)), an++)
                  : ((n = E), 0 === pn && r(Q)),
                n !== E && ((cn = t), (n = X(n))),
                (t = n)),
              t
            );
          }
          function u() {
            var t, n, i, s, o, a, c, l, u;
            if (((t = an), (n = d()), n !== E))
              if (((i = S()), i !== E)) {
                for (
                  s = [],
                    o = an,
                    43 === e.charCodeAt(an)
                      ? ((a = K), an++)
                      : ((a = E), 0 === pn && r(J)),
                    a === E &&
                      (45 === e.charCodeAt(an)
                        ? ((a = Z), an++)
                        : ((a = E), 0 === pn && r($))),
                    a !== E
                      ? ((c = S()),
                        c !== E
                          ? ((l = d()),
                            l !== E
                              ? ((u = S()),
                                u !== E
                                  ? ((a = [a, c, l, u]), (o = a))
                                  : ((an = o), (o = G)))
                              : ((an = o), (o = G)))
                          : ((an = o), (o = G)))
                      : ((an = o), (o = G));
                  o !== E;

                )
                  s.push(o),
                    (o = an),
                    43 === e.charCodeAt(an)
                      ? ((a = K), an++)
                      : ((a = E), 0 === pn && r(J)),
                    a === E &&
                      (45 === e.charCodeAt(an)
                        ? ((a = Z), an++)
                        : ((a = E), 0 === pn && r($))),
                    a !== E
                      ? ((c = S()),
                        c !== E
                          ? ((l = d()),
                            l !== E
                              ? ((u = S()),
                                u !== E
                                  ? ((a = [a, c, l, u]), (o = a))
                                  : ((an = o), (o = G)))
                              : ((an = o), (o = G)))
                          : ((an = o), (o = G)))
                      : ((an = o), (o = G));
                s !== E
                  ? ((cn = t), (n = ee(n, s)), (t = n))
                  : ((an = t), (t = G));
              } else (an = t), (t = G);
            else (an = t), (t = G);
            return t;
          }
          function d() {
            var t, n, i, s, o, a, c, l, u;
            if (((t = an), (n = h()), n !== E))
              if (((i = S()), i !== E)) {
                for (
                  s = [],
                    o = an,
                    47 === e.charCodeAt(an)
                      ? ((a = te), an++)
                      : ((a = E), 0 === pn && r(ne)),
                    a === E &&
                      (42 === e.charCodeAt(an)
                        ? ((a = ie), an++)
                        : ((a = E), 0 === pn && r(re))),
                    a !== E
                      ? ((c = S()),
                        c !== E
                          ? ((l = h()),
                            l !== E
                              ? ((u = S()),
                                u !== E
                                  ? ((a = [a, c, l, u]), (o = a))
                                  : ((an = o), (o = G)))
                              : ((an = o), (o = G)))
                          : ((an = o), (o = G)))
                      : ((an = o), (o = G));
                  o !== E;

                )
                  s.push(o),
                    (o = an),
                    47 === e.charCodeAt(an)
                      ? ((a = te), an++)
                      : ((a = E), 0 === pn && r(ne)),
                    a === E &&
                      (42 === e.charCodeAt(an)
                        ? ((a = ie), an++)
                        : ((a = E), 0 === pn && r(re))),
                    a !== E
                      ? ((c = S()),
                        c !== E
                          ? ((l = h()),
                            l !== E
                              ? ((u = S()),
                                u !== E
                                  ? ((a = [a, c, l, u]), (o = a))
                                  : ((an = o), (o = G)))
                              : ((an = o), (o = G)))
                          : ((an = o), (o = G)))
                      : ((an = o), (o = G));
                s !== E
                  ? ((cn = t), (n = se(n, s)), (t = n))
                  : ((an = t), (t = G));
              } else (an = t), (t = G);
            else (an = t), (t = G);
            return t;
          }
          function h() {
            var t, n, i, s, o, a, c;
            return (
              (t = an),
              (n = p()),
              n !== E
                ? ((i = S()),
                  i !== E
                    ? ((s = an),
                      94 === e.charCodeAt(an)
                        ? ((o = oe), an++)
                        : ((o = E), 0 === pn && r(ae)),
                      o !== E
                        ? ((a = S()),
                          a !== E
                            ? ((c = h()),
                              c !== E
                                ? ((o = [o, a, c]), (s = o))
                                : ((an = s), (s = G)))
                            : ((an = s), (s = G)))
                        : ((an = s), (s = G)),
                      s === E && (s = D),
                      s !== E
                        ? ((cn = t), (n = ce(n, s)), (t = n))
                        : ((an = t), (t = G)))
                    : ((an = t), (t = G)))
                : ((an = t), (t = G)),
              t
            );
          }
          function p() {
            var t, n, i, s, o, a;
            return (
              (t = f()),
              t === E &&
                ((t = an),
                40 === e.charCodeAt(an)
                  ? ((n = q), an++)
                  : ((n = E), 0 === pn && r(U)),
                n !== E
                  ? ((i = S()),
                    i !== E
                      ? ((s = u()),
                        s !== E
                          ? ((o = S()),
                            o !== E
                              ? (41 === e.charCodeAt(an)
                                  ? ((a = Y), an++)
                                  : ((a = E), 0 === pn && r(H)),
                                a !== E
                                  ? ((cn = t), (n = le(s)), (t = n))
                                  : ((an = t), (t = G)))
                              : ((an = t), (t = G)))
                          : ((an = t), (t = G)))
                      : ((an = t), (t = G)))
                  : ((an = t), (t = G)),
                t === E && (t = b())),
              t
            );
          }
          function f() {
            var t, n, i, s;
            return (
              (t = m()),
              t === E &&
                ((t = an),
                45 === e.charCodeAt(an)
                  ? ((n = Z), an++)
                  : ((n = E), 0 === pn && r($)),
                n !== E
                  ? ((i = S()),
                    i !== E
                      ? ((s = f()),
                        s !== E
                          ? ((cn = t), (n = ue(s)), (t = n))
                          : ((an = t), (t = G)))
                      : ((an = t), (t = G)))
                  : ((an = t), (t = G)),
                t === E &&
                  ((t = an),
                  45 === e.charCodeAt(an)
                    ? ((n = Z), an++)
                    : ((n = E), 0 === pn && r($)),
                  n !== E
                    ? ((i = S()),
                      i !== E
                        ? ((s = h()),
                          s !== E
                            ? ((cn = t), (n = de(s)), (t = n))
                            : ((an = t), (t = G)))
                        : ((an = t), (t = G)))
                    : ((an = t), (t = G)))),
              t
            );
          }
          function m() {
            var t, n, i, s, o, a, c, l;
            return (
              (t = an),
              (n = g()),
              n !== E
                ? ((i = S()),
                  i !== E
                    ? (40 === e.charCodeAt(an)
                        ? ((s = q), an++)
                        : ((s = E), 0 === pn && r(U)),
                      s !== E
                        ? ((o = S()),
                          o !== E
                            ? ((a = u()),
                              a !== E
                                ? ((c = S()),
                                  c !== E
                                    ? (41 === e.charCodeAt(an)
                                        ? ((l = Y), an++)
                                        : ((l = E), 0 === pn && r(H)),
                                      l !== E
                                        ? ((cn = t), (n = he(n, a)), (t = n))
                                        : ((an = t), (t = G)))
                                    : ((an = t), (t = G)))
                                : ((an = t), (t = G)))
                            : ((an = t), (t = G)))
                        : ((an = t), (t = G)))
                    : ((an = t), (t = G)))
                : ((an = t), (t = G)),
              t === E &&
                ((t = an),
                (n = P()),
                n !== E
                  ? ((i = S()),
                    i !== E
                      ? (40 === e.charCodeAt(an)
                          ? ((s = q), an++)
                          : ((s = E), 0 === pn && r(U)),
                        s !== E
                          ? ((o = S()),
                            o !== E
                              ? ((a = u()),
                                a !== E
                                  ? ((c = S()),
                                    c !== E
                                      ? (41 === e.charCodeAt(an)
                                          ? ((l = Y), an++)
                                          : ((l = E), 0 === pn && r(H)),
                                        l !== E
                                          ? ((cn = t), (n = pe(n, a)), (t = n))
                                          : ((an = t), (t = G)))
                                      : ((an = t), (t = G)))
                                  : ((an = t), (t = G)))
                              : ((an = t), (t = G)))
                          : ((an = t), (t = G)))
                      : ((an = t), (t = G)))
                  : ((an = t), (t = G))),
              t
            );
          }
          function g() {
            var t;
            return (
              e.substr(an, 3) === fe
                ? ((t = fe), (an += 3))
                : ((t = E), 0 === pn && r(me)),
              t === E &&
                (e.substr(an, 3) === ge
                  ? ((t = ge), (an += 3))
                  : ((t = E), 0 === pn && r(be)),
                t === E &&
                  (e.substr(an, 3) === ve
                    ? ((t = ve), (an += 3))
                    : ((t = E), 0 === pn && r(ye)),
                  t === E &&
                    (e.substr(an, 6) === xe
                      ? ((t = xe), (an += 6))
                      : ((t = E), 0 === pn && r(we)),
                    t === E &&
                      (e.substr(an, 6) === ke
                        ? ((t = ke), (an += 6))
                        : ((t = E), 0 === pn && r(Pe)),
                      t === E &&
                        (e.substr(an, 6) === Ce
                          ? ((t = Ce), (an += 6))
                          : ((t = E), 0 === pn && r(Se)),
                        t === E &&
                          (e.substr(an, 3) === Ae
                            ? ((t = Ae), (an += 3))
                            : ((t = E), 0 === pn && r(Te)),
                          t === E &&
                            (e.substr(an, 4) === Me
                              ? ((t = Me), (an += 4))
                              : ((t = E), 0 === pn && r(Ie)),
                            t === E &&
                              (e.substr(an, 2) === Fe
                                ? ((t = Fe), (an += 2))
                                : ((t = E), 0 === pn && r(Ee)),
                              t === E &&
                                (e.substr(an, 3) === je
                                  ? ((t = je), (an += 3))
                                  : ((t = E), 0 === pn && r(Oe)),
                                t === E &&
                                  (e.substr(an, 3) === Le
                                    ? ((t = Le), (an += 3))
                                    : ((t = E), 0 === pn && r(Ge)),
                                  t === E &&
                                    (e.substr(an, 5) === De
                                      ? ((t = De), (an += 5))
                                      : ((t = E), 0 === pn && r(Re)),
                                    t === E &&
                                      (e.substr(an, 5) === Ne
                                        ? ((t = Ne), (an += 5))
                                        : ((t = E), 0 === pn && r(ze)),
                                      t === E &&
                                        (e.substr(an, 9) === Be
                                          ? ((t = Be), (an += 9))
                                          : ((t = E),
                                            0 === pn && r(Ve))))))))))))))),
              t
            );
          }
          function b() {
            var e, t, n, i;
            return (
              (e = an),
              (t = v()),
              t !== E
                ? ((n = S()),
                  n !== E
                    ? ((i = x()),
                      i !== E
                        ? ((cn = e), (t = qe(t, i)), (e = t))
                        : ((an = e), (e = G)))
                    : ((an = e), (e = G)))
                : ((an = e), (e = G)),
              e === E &&
                ((e = an),
                (t = v()),
                t !== E && ((cn = e), (t = Ue(t))),
                (e = t),
                e === E && ((e = P()), e === E && (e = C()))),
              e
            );
          }
          function v() {
            var t, n, i, s, o, a, c, l, u;
            return (
              (t = an),
              (n = an),
              45 === e.charCodeAt(an)
                ? ((i = Z), an++)
                : ((i = E), 0 === pn && r($)),
              i === E && (i = D),
              i !== E
                ? ((s = y()),
                  s !== E
                    ? (46 === e.charCodeAt(an)
                        ? ((o = _e), an++)
                        : ((o = E), 0 === pn && r(Qe)),
                      o !== E
                        ? ((a = y()),
                          a !== E
                            ? (101 === e.charCodeAt(an)
                                ? ((c = Ye), an++)
                                : ((c = E), 0 === pn && r(He)),
                              c !== E
                                ? (45 === e.charCodeAt(an)
                                    ? ((l = Z), an++)
                                    : ((l = E), 0 === pn && r($)),
                                  l === E && (l = D),
                                  l !== E
                                    ? ((u = y()),
                                      u !== E
                                        ? ((i = [i, s, o, a, c, l, u]), (n = i))
                                        : ((an = n), (n = G)))
                                    : ((an = n), (n = G)))
                                : ((an = n), (n = G)))
                            : ((an = n), (n = G)))
                        : ((an = n), (n = G)))
                    : ((an = n), (n = G)))
                : ((an = n), (n = G)),
              n === E &&
                ((n = an),
                45 === e.charCodeAt(an)
                  ? ((i = Z), an++)
                  : ((i = E), 0 === pn && r($)),
                i === E && (i = D),
                i !== E
                  ? ((s = y()),
                    s !== E
                      ? (46 === e.charCodeAt(an)
                          ? ((o = _e), an++)
                          : ((o = E), 0 === pn && r(Qe)),
                        o !== E
                          ? ((a = y()),
                            a !== E
                              ? ((i = [i, s, o, a]), (n = i))
                              : ((an = n), (n = G)))
                          : ((an = n), (n = G)))
                      : ((an = n), (n = G)))
                  : ((an = n), (n = G)),
                n === E &&
                  ((n = an),
                  45 === e.charCodeAt(an)
                    ? ((i = Z), an++)
                    : ((i = E), 0 === pn && r($)),
                  i === E && (i = D),
                  i !== E
                    ? ((s = y()),
                      s !== E
                        ? (46 === e.charCodeAt(an)
                            ? ((o = _e), an++)
                            : ((o = E), 0 === pn && r(Qe)),
                          o !== E
                            ? ((i = [i, s, o]), (n = i))
                            : ((an = n), (n = G)))
                        : ((an = n), (n = G)))
                    : ((an = n), (n = G)),
                  n === E &&
                    ((n = an),
                    45 === e.charCodeAt(an)
                      ? ((i = Z), an++)
                      : ((i = E), 0 === pn && r($)),
                    i === E && (i = D),
                    i !== E
                      ? (46 === e.charCodeAt(an)
                          ? ((s = _e), an++)
                          : ((s = E), 0 === pn && r(Qe)),
                        s !== E
                          ? ((o = y()),
                            o !== E
                              ? ((i = [i, s, o]), (n = i))
                              : ((an = n), (n = G)))
                          : ((an = n), (n = G)))
                      : ((an = n), (n = G)),
                    n === E &&
                      ((n = an),
                      45 === e.charCodeAt(an)
                        ? ((i = Z), an++)
                        : ((i = E), 0 === pn && r($)),
                      i === E && (i = D),
                      i !== E
                        ? ((s = y()),
                          s !== E
                            ? ((i = [i, s]), (n = i))
                            : ((an = n), (n = G)))
                        : ((an = n), (n = G)))))),
              n !== E && ((cn = t), (n = We(n))),
              (t = n),
              t === E &&
                ((t = an),
                e.substr(an, 2) === Xe
                  ? ((n = Xe), (an += 2))
                  : ((n = E), 0 === pn && r(Ke)),
                n === E &&
                  (960 === e.charCodeAt(an)
                    ? ((n = Je), an++)
                    : ((n = E), 0 === pn && r(Ze)),
                  n === E &&
                    (101 === e.charCodeAt(an)
                      ? ((n = Ye), an++)
                      : ((n = E), 0 === pn && r(He)))),
                n !== E && ((cn = t), (n = $e(n))),
                (t = n)),
              t
            );
          }
          function y() {
            var t, n, i;
            if (
              ((t = an),
              (n = []),
              et.test(e.charAt(an))
                ? ((i = e.charAt(an)), an++)
                : ((i = E), 0 === pn && r(tt)),
              i !== E)
            )
              for (; i !== E; )
                n.push(i),
                  et.test(e.charAt(an))
                    ? ((i = e.charAt(an)), an++)
                    : ((i = E), 0 === pn && r(tt));
            else n = G;
            return n !== E && ((cn = t), (n = nt(n))), (t = n);
          }
          function x() {
            var e;
            return (e = w()), e === E && (e = k()), e;
          }
          function w() {
            var t, n;
            return (
              (t = an),
              e.substr(an, 6) === it
                ? ((n = it), (an += 6))
                : ((n = E), 0 === pn && r(rt)),
              n === E &&
                (e.substr(an, 5) === st
                  ? ((n = st), (an += 5))
                  : ((n = E), 0 === pn && r(ot)),
                n === E &&
                  (e.substr(an, 2) === at
                    ? ((n = at), (an += 2))
                    : ((n = E), 0 === pn && r(ct)),
                  n === E &&
                    (e.substr(an, 3) === lt
                      ? ((n = lt), (an += 3))
                      : ((n = E), 0 === pn && r(ut)),
                    n === E &&
                      (e.substr(an, 2) === dt
                        ? ((n = dt), (an += 2))
                        : ((n = E), 0 === pn && r(ht)),
                      n === E &&
                        (e.substr(an, 10) === pt
                          ? ((n = pt), (an += 10))
                          : ((n = E), 0 === pn && r(ft)),
                        n === E &&
                          (e.substr(an, 6) === mt
                            ? ((n = mt), (an += 6))
                            : ((n = E), 0 === pn && r(gt)),
                          n === E &&
                            (e.substr(an, 4) === bt
                              ? ((n = bt), (an += 4))
                              : ((n = E), 0 === pn && r(vt)),
                            n === E &&
                              (e.substr(an, 3) === yt
                                ? ((n = yt), (an += 3))
                                : ((n = E), 0 === pn && r(xt)),
                              n === E &&
                                (e.substr(an, 2) === wt
                                  ? ((n = wt), (an += 2))
                                  : ((n = E), 0 === pn && r(kt))))))))))),
              n !== E && ((cn = t), (n = Pt(n))),
              (t = n)
            );
          }
          function k() {
            var t, n;
            return (
              (t = an),
              e.substr(an, 7) === Ct
                ? ((n = Ct), (an += 7))
                : ((n = E), 0 === pn && r(St)),
              n === E &&
                (e.substr(an, 6) === At
                  ? ((n = At), (an += 6))
                  : ((n = E), 0 === pn && r(Tt)),
                n === E &&
                  (e.substr(an, 3) === Mt
                    ? ((n = Mt), (an += 3))
                    : ((n = E), 0 === pn && r(It)),
                  n === E &&
                    (e.substr(an, 2) === Ft
                      ? ((n = Ft), (an += 2))
                      : ((n = E), 0 === pn && r(Et)),
                    n === E &&
                      (e.substr(an, 7) === jt
                        ? ((n = jt), (an += 7))
                        : ((n = E), 0 === pn && r(Ot)),
                      n === E &&
                        (e.substr(an, 3) === Lt
                          ? ((n = Lt), (an += 3))
                          : ((n = E), 0 === pn && r(Gt)),
                        n === E &&
                          (176 === e.charCodeAt(an)
                            ? ((n = Dt), an++)
                            : ((n = E), 0 === pn && r(Rt)),
                          n === E &&
                            (e.substr(an, 10) === Nt
                              ? ((n = Nt), (an += 10))
                              : ((n = E), 0 === pn && r(zt))))))))),
              n !== E && ((cn = t), (n = Bt(n))),
              (t = n)
            );
          }
          function P() {
            var t, n, i, s;
            if (
              ((t = an),
              64 === e.charCodeAt(an)
                ? ((n = Vt), an++)
                : ((n = E), 0 === pn && r(qt)),
              n !== E)
            ) {
              if (
                ((i = []),
                Ut.test(e.charAt(an))
                  ? ((s = e.charAt(an)), an++)
                  : ((s = E), 0 === pn && r(_t)),
                s !== E)
              )
                for (; s !== E; )
                  i.push(s),
                    Ut.test(e.charAt(an))
                      ? ((s = e.charAt(an)), an++)
                      : ((s = E), 0 === pn && r(_t));
              else i = G;
              i !== E ? ((cn = t), (n = Qt(i)), (t = n)) : ((an = t), (t = G));
            } else (an = t), (t = G);
            return t;
          }
          function C() {
            var t, n;
            return (
              (t = an),
              120 === e.charCodeAt(an)
                ? ((n = Yt), an++)
                : ((n = E), 0 === pn && r(Ht)),
              n === E &&
                (121 === e.charCodeAt(an)
                  ? ((n = Wt), an++)
                  : ((n = E), 0 === pn && r(Xt)),
                n === E &&
                  (952 === e.charCodeAt(an)
                    ? ((n = Kt), an++)
                    : ((n = E), 0 === pn && r(Jt)),
                  n === E &&
                    (114 === e.charCodeAt(an)
                      ? ((n = Zt), an++)
                      : ((n = E), 0 === pn && r($t)),
                    n === E &&
                      (116 === e.charCodeAt(an)
                        ? ((n = en), an++)
                        : ((n = E), 0 === pn && r(tn)))))),
              n !== E && ((cn = t), (n = nn(n))),
              (t = n)
            );
          }
          function S() {
            var e, t;
            for (pn++, e = [], t = A(); t !== E; ) e.push(t), (t = A());
            return pn--, e === E && ((t = E), 0 === pn && r(rn)), e;
          }
          function A() {
            var t;
            return (
              sn.test(e.charAt(an))
                ? ((t = e.charAt(an)), an++)
                : ((t = E), 0 === pn && r(on)),
              t
            );
          }
          function T(e) {
            var t,
              n = e.kind;
            for (var i in e.children)
              e.children.hasOwnProperty(i) &&
                (n += ':' + i + ':' + e.children[i].index);
            return (t = mn[n])
              ? t
              : ((e.index = fn), (e.refCount = 0), (mn[n] = e), fn++, e);
          }
          function M(e) {
            var t;
            for (t in e.children) M(e.children[t]);
            return e.refCount++, e;
          }
          var I,
            F = arguments.length > 1 ? arguments[1] : {},
            E = {},
            j = { start: o },
            O = o,
            L = function() {
              return M(T({ kind: 'blank', type: 'blank', children: {} }));
            },
            G = E,
            D = null,
            R = '=',
            N = { type: 'literal', value: '=', description: '"="' },
            z = function(e, t) {
              var n = {
                kind: 'equation',
                type: 'equation',
                children: { expr: t },
              };
              return e && (n.children.declaration = e[1]), M(T(n));
            },
            B = /^[a-z]/,
            V = { type: 'class', value: '[a-z]', description: '[a-z]' },
            q = '(',
            U = { type: 'literal', value: '(', description: '"("' },
            _ = /^[xyr\u03B8]/,
            Q = {
              type: 'class',
              value: '[xyr\\u03B8]',
              description: '[xyr\\u03B8]',
            },
            Y = ')',
            H = { type: 'literal', value: ')', description: '")"' },
            W = function(e, t) {
              var n = e.join(''),
                i = {
                  kind: 'declaration:' + n,
                  type: 'declaration',
                  children: {},
                  name: n,
                  argument: t,
                };
              return T(i);
            },
            X = function(e) {
              var t = {
                kind: 'declaration:' + e,
                type: 'declaration',
                children: {},
                argument: e,
              };
              return T(t);
            },
            K = '+',
            J = { type: 'literal', value: '+', description: '"+"' },
            Z = '-',
            $ = { type: 'literal', value: '-', description: '"-"' },
            ee = function(e, t) {
              var n, i, r;
              for (n = e, i = 0; i < t.length; i++)
                (r = t[i][0]),
                  (n = T({
                    kind: 'binary-expr:' + r,
                    type: 'binary-expr',
                    children: { left: n, right: t[i][2] },
                    subtype: 'additive',
                    operator: r,
                  }));
              return n;
            },
            te = '/',
            ne = { type: 'literal', value: '/', description: '"/"' },
            ie = '*',
            re = { type: 'literal', value: '*', description: '"*"' },
            se = function(e, t) {
              var n, i, r;
              for (n = e, i = 0; i < t.length; i++)
                (r = t[i][0]),
                  (n = T({
                    kind: 'binary-expr:' + r,
                    type: 'binary-expr',
                    children: { left: n, right: t[i][2] },
                    subtype: 'multiplicative',
                    operator: r,
                  }));
              return n;
            },
            oe = '^',
            ae = { type: 'literal', value: '^', description: '"^"' },
            ce = function(e, t) {
              if (t) {
                var n,
                  i = t[2];
                return (
                  (n = {
                    kind: 'binary-expr:^',
                    type: 'binary-expr',
                    children: { left: e, right: i },
                    subtype: 'power',
                    operator: '^',
                  }),
                  T(n)
                );
              }
              return e;
            },
            le = function(e) {
              return e;
            },
            ue = function(e) {
              return T({
                kind: 'unary-expr:-',
                type: 'unary-expr',
                children: { child: e },
                operator: '-',
              });
            },
            de = function(e) {
              return T({
                kind: 'unary-expr:-',
                type: 'unary-expr',
                children: { child: e },
                operator: '-',
              });
            },
            he = function(e, t) {
              return T({
                kind: 'function:' + e,
                type: 'function',
                children: { arg: t },
                subtype: 'sys',
                name: e,
              });
            },
            pe = function(e, t) {
              return T({
                kind: 'function:custom',
                type: 'function',
                children: { name: e, arg: t },
                subtype: 'custom',
              });
            },
            fe = 'sin',
            me = { type: 'literal', value: 'sin', description: '"sin"' },
            ge = 'cos',
            be = { type: 'literal', value: 'cos', description: '"cos"' },
            ve = 'tan',
            ye = { type: 'literal', value: 'tan', description: '"tan"' },
            xe = 'Arcsin',
            we = { type: 'literal', value: 'Arcsin', description: '"Arcsin"' },
            ke = 'Arccos',
            Pe = { type: 'literal', value: 'Arccos', description: '"Arccos"' },
            Ce = 'Arctan',
            Se = { type: 'literal', value: 'Arctan', description: '"Arctan"' },
            Ae = 'abs',
            Te = { type: 'literal', value: 'abs', description: '"abs"' },
            Me = 'sqrt',
            Ie = { type: 'literal', value: 'sqrt', description: '"sqrt"' },
            Fe = 'ln',
            Ee = { type: 'literal', value: 'ln', description: '"ln"' },
            je = 'log',
            Oe = { type: 'literal', value: 'log', description: '"log"' },
            Le = 'sgn',
            Ge = { type: 'literal', value: 'sgn', description: '"sgn"' },
            De = 'round',
            Re = { type: 'literal', value: 'round', description: '"round"' },
            Ne = 'trunc',
            ze = { type: 'literal', value: 'trunc', description: '"trunc"' },
            Be = 'isDefined',
            Ve = {
              type: 'literal',
              value: 'isDefined',
              description: '"isDefined"',
            },
            qe = function(e, t) {
              return T({
                kind: 'primary',
                type: 'primary',
                children: { value: e, unit: t },
              });
            },
            Ue = function(e) {
              return T({
                kind: 'primary',
                type: 'primary',
                children: { value: e },
                unit: n,
              });
            },
            _e = '.',
            Qe = { type: 'literal', value: '.', description: '"."' },
            Ye = 'e',
            He = { type: 'literal', value: 'e', description: '"e"' },
            We = function(e) {
              var t = e.join('');
              return T({
                kind: 'constant:numeric:' + t,
                type: 'constant',
                children: {},
                subtype: 'numeric',
                value: t,
              });
            },
            Xe = 'pi',
            Ke = { type: 'literal', value: 'pi', description: '"pi"' },
            Je = 'π',
            Ze = { type: 'literal', value: 'π', description: '"\\u03C0"' },
            $e = function(e) {
              var t = { pi: 'pi', π: 'pi', e: 'e' },
                n = t[e] ? t[e] : e;
              return T({
                kind: 'constant:symbolic:' + n,
                type: 'constant',
                children: {},
                subtype: 'symbolic',
                value: n,
              });
            },
            et = /^[0-9]/,
            tt = { type: 'class', value: '[0-9]', description: '[0-9]' },
            nt = function(e) {
              return e.join('');
            },
            it = 'pixels',
            rt = { type: 'literal', value: 'pixels', description: '"pixels"' },
            st = 'pixel',
            ot = { type: 'literal', value: 'pixel', description: '"pixel"' },
            at = 'px',
            ct = { type: 'literal', value: 'px', description: '"px"' },
            lt = 'pix',
            ut = { type: 'literal', value: 'pix', description: '"pix"' },
            dt = 'cm',
            ht = { type: 'literal', value: 'cm', description: '"cm"' },
            pt = 'centimeter',
            ft = {
              type: 'literal',
              value: 'centimeter',
              description: '"centimeter"',
            },
            mt = 'inches',
            gt = { type: 'literal', value: 'inches', description: '"inches"' },
            bt = 'inch',
            vt = { type: 'literal', value: 'inch', description: '"inch"' },
            yt = 'in.',
            xt = { type: 'literal', value: 'in.', description: '"in."' },
            wt = 'in',
            kt = { type: 'literal', value: 'in', description: '"in"' },
            Pt = function(e) {
              return T({
                kind: 'unit:' + e,
                type: 'unit',
                children: {},
                subtype: 'distance',
                name: e,
              });
            },
            Ct = 'radians',
            St = {
              type: 'literal',
              value: 'radians',
              description: '"radians"',
            },
            At = 'radian',
            Tt = { type: 'literal', value: 'radian', description: '"radian"' },
            Mt = 'rad',
            It = { type: 'literal', value: 'rad', description: '"rad"' },
            Ft = 'rd',
            Et = { type: 'literal', value: 'rd', description: '"rd"' },
            jt = 'degrees',
            Ot = {
              type: 'literal',
              value: 'degrees',
              description: '"degrees"',
            },
            Lt = 'deg',
            Gt = { type: 'literal', value: 'deg', description: '"deg"' },
            Dt = '°',
            Rt = { type: 'literal', value: '°', description: '"\\xB0"' },
            Nt = 'signed deg',
            zt = {
              type: 'literal',
              value: 'signed deg',
              description: '"signed deg"',
            },
            Bt = function(e) {
              return T({
                kind: 'unit:' + e,
                type: 'unit',
                children: {},
                subtype: 'angle',
                name: e,
              });
            },
            Vt = '@',
            qt = { type: 'literal', value: '@', description: '"@"' },
            Ut = /^[0-9a-zA-Z_]/,
            _t = {
              type: 'class',
              value: '[0-9a-zA-Z_]',
              description: '[0-9a-zA-Z_]',
            },
            Qt = function(e) {
              var t = e.join('');
              return T({
                kind: 'reference:' + t,
                type: 'reference',
                children: {},
                name: t,
              });
            },
            Yt = 'x',
            Ht = { type: 'literal', value: 'x', description: '"x"' },
            Wt = 'y',
            Xt = { type: 'literal', value: 'y', description: '"y"' },
            Kt = 'θ',
            Jt = { type: 'literal', value: 'θ', description: '"\\u03B8"' },
            Zt = 'r',
            $t = { type: 'literal', value: 'r', description: '"r"' },
            en = 't',
            tn = { type: 'literal', value: 't', description: '"t"' },
            nn = function(e) {
              return T({
                kind: 'variable:' + e,
                type: 'variable',
                children: {},
                name: e,
              });
            },
            rn = { type: 'other', description: 'whitespace' },
            sn = /^[ \t\n\r]/,
            on = {
              type: 'class',
              value: '[ \\t\\n\\r]',
              description: '[ \\t\\n\\r]',
            },
            an = 0,
            cn = 0,
            ln = 0,
            un = { line: 1, column: 1, seenCR: !1 },
            dn = 0,
            hn = [],
            pn = 0;
          if ('startRule' in F) {
            if (!(F.startRule in j))
              throw new Error(
                'Can\'t start parsing from rule "' + F.startRule + '".'
              );
            O = j[F.startRule];
          }
          var fn = 0,
            mn = {};
          if (((I = O()), I !== E && an === e.length)) return I;
          throw (I !== E &&
            an < e.length &&
            r({ type: 'end', description: 'end of input' }),
          s(null, hn, dn));
        }
        return e(t, Error), { SyntaxError: t, parse: i };
      })()),
      (o.jskParser = (function() {
        function e(e, t) {
          function n() {
            this.constructor = e;
          }
          (n.prototype = t.prototype), (e.prototype = new n());
        }
        function t(e, t, n, i, r, s) {
          (this.message = e),
            (this.expected = t),
            (this.found = n),
            (this.offset = i),
            (this.line = r),
            (this.column = s),
            (this.name = 'SyntaxError');
        }
        function n(e) {
          function n(t) {
            function n(t, n, i) {
              var r, s;
              for (r = n; i > r; r++)
                (s = e.charAt(r)),
                  '\n' === s
                    ? (t.seenCR || t.line++, (t.column = 1), (t.seenCR = !1))
                    : '\r' === s || '\u2028' === s || '\u2029' === s
                    ? (t.line++, (t.column = 1), (t.seenCR = !0))
                    : (t.column++, (t.seenCR = !1));
            }
            return (
              Ts !== t &&
                (Ts > t &&
                  ((Ts = 0), (Ms = { line: 1, column: 1, seenCR: !1 })),
                n(Ms, Ts, t),
                (Ts = t)),
              Ms
            );
          }
          function i(e) {
            Is > Ss || (Ss > Is && ((Is = Ss), (Fs = [])), Fs.push(e));
          }
          function r(i, r, s) {
            function o(e) {
              var t = 1;
              for (
                e.sort(function(e, t) {
                  return e.description < t.description
                    ? -1
                    : e.description > t.description
                    ? 1
                    : 0;
                });
                t < e.length;

              )
                e[t - 1] === e[t] ? e.splice(t, 1) : t++;
            }
            function a(e, t) {
              function n(e) {
                function t(e) {
                  return e
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
                }
                return e
                  .replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\x08/g, '\\b')
                  .replace(/\t/g, '\\t')
                  .replace(/\n/g, '\\n')
                  .replace(/\f/g, '\\f')
                  .replace(/\r/g, '\\r')
                  .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(e) {
                    return '\\x0' + t(e);
                  })
                  .replace(/[\x10-\x1F\x80-\xFF]/g, function(e) {
                    return '\\x' + t(e);
                  })
                  .replace(/[\u0180-\u0FFF]/g, function(e) {
                    return '\\u0' + t(e);
                  })
                  .replace(/[\u1080-\uFFFF]/g, function(e) {
                    return '\\u' + t(e);
                  });
              }
              var i,
                r,
                s,
                o = new Array(e.length);
              for (s = 0; s < e.length; s++) o[s] = e[s].description;
              return (
                (i =
                  e.length > 1
                    ? o.slice(0, -1).join(', ') + ' or ' + o[e.length - 1]
                    : o[0]),
                (r = t ? '"' + n(t) + '"' : 'end of input'),
                'Expected ' + i + ' but ' + r + ' found.'
              );
            }
            var c = n(s),
              l = s < e.length ? e.charAt(s) : null;
            return (
              null !== r && o(r),
              new t(null !== i ? i : a(r, l), r, l, s, c.line, c.column)
            );
          }
          function s() {
            var e;
            return (e = o());
          }
          function o() {
            var e, t;
            for (e = [], t = a(); t !== ee; ) e.push(t), (t = a());
            return e;
          }
          function a() {
            var t, n, r, s, o, a, d, h, p;
            return (
              (t = Ss),
              (n = W()),
              n !== ee
                ? ((r = c()),
                  r !== ee
                    ? ((s = W()),
                      s !== ee
                        ? ((o = l()),
                          o !== ee
                            ? ((a = W()),
                              a !== ee
                                ? ((d = u()),
                                  d === ee && (d = re),
                                  d !== ee
                                    ? (59 === e.charCodeAt(Ss)
                                        ? ((h = se), Ss++)
                                        : ((h = ee), 0 === Es && i(oe)),
                                      h !== ee
                                        ? ((p = W()),
                                          p !== ee
                                            ? ((As = t),
                                              (n = ae(r, o, d)),
                                              (t = n))
                                            : ((Ss = t), (t = ie)))
                                        : ((Ss = t), (t = ie)))
                                    : ((Ss = t), (t = ie)))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function c() {
            var e, t;
            return (
              (e = Ss),
              (t = p()),
              t === ee &&
                ((t = f()),
                t === ee &&
                  ((t = m()),
                  t === ee &&
                    ((t = g()),
                    t === ee &&
                      ((t = b()),
                      t === ee &&
                        ((t = v()),
                        t === ee &&
                          ((t = y()),
                          t === ee &&
                            ((t = x()),
                            t === ee &&
                              ((t = w()),
                              t === ee &&
                                ((t = k()),
                                t === ee &&
                                  ((t = P()),
                                  t === ee &&
                                    ((t = C()),
                                    t === ee && (t = S())))))))))))),
              t !== ee && ((As = e), (t = ce(t))),
              (e = t)
            );
          }
          function l() {
            var e, t;
            if (((e = []), (t = d()), t !== ee))
              for (; t !== ee; ) e.push(t), (t = d());
            else e = ie;
            return e;
          }
          function u() {
            var t, n, r, s, o, a, c, l, u, d, h;
            if (((t = Ss), (n = W()), n !== ee))
              if (
                (91 === e.charCodeAt(Ss)
                  ? ((r = le), Ss++)
                  : ((r = ee), 0 === Es && i(ue)),
                r !== ee)
              )
                if (((s = W()), s !== ee))
                  if (((o = A()), o !== ee)) {
                    for (
                      a = [],
                        c = Ss,
                        l = W(),
                        l !== ee
                          ? (44 === e.charCodeAt(Ss)
                              ? ((u = de), Ss++)
                              : ((u = ee), 0 === Es && i(he)),
                            u !== ee
                              ? ((d = W()),
                                d !== ee
                                  ? ((h = A()),
                                    h !== ee
                                      ? ((l = [l, u, d, h]), (c = l))
                                      : ((Ss = c), (c = ie)))
                                  : ((Ss = c), (c = ie)))
                              : ((Ss = c), (c = ie)))
                          : ((Ss = c), (c = ie));
                      c !== ee;

                    )
                      a.push(c),
                        (c = Ss),
                        (l = W()),
                        l !== ee
                          ? (44 === e.charCodeAt(Ss)
                              ? ((u = de), Ss++)
                              : ((u = ee), 0 === Es && i(he)),
                            u !== ee
                              ? ((d = W()),
                                d !== ee
                                  ? ((h = A()),
                                    h !== ee
                                      ? ((l = [l, u, d, h]), (c = l))
                                      : ((Ss = c), (c = ie)))
                                  : ((Ss = c), (c = ie)))
                              : ((Ss = c), (c = ie)))
                          : ((Ss = c), (c = ie));
                    a !== ee
                      ? (93 === e.charCodeAt(Ss)
                          ? ((c = pe), Ss++)
                          : ((c = ee), 0 === Es && i(fe)),
                        c !== ee
                          ? ((As = t), (n = me(o, a)), (t = n))
                          : ((Ss = t), (t = ie)))
                      : ((Ss = t), (t = ie));
                  } else (Ss = t), (t = ie);
                else (Ss = t), (t = ie);
              else (Ss = t), (t = ie);
            else (Ss = t), (t = ie);
            return t;
          }
          function d() {
            var t, n, r, s, o, a, c, l, u;
            if (
              ((t = Ss),
              40 === e.charCodeAt(Ss)
                ? ((n = ge), Ss++)
                : ((n = ee), 0 === Es && i(be)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? (41 === e.charCodeAt(Ss)
                        ? ((s = ve), Ss++)
                        : ((s = ee), 0 === Es && i(ye)),
                      s !== ee
                        ? ((As = t), (n = xe()), (t = n))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t === ee)
            )
              if (
                ((t = Ss),
                40 === e.charCodeAt(Ss)
                  ? ((n = ge), Ss++)
                  : ((n = ee), 0 === Es && i(be)),
                n !== ee)
              )
                if (((r = h()), r !== ee)) {
                  for (
                    s = [],
                      o = Ss,
                      a = W(),
                      a !== ee
                        ? (44 === e.charCodeAt(Ss)
                            ? ((c = de), Ss++)
                            : ((c = ee), 0 === Es && i(he)),
                          c !== ee
                            ? ((l = W()),
                              l !== ee
                                ? ((u = h()),
                                  u !== ee
                                    ? ((a = [a, c, l, u]), (o = a))
                                    : ((Ss = o), (o = ie)))
                                : ((Ss = o), (o = ie)))
                            : ((Ss = o), (o = ie)))
                        : ((Ss = o), (o = ie));
                    o !== ee;

                  )
                    s.push(o),
                      (o = Ss),
                      (a = W()),
                      a !== ee
                        ? (44 === e.charCodeAt(Ss)
                            ? ((c = de), Ss++)
                            : ((c = ee), 0 === Es && i(he)),
                          c !== ee
                            ? ((l = W()),
                              l !== ee
                                ? ((u = h()),
                                  u !== ee
                                    ? ((a = [a, c, l, u]), (o = a))
                                    : ((Ss = o), (o = ie)))
                                : ((Ss = o), (o = ie)))
                            : ((Ss = o), (o = ie)))
                        : ((Ss = o), (o = ie));
                  s !== ee
                    ? (41 === e.charCodeAt(Ss)
                        ? ((o = ve), Ss++)
                        : ((o = ee), 0 === Es && i(ye)),
                      o !== ee
                        ? ((As = t), (n = we(r, s)), (t = n))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie));
                } else (Ss = t), (t = ie);
              else (Ss = t), (t = ie);
            return t;
          }
          function h() {
            var e;
            return (e = U()), e === ee && (e = Y()), e;
          }
          function p() {
            var t;
            return (
              e.substr(Ss, 15) === ke
                ? ((t = ke), (Ss += 15))
                : ((t = ee), 0 === Es && i(Pe)),
              t === ee &&
                (e.substr(Ss, 5) === Ce
                  ? ((t = Ce), (Ss += 5))
                  : ((t = ee), 0 === Es && i(Se)),
                t === ee &&
                  (e.substr(Ss, 10) === Ae
                    ? ((t = Ae), (Ss += 10))
                    : ((t = ee), 0 === Es && i(Te)),
                  t === ee &&
                    (e.substr(Ss, 8) === Me
                      ? ((t = Me), (Ss += 8))
                      : ((t = ee), 0 === Es && i(Ie)),
                    t === ee &&
                      (e.substr(Ss, 10) === Fe
                        ? ((t = Fe), (Ss += 10))
                        : ((t = ee), 0 === Es && i(Ee)),
                      t === ee &&
                        (e.substr(Ss, 10) === je
                          ? ((t = je), (Ss += 10))
                          : ((t = ee), 0 === Es && i(Oe)),
                        t === ee &&
                          (e.substr(Ss, 9) === Le
                            ? ((t = Le), (Ss += 9))
                            : ((t = ee), 0 === Es && i(Ge)),
                          t === ee &&
                            (e.substr(Ss, 6) === De
                              ? ((t = De), (Ss += 6))
                              : ((t = ee), 0 === Es && i(Re)),
                            t === ee &&
                              (e.substr(Ss, 11) === Ne
                                ? ((t = Ne), (Ss += 11))
                                : ((t = ee), 0 === Es && i(ze)),
                              t === ee &&
                                (e.substr(Ss, 9) === Be
                                  ? ((t = Be), (Ss += 9))
                                  : ((t = ee), 0 === Es && i(Ve)),
                                t === ee &&
                                  (e.substr(Ss, 15) === qe
                                    ? ((t = qe), (Ss += 15))
                                    : ((t = ee), 0 === Es && i(Ue)),
                                  t === ee &&
                                    (e.substr(Ss, 20) === _e
                                      ? ((t = _e), (Ss += 20))
                                      : ((t = ee), 0 === Es && i(Qe)),
                                    t === ee &&
                                      (e.substr(Ss, 11) === Ye
                                        ? ((t = Ye), (Ss += 11))
                                        : ((t = ee),
                                          0 === Es && i(He)))))))))))))),
              t
            );
          }
          function f() {
            var t;
            return (
              e.substr(Ss, 7) === We
                ? ((t = We), (Ss += 7))
                : ((t = ee), 0 === Es && i(Xe)),
              t === ee &&
                (e.substr(Ss, 3) === Ke
                  ? ((t = Ke), (Ss += 3))
                  : ((t = ee), 0 === Es && i(Je)),
                t === ee &&
                  (e.substr(Ss, 4) === Ze
                    ? ((t = Ze), (Ss += 4))
                    : ((t = ee), 0 === Es && i($e)),
                  t === ee &&
                    (e.substr(Ss, 13) === et
                      ? ((t = et), (Ss += 13))
                      : ((t = ee), 0 === Es && i(tt)),
                    t === ee &&
                      (e.substr(Ss, 8) === nt
                        ? ((t = nt), (Ss += 8))
                        : ((t = ee), 0 === Es && i(it)),
                      t === ee &&
                        (e.substr(Ss, 5) === rt
                          ? ((t = rt), (Ss += 5))
                          : ((t = ee), 0 === Es && i(st)),
                        t === ee &&
                          (e.substr(Ss, 5) === ot
                            ? ((t = ot), (Ss += 5))
                            : ((t = ee), 0 === Es && i(at)),
                          t === ee &&
                            (e.substr(Ss, 8) === ct
                              ? ((t = ct), (Ss += 8))
                              : ((t = ee), 0 === Es && i(lt)),
                            t === ee &&
                              (e.substr(Ss, 14) === ut
                                ? ((t = ut), (Ss += 14))
                                : ((t = ee), 0 === Es && i(dt)),
                              t === ee &&
                                (e.substr(Ss, 12) === ht
                                  ? ((t = ht), (Ss += 12))
                                  : ((t = ee), 0 === Es && i(pt))))))))))),
              t
            );
          }
          function m() {
            var t;
            return (
              e.substr(Ss, 7) === ft
                ? ((t = ft), (Ss += 7))
                : ((t = ee), 0 === Es && i(mt)),
              t === ee &&
                (e.substr(Ss, 15) === gt
                  ? ((t = gt), (Ss += 15))
                  : ((t = ee), 0 === Es && i(bt))),
              t
            );
          }
          function g() {
            var t;
            return (
              e.substr(Ss, 16) === vt
                ? ((t = vt), (Ss += 16))
                : ((t = ee), 0 === Es && i(yt)),
              t === ee &&
                (e.substr(Ss, 6) === xt
                  ? ((t = xt), (Ss += 6))
                  : ((t = ee), 0 === Es && i(wt))),
              t
            );
          }
          function b() {
            var t;
            return (
              e.substr(Ss, 10) === kt
                ? ((t = kt), (Ss += 10))
                : ((t = ee), 0 === Es && i(Pt)),
              t === ee &&
                (e.substr(Ss, 21) === Ct
                  ? ((t = Ct), (Ss += 21))
                  : ((t = ee), 0 === Es && i(St)),
                t === ee &&
                  (e.substr(Ss, 17) === At
                    ? ((t = At), (Ss += 17))
                    : ((t = ee), 0 === Es && i(Tt)),
                  t === ee &&
                    (e.substr(Ss, 20) === Mt
                      ? ((t = Mt), (Ss += 20))
                      : ((t = ee), 0 === Es && i(It)),
                    t === ee &&
                      (e.substr(Ss, 8) === Ft
                        ? ((t = Ft), (Ss += 8))
                        : ((t = ee), 0 === Es && i(Et)),
                      t === ee &&
                        (e.substr(Ss, 20) === jt
                          ? ((t = jt), (Ss += 20))
                          : ((t = ee), 0 === Es && i(Ot)),
                        t === ee &&
                          (e.substr(Ss, 22) === Lt
                            ? ((t = Lt), (Ss += 22))
                            : ((t = ee), 0 === Es && i(Gt)),
                          t === ee &&
                            (e.substr(Ss, 8) === Dt
                              ? ((t = Dt), (Ss += 8))
                              : ((t = ee), 0 === Es && i(Rt)),
                            t === ee &&
                              (e.substr(Ss, 17) === Nt
                                ? ((t = Nt), (Ss += 17))
                                : ((t = ee), 0 === Es && i(zt)),
                              t === ee &&
                                (e.substr(Ss, 37) === Bt
                                  ? ((t = Bt), (Ss += 37))
                                  : ((t = ee), 0 === Es && i(Vt)),
                                t === ee &&
                                  (e.substr(Ss, 16) === qt
                                    ? ((t = qt), (Ss += 16))
                                    : ((t = ee), 0 === Es && i(Ut)),
                                  t === ee &&
                                    (e.substr(Ss, 37) === _t
                                      ? ((t = _t), (Ss += 37))
                                      : ((t = ee), 0 === Es && i(Qt)),
                                    t === ee &&
                                      (e.substr(Ss, 38) === Yt
                                        ? ((t = Yt), (Ss += 38))
                                        : ((t = ee), 0 === Es && i(Ht)),
                                      t === ee &&
                                        (e.substr(Ss, 11) === Wt
                                          ? ((t = Wt), (Ss += 11))
                                          : ((t = ee),
                                            0 === Es && i(Xt))))))))))))))),
              t
            );
          }
          function v() {
            var t;
            return (
              e.substr(Ss, 18) === Kt
                ? ((t = Kt), (Ss += 18))
                : ((t = ee), 0 === Es && i(Jt)),
              t === ee &&
                (e.substr(Ss, 19) === Zt
                  ? ((t = Zt), (Ss += 19))
                  : ((t = ee), 0 === Es && i($t)),
                t === ee &&
                  (e.substr(Ss, 13) === en
                    ? ((t = en), (Ss += 13))
                    : ((t = ee), 0 === Es && i(tn)),
                  t === ee &&
                    (e.substr(Ss, 13) === nn
                      ? ((t = nn), (Ss += 13))
                      : ((t = ee), 0 === Es && i(rn))))),
              t
            );
          }
          function y() {
            var t;
            return (
              e.substr(Ss, 5) === sn
                ? ((t = sn), (Ss += 5))
                : ((t = ee), 0 === Es && i(on)),
              t === ee &&
                (e.substr(Ss, 12) === an
                  ? ((t = an), (Ss += 12))
                  : ((t = ee), 0 === Es && i(cn)),
                t === ee &&
                  (e.substr(Ss, 18) === ln
                    ? ((t = ln), (Ss += 18))
                    : ((t = ee), 0 === Es && i(un)))),
              t
            );
          }
          function x() {
            var t;
            return (
              e.substr(Ss, 6) === dn
                ? ((t = dn), (Ss += 6))
                : ((t = ee), 0 === Es && i(hn)),
              t === ee &&
                (e.substr(Ss, 5) === pn
                  ? ((t = pn), (Ss += 5))
                  : ((t = ee), 0 === Es && i(fn)),
                t === ee &&
                  (e.substr(Ss, 9) === mn
                    ? ((t = mn), (Ss += 9))
                    : ((t = ee), 0 === Es && i(gn)),
                  t === ee &&
                    (e.substr(Ss, 13) === bn
                      ? ((t = bn), (Ss += 13))
                      : ((t = ee), 0 === Es && i(vn)),
                    t === ee &&
                      (e.substr(Ss, 6) === yn
                        ? ((t = yn), (Ss += 6))
                        : ((t = ee), 0 === Es && i(xn)),
                      t === ee &&
                        (e.substr(Ss, 4) === wn
                          ? ((t = wn), (Ss += 4))
                          : ((t = ee), 0 === Es && i(kn)),
                        t === ee &&
                          (e.substr(Ss, 5) === Pn
                            ? ((t = Pn), (Ss += 5))
                            : ((t = ee), 0 === Es && i(Cn)),
                          t === ee &&
                            (e.substr(Ss, 8) === Sn
                              ? ((t = Sn), (Ss += 8))
                              : ((t = ee), 0 === Es && i(An)),
                            t === ee &&
                              (e.substr(Ss, 14) === Tn
                                ? ((t = Tn), (Ss += 14))
                                : ((t = ee), 0 === Es && i(Mn)),
                              t === ee &&
                                (e.substr(Ss, 12) === In
                                  ? ((t = In), (Ss += 12))
                                  : ((t = ee), 0 === Es && i(Fn)),
                                t === ee &&
                                  (e.substr(Ss, 11) === En
                                    ? ((t = En), (Ss += 11))
                                    : ((t = ee), 0 === Es && i(jn)),
                                  t === ee &&
                                    (e.substr(Ss, 8) === On
                                      ? ((t = On), (Ss += 8))
                                      : ((t = ee), 0 === Es && i(Ln)),
                                    t === ee &&
                                      (e.substr(Ss, 8) === Gn
                                        ? ((t = Gn), (Ss += 8))
                                        : ((t = ee), 0 === Es && i(Dn)),
                                      t === ee &&
                                        (e.substr(Ss, 18) === Rn
                                          ? ((t = Rn), (Ss += 18))
                                          : ((t = ee), 0 === Es && i(Nn)),
                                        t === ee &&
                                          (e.substr(Ss, 9) === zn
                                            ? ((t = zn), (Ss += 9))
                                            : ((t = ee), 0 === Es && i(Bn)),
                                          t === ee &&
                                            (e.substr(Ss, 9) === Vn
                                              ? ((t = Vn), (Ss += 9))
                                              : ((t = ee),
                                                0 === Es &&
                                                  i(qn))))))))))))))))),
              t
            );
          }
          function w() {
            var t;
            return (
              e.substr(Ss, 22) === Un
                ? ((t = Un), (Ss += 22))
                : ((t = ee), 0 === Es && i(_n)),
              t === ee &&
                (e.substr(Ss, 10) === Qn
                  ? ((t = Qn), (Ss += 10))
                  : ((t = ee), 0 === Es && i(Yn)),
                t === ee &&
                  (e.substr(Ss, 10) === Hn
                    ? ((t = Hn), (Ss += 10))
                    : ((t = ee), 0 === Es && i(Wn)),
                  t === ee &&
                    (e.substr(Ss, 10) === Xn
                      ? ((t = Xn), (Ss += 10))
                      : ((t = ee), 0 === Es && i(Kn)),
                    t === ee &&
                      (e.substr(Ss, 13) === Jn
                        ? ((t = Jn), (Ss += 13))
                        : ((t = ee), 0 === Es && i(Zn)),
                      t === ee &&
                        (e.substr(Ss, 18) === $n
                          ? ((t = $n), (Ss += 18))
                          : ((t = ee), 0 === Es && i(ei))))))),
              t
            );
          }
          function k() {
            var t;
            return (
              e.substr(Ss, 14) === ti
                ? ((t = ti), (Ss += 14))
                : ((t = ee), 0 === Es && i(ni)),
              t === ee &&
                (e.substr(Ss, 11) === ii
                  ? ((t = ii), (Ss += 11))
                  : ((t = ee), 0 === Es && i(ri)),
                t === ee &&
                  (e.substr(Ss, 10) === si
                    ? ((t = si), (Ss += 10))
                    : ((t = ee), 0 === Es && i(oi)))),
              t
            );
          }
          function P() {
            var t;
            return (
              e.substr(Ss, 5) === ai
                ? ((t = ai), (Ss += 5))
                : ((t = ee), 0 === Es && i(ci)),
              t === ee &&
                (e.substr(Ss, 12) === li
                  ? ((t = li), (Ss += 12))
                  : ((t = ee), 0 === Es && i(ui))),
              t
            );
          }
          function C() {
            var t;
            return (
              e.substr(Ss, 8) === di
                ? ((t = di), (Ss += 8))
                : ((t = ee), 0 === Es && i(hi)),
              t
            );
          }
          function S() {
            var t;
            return (
              e.substr(Ss, 9) === pi
                ? ((t = pi), (Ss += 9))
                : ((t = ee), 0 === Es && i(fi)),
              t === ee &&
                (e.substr(Ss, 10) === mi
                  ? ((t = mi), (Ss += 10))
                  : ((t = ee), 0 === Es && i(gi)),
                t === ee &&
                  (e.substr(Ss, 10) === bi
                    ? ((t = bi), (Ss += 10))
                    : ((t = ee), 0 === Es && i(vi)))),
              t
            );
          }
          function A() {
            var e;
            return (
              (e = T()),
              e === ee &&
                ((e = M()),
                e === ee &&
                  ((e = I()),
                  e === ee &&
                    ((e = F()),
                    e === ee &&
                      ((e = E()),
                      e === ee &&
                        ((e = j()),
                        e === ee &&
                          ((e = O()),
                          e === ee &&
                            ((e = L()),
                            e === ee &&
                              ((e = G()),
                              e === ee &&
                                ((e = D()),
                                e === ee &&
                                  ((e = R()),
                                  e === ee &&
                                    ((e = N()),
                                    e === ee &&
                                      ((e = V()),
                                      e === ee && (e = q()))))))))))))),
              e
            );
          }
          function T() {
            var t;
            return (
              e.substr(Ss, 3) === yi
                ? ((t = yi), (Ss += 3))
                : ((t = ee), 0 === Es && i(xi)),
              t === ee &&
                (e.substr(Ss, 5) === wi
                  ? ((t = wi), (Ss += 5))
                  : ((t = ee), 0 === Es && i(ki)),
                t === ee &&
                  (e.substr(Ss, 4) === Pi
                    ? ((t = Pi), (Ss += 4))
                    : ((t = ee), 0 === Es && i(Ci)),
                  t === ee &&
                    (e.substr(Ss, 5) === Si
                      ? ((t = Si), (Ss += 5))
                      : ((t = ee), 0 === Es && i(Ai)),
                    t === ee &&
                      (e.substr(Ss, 7) === Ti
                        ? ((t = Ti), (Ss += 7))
                        : ((t = ee), 0 === Es && i(Mi)),
                      t === ee &&
                        (e.substr(Ss, 5) === Ii
                          ? ((t = Ii), (Ss += 5))
                          : ((t = ee), 0 === Es && i(Fi)),
                        t === ee &&
                          (e.substr(Ss, 4) === Ei
                            ? ((t = Ei), (Ss += 4))
                            : ((t = ee), 0 === Es && i(ji)),
                          t === ee &&
                            (e.substr(Ss, 6) === Oi
                              ? ((t = Oi), (Ss += 6))
                              : ((t = ee), 0 === Es && i(Li))))))))),
              t
            );
          }
          function M() {
            var t, n, r, s, o, a, c, l, u, d, h, p, f, m;
            return (
              (t = Ss),
              e.substr(Ss, 6) === Gi
                ? ((n = Gi), (Ss += 6))
                : ((n = ee), 0 === Es && i(Di)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = U()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (44 === e.charCodeAt(Ss)
                                ? ((a = de), Ss++)
                                : ((a = ee), 0 === Es && i(he)),
                              a !== ee
                                ? ((c = W()),
                                  c !== ee
                                    ? ((l = U()),
                                      l !== ee
                                        ? ((u = W()),
                                          u !== ee
                                            ? (44 === e.charCodeAt(Ss)
                                                ? ((d = de), Ss++)
                                                : ((d = ee), 0 === Es && i(he)),
                                              d !== ee
                                                ? ((h = W()),
                                                  h !== ee
                                                    ? ((p = U()),
                                                      p !== ee
                                                        ? ((f = W()),
                                                          f !== ee
                                                            ? (41 ===
                                                              e.charCodeAt(Ss)
                                                                ? ((m = ve),
                                                                  Ss++)
                                                                : ((m = ee),
                                                                  0 === Es &&
                                                                    i(ye)),
                                                              m !== ee
                                                                ? ((As = t),
                                                                  (n = Ri(
                                                                    s,
                                                                    l,
                                                                    p
                                                                  )),
                                                                  (t = n))
                                                                : ((Ss = t),
                                                                  (t = ie)))
                                                            : ((Ss = t),
                                                              (t = ie)))
                                                        : ((Ss = t), (t = ie)))
                                                    : ((Ss = t), (t = ie)))
                                                : ((Ss = t), (t = ie)))
                                            : ((Ss = t), (t = ie)))
                                        : ((Ss = t), (t = ie)))
                                    : ((Ss = t), (t = ie)))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function I() {
            var t;
            return (
              e.substr(Ss, 8) === Ni
                ? ((t = Ni), (Ss += 8))
                : ((t = ee), 0 === Es && i(zi)),
              t === ee &&
                (e.substr(Ss, 4) === Bi
                  ? ((t = Bi), (Ss += 4))
                  : ((t = ee), 0 === Es && i(Vi)),
                t === ee &&
                  (e.substr(Ss, 10) === qi
                    ? ((t = qi), (Ss += 10))
                    : ((t = ee), 0 === Es && i(Ui)),
                  t === ee &&
                    (e.substr(Ss, 5) === _i
                      ? ((t = _i), (Ss += 5))
                      : ((t = ee), 0 === Es && i(Qi)),
                    t === ee &&
                      (e.substr(Ss, 6) === Yi
                        ? ((t = Yi), (Ss += 6))
                        : ((t = ee), 0 === Es && i(Hi)),
                      t === ee &&
                        (e.substr(Ss, 6) === Wi
                          ? ((t = Wi), (Ss += 6))
                          : ((t = ee), 0 === Es && i(Xi)),
                        t === ee &&
                          (e.substr(Ss, 5) === Ki
                            ? ((t = Ki), (Ss += 5))
                            : ((t = ee), 0 === Es && i(Ji)))))))),
              t
            );
          }
          function F() {
            var t;
            return (
              e.substr(Ss, 3) === Zi
                ? ((t = Zi), (Ss += 3))
                : ((t = ee), 0 === Es && i($i)),
              t === ee &&
                (e.substr(Ss, 5) === er
                  ? ((t = er), (Ss += 5))
                  : ((t = ee), 0 === Es && i(tr)),
                t === ee &&
                  (e.substr(Ss, 11) === nr
                    ? ((t = nr), (Ss += 11))
                    : ((t = ee), 0 === Es && i(ir)),
                  t === ee &&
                    (e.substr(Ss, 5) === rr
                      ? ((t = rr), (Ss += 5))
                      : ((t = ee), 0 === Es && i(sr))))),
              t
            );
          }
          function E() {
            var t;
            return (
              e.substr(Ss, 6) === or
                ? ((t = or), (Ss += 6))
                : ((t = ee), 0 === Es && i(ar)),
              t
            );
          }
          function j() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 7) === cr
                ? ((n = cr), (Ss += 7))
                : ((n = ee), 0 === Es && i(lr)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = Y()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = ur(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function O() {
            var t;
            return (
              e.substr(Ss, 4) === dr
                ? ((t = dr), (Ss += 4))
                : ((t = ee), 0 === Es && i(hr)),
              t
            );
          }
          function L() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 6) === pr
                ? ((n = pr), (Ss += 6))
                : ((n = ee), 0 === Es && i(fr)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = Y()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = mr(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function G() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 6) === gr
                ? ((n = gr), (Ss += 6))
                : ((n = ee), 0 === Es && i(br)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = J()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = vr(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function D() {
            var t;
            return (
              e.substr(Ss, 6) === yr
                ? ((t = yr), (Ss += 6))
                : ((t = ee), 0 === Es && i(xr)),
              t
            );
          }
          function R() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 6) === wr
                ? ((n = wr), (Ss += 6))
                : ((n = ee), 0 === Es && i(kr)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = Y()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = Pr(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function N() {
            var t;
            return (
              e.substr(Ss, 4) === Cr
                ? ((t = Cr), (Ss += 4))
                : ((t = ee), 0 === Es && i(Sr)),
              t === ee &&
                (e.substr(Ss, 6) === Ar
                  ? ((t = Ar), (Ss += 6))
                  : ((t = ee), 0 === Es && i(Tr)),
                t === ee &&
                  (e.substr(Ss, 5) === Mr
                    ? ((t = Mr), (Ss += 5))
                    : ((t = ee), 0 === Es && i(Ir)),
                  t === ee &&
                    ((t = B()),
                    t === ee &&
                      ((t = z()),
                      t === ee &&
                        (e.substr(Ss, 11) === Fr
                          ? ((t = Fr), (Ss += 11))
                          : ((t = ee), 0 === Es && i(Er)),
                        t === ee &&
                          (e.substr(Ss, 12) === jr
                            ? ((t = jr), (Ss += 12))
                            : ((t = ee), 0 === Es && i(Or)),
                          t === ee &&
                            (e.substr(Ss, 13) === Lr
                              ? ((t = Lr), (Ss += 13))
                              : ((t = ee), 0 === Es && i(Gr))))))))),
              t
            );
          }
          function z() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 5) === Dr
                ? ((n = Dr), (Ss += 5))
                : ((n = ee), 0 === Es && i(Rr)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = Y()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = Nr(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function B() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 5) === zr
                ? ((n = zr), (Ss += 5))
                : ((n = ee), 0 === Es && i(Br)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = U()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = Vr(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function V() {
            var t, n, r, s, o, a;
            return (
              (t = Ss),
              e.substr(Ss, 7) === qr
                ? ((n = qr), (Ss += 7))
                : ((n = ee), 0 === Es && i(Ur)),
              n !== ee
                ? ((r = W()),
                  r !== ee
                    ? ((s = U()),
                      s !== ee
                        ? ((o = W()),
                          o !== ee
                            ? (41 === e.charCodeAt(Ss)
                                ? ((a = ve), Ss++)
                                : ((a = ee), 0 === Es && i(ye)),
                              a !== ee
                                ? ((As = t), (n = _r(s)), (t = n))
                                : ((Ss = t), (t = ie)))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function q() {
            var t;
            return (
              e.substr(Ss, 6) === Qr
                ? ((t = Qr), (Ss += 6))
                : ((t = ee), 0 === Es && i(Yr)),
              t
            );
          }
          function U() {
            var e;
            return (e = _()), e === ee && (e = Q()), e;
          }
          function _() {
            var t, n, r, s, o, a, c, l;
            return (
              (t = Ss),
              45 === e.charCodeAt(Ss)
                ? ((n = Hr), Ss++)
                : ((n = ee), 0 === Es && i(Wr)),
              n === ee && (n = re),
              n !== ee
                ? ((r = J()),
                  r !== ee
                    ? ((s = Ss),
                      46 === e.charCodeAt(Ss)
                        ? ((o = Xr), Ss++)
                        : ((o = ee), 0 === Es && i(Kr)),
                      o !== ee
                        ? ((a = J()),
                          a === ee && (a = re),
                          a !== ee
                            ? ((o = [o, a]), (s = o))
                            : ((Ss = s), (s = ie)))
                        : ((Ss = s), (s = ie)),
                      s === ee && (s = re),
                      s !== ee
                        ? ((o = Ss),
                          101 === e.charCodeAt(Ss)
                            ? ((a = Jr), Ss++)
                            : ((a = ee), 0 === Es && i(Zr)),
                          a !== ee
                            ? (45 === e.charCodeAt(Ss)
                                ? ((c = Hr), Ss++)
                                : ((c = ee), 0 === Es && i(Wr)),
                              c === ee && (c = re),
                              c !== ee
                                ? ((l = J()),
                                  l !== ee
                                    ? ((a = [a, c, l]), (o = a))
                                    : ((Ss = o), (o = ie)))
                                : ((Ss = o), (o = ie)))
                            : ((Ss = o), (o = ie)),
                          o === ee && (o = re),
                          o !== ee
                            ? ((As = t), (n = $r(n, r, s, o)), (t = n))
                            : ((Ss = t), (t = ie)))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function Q() {
            var t, n, r, s, o, a, c;
            return (
              (t = Ss),
              45 === e.charCodeAt(Ss)
                ? ((n = Hr), Ss++)
                : ((n = ee), 0 === Es && i(Wr)),
              n === ee && (n = re),
              n !== ee
                ? ((r = Ss),
                  46 === e.charCodeAt(Ss)
                    ? ((s = Xr), Ss++)
                    : ((s = ee), 0 === Es && i(Kr)),
                  s !== ee
                    ? ((o = J()),
                      o !== ee ? ((s = [s, o]), (r = s)) : ((Ss = r), (r = ie)))
                    : ((Ss = r), (r = ie)),
                  r !== ee
                    ? ((s = Ss),
                      101 === e.charCodeAt(Ss)
                        ? ((o = Jr), Ss++)
                        : ((o = ee), 0 === Es && i(Zr)),
                      o !== ee
                        ? (45 === e.charCodeAt(Ss)
                            ? ((a = Hr), Ss++)
                            : ((a = ee), 0 === Es && i(Wr)),
                          a === ee && (a = re),
                          a !== ee
                            ? ((c = J()),
                              c !== ee
                                ? ((o = [o, a, c]), (s = o))
                                : ((Ss = s), (s = ie)))
                            : ((Ss = s), (s = ie)))
                        : ((Ss = s), (s = ie)),
                      s === ee && (s = re),
                      s !== ee
                        ? ((As = t), (n = es(n, r, s)), (t = n))
                        : ((Ss = t), (t = ie)))
                    : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie)),
              t
            );
          }
          function Y() {
            var t, n, r, s, o;
            if (
              ((t = Ss),
              (n = Ss),
              39 === e.charCodeAt(Ss)
                ? ((r = ts), Ss++)
                : ((r = ee), 0 === Es && i(ns)),
              r !== ee)
            ) {
              for (s = [], o = H(); o !== ee; ) s.push(o), (o = H());
              s !== ee
                ? (39 === e.charCodeAt(Ss)
                    ? ((o = ts), Ss++)
                    : ((o = ee), 0 === Es && i(ns)),
                  o !== ee ? ((r = [r, s, o]), (n = r)) : ((Ss = n), (n = ie)))
                : ((Ss = n), (n = ie));
            } else (Ss = n), (n = ie);
            return n !== ee && ((As = t), (n = is(n))), (t = n);
          }
          function H() {
            var t, n;
            return (
              rs.test(e.charAt(Ss))
                ? ((t = e.charAt(Ss)), Ss++)
                : ((t = ee), 0 === Es && i(ss)),
              t === ee &&
                ((t = Ss),
                e.substr(Ss, 2) === os
                  ? ((n = os), (Ss += 2))
                  : ((n = ee), 0 === Es && i(as)),
                n !== ee && ((As = t), (n = cs())),
                (t = n)),
              t
            );
          }
          function W() {
            var e, t, n;
            for (e = Ss, t = [], n = X(), n === ee && (n = K()); n !== ee; )
              t.push(n), (n = X()), n === ee && (n = K());
            return t !== ee && ((As = e), (t = ls())), (e = t);
          }
          function X() {
            var t, n, r, s;
            if (
              ((t = Ss),
              123 === e.charCodeAt(Ss)
                ? ((n = us), Ss++)
                : ((n = ee), 0 === Es && i(ds)),
              n !== ee)
            ) {
              for (
                r = [],
                  hs.test(e.charAt(Ss))
                    ? ((s = e.charAt(Ss)), Ss++)
                    : ((s = ee), 0 === Es && i(ps));
                s !== ee;

              )
                r.push(s),
                  hs.test(e.charAt(Ss))
                    ? ((s = e.charAt(Ss)), Ss++)
                    : ((s = ee), 0 === Es && i(ps));
              r !== ee
                ? (125 === e.charCodeAt(Ss)
                    ? ((s = fs), Ss++)
                    : ((s = ee), 0 === Es && i(ms)),
                  s !== ee ? ((n = [n, r, s]), (t = n)) : ((Ss = t), (t = ie)))
                : ((Ss = t), (t = ie));
            } else (Ss = t), (t = ie);
            return t;
          }
          function K() {
            var t;
            return (
              32 === e.charCodeAt(Ss)
                ? ((t = gs), Ss++)
                : ((t = ee), 0 === Es && i(bs)),
              t === ee &&
                (9 === e.charCodeAt(Ss)
                  ? ((t = vs), Ss++)
                  : ((t = ee), 0 === Es && i(ys)),
                t === ee &&
                  (10 === e.charCodeAt(Ss)
                    ? ((t = xs), Ss++)
                    : ((t = ee), 0 === Es && i(ws)))),
              t
            );
          }
          function J() {
            var t, n, r;
            if (
              ((t = Ss),
              (n = []),
              ks.test(e.charAt(Ss))
                ? ((r = e.charAt(Ss)), Ss++)
                : ((r = ee), 0 === Es && i(Ps)),
              r !== ee)
            )
              for (; r !== ee; )
                n.push(r),
                  ks.test(e.charAt(Ss))
                    ? ((r = e.charAt(Ss)), Ss++)
                    : ((r = ee), 0 === Es && i(Ps));
            else n = ie;
            return n !== ee && ((As = t), (n = Cs(n))), (t = n);
          }
          var Z,
            $ = arguments.length > 1 ? arguments[1] : {},
            ee = {},
            te = { start: s },
            ne = s,
            ie = ee,
            re = null,
            se = ';',
            oe = { type: 'literal', value: ';', description: '";"' },
            ae = function(e, t, n) {
              var i = ++js;
              return { id: i, type: e, argGroups: t, opts: n ? n : [] };
            },
            ce = function(e) {
              return e;
            },
            le = '[',
            ue = { type: 'literal', value: '[', description: '"["' },
            de = ',',
            he = { type: 'literal', value: ',', description: '","' },
            pe = ']',
            fe = { type: 'literal', value: ']', description: '"]"' },
            me = function(e, t) {
              var n,
                i = [];
              for (i.push(e), n = 0; n < t.length; n += 1) i.push(t[n][3]);
              return i;
            },
            ge = '(',
            be = { type: 'literal', value: '(', description: '"("' },
            ve = ')',
            ye = { type: 'literal', value: ')', description: '")"' },
            xe = function() {
              return [];
            },
            we = function(e, t) {
              var n,
                i = [];
              for (i.push(e), n = 0; n < t.length; n += 1) i.push(t[n][3]);
              return i;
            },
            ke = 'Point on object',
            Pe = {
              type: 'literal',
              value: 'Point on object',
              description: '"Point on object"',
            },
            Ce = 'Point',
            Se = { type: 'literal', value: 'Point', description: '"Point"' },
            Ae = 'FixedPoint',
            Te = {
              type: 'literal',
              value: 'FixedPoint',
              description: '"FixedPoint"',
            },
            Me = 'Midpoint',
            Ie = {
              type: 'literal',
              value: 'Midpoint',
              description: '"Midpoint"',
            },
            Fe = 'Intersect1',
            Ee = {
              type: 'literal',
              value: 'Intersect1',
              description: '"Intersect1"',
            },
            je = 'Intersect2',
            Oe = {
              type: 'literal',
              value: 'Intersect2',
              description: '"Intersect2"',
            },
            Le = 'Intersect',
            Ge = {
              type: 'literal',
              value: 'Intersect',
              description: '"Intersect"',
            },
            De = 'PlotXY',
            Re = { type: 'literal', value: 'PlotXY', description: '"PlotXY"' },
            Ne = 'PlotFixedXY',
            ze = {
              type: 'literal',
              value: 'PlotFixedXY',
              description: '"PlotFixedXY"',
            },
            Be = 'UnitPoint',
            Ve = {
              type: 'literal',
              value: 'UnitPoint',
              description: '"UnitPoint"',
            },
            qe = 'SquareUnitPoint',
            Ue = {
              type: 'literal',
              value: 'SquareUnitPoint',
              description: '"SquareUnitPoint"',
            },
            _e = 'RectangularUnitPoint',
            Qe = {
              type: 'literal',
              value: 'RectangularUnitPoint',
              description: '"RectangularUnitPoint"',
            },
            Ye = 'DriverPoint',
            He = {
              type: 'literal',
              value: 'DriverPoint',
              description: '"DriverPoint"',
            },
            We = 'Segment',
            Xe = {
              type: 'literal',
              value: 'Segment',
              description: '"Segment"',
            },
            Ke = 'Ray',
            Je = { type: 'literal', value: 'Ray', description: '"Ray"' },
            Ze = 'Line',
            $e = { type: 'literal', value: 'Line', description: '"Line"' },
            et = 'Perpendicular',
            tt = {
              type: 'literal',
              value: 'Perpendicular',
              description: '"Perpendicular"',
            },
            nt = 'Parallel',
            it = {
              type: 'literal',
              value: 'Parallel',
              description: '"Parallel"',
            },
            rt = 'AxisX',
            st = { type: 'literal', value: 'AxisX', description: '"AxisX"' },
            ot = 'AxisY',
            at = { type: 'literal', value: 'AxisY', description: '"AxisY"' },
            ct = 'Bisector',
            lt = {
              type: 'literal',
              value: 'Bisector',
              description: '"Bisector"',
            },
            ut = 'HorizontalAxis',
            dt = {
              type: 'literal',
              value: 'HorizontalAxis',
              description: '"HorizontalAxis"',
            },
            ht = 'VerticalAxis',
            pt = {
              type: 'literal',
              value: 'VerticalAxis',
              description: '"VerticalAxis"',
            },
            ft = 'Polygon',
            mt = {
              type: 'literal',
              value: 'Polygon',
              description: '"Polygon"',
            },
            gt = 'Circle interior',
            bt = {
              type: 'literal',
              value: 'Circle interior',
              description: '"Circle interior"',
            },
            vt = 'Circle by radius',
            yt = {
              type: 'literal',
              value: 'Circle by radius',
              description: '"Circle by radius"',
            },
            xt = 'Circle',
            wt = { type: 'literal', value: 'Circle', description: '"Circle"' },
            kt = 'Reflection',
            Pt = {
              type: 'literal',
              value: 'Reflection',
              description: '"Reflection"',
            },
            Ct = 'Dilation/SegmentRatio',
            St = {
              type: 'literal',
              value: 'Dilation/SegmentRatio',
              description: '"Dilation/SegmentRatio"',
            },
            At = 'Dilation/3PtRatio',
            Tt = {
              type: 'literal',
              value: 'Dilation/3PtRatio',
              description: '"Dilation/3PtRatio"',
            },
            Mt = 'Dilation/MarkedRatio',
            It = {
              type: 'literal',
              value: 'Dilation/MarkedRatio',
              description: '"Dilation/MarkedRatio"',
            },
            Ft = 'Dilation',
            Et = {
              type: 'literal',
              value: 'Dilation',
              description: '"Dilation"',
            },
            jt = 'Rotation/MarkedAngle',
            Ot = {
              type: 'literal',
              value: 'Rotation/MarkedAngle',
              description: '"Rotation/MarkedAngle"',
            },
            Lt = 'Rotation/MeasuredAngle',
            Gt = {
              type: 'literal',
              value: 'Rotation/MeasuredAngle',
              description: '"Rotation/MeasuredAngle"',
            },
            Dt = 'Rotation',
            Rt = {
              type: 'literal',
              value: 'Rotation',
              description: '"Rotation"',
            },
            Nt = 'VectorTranslation',
            zt = {
              type: 'literal',
              value: 'VectorTranslation',
              description: '"VectorTranslation"',
            },
            Bt = 'Translation/FixedAngle/MarkedDistance',
            Vt = {
              type: 'literal',
              value: 'Translation/FixedAngle/MarkedDistance',
              description: '"Translation/FixedAngle/MarkedDistance"',
            },
            qt = 'PolarTranslation',
            Ut = {
              type: 'literal',
              value: 'PolarTranslation',
              description: '"PolarTranslation"',
            },
            _t = 'Translation/MarkedAngle/FixedDistance',
            Qt = {
              type: 'literal',
              value: 'Translation/MarkedAngle/FixedDistance',
              description: '"Translation/MarkedAngle/FixedDistance"',
            },
            Yt = 'Translation/MarkedAngle/MarkedDistance',
            Ht = {
              type: 'literal',
              value: 'Translation/MarkedAngle/MarkedDistance',
              description: '"Translation/MarkedAngle/MarkedDistance"',
            },
            Wt = 'Translation',
            Xt = {
              type: 'literal',
              value: 'Translation',
              description: '"Translation"',
            },
            Kt = 'Colorized_Spectrum',
            Jt = {
              type: 'literal',
              value: 'Colorized_Spectrum',
              description: '"Colorized_Spectrum"',
            },
            Zt = 'Colorized_Grayscale',
            $t = {
              type: 'literal',
              value: 'Colorized_Grayscale',
              description: '"Colorized_Grayscale"',
            },
            en = 'Colorized_RGB',
            tn = {
              type: 'literal',
              value: 'Colorized_RGB',
              description: '"Colorized_RGB"',
            },
            nn = 'Colorized_HSV',
            rn = {
              type: 'literal',
              value: 'Colorized_HSV',
              description: '"Colorized_HSV"',
            },
            sn = 'Image',
            on = { type: 'literal', value: 'Image', description: '"Image"' },
            an = 'ImageOnPoint',
            cn = {
              type: 'literal',
              value: 'ImageOnPoint',
              description: '"ImageOnPoint"',
            },
            ln = 'ImageBetweenPoints',
            un = {
              type: 'literal',
              value: 'ImageBetweenPoints',
              description: '"ImageBetweenPoints"',
            },
            dn = 'Length',
            hn = { type: 'literal', value: 'Length', description: '"Length"' },
            pn = 'Angle',
            fn = { type: 'literal', value: 'Angle', description: '"Angle"' },
            mn = 'Perimeter',
            gn = {
              type: 'literal',
              value: 'Perimeter',
              description: '"Perimeter"',
            },
            bn = 'Circumference',
            vn = {
              type: 'literal',
              value: 'Circumference',
              description: '"Circumference"',
            },
            yn = 'Radius',
            xn = { type: 'literal', value: 'Radius', description: '"Radius"' },
            wn = 'Area',
            kn = { type: 'literal', value: 'Area', description: '"Area"' },
            Pn = 'Slope',
            Cn = { type: 'literal', value: 'Slope', description: '"Slope"' },
            Sn = 'Distance',
            An = {
              type: 'literal',
              value: 'Distance',
              description: '"Distance"',
            },
            Tn = 'Ratio/Segments',
            Mn = {
              type: 'literal',
              value: 'Ratio/Segments',
              description: '"Ratio/Segments"',
            },
            In = 'Ratio/Points',
            Fn = {
              type: 'literal',
              value: 'Ratio/Points',
              description: '"Ratio/Points"',
            },
            En = 'Coordinates',
            jn = {
              type: 'literal',
              value: 'Coordinates',
              description: '"Coordinates"',
            },
            On = 'Abscissa',
            Ln = {
              type: 'literal',
              value: 'Abscissa',
              description: '"Abscissa"',
            },
            Gn = 'Ordinate',
            Dn = {
              type: 'literal',
              value: 'Ordinate',
              description: '"Ordinate"',
            },
            Rn = 'CoordinateDistance',
            Nn = {
              type: 'literal',
              value: 'CoordinateDistance',
              description: '"CoordinateDistance"',
            },
            zn = 'Calculate',
            Bn = {
              type: 'literal',
              value: 'Calculate',
              description: '"Calculate"',
            },
            Vn = 'Parameter',
            qn = {
              type: 'literal',
              value: 'Parameter',
              description: '"Parameter"',
            },
            Un = 'ToggleVisibilityButton',
            _n = {
              type: 'literal',
              value: 'ToggleVisibilityButton',
              description: '"ToggleVisibilityButton"',
            },
            Qn = 'ShowButton',
            Yn = {
              type: 'literal',
              value: 'ShowButton',
              description: '"ShowButton"',
            },
            Hn = 'HideButton',
            Wn = {
              type: 'literal',
              value: 'HideButton',
              description: '"HideButton"',
            },
            Xn = 'MoveButton',
            Kn = {
              type: 'literal',
              value: 'MoveButton',
              description: '"MoveButton"',
            },
            Jn = 'AnimateButton',
            Zn = {
              type: 'literal',
              value: 'AnimateButton',
              description: '"AnimateButton"',
            },
            $n = 'SimultaneousButton',
            ei = {
              type: 'literal',
              value: 'SimultaneousButton',
              description: '"SimultaneousButton"',
            },
            ti = 'CoordSysByAxes',
            ni = {
              type: 'literal',
              value: 'CoordSysByAxes',
              description: '"CoordSysByAxes"',
            },
            ii = 'Origin&Unit',
            ri = {
              type: 'literal',
              value: 'Origin&Unit',
              description: '"Origin&Unit"',
            },
            si = 'UnitCircle',
            oi = {
              type: 'literal',
              value: 'UnitCircle',
              description: '"UnitCircle"',
            },
            ai = 'Locus',
            ci = { type: 'literal', value: 'Locus', description: '"Locus"' },
            li = 'FunctionPlot',
            ui = {
              type: 'literal',
              value: 'FunctionPlot',
              description: '"FunctionPlot"',
            },
            di = 'Function',
            hi = {
              type: 'literal',
              value: 'Function',
              description: '"Function"',
            },
            pi = 'FixedText',
            fi = {
              type: 'literal',
              value: 'FixedText',
              description: '"FixedText"',
            },
            mi = 'PeggedText',
            gi = {
              type: 'literal',
              value: 'PeggedText',
              description: '"PeggedText"',
            },
            bi = 'ConcatText',
            vi = {
              type: 'literal',
              value: 'ConcatText',
              description: '"ConcatText"',
            },
            yi = 'red',
            xi = { type: 'literal', value: 'red', description: '"red"' },
            wi = 'green',
            ki = { type: 'literal', value: 'green', description: '"green"' },
            Pi = 'blue',
            Ci = { type: 'literal', value: 'blue', description: '"blue"' },
            Si = 'black',
            Ai = { type: 'literal', value: 'black', description: '"black"' },
            Ti = 'magenta',
            Mi = {
              type: 'literal',
              value: 'magenta',
              description: '"magenta"',
            },
            Ii = 'white',
            Fi = { type: 'literal', value: 'white', description: '"white"' },
            Ei = 'cyan',
            ji = { type: 'literal', value: 'cyan', description: '"cyan"' },
            Oi = 'yellow',
            Li = { type: 'literal', value: 'yellow', description: '"yellow"' },
            Gi = 'color(',
            Di = { type: 'literal', value: 'color(', description: '"color("' },
            Ri = function(e, t, n) {
              return 'color(' + [e, t, n].join() + ')';
            },
            Ni = 'hairline',
            zi = {
              type: 'literal',
              value: 'hairline',
              description: '"hairline"',
            },
            Bi = 'thin',
            Vi = { type: 'literal', value: 'thin', description: '"thin"' },
            qi = 'mediumLine',
            Ui = {
              type: 'literal',
              value: 'mediumLine',
              description: '"mediumLine"',
            },
            _i = 'thick',
            Qi = { type: 'literal', value: 'thick', description: '"thick"' },
            Yi = 'dashed',
            Hi = { type: 'literal', value: 'dashed', description: '"dashed"' },
            Wi = 'dotted',
            Xi = { type: 'literal', value: 'dotted', description: '"dotted"' },
            Ki = 'solid',
            Ji = { type: 'literal', value: 'solid', description: '"solid"' },
            Zi = 'dot',
            $i = { type: 'literal', value: 'dot', description: '"dot"' },
            er = 'small',
            tr = { type: 'literal', value: 'small', description: '"small"' },
            nr = 'mediumPoint',
            ir = {
              type: 'literal',
              value: 'mediumPoint',
              description: '"mediumPoint"',
            },
            rr = 'large',
            sr = { type: 'literal', value: 'large', description: '"large"' },
            or = 'hidden',
            ar = { type: 'literal', value: 'hidden', description: '"hidden"' },
            cr = 'suffix(',
            lr = {
              type: 'literal',
              value: 'suffix(',
              description: '"suffix("',
            },
            ur = function(e) {
              return "suffix('" + e + "')";
            },
            dr = 'auto',
            hr = { type: 'literal', value: 'auto', description: '"auto"' },
            pr = 'label(',
            fr = { type: 'literal', value: 'label(', description: '"label("' },
            mr = function(e) {
              return "label('" + e + "')";
            },
            gr = 'layer(',
            br = { type: 'literal', value: 'layer(', description: '"layer("' },
            vr = function(e) {
              return 'layer(' + e + ')';
            },
            yr = 'traced',
            xr = { type: 'literal', value: 'traced', description: '"traced"' },
            wr = 'image(',
            kr = { type: 'literal', value: 'image(', description: '"image("' },
            Pr = function(e) {
              return "image('" + e + "')";
            },
            Cr = 'bold',
            Sr = { type: 'literal', value: 'bold', description: '"bold"' },
            Ar = 'italic',
            Tr = { type: 'literal', value: 'italic', description: '"italic"' },
            Mr = 'plain',
            Ir = { type: 'literal', value: 'plain', description: '"plain"' },
            Fr = 'justifyLeft',
            Er = {
              type: 'literal',
              value: 'justifyLeft',
              description: '"justifyLeft"',
            },
            jr = 'justifyRight',
            Or = {
              type: 'literal',
              value: 'justifyRight',
              description: '"justifyRight"',
            },
            Lr = 'justifyCenter',
            Gr = {
              type: 'literal',
              value: 'justifyCenter',
              description: '"justifyCenter"',
            },
            Dr = 'font(',
            Rr = { type: 'literal', value: 'font(', description: '"font("' },
            Nr = function(e) {
              return "font('" + e + "')";
            },
            zr = 'size(',
            Br = { type: 'literal', value: 'size(', description: '"size("' },
            Vr = function(e) {
              return 'size(' + e + ')';
            },
            qr = 'digits(',
            Ur = {
              type: 'literal',
              value: 'digits(',
              description: '"digits("',
            },
            _r = function(e) {
              return "digits('" + e + "')";
            },
            Qr = 'medium',
            Yr = { type: 'literal', value: 'medium', description: '"medium"' },
            Hr = '-',
            Wr = { type: 'literal', value: '-', description: '"-"' },
            Xr = '.',
            Kr = { type: 'literal', value: '.', description: '"."' },
            Jr = 'e',
            Zr = { type: 'literal', value: 'e', description: '"e"' },
            $r = function(e, t, n, i) {
              var r = '',
                s = '';
              return (
                i && (r = i.join('')),
                n && (s = '.' + (n[1] ? n[1] : '')),
                (e = e ? e : ''),
                e + t + s + r
              );
            },
            es = function(e, t, n) {
              var i = '',
                r = '';
              return (
                n && (i = n.join('')),
                (r = '.' + t[1]),
                (e = e ? e : ''),
                e + r + i
              );
            },
            ts = "'",
            ns = { type: 'literal', value: "'", description: '"\'"' },
            is = function(e) {
              return e[1].join('');
            },
            rs = /^[^']/,
            ss = { type: 'class', value: "[^']", description: "[^']" },
            os = "''",
            as = { type: 'literal', value: "''", description: '"\'\'"' },
            cs = function() {
              return '&apos;';
            },
            ls = function() {
              return '';
            },
            us = '{',
            ds = { type: 'literal', value: '{', description: '"{"' },
            hs = /^[^}]/,
            ps = { type: 'class', value: '[^}]', description: '[^}]' },
            fs = '}',
            ms = { type: 'literal', value: '}', description: '"}"' },
            gs = ' ',
            bs = { type: 'literal', value: ' ', description: '" "' },
            vs = '	',
            ys = { type: 'literal', value: '	', description: '"\\t"' },
            xs = '\n',
            ws = { type: 'literal', value: '\n', description: '"\\n"' },
            ks = /^[0-9]/,
            Ps = { type: 'class', value: '[0-9]', description: '[0-9]' },
            Cs = function(e) {
              return e.join('');
            },
            Ss = 0,
            As = 0,
            Ts = 0,
            Ms = { line: 1, column: 1, seenCR: !1 },
            Is = 0,
            Fs = [],
            Es = 0;
          if ('startRule' in $) {
            if (!($.startRule in te))
              throw new Error(
                'Can\'t start parsing from rule "' + $.startRule + '".'
              );
            ne = te[$.startRule];
          }
          var js = 0;
          if (((Z = ne()), Z !== ee && Ss === e.length)) return Z;
          throw (Z !== ee &&
            Ss < e.length &&
            i({ type: 'end', description: 'end of input' }),
          r(null, Fs, Is));
        }
        return e(t, Error), { SyntaxError: t, parse: n };
      })()),
      (o.mfsParser = (function() {
        function e(e, t) {
          function n() {
            this.constructor = e;
          }
          (n.prototype = t.prototype), (e.prototype = new n());
        }
        function t(e, t, n, i, r, s) {
          (this.message = e),
            (this.expected = t),
            (this.found = n),
            (this.offset = i),
            (this.line = r),
            (this.column = s),
            (this.name = 'SyntaxError');
        }
        function n(e) {
          function n(t) {
            function n(t, n, i) {
              var r, s;
              for (r = n; i > r; r++)
                (s = e.charAt(r)),
                  '\n' === s
                    ? (t.seenCR || t.line++, (t.column = 1), (t.seenCR = !1))
                    : '\r' === s || '\u2028' === s || '\u2029' === s
                    ? (t.line++, (t.column = 1), (t.seenCR = !0))
                    : (t.column++, (t.seenCR = !1));
            }
            return (
              Rt !== t &&
                (Rt > t &&
                  ((Rt = 0), (Nt = { line: 1, column: 1, seenCR: !1 })),
                n(Nt, Rt, t),
                (Rt = t)),
              Nt
            );
          }
          function i(e) {
            zt > Gt || (Gt > zt && ((zt = Gt), (Bt = [])), Bt.push(e));
          }
          function r(i, r, s) {
            function o(e) {
              var t = 1;
              for (
                e.sort(function(e, t) {
                  return e.description < t.description
                    ? -1
                    : e.description > t.description
                    ? 1
                    : 0;
                });
                t < e.length;

              )
                e[t - 1] === e[t] ? e.splice(t, 1) : t++;
            }
            function a(e, t) {
              function n(e) {
                function t(e) {
                  return e
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
                }
                return e
                  .replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\x08/g, '\\b')
                  .replace(/\t/g, '\\t')
                  .replace(/\n/g, '\\n')
                  .replace(/\f/g, '\\f')
                  .replace(/\r/g, '\\r')
                  .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(e) {
                    return '\\x0' + t(e);
                  })
                  .replace(/[\x10-\x1F\x80-\xFF]/g, function(e) {
                    return '\\x' + t(e);
                  })
                  .replace(/[\u0180-\u0FFF]/g, function(e) {
                    return '\\u0' + t(e);
                  })
                  .replace(/[\u1080-\uFFFF]/g, function(e) {
                    return '\\u' + t(e);
                  });
              }
              var i,
                r,
                s,
                o = new Array(e.length);
              for (s = 0; s < e.length; s++) o[s] = e[s].description;
              return (
                (i =
                  e.length > 1
                    ? o.slice(0, -1).join(', ') + ' or ' + o[e.length - 1]
                    : o[0]),
                (r = t ? '"' + n(t) + '"' : 'end of input'),
                'Expected ' + i + ' but ' + r + ' found.'
              );
            }
            var c = n(s),
              l = s < e.length ? e.charAt(s) : null;
            return (
              null !== r && o(r),
              new t(null !== i ? i : a(r, l), r, l, s, c.line, c.column)
            );
          }
          function s() {
            var e, t;
            return (
              (e = Gt), (t = o()), t !== O && ((Dt = e), (t = D(t))), (e = t)
            );
          }
          function o() {
            var e;
            return (
              (e = k()),
              e === O &&
                ((e = d()),
                e === O &&
                  ((e = g()),
                  e === O &&
                    ((e = v()),
                    e === O &&
                      ((e = y()),
                      e === O &&
                        ((e = f()),
                        e === O &&
                          ((e = h()),
                          e === O &&
                            ((e = a()),
                            e === O &&
                              ((e = M()),
                              e === O &&
                                ((e = c()),
                                e === O &&
                                  ((e = l()),
                                  e === O &&
                                    ((e = u()),
                                    e === O &&
                                      ((e = I()),
                                      e === O &&
                                        ((e = p()),
                                        e === O &&
                                          ((e = m()),
                                          e === O &&
                                            ((e = x()),
                                            e === O &&
                                              ((e = w()),
                                              e === O &&
                                                ((e = T()),
                                                e === O &&
                                                  (e = F())))))))))))))))))),
              e
            );
          }
          function a() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === N
                ? ((n = N), (Gt += 2))
                : ((n = O), 0 === Vt && i(z)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = q(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function c() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === U
                ? ((n = U), (Gt += 2))
                : ((n = O), 0 === Vt && i(_)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = Q(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function l() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === Y
                ? ((n = Y), (Gt += 2))
                : ((n = O), 0 === Vt && i(H)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = W(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function u() {
            var t, n, r, s, a;
            return (
              (t = Gt),
              e.substr(Gt, 2) === X
                ? ((n = X), (Gt += 2))
                : ((n = O), 0 === Vt && i(K)),
              n !== O
                ? ((r = o()),
                  r !== O
                    ? ((s = o()),
                      s !== O
                        ? (62 === e.charCodeAt(Gt)
                            ? ((a = B), Gt++)
                            : ((a = O), 0 === Vt && i(V)),
                          a !== O
                            ? ((Dt = t), (n = J(r, s)), (t = n))
                            : ((Gt = t), (t = R)))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R)),
              t
            );
          }
          function d() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === Z
                ? ((n = Z), (Gt += 2))
                : ((n = O), 0 === Vt && i($)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = ee(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function h() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === te
                ? ((n = te), (Gt += 2))
                : ((n = O), 0 === Vt && i(ne)),
              n !== O)
            ) {
              for (
                r = [],
                  ie.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(re));
                s !== O;

              )
                r.push(s),
                  ie.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(re));
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = se(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function p() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === oe
                ? ((n = oe), (Gt += 2))
                : ((n = O), 0 === Vt && i(ae)),
              n !== O)
            ) {
              for (
                r = [],
                  ie.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(re));
                s !== O;

              )
                r.push(s),
                  ie.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(re));
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = ce(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function f() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === le
                ? ((n = le), (Gt += 2))
                : ((n = O), 0 === Vt && i(ue)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = de(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function m() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === he
                ? ((n = he), (Gt += 2))
                : ((n = O), 0 === Vt && i(pe)),
              n !== O)
            ) {
              for (r = [], s = o(); s !== O; ) r.push(s), (s = o());
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = fe(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function g() {
            var t, n, r, s, a;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === me
                ? ((n = me), (Gt += 2))
                : ((n = O), 0 === Vt && i(ge)),
              n !== O)
            ) {
              for (r = [], s = b(); s !== O; ) r.push(s), (s = b());
              r !== O
                ? ((s = o()),
                  s !== O
                    ? (62 === e.charCodeAt(Gt)
                        ? ((a = B), Gt++)
                        : ((a = O), 0 === Vt && i(V)),
                      a !== O
                        ? ((Dt = t), (n = be(r, s)), (t = n))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function b() {
            var t, n, r, s;
            if (
              ((t = Gt),
              ve.test(e.charAt(Gt))
                ? ((n = e.charAt(Gt)), Gt++)
                : ((n = O), 0 === Vt && i(ye)),
              n !== O)
            ) {
              for (
                r = [],
                  xe.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(we));
                s !== O;

              )
                r.push(s),
                  xe.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(we));
              r !== O
                ? ((Dt = t), (n = ke(n, r)), (t = n))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function v() {
            var t, n, r, s, a;
            return (
              (t = Gt),
              e.substr(Gt, 2) === Pe
                ? ((n = Pe), (Gt += 2))
                : ((n = O), 0 === Vt && i(Ce)),
              n !== O
                ? ((r = o()),
                  r !== O
                    ? ((s = o()),
                      s !== O
                        ? (62 === e.charCodeAt(Gt)
                            ? ((a = B), Gt++)
                            : ((a = O), 0 === Vt && i(V)),
                          a !== O
                            ? ((Dt = t), (n = Se(r, s)), (t = n))
                            : ((Gt = t), (t = R)))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R)),
              t
            );
          }
          function y() {
            var t, n, r, s, a;
            return (
              (t = Gt),
              e.substr(Gt, 2) === Ae
                ? ((n = Ae), (Gt += 2))
                : ((n = O), 0 === Vt && i(Te)),
              n !== O
                ? ((r = o()),
                  r !== O
                    ? ((s = o()),
                      s !== O
                        ? (62 === e.charCodeAt(Gt)
                            ? ((a = B), Gt++)
                            : ((a = O), 0 === Vt && i(V)),
                          a !== O
                            ? ((Dt = t), (n = Me(r, s)), (t = n))
                            : ((Gt = t), (t = R)))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R)),
              t
            );
          }
          function x() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === Ie
                ? ((n = Ie), (Gt += 2))
                : ((n = O), 0 === Vt && i(Fe)),
              n !== O)
            ) {
              if (
                ((r = []),
                Ee.test(e.charAt(Gt))
                  ? ((s = e.charAt(Gt)), Gt++)
                  : ((s = O), 0 === Vt && i(je)),
                s !== O)
              )
                for (; s !== O; )
                  r.push(s),
                    Ee.test(e.charAt(Gt))
                      ? ((s = e.charAt(Gt)), Gt++)
                      : ((s = O), 0 === Vt && i(je));
              else r = R;
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = Oe(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function w() {
            var t, n, r, s, a, c, l;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === Le
                ? ((n = Le), (Gt += 2))
                : ((n = O), 0 === Vt && i(Ge)),
              n !== O)
            ) {
              for (
                r = [],
                  Ee.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(je));
                s !== O;

              )
                r.push(s),
                  Ee.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(je));
              if (r !== O)
                if (
                  (120 === e.charCodeAt(Gt)
                    ? ((s = De), Gt++)
                    : ((s = O), 0 === Vt && i(Re)),
                  s !== O)
                ) {
                  for (
                    a = [],
                      Ee.test(e.charAt(Gt))
                        ? ((c = e.charAt(Gt)), Gt++)
                        : ((c = O), 0 === Vt && i(je));
                    c !== O;

                  )
                    a.push(c),
                      Ee.test(e.charAt(Gt))
                        ? ((c = e.charAt(Gt)), Gt++)
                        : ((c = O), 0 === Vt && i(je));
                  if (a !== O) {
                    for (c = [], l = o(); l !== O; ) c.push(l), (l = o());
                    c !== O
                      ? (62 === e.charCodeAt(Gt)
                          ? ((l = B), Gt++)
                          : ((l = O), 0 === Vt && i(V)),
                        l !== O
                          ? ((Dt = t), (n = Ne(r, a, c)), (t = n))
                          : ((Gt = t), (t = R)))
                      : ((Gt = t), (t = R));
                  } else (Gt = t), (t = R);
                } else (Gt = t), (t = R);
              else (Gt = t), (t = R);
            } else (Gt = t), (t = R);
            if (t === O)
              if (
                ((t = Gt),
                e.substr(Gt, 2) === Le
                  ? ((n = Le), (Gt += 2))
                  : ((n = O), 0 === Vt && i(Ge)),
                n !== O)
              ) {
                for (
                  r = [],
                    Ee.test(e.charAt(Gt))
                      ? ((s = e.charAt(Gt)), Gt++)
                      : ((s = O), 0 === Vt && i(je));
                  s !== O;

                )
                  r.push(s),
                    Ee.test(e.charAt(Gt))
                      ? ((s = e.charAt(Gt)), Gt++)
                      : ((s = O), 0 === Vt && i(je));
                if (r !== O) {
                  for (s = [], a = o(); a !== O; ) s.push(a), (a = o());
                  s !== O
                    ? (62 === e.charCodeAt(Gt)
                        ? ((a = B), Gt++)
                        : ((a = O), 0 === Vt && i(V)),
                      a !== O
                        ? ((Dt = t), (n = ze(r, s)), (t = n))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R));
                } else (Gt = t), (t = R);
              } else (Gt = t), (t = R);
            return t;
          }
          function k() {
            var t, n, r, s;
            return (
              (t = Gt),
              e.substr(Gt, 5) === Be
                ? ((n = Be), (Gt += 5))
                : ((n = O), 0 === Vt && i(Ve)),
              n !== O && ((Dt = t), (n = qe())),
              (t = n),
              t === O &&
                ((t = Gt),
                e.substr(Gt, 5) === Ue
                  ? ((n = Ue), (Gt += 5))
                  : ((n = O), 0 === Vt && i(_e)),
                n !== O && ((Dt = t), (n = qe())),
                (t = n),
                t === O &&
                  ((t = Gt),
                  e.substr(Gt, 3) === Qe
                    ? ((n = Qe), (Gt += 3))
                    : ((n = O), 0 === Vt && i(Ye)),
                  n !== O
                    ? ((r = P()),
                      r !== O
                        ? (e.substr(Gt, 2) === He
                            ? ((s = He), (Gt += 2))
                            : ((s = O), 0 === Vt && i(We)),
                          s !== O
                            ? ((Dt = t), (n = Xe(r)), (t = n))
                            : ((Gt = t), (t = R)))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)),
                  t === O &&
                    ((t = Gt),
                    e.substr(Gt, 3) === Ke
                      ? ((n = Ke), (Gt += 3))
                      : ((n = O), 0 === Vt && i(Je)),
                    n !== O
                      ? ((r = S()),
                        r !== O
                          ? (e.substr(Gt, 2) === Ze
                              ? ((s = Ze), (Gt += 2))
                              : ((s = O), 0 === Vt && i($e)),
                            s !== O
                              ? ((Dt = t), (n = Xe(r)), (t = n))
                              : ((Gt = t), (t = R)))
                          : ((Gt = t), (t = R)))
                      : ((Gt = t), (t = R))))),
              t
            );
          }
          function P() {
            var e, t, n;
            if (((e = Gt), (t = []), (n = C()), n !== O))
              for (; n !== O; ) t.push(n), (n = C());
            else t = R;
            return t !== O && ((Dt = e), (t = et(t))), (e = t);
          }
          function C() {
            var t, n;
            return (
              tt.test(e.charAt(Gt))
                ? ((t = e.charAt(Gt)), Gt++)
                : ((t = O), 0 === Vt && i(nt)),
              t === O &&
                ((t = Gt),
                e.substr(Gt, 2) === it
                  ? ((n = it), (Gt += 2))
                  : ((n = O), 0 === Vt && i(rt)),
                n !== O && ((Dt = t), (n = st())),
                (t = n),
                t === O &&
                  ((t = Gt),
                  e.substr(Gt, 2) === ot
                    ? ((n = ot), (Gt += 2))
                    : ((n = O), 0 === Vt && i(at)),
                  n !== O && ((Dt = t), (n = ct())),
                  (t = n),
                  t === O &&
                    ((t = Gt),
                    e.substr(Gt, 2) === lt
                      ? ((n = lt), (Gt += 2))
                      : ((n = O), 0 === Vt && i(ut)),
                    n !== O && ((Dt = t), (n = dt())),
                    (t = n)))),
              t
            );
          }
          function S() {
            var e, t, n;
            if (((e = Gt), (t = []), (n = A()), n !== O))
              for (; n !== O; ) t.push(n), (n = A());
            else t = R;
            return t !== O && ((Dt = e), (t = et(t))), (e = t);
          }
          function A() {
            var t, n;
            return (
              ht.test(e.charAt(Gt))
                ? ((t = e.charAt(Gt)), Gt++)
                : ((t = O), 0 === Vt && i(pt)),
              t === O &&
                ((t = Gt),
                e.substr(Gt, 2) === it
                  ? ((n = it), (Gt += 2))
                  : ((n = O), 0 === Vt && i(rt)),
                n !== O && ((Dt = t), (n = st())),
                (t = n),
                t === O &&
                  ((t = Gt),
                  e.substr(Gt, 2) === lt
                    ? ((n = lt), (Gt += 2))
                    : ((n = O), 0 === Vt && i(ut)),
                  n !== O && ((Dt = t), (n = dt())),
                  (t = n),
                  t === O &&
                    ((t = Gt),
                    e.substr(Gt, 2) === ot
                      ? ((n = ot), (Gt += 2))
                      : ((n = O), 0 === Vt && i(at)),
                    n !== O && ((Dt = t), (n = ct())),
                    (t = n)))),
              t
            );
          }
          function T() {
            var t, n, r, s, a;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === ft
                ? ((n = ft), (Gt += 2))
                : ((n = O), 0 === Vt && i(mt)),
              n !== O)
            )
              if (
                (76 === e.charCodeAt(Gt)
                  ? ((r = bt), Gt++)
                  : ((r = O), 0 === Vt && i(vt)),
                r === O &&
                  (82 === e.charCodeAt(Gt)
                    ? ((r = yt), Gt++)
                    : ((r = O), 0 === Vt && i(xt)),
                  r === O &&
                    (67 === e.charCodeAt(Gt)
                      ? ((r = wt), Gt++)
                      : ((r = O), 0 === Vt && i(kt)))),
                r === O && (r = gt),
                r !== O)
              ) {
                for (s = [], a = o(); a !== O; ) s.push(a), (a = o());
                s !== O
                  ? (62 === e.charCodeAt(Gt)
                      ? ((a = B), Gt++)
                      : ((a = O), 0 === Vt && i(V)),
                    a !== O
                      ? ((Dt = t), (n = Pt(r, s)), (t = n))
                      : ((Gt = t), (t = R)))
                  : ((Gt = t), (t = R));
              } else (Gt = t), (t = R);
            else (Gt = t), (t = R);
            return t;
          }
          function M() {
            var t, n;
            return (
              (t = Gt),
              e.substr(Gt, 3) === Ct
                ? ((n = Ct), (Gt += 3))
                : ((n = O), 0 === Vt && i(St)),
              n !== O && ((Dt = t), (n = At())),
              (t = n)
            );
          }
          function I() {
            var t, n, r, s;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === Tt
                ? ((n = Tt), (Gt += 2))
                : ((n = O), 0 === Vt && i(Mt)),
              n !== O)
            ) {
              for (
                r = [],
                  It.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(Ft));
                s !== O;

              )
                r.push(s),
                  It.test(e.charAt(Gt))
                    ? ((s = e.charAt(Gt)), Gt++)
                    : ((s = O), 0 === Vt && i(Ft));
              r !== O
                ? (62 === e.charCodeAt(Gt)
                    ? ((s = B), Gt++)
                    : ((s = O), 0 === Vt && i(V)),
                  s !== O
                    ? ((Dt = t), (n = Et(r)), (t = n))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          function F() {
            var t, n, r, s, a;
            if (
              ((t = Gt),
              e.substr(Gt, 2) === jt
                ? ((n = jt), (Gt += 2))
                : ((n = O), 0 === Vt && i(Ot)),
              n !== O)
            ) {
              if (
                ((r = []),
                Ee.test(e.charAt(Gt))
                  ? ((s = e.charAt(Gt)), Gt++)
                  : ((s = O), 0 === Vt && i(je)),
                s !== O)
              )
                for (; s !== O; )
                  r.push(s),
                    Ee.test(e.charAt(Gt))
                      ? ((s = e.charAt(Gt)), Gt++)
                      : ((s = O), 0 === Vt && i(je));
              else r = R;
              r !== O
                ? ((s = o()),
                  s !== O
                    ? (62 === e.charCodeAt(Gt)
                        ? ((a = B), Gt++)
                        : ((a = O), 0 === Vt && i(V)),
                      a !== O
                        ? ((Dt = t), (n = Lt(r, s)), (t = n))
                        : ((Gt = t), (t = R)))
                    : ((Gt = t), (t = R)))
                : ((Gt = t), (t = R));
            } else (Gt = t), (t = R);
            return t;
          }
          var E,
            j = arguments.length > 1 ? arguments[1] : {},
            O = {},
            L = { start: s },
            G = s,
            D = function(e) {
              return e;
            },
            R = O,
            N = '<|',
            z = { type: 'literal', value: '<|', description: '"<|"' },
            B = '>',
            V = { type: 'literal', value: '>', description: '">"' },
            q = function(e) {
              return { type: 'abs', value: e };
            },
            U = '<[',
            _ = { type: 'literal', value: '<[', description: '"<["' },
            Q = function(e) {
              return { type: 'bracket', value: e };
            },
            Y = '<{',
            H = { type: 'literal', value: '<{', description: '"<{"' },
            W = function(e) {
              return { type: 'curly', value: e };
            },
            X = '</',
            K = { type: 'literal', value: '</', description: '"</"' },
            J = function(e, t) {
              return { type: 'fraction', value: [e, t] };
            },
            Z = '<H',
            $ = { type: 'literal', value: '<H', description: '"<H"' },
            ee = function(e) {
              return { type: 'horizontal', value: e };
            },
            te = '<%',
            ne = { type: 'literal', value: '<%', description: '"<%"' },
            ie = /^[a-zA-Z0-9_\-]/,
            re = {
              type: 'class',
              value: '[a-zA-Z0-9_\\-]',
              description: '[a-zA-Z0-9_\\-]',
            },
            se = function(e) {
              return { type: 'parameter', value: e.join('') };
            },
            oe = '<I',
            ae = { type: 'literal', value: '<I', description: '"<I"' },
            ce = function(e) {
              return { type: 'input', value: e.join('') };
            },
            le = '<(',
            ue = { type: 'literal', value: '<(', description: '"<("' },
            de = function(e) {
              return { type: 'paren', value: e };
            },
            he = '<R',
            pe = { type: 'literal', value: '<R', description: '"<R"' },
            fe = function(e) {
              return { type: 'root', value: e };
            },
            me = '<S',
            ge = { type: 'literal', value: '<S', description: '"<S"' },
            be = function(e, t) {
              var n,
                i = e;
              if (e) {
                for (i = [], n = 0; n < e.length; n++)
                  'legacyOverbar' !== e[n].code
                    ? i.push(e[n])
                    : (t = {
                        type: 'overbar',
                        variant: parseInt(e[n].value, 16),
                        value: t,
                      });
                i.push(t);
              }
              return { type: 'style', value: i };
            },
            ve = /^[OGLPRSTUW#+]/,
            ye = {
              type: 'class',
              value: '[OGLPRSTUW#+]',
              description: '[OGLPRSTUW#+]',
            },
            xe = /^[0-9a-fA-F]/,
            we = {
              type: 'class',
              value: '[0-9a-fA-F]',
              description: '[0-9a-fA-F]',
            },
            ke = function(e, t) {
              var n = {
                O: 'legacyOverbar',
                G: 'green',
                L: 'blue',
                P: 'fontFamily',
                R: 'red',
                S: 'fontStyle',
                T: 'tightness',
                U: 'underbar',
                W: 'fontWeight',
                '#': 'fontSize',
                '+': 'diminish-size',
              };
              return t && 0 !== t.length
                ? { code: n[e], value: 1 === t.length ? t[0] : t.join('') }
                : { code: n[e], value: '0' };
            },
            Pe = '<-',
            Ce = { type: 'literal', value: '<-', description: '"<-"' },
            Se = function(e, t) {
              return { type: 'sub', value: [e, t] };
            },
            Ae = '<+',
            Te = { type: 'literal', value: '<+', description: '"<+"' },
            Me = function(e, t) {
              return { type: 'super', value: [e, t] };
            },
            Ie = '<!',
            Fe = { type: 'literal', value: '<!', description: '"<!"' },
            Ee = /^[0-9A-Fa-f]/,
            je = {
              type: 'class',
              value: '[0-9A-Fa-f]',
              description: '[0-9A-Fa-f]',
            },
            Oe = function(e) {
              return { type: 'symbol', value: e.join('') };
            },
            Le = '<?',
            Ge = { type: 'literal', value: '<?', description: '"<?"' },
            De = 'x',
            Re = { type: 'literal', value: 'x', description: '"x"' },
            Ne = function(e, t, n) {
              return {
                type: 'switch',
                visibleNode: parseInt(e, 16),
                value: n,
                refCon: t.join(''),
              };
            },
            ze = function(e, t) {
              return {
                type: 'switch',
                visibleNode: parseInt(e, 16),
                value: t,
                refCon: '',
              };
            },
            Be = "<T''>",
            Ve = { type: 'literal', value: "<T''>", description: '"<T\'\'>"' },
            qe = function() {
              return { type: 'text', value: '' };
            },
            Ue = '<T"">',
            _e = {
              type: 'literal',
              value: '<T"">',
              description: '"<T\\"\\">"',
            },
            Qe = "<T'",
            Ye = { type: 'literal', value: "<T'", description: '"<T\'"' },
            He = "'>",
            We = { type: 'literal', value: "'>", description: '"\'>"' },
            Xe = function(e) {
              return { type: 'text', value: e };
            },
            Ke = '<T"',
            Je = { type: 'literal', value: '<T"', description: '"<T\\""' },
            Ze = '">',
            $e = { type: 'literal', value: '">', description: '"\\">"' },
            et = function(e) {
              return e.join('');
            },
            tt = /^[^'\\]/,
            nt = { type: 'class', value: "[^'\\\\]", description: "[^'\\\\]" },
            it = '\\\\',
            rt = { type: 'literal', value: '\\\\', description: '"\\\\\\\\"' },
            st = function() {
              return '\\';
            },
            ot = "\\'",
            at = { type: 'literal', value: "\\'", description: '"\\\\\'"' },
            ct = function() {
              return "'";
            },
            lt = '\\"',
            ut = { type: 'literal', value: '\\"', description: '"\\\\\\""' },
            dt = function() {
              return '"';
            },
            ht = /^[^"\\]/,
            pt = { type: 'class', value: '[^"\\\\]', description: '[^"\\\\]' },
            ft = '<V',
            mt = { type: 'literal', value: '<V', description: '"<V"' },
            gt = null,
            bt = 'L',
            vt = { type: 'literal', value: 'L', description: '"L"' },
            yt = 'R',
            xt = { type: 'literal', value: 'R', description: '"R"' },
            wt = 'C',
            kt = { type: 'literal', value: 'C', description: '"C"' },
            Pt = function(e, t) {
              return { type: 'vertical', alignment: e, value: t };
            },
            Ct = '<0>',
            St = { type: 'literal', value: '<0>', description: '"<0>"' },
            At = function() {
              return { type: 'text', value: '' };
            },
            Tt = '<F',
            Mt = { type: 'literal', value: '<F', description: '"<F"' },
            It = /^[^>]/,
            Ft = { type: 'class', value: '[^>]', description: '[^>]' },
            Et = function(e) {
              return { type: 'future', value: e.join('') };
            },
            jt = '<O',
            Ot = { type: 'literal', value: '<O', description: '"<O"' },
            Lt = function(e, t) {
              return {
                type: 'overbar',
                variant: parseInt(e.join(''), 16),
                value: t,
              };
            },
            Gt = 0,
            Dt = 0,
            Rt = 0,
            Nt = { line: 1, column: 1, seenCR: !1 },
            zt = 0,
            Bt = [],
            Vt = 0;
          if ('startRule' in j) {
            if (!(j.startRule in L))
              throw new Error(
                'Can\'t start parsing from rule "' + j.startRule + '".'
              );
            G = L[j.startRule];
          }
          if (((E = G()), E !== O && Gt === e.length)) return E;
          throw (E !== O &&
            Gt < e.length &&
            i({ type: 'end', description: 'end of input' }),
          r(null, Bt, zt));
        }
        return e(t, Error), { SyntaxError: t, parse: n };
      })()),
      (o.sQueryParser = (function() {
        function e(e, t) {
          function n() {
            this.constructor = e;
          }
          (n.prototype = t.prototype), (e.prototype = new n());
        }
        function t(e, t, n, i, r, s) {
          (this.message = e),
            (this.expected = t),
            (this.found = n),
            (this.offset = i),
            (this.line = r),
            (this.column = s),
            (this.name = 'SyntaxError');
        }
        function n(e) {
          function n(t) {
            function n(t, n, i) {
              var r, s;
              for (r = n; i > r; r++)
                (s = e.charAt(r)),
                  '\n' === s
                    ? (t.seenCR || t.line++, (t.column = 1), (t.seenCR = !1))
                    : '\r' === s || '\u2028' === s || '\u2029' === s
                    ? (t.line++, (t.column = 1), (t.seenCR = !0))
                    : (t.column++, (t.seenCR = !1));
            }
            return (
              Ee !== t &&
                (Ee > t &&
                  ((Ee = 0), (je = { line: 1, column: 1, seenCR: !1 })),
                n(je, Ee, t),
                (Ee = t)),
              je
            );
          }
          function i(e) {
            Oe > Ie || (Ie > Oe && ((Oe = Ie), (Le = [])), Le.push(e));
          }
          function r(i, r, s) {
            function o(e) {
              var t = 1;
              for (
                e.sort(function(e, t) {
                  return e.description < t.description
                    ? -1
                    : e.description > t.description
                    ? 1
                    : 0;
                });
                t < e.length;

              )
                e[t - 1] === e[t] ? e.splice(t, 1) : t++;
            }
            function a(e, t) {
              function n(e) {
                function t(e) {
                  return e
                    .charCodeAt(0)
                    .toString(16)
                    .toUpperCase();
                }
                return e
                  .replace(/\\/g, '\\\\')
                  .replace(/"/g, '\\"')
                  .replace(/\x08/g, '\\b')
                  .replace(/\t/g, '\\t')
                  .replace(/\n/g, '\\n')
                  .replace(/\f/g, '\\f')
                  .replace(/\r/g, '\\r')
                  .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(e) {
                    return '\\x0' + t(e);
                  })
                  .replace(/[\x10-\x1F\x80-\xFF]/g, function(e) {
                    return '\\x' + t(e);
                  })
                  .replace(/[\u0180-\u0FFF]/g, function(e) {
                    return '\\u0' + t(e);
                  })
                  .replace(/[\u1080-\uFFFF]/g, function(e) {
                    return '\\u' + t(e);
                  });
              }
              var i,
                r,
                s,
                o = new Array(e.length);
              for (s = 0; s < e.length; s++) o[s] = e[s].description;
              return (
                (i =
                  e.length > 1
                    ? o.slice(0, -1).join(', ') + ' or ' + o[e.length - 1]
                    : o[0]),
                (r = t ? '"' + n(t) + '"' : 'end of input'),
                'Expected ' + i + ' but ' + r + ' found.'
              );
            }
            var c = n(s),
              l = s < e.length ? e.charAt(s) : null;
            return (
              null !== r && o(r),
              new t(null !== i ? i : a(r, l), r, l, s, c.line, c.column)
            );
          }
          function s() {
            var e;
            return (e = o());
          }
          function o() {
            var t, n, r, s, o, c;
            if (((t = Ie), (n = a()), n !== S)) {
              for (
                r = [],
                  s = Ie,
                  44 === e.charCodeAt(Ie)
                    ? ((o = I), Ie++)
                    : ((o = S), 0 === Ge && i(F)),
                  o !== S
                    ? ((c = a()),
                      c !== S ? ((o = [o, c]), (s = o)) : ((Ie = s), (s = M)))
                    : ((Ie = s), (s = M));
                s !== S;

              )
                r.push(s),
                  (s = Ie),
                  44 === e.charCodeAt(Ie)
                    ? ((o = I), Ie++)
                    : ((o = S), 0 === Ge && i(F)),
                  o !== S
                    ? ((c = a()),
                      c !== S ? ((o = [o, c]), (s = o)) : ((Ie = s), (s = M)))
                    : ((Ie = s), (s = M));
              r !== S
                ? ((Fe = t), (n = E(n, r)), (t = n))
                : ((Ie = t), (t = M));
            } else (Ie = t), (t = M);
            return t;
          }
          function a() {
            var e, t, n, i;
            if (
              ((e = Ie),
              (t = c()),
              t === S && (t = l()),
              t === S && (t = j),
              t !== S)
            ) {
              for (
                n = [], i = h(), i === S && ((i = u()), i === S && (i = d()));
                i !== S;

              )
                n.push(i),
                  (i = h()),
                  i === S && ((i = u()), i === S && (i = d()));
              n !== S
                ? ((Fe = e), (t = O(t, n)), (e = t))
                : ((Ie = e), (e = M));
            } else (Ie = e), (e = M);
            return e;
          }
          function c() {
            var t, n;
            return (
              (t = Ie),
              42 === e.charCodeAt(Ie)
                ? ((n = L), Ie++)
                : ((n = S), 0 === Ge && i(G)),
              n !== S && ((Fe = t), (n = D())),
              (t = n)
            );
          }
          function l() {
            var e, t;
            return (
              (e = Ie), (t = b()), t !== S && ((Fe = e), (t = R(t))), (e = t)
            );
          }
          function u() {
            var t, n, r;
            return (
              (t = Ie),
              35 === e.charCodeAt(Ie)
                ? ((n = N), Ie++)
                : ((n = S), 0 === Ge && i(z)),
              n !== S
                ? ((r = b()),
                  r !== S
                    ? ((Fe = t), (n = B(r)), (t = n))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M)),
              t
            );
          }
          function d() {
            var t, n, r;
            return (
              (t = Ie),
              46 === e.charCodeAt(Ie)
                ? ((n = V), Ie++)
                : ((n = S), 0 === Ge && i(q)),
              n !== S
                ? ((r = b()),
                  r !== S
                    ? ((Fe = t), (n = U(r)), (t = n))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M)),
              t
            );
          }
          function h() {
            var t, n, r, s, o, a;
            return (
              (t = Ie),
              91 === e.charCodeAt(Ie)
                ? ((n = _), Ie++)
                : ((n = S), 0 === Ge && i(Q)),
              n !== S
                ? ((r = b()),
                  r !== S
                    ? ((s = p()),
                      s !== S
                        ? ((o = f()),
                          o !== S
                            ? (93 === e.charCodeAt(Ie)
                                ? ((a = Y), Ie++)
                                : ((a = S), 0 === Ge && i(H)),
                              a !== S
                                ? ((Fe = t), (n = W(r, s, o)), (t = n))
                                : ((Ie = t), (t = M)))
                            : ((Ie = t), (t = M)))
                        : ((Ie = t), (t = M)))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M)),
              t
            );
          }
          function p() {
            var t;
            return (
              61 === e.charCodeAt(Ie)
                ? ((t = X), Ie++)
                : ((t = S), 0 === Ge && i(K)),
              t
            );
          }
          function f() {
            var e;
            return (e = v()), e === S && ((e = m()), e === S && (e = g())), e;
          }
          function m() {
            var t, n;
            return (
              (t = Ie),
              e.substr(Ie, 4) === J
                ? ((n = J), (Ie += 4))
                : ((n = S), 0 === Ge && i(Z)),
              n !== S && ((Fe = t), (n = $())),
              (t = n)
            );
          }
          function g() {
            var t, n;
            return (
              (t = Ie),
              e.substr(Ie, 5) === ee
                ? ((n = ee), (Ie += 5))
                : ((n = S), 0 === Ge && i(te)),
              n !== S && ((Fe = t), (n = ne())),
              (t = n)
            );
          }
          function b() {
            var t, n, r;
            if (
              ((t = Ie),
              (n = []),
              ie.test(e.charAt(Ie))
                ? ((r = e.charAt(Ie)), Ie++)
                : ((r = S), 0 === Ge && i(re)),
              r !== S)
            )
              for (; r !== S; )
                n.push(r),
                  ie.test(e.charAt(Ie))
                    ? ((r = e.charAt(Ie)), Ie++)
                    : ((r = S), 0 === Ge && i(re));
            else n = M;
            return n !== S && ((Fe = t), (n = se(n))), (t = n);
          }
          function v() {
            var e;
            return (e = y()), e === S && (e = x()), e;
          }
          function y() {
            var t, n, r, s, o, a;
            if (
              ((t = Ie),
              34 === e.charCodeAt(Ie)
                ? ((n = oe), Ie++)
                : ((n = S), 0 === Ge && i(ae)),
              n !== S)
            ) {
              for (
                r = [],
                  ce.test(e.charAt(Ie))
                    ? ((s = e.charAt(Ie)), Ie++)
                    : ((s = S), 0 === Ge && i(le)),
                  s === S &&
                    ((s = Ie),
                    92 === e.charCodeAt(Ie)
                      ? ((o = ue), Ie++)
                      : ((o = S), 0 === Ge && i(de)),
                    o !== S
                      ? ((a = w()),
                        a !== S
                          ? ((Fe = s), (o = he(a)), (s = o))
                          : ((Ie = s), (s = M)))
                      : ((Ie = s), (s = M)),
                    s === S && (s = k()));
                s !== S;

              )
                r.push(s),
                  ce.test(e.charAt(Ie))
                    ? ((s = e.charAt(Ie)), Ie++)
                    : ((s = S), 0 === Ge && i(le)),
                  s === S &&
                    ((s = Ie),
                    92 === e.charCodeAt(Ie)
                      ? ((o = ue), Ie++)
                      : ((o = S), 0 === Ge && i(de)),
                    o !== S
                      ? ((a = w()),
                        a !== S
                          ? ((Fe = s), (o = he(a)), (s = o))
                          : ((Ie = s), (s = M)))
                      : ((Ie = s), (s = M)),
                    s === S && (s = k()));
              r !== S
                ? (34 === e.charCodeAt(Ie)
                    ? ((s = oe), Ie++)
                    : ((s = S), 0 === Ge && i(ae)),
                  s !== S
                    ? ((Fe = t), (n = pe(r)), (t = n))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M));
            } else (Ie = t), (t = M);
            return t;
          }
          function x() {
            var t, n, r, s, o, a;
            if (
              ((t = Ie),
              39 === e.charCodeAt(Ie)
                ? ((n = fe), Ie++)
                : ((n = S), 0 === Ge && i(me)),
              n !== S)
            ) {
              for (
                r = [],
                  ge.test(e.charAt(Ie))
                    ? ((s = e.charAt(Ie)), Ie++)
                    : ((s = S), 0 === Ge && i(be)),
                  s === S &&
                    ((s = Ie),
                    92 === e.charCodeAt(Ie)
                      ? ((o = ue), Ie++)
                      : ((o = S), 0 === Ge && i(de)),
                    o !== S
                      ? ((a = w()),
                        a !== S
                          ? ((Fe = s), (o = he(a)), (s = o))
                          : ((Ie = s), (s = M)))
                      : ((Ie = s), (s = M)),
                    s === S && (s = k()));
                s !== S;

              )
                r.push(s),
                  ge.test(e.charAt(Ie))
                    ? ((s = e.charAt(Ie)), Ie++)
                    : ((s = S), 0 === Ge && i(be)),
                  s === S &&
                    ((s = Ie),
                    92 === e.charCodeAt(Ie)
                      ? ((o = ue), Ie++)
                      : ((o = S), 0 === Ge && i(de)),
                    o !== S
                      ? ((a = w()),
                        a !== S
                          ? ((Fe = s), (o = he(a)), (s = o))
                          : ((Ie = s), (s = M)))
                      : ((Ie = s), (s = M)),
                    s === S && (s = k()));
              r !== S
                ? (39 === e.charCodeAt(Ie)
                    ? ((s = fe), Ie++)
                    : ((s = S), 0 === Ge && i(me)),
                  s !== S
                    ? ((Fe = t), (n = pe(r)), (t = n))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M));
            } else (Ie = t), (t = M);
            return t;
          }
          function w() {
            var t;
            return (
              10 === e.charCodeAt(Ie)
                ? ((t = ve), Ie++)
                : ((t = S), 0 === Ge && i(ye)),
              t === S &&
                (e.substr(Ie, 2) === xe
                  ? ((t = xe), (Ie += 2))
                  : ((t = S), 0 === Ge && i(we)),
                t === S &&
                  (13 === e.charCodeAt(Ie)
                    ? ((t = ke), Ie++)
                    : ((t = S), 0 === Ge && i(Pe)),
                  t === S &&
                    (12 === e.charCodeAt(Ie)
                      ? ((t = Ce), Ie++)
                      : ((t = S), 0 === Ge && i(Se))))),
              t
            );
          }
          function k() {
            var t, n, r;
            return (
              (t = Ie),
              92 === e.charCodeAt(Ie)
                ? ((n = ue), Ie++)
                : ((n = S), 0 === Ge && i(de)),
              n !== S
                ? (Ae.test(e.charAt(Ie))
                    ? ((r = e.charAt(Ie)), Ie++)
                    : ((r = S), 0 === Ge && i(Te)),
                  r !== S
                    ? ((Fe = t), (n = Me(r)), (t = n))
                    : ((Ie = t), (t = M)))
                : ((Ie = t), (t = M)),
              t
            );
          }
          var P,
            C = arguments.length > 1 ? arguments[1] : {},
            S = {},
            A = { start: s },
            T = s,
            M = S,
            I = ',',
            F = { type: 'literal', value: ',', description: '","' },
            E = function(e, t) {
              var n,
                i = [];
              for (e && i.push(e), n = 0; n < t.length; n += 1) i.push(t[n][1]);
              return i;
            },
            j = null,
            O = function(e, t) {
              var n = { type: 'selectorAnd' },
                i = [];
              return (
                e && i.push(e),
                (i = i.concat(t)),
                1 === i.length ? i[0] : ((n.parts = i), n)
              );
            },
            L = '*',
            G = { type: 'literal', value: '*', description: '"*"' },
            D = function() {
              return { type: 'global' };
            },
            R = function(e) {
              return { type: 'kind', name: e };
            },
            N = '#',
            z = { type: 'literal', value: '#', description: '"#"' },
            B = function(e) {
              return { type: 'id', name: e };
            },
            V = '.',
            q = { type: 'literal', value: '.', description: '"."' },
            U = function(e) {
              return { type: 'class', name: e };
            },
            _ = '[',
            Q = { type: 'literal', value: '[', description: '"["' },
            Y = ']',
            H = { type: 'literal', value: ']', description: '"]"' },
            W = function(e, t, n) {
              return { type: 'attr', name: e, oper: t, value: n };
            },
            X = '=',
            K = { type: 'literal', value: '=', description: '"="' },
            J = 'true',
            Z = { type: 'literal', value: 'true', description: '"true"' },
            $ = function() {
              return !0;
            },
            ee = 'false',
            te = { type: 'literal', value: 'false', description: '"false"' },
            ne = function() {
              return !1;
            },
            ie = /^[0-9a-zA-Z_]/,
            re = {
              type: 'class',
              value: '[0-9a-zA-Z_]',
              description: '[0-9a-zA-Z_]',
            },
            se = function(e) {
              return e.join('');
            },
            oe = '"',
            ae = { type: 'literal', value: '"', description: '"\\""' },
            ce = /^[^\n\r\f\\"]/,
            le = {
              type: 'class',
              value: '[^\\n\\r\\f\\\\"]',
              description: '[^\\n\\r\\f\\\\"]',
            },
            ue = '\\',
            de = { type: 'literal', value: '\\', description: '"\\\\"' },
            he = function(e) {
              return e;
            },
            pe = function(e) {
              return e.join('');
            },
            fe = "'",
            me = { type: 'literal', value: "'", description: '"\'"' },
            ge = /^[^\n\r\f\\']/,
            be = {
              type: 'class',
              value: "[^\\n\\r\\f\\\\']",
              description: "[^\\n\\r\\f\\\\']",
            },
            ve = '\n',
            ye = { type: 'literal', value: '\n', description: '"\\n"' },
            xe = '\r\n',
            we = { type: 'literal', value: '\r\n', description: '"\\r\\n"' },
            ke = '\r',
            Pe = { type: 'literal', value: '\r', description: '"\\r"' },
            Ce = '\f',
            Se = { type: 'literal', value: '\f', description: '"\\f"' },
            Ae = /^[^\r\n\f0-9a-fA-F]/,
            Te = {
              type: 'class',
              value: '[^\\r\\n\\f0-9a-fA-F]',
              description: '[^\\r\\n\\f0-9a-fA-F]',
            },
            Me = function(e) {
              return e;
            },
            Ie = 0,
            Fe = 0,
            Ee = 0,
            je = { line: 1, column: 1, seenCR: !1 },
            Oe = 0,
            Le = [],
            Ge = 0;
          if ('startRule' in C) {
            if (!(C.startRule in A))
              throw new Error(
                'Can\'t start parsing from rule "' + C.startRule + '".'
              );
            T = A[C.startRule];
          }
          if (((P = T()), P !== S && Ie === e.length)) return P;
          throw (P !== S &&
            Ie < e.length &&
            i({ type: 'end', description: 'end of input' }),
          r(null, Le, Oe));
        }
        return e(t, Error), { SyntaxError: t, parse: n };
      })()),
      (function() {
        function e(e, t, n) {
          return function(i, r) {
            return t.call(e, n, i, r);
          };
        }
        function n() {
          return function(e, t) {};
        }
        function i(t, i) {
          var r,
            s,
            o = {};
          if (!t || !i) return null;
          (o.engine = t), (o.draw = i);
          for (r in t.primitives)
            if ('function' == typeof t.primitives[r])
              (o['prepare' + r] = n()),
                (o['draw' + r] = e(t.primitives, t.primitives[r], o.draw)),
                (o['cleanup' + r] = n());
            else
              for (s in t.primitives[r])
                o[s + r] = e(t.primitives, t.primitives[r][s], o.draw);
          return o;
        }
        var r = {
          _forward: function(e) {
            t.each(this.engines, function(t, n) {
              n.engine[e] && n.engine[e](n.draw);
            });
          },
          prepareFrame: function(e, n) {
            t.each(this.engines, function(t, i) {
              i.engine.prepareFrame &&
                i.engine.prepareFrame(i.draw, e, i.preclear, n);
            });
          },
          cleanupFrame: function(e) {
            t.each(this.engines, function(t, n) {
              n.engine.cleanupFrame && n.engine.cleanupFrame(n.draw, e);
            });
          },
          translate: function(e, n) {
            t.each(this.engines, function(t, i) {
              i.trace && i.engine.translate(i.draw, e, n);
            });
          },
          fade: function(e) {
            t.each(this.engines, function(t, n) {
              n.trace && n.engine.fade(n.draw, e);
            });
          },
          destroy: function() {
            this._forward('destroy');
          },
        };
        o.draw = {
          availableEngines: {},
          create: function(e) {
            var t,
              n,
              s = o.draw,
              a = e.rootNode,
              c = {};
            (e.width = e.width || a.width()),
              (e.height = e.height || a.height());
            var l = function(t) {
              var n = i(
                s.availableEngines.canvas,
                s.availableEngines.canvas.create(e)
              );
              return n && (t ? (n.trace = !0) : (n.preclear = !0)), n;
            };
            s.availableEngines.canvas &&
              ((c.trace = l(!0)), (c.canvas = l(!1))),
              s.availableEngines.html &&
                ((t = i(
                  s.availableEngines.html,
                  s.availableEngines.html.create(e)
                )),
                t && (c.html = t)),
              s.availableEngines.canvas && (c.canvasTop = l(!1)),
              (n = Object.create(r));
            for (t in c) c.hasOwnProperty(t) && !c[t] && delete c[t];
            return (n.engines = c), n;
          },
        };
      })(),
      (function() {
        function r(e, t, n) {
          e.beginPath(), e.moveTo(t.x, t.y), e.lineTo(n.x, n.y), e.stroke();
        }
        function s(e, t, n, i, r) {
          function s(e) {
            return Math.abs(e) < b;
          }
          var o,
            c,
            l,
            u,
            d,
            h,
            p,
            f,
            m = t.length / 2,
            g = !1;
          e.beginPath();
          var b = 1e7;
          for (o = 0, c = 0; m > o; ++o, c += 2) {
            if (((u = t[c]), (d = t[c + 1]), s(u) && s(d))) {
              if (u === h && d === p) {
                l = !0;
                continue;
              }
              n &&
                n[o] &&
                (l &&
                  (e.stroke(),
                  (e.fillStyle = e.strokeStyle),
                  a(e, { x: h, y: p }, e.lineWidth / 2),
                  e.beginPath()),
                (g = !1)),
                (l = !1),
                g
                  ? ((f = i && i[o]),
                    f && '' !== f && (e.strokeStyle = f),
                    e.lineTo(u, d),
                    f && (e.stroke(), e.beginPath(), e.moveTo(u, d)))
                  : (e.moveTo(u, d), (g = !0));
            } else
              l &&
                (e.stroke(),
                (e.fillStyle = e.strokeStyle),
                a(e, { x: h, y: p }, e.lineWidth / 2),
                e.beginPath()),
                (g = !1);
            (h = u), (p = d);
          }
          r &&
            g &&
            ((n && n[o]) ||
              ((u = t[0]), (d = t[1]), s(u) && s(d) && e.lineTo(u, d))),
            e.stroke();
        }
        function a(e, t, n) {
          e.beginPath(), e.arc(t.x, t.y, n, 0, 2 * Math.PI, !0), e.fill();
        }
        function c(e, t) {
          e.beginPath(),
            0 !== t.orientation
              ? e.arc(
                  t.center.x,
                  t.center.y,
                  t.radius,
                  t.initialAngle,
                  t.finalAngle,
                  !1
                )
              : (e.moveTo(t.initialPoint.x, t.initialPoint.y),
                e.lineTo(t.finalPoint.x, t.finalPoint.y));
        }
        function l(e, t, n, i, r) {
          var s, o, c;
          for (s = 0, o = 0; n > s; ++s, o += 2)
            r && (e.fillStyle = r[s]),
              (c = { x: t[o], y: t[o + 1] }),
              a(e, c, i);
        }
        function u(e, t, n) {
          if (n.x === n.y)
            return (
              e.beginPath(),
              e.arc(t.x, t.y, n.x, 0, 2 * Math.PI, !0),
              void e.stroke()
            );
          var i = 0.551784,
            r = n.x * i,
            s = n.y * i,
            o = t.x + n.x,
            a = t.y + n.y;
          e.beginPath(),
            e.moveTo(t.x - n.x, t.y),
            e.bezierCurveTo(
              t.x - n.x,
              t.y - s,
              t.x - r,
              t.y - n.y,
              t.x,
              t.y - n.y
            ),
            e.bezierCurveTo(t.x + r, t.y - n.y, o, t.y - s, o, t.y),
            e.bezierCurveTo(o, t.y + s, t.x + r, a, t.x, a),
            e.bezierCurveTo(t.x - r, a, t.x - n.x, t.y + s, t.x - n.x, t.y),
            e.stroke();
        }
        function d(e, t, n) {
          e.beginPath(),
            e.moveTo(t[0].x, t[0].y),
            e.lineTo(t[1].x, t[1].y),
            e.lineTo(t[2].x, t[2].y),
            e.closePath(),
            e.fill(),
            n && e.stroke();
        }
        function h(e, t, n) {
          var i = 10,
            r = i,
            s = t.subtract(e),
            o = s.vLength(),
            a = o - r;
          return o > i ? s.multiply(a / o).add(e) : void 0;
        }
        function p(e, t, n, i) {
          var r;
          return (r = e - (t * i) / n);
        }
        function f(e, t, n) {
          var i = 2,
            r = n / 2 + i || i,
            s = [],
            a = t.subtract(e).unit(),
            c = new o.GeometricPoint(-a.y, a.x);
          return (
            s.push(e.add(c.multiply(r))),
            s.push(t),
            s.push(e.add(c.multiply(-r))),
            s
          );
        }
        function m(e, t, n, i, r, s, a) {
          if (0 === t.orientation)
            return (
              e.beginPath(),
              e.moveTo(t.initialPoint.x, t.initialPoint.y),
              e.lineTo(t.finalPoint.x, t.finalPoint.y),
              void e.closePath()
            );
          var c,
            l,
            u,
            h,
            m = 10,
            g = t,
            b = g.center,
            v = t.orientation,
            y = t.arcAngle,
            x = t.initialAngle,
            w = t.finalAngle,
            k = x,
            P = w,
            C = 'tail' === r || 'both' === r,
            S = 'head' === r || 'both' === r,
            A = 0,
            T = !1,
            M = !1;
          S && ((A += m), v > 0 ? (M = !0) : (T = !0)),
            C && ((A += m), 0 > v ? (M = !0) : (T = !0)),
            Math.abs(y * n) <= A && (T = M = !1),
            T &&
              ((c = new o.GeometricPoint(Math.cos(x), Math.sin(x))
                .multiply(n)
                .add(b)),
              (k = p(x, v, n, m))),
            M &&
              ((l = new o.GeometricPoint(Math.cos(w), Math.sin(w))
                .multiply(n)
                .add(b)),
              (P = p(w, v, n, m))),
            e.beginPath(),
            e.arc(b.x, b.y, n, k, P, !1),
            e.stroke(),
            s &&
              (e.beginPath(),
              e.arc(b.x, b.y, n, x, w, !1),
              e.lineTo(b.x, b.y),
              e.closePath(),
              (h = e.globalAlpha),
              (e.globalAlpha *= a),
              e.fill(),
              (e.globalAlpha = h)),
            T &&
              ((u = new o.GeometricPoint(Math.cos(k), Math.sin(k))
                .multiply(n)
                .add(b)),
              d(e, f(u, c, i))),
            M &&
              ((u = new o.GeometricPoint(Math.cos(P), Math.sin(P))
                .multiply(n)
                .add(b)),
              d(e, f(u, l, i)));
        }
        function g(e, t, n, i, r, s, a) {
          var c,
            l,
            u,
            p = 10,
            m = t,
            g = m.center,
            b = m.orientation,
            v = m.initialAngle,
            y = o.GeometricPoint(Math.cos(v), Math.sin(v)).multiply(n),
            x = o.GeometricPoint(-y.y, y.x),
            w = y.add(x),
            k = y.add(g),
            P = x.add(g),
            C = k,
            S = P,
            A = w.add(g),
            T = 'tail' === r || 'both' === r,
            M = 'head' === r || 'both' === r,
            I = !1,
            F = !1;
          M && (b > 0 ? (F = !0) : (I = !0)),
            T && (0 > b ? (F = !0) : (I = !0)),
            p >= n && (I = F = !1),
            F && ((l = h(A, P, i)), l && (P = l)),
            I && ((c = h(A, k, i)), c && (k = c)),
            e.beginPath(),
            e.moveTo(k.x, k.y),
            e.lineTo(A.x, A.y),
            e.lineTo(P.x, P.y),
            e.stroke(),
            s &&
              (e.beginPath(),
              e.moveTo(C.x, C.y),
              e.lineTo(A.x, A.y),
              e.lineTo(S.x, S.y),
              e.lineTo(g.x, g.y),
              e.closePath(),
              (u = e.globalAlpha),
              (e.globalAlpha *= a),
              e.fill(),
              (e.globalAlpha = u)),
            l && d(e, f(P, S, i)),
            c && d(e, f(k, C, i));
        }
        function b(e, t) {
          var n = t.pictureCache;
          if (n[t.image.src]) return n[t.image.src];
          var i = { state: 'error', id: t.id, onStateChange: t.onStateChange };
          return (
            (i.imageSpec = t.image),
            t.image &&
              ((i.state = 'loading'),
              (i.img = k(i.imageSpec, function() {
                (i.state = 'ready'), i.onStateChange && i.onStateChange();
              }))),
            (n[t.image.src] = i),
            i
          );
        }
        function v(e, t, n) {
          var i,
            r = e.context,
            s = n.transform,
            o = t.imageSpec ? t.imageSpec.width : 200,
            a = t.imageSpec ? t.imageSpec.height : 100,
            c = n.clipPolygon;
          if (n.renderable) {
            if ((r.save(), (r.globalAlpha *= n.opacity), c && c.length > 0)) {
              for (
                r.beginPath(), r.moveTo(c[0].getX(), c[0].getY()), i = 1;
                i < c.length;
                i++
              )
                r.lineTo(c[i].getX(), c[i].getY());
              r.closePath(), r.clip();
            }
            r.transform(s.m00, s.m01, s.m10, s.m11, s.m20, s.m21),
              'ready' === t.state
                ? r.drawImage(t.img, 0, 0)
                : 'loading' === t.state
                ? ((r.strokeStyle = 'black'), r.strokeRect(0, 0, o, a))
                : ((r.strokeStyle = 'red'),
                  r.strokeRect(0, 0, o, a),
                  r.beginPath(),
                  r.moveTo(0, 0),
                  r.lineTo(o, a),
                  r.moveTo(o, 0),
                  r.lineTo(0, a),
                  r.closePath(),
                  r.stroke()),
              n.isFocusable &&
                (r.beginPath(),
                s.m00 >= 1 && s.m11 >= 1
                  ? (r.lineWidth = n.width)
                  : (r.lineWidth = n.width * (1 / Math.min(s.m00, s.m11))),
                (r.strokeStyle = n.color),
                r.strokeRect(0, 0, o, a),
                r.closePath(),
                r.stroke()),
              r.restore();
          }
        }
        function y(e, t, n) {
          t.onStateChange = null;
        }
        function x(n, i) {
          var r,
            s,
            o,
            a = n,
            c = i;
          return (
            (o = e.devicePixelRatio),
            o && ((a = Math.round(a * o)), (c = Math.round(c * o))),
            (r = t(
              '<canvas aria-hidden="true" width="' +
                a +
                '" height="' +
                c +
                '"></canvas>'
            )),
            (s = r[0].getContext && r[0].getContext('2d'))
              ? (s.setLineDash ||
                  ((s.setLineDash = function(e) {}),
                  (s.getLineDash = function() {
                    return [];
                  })),
                o && s.scale(o, o),
                { canvas: r, context: s, width: a, height: c })
              : null
          );
        }
        function w(e) {
          e.backbuffer = x(e.canvas.width(), e.canvas.height());
        }
        var k = function(e, t) {
          var n = new Image();
          return (n.src = e.src), t && (n.onload = t), n;
        };
        o.draw.availableEngines.canvas = {
          create: function(e) {
            var t = x(e.width, e.height);
            return t
              ? (t.canvas.css({
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: e.width,
                  height: e.height,
                  overflow: 'hidden',
                }),
                t.canvas.appendTo(e.rootNode),
                t)
              : t;
          },
          destroy: function(e) {
            e.canvas && e.canvas.remove();
          },
          prepareFrame: function(e, t, n, i) {
            var r, s, a, c, l;
            e.context.save(),
              e.context.transform(i.m00, i.m01, i.m10, i.m11, i.m20, i.m21),
              n &&
                o.Geom.isValidRect(t) &&
                ((s = o.GeometricPoint(0, 0)),
                (a = o.GeometricPoint(e.canvas.width(), e.canvas.height())),
                (l = i.inverse()),
                l.transform(s),
                l.transform(a),
                (c = { left: s.x, top: s.y, right: a.x, bottom: a.y }),
                (r = o.Geom.insetRect(t, -1)),
                (r.left = Math.round(r.left)),
                (r.top = Math.round(r.top)),
                (r.right = Math.round(r.right)),
                (r.bottom = Math.round(r.bottom)),
                (r = o.Geom.intersectRects(r, c)),
                o.Geom.isEmptyRect(r) &&
                  (r = { left: -1, top: -1, right: -1, bottom: -1 }),
                e.context.beginPath(),
                e.context.rect(
                  r.left,
                  r.top,
                  r.right - r.left,
                  r.bottom - r.top
                ),
                e.context.clip(),
                e.context.clearRect(s.x, s.y, a.x - s.x, a.y - s.y));
          },
          cleanupFrame: function(e, t) {
            e.context.restore();
          },
          clear: function(e) {
            e.context.clearRect(0, 0, e.canvas.width(), e.canvas.height());
          },
          translate: function(e, t, n) {
            var i = e.canvas.width(),
              r = e.canvas.height();
            e.backbuffer || w(e),
              e.backbuffer.context.clearRect(0, 0, i, r),
              e.backbuffer.context.drawImage(e.canvas[0], -t, -n, i, r),
              e.context.clearRect(0, 0, i, r),
              e.context.drawImage(e.backbuffer.canvas[0], 0, 0, i, r);
          },
          fade: function(e, t) {
            e.backbuffer || w(e),
              e.backbuffer.context.save(),
              e.backbuffer.context.clearRect(
                0,
                0,
                e.canvas.width(),
                e.canvas.height()
              ),
              (e.backbuffer.context.globalAlpha = t),
              e.backbuffer.context.drawImage(
                e.canvas[0],
                0,
                0,
                e.canvas.width(),
                e.canvas.height()
              ),
              e.context.clearRect(0, 0, e.canvas.width(), e.canvas.height()),
              e.context.drawImage(
                e.backbuffer.canvas[0],
                0,
                0,
                e.canvas.width(),
                e.canvas.height()
              ),
              e.backbuffer.context.restore();
          },
          primitives: {
            Point: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.fillStyle = n.color),
                (i.strokeStyle = 'black'),
                (i.lineWidth = n.lineWidth),
                n.dropShadow &&
                  ((i.shadowColor = 'black'),
                  (i.shadowBlur = 7),
                  (i.shadowOffsetX = 3),
                  (i.shadowOffsetY = 3)),
                i.setLineDash([]),
                i.beginPath(),
                i.arc(n.cx, n.cy, n.radius, 0, 2 * Math.PI, !0),
                i.fill(),
                n.lineWidth > 0 && i.stroke(),
                i.closePath(),
                i.restore());
            },
            String: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.fillStyle = 'black'),
                (i.strokeStyle = 'black'),
                (i.lineWidth = 1),
                (i.textAlign = 'center'),
                (i.textBaseline = 'middle'),
                i.fillText(n.text, n.x, n.y),
                i.restore());
            },
            Circle: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.strokeStyle = n.color),
                (i.lineWidth = n.width),
                i.setLineDash(n.lineDash || []),
                i.beginPath(),
                i.arc(n.cx, n.cy, n.r, 0, 2 * Math.PI, !0),
                i.stroke(),
                i.restore());
            },
            Arc: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.strokeStyle = n.color),
                (i.lineWidth = n.width),
                i.setLineDash(n.lineDash || []),
                c(i, n.arc),
                i.stroke(),
                i.restore());
            },
            CircleInterior: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.fillStyle = n.color),
                n.drawBorder &&
                  ((i.strokeStyle = n.borderColor),
                  (i.lineWidth = n.borderWidth),
                  i.setLineDash(n.lineDash || [])),
                i.beginPath(),
                i.arc(n.cx, n.cy, n.r, 0, 2 * Math.PI, !0),
                i.fill(),
                n.drawBorder && i.stroke(),
                i.restore());
            },
            ArcInterior: function(e, t, n) {
              var i,
                r = e.context;
              n.renderable &&
                (r.save(),
                (r.globalAlpha *= n.opacity),
                (r.fillStyle = n.color),
                n.drawBorder &&
                  ((r.strokeStyle = n.borderColor),
                  (r.lineWidth = n.borderWidth),
                  r.setLineDash(n.lineDash || [])),
                (i = n.arc),
                c(r, n.arc),
                'ArcSegment' === n.genus
                  ? r.closePath()
                  : (r.lineTo(i.center.x, i.center.y), r.closePath()),
                r.fill(),
                n.drawBorder && r.stroke(),
                r.restore());
            },
            Polygon: function(e, t, n) {
              var i,
                r,
                s = e.context;
              if (n.renderable) {
                for (
                  s.save(),
                    n.drawBorder &&
                      ((r = s.globalAlpha),
                      (s.strokeStyle = n.borderColor),
                      (s.lineWidth = n.borderWidth),
                      (s.miterLimit = 10 / n.borderWidth),
                      s.setLineDash(n.lineDash || [])),
                    s.globalAlpha *= n.opacity,
                    s.fillStyle = n.color,
                    s.beginPath(),
                    s.moveTo(n.points[0].x, n.points[0].y),
                    i = 1;
                  i < n.points.length;
                  i++
                )
                  s.lineTo(n.points[i].x, n.points[i].y);
                s.closePath(),
                  s.fill('evenodd'),
                  n.drawBorder &&
                    ((s.globalAlpha = r * n.fadeOpacity), s.stroke()),
                  s.restore();
              }
            },
            Rectangle: function(e, t, n) {
              function i(e, t, n) {
                return Math.max(Math.min(e, n), t);
              }
              var r,
                s = e.context,
                o = n.rect,
                a = {
                  left: -1,
                  top: -1,
                  right: e.width + 1,
                  bottom: e.height + 1,
                };
              (r = {
                left: Math.round(i(o.left, a.left, a.right)) - 0.5,
                top: Math.round(i(o.top, a.top, a.bottom)) - 0.5,
                right: Math.round(i(o.right, a.left, a.right)) + 0.5,
                bottom: Math.round(i(o.bottom, a.top, a.bottom)) + 0.5,
              }),
                s.save(),
                (s.globalAlpha *= n.opacity),
                (s.lineWidth = n.isFocusable ? n.borderWidth : 1),
                (s.lineCap = 'butt'),
                (s.lineJoin = 'miter'),
                (s.strokeStyle = n.isFocusable
                  ? n.borderColor
                  : n.color || '#999'),
                s.beginPath(),
                s.moveTo(r.left, r.top),
                s.lineTo(r.right, r.top),
                s.lineTo(r.right, r.bottom),
                s.lineTo(r.left, r.bottom),
                s.closePath(),
                s.stroke(),
                s.restore();
            },
            Segment: function(e, t, n) {
              var i = e.context;
              n.renderable &&
                (i.save(),
                (i.globalAlpha *= n.opacity),
                (i.lineWidth = n.width),
                (i.strokeStyle = n.color),
                i.setLineDash(n.lineDash || []),
                i.beginPath(),
                i.moveTo(n.p0x, n.p0y),
                i.lineTo(n.p1x, n.p1y),
                (i.lineCap = 'round'),
                i.stroke(),
                i.closePath(),
                i.setLineDash([]),
                i.restore());
            },
            Text: {
              prepare: function(e, n) {
                return t.extend({}, n);
              },
              measure: function(e, t, n) {
                var i,
                  r = e.context,
                  s = t.renderBounds;
                return (
                  (n.x = 0),
                  (n.y = 0),
                  (n.renderable = !0),
                  (n.visibility = 'visible'),
                  (n.opacity = 1),
                  (n.constraintFrame = 0),
                  r.save(),
                  r.beginPath(),
                  r.rect(0, 0, 0, 0),
                  r.clip(),
                  this.Text.draw(e, t, n),
                  (i = {
                    width: t.renderBounds.right - t.renderBounds.left,
                    height: t.renderBounds.bottom - t.renderBounds.top,
                  }),
                  r.restore(),
                  (t.renderBounds = s),
                  i
                );
              },
              draw: function(s, a, c) {
                function l(e, t) {
                  function i(e, t, i) {
                    n !== e &&
                      e !== t &&
                      (r.length > 0 && (r += ' '), (r += e), i && (r += i));
                  }
                  var r = '';
                  i(t['font-weight'], 'normal'),
                    i(t['font-style'], 'normal'),
                    i(t['font-size'], '', 'px'),
                    i(t['font-family']),
                    r.length > 0 && (e.font = r),
                    n !== t.color && (e.fillStyle = t.color);
                }
                function u(e) {
                  var n,
                    i = { ascent: 0.1, descent: 0.2, left: 0, right: 0 },
                    r = {
                      zapfino: {
                        ascent: 1.2,
                        descent: 2.6,
                        left: 0.2,
                        right: 0.4,
                      },
                    },
                    s = e['font-family'],
                    o = s && s.toLowerCase();
                  return (
                    t.each(r, function(e, t) {
                      return o.indexOf(e) >= 0 ? ((n = t), !1) : void 0;
                    }),
                    n || i
                  );
                }
                function d(e, t, n) {
                  var i,
                    r,
                    s = t['font-size'] || v,
                    o = u(t),
                    a = f(n);
                  return (
                    e.save(),
                    l(e, t),
                    (i = e.measureText(a.text)),
                    e.restore(),
                    (r = (a.maxSubscript + a.maxSuperscript) * x),
                    {
                      width: Math.round(i.width * (1 + o.left + o.right)),
                      height: Math.round(s * (1 + o.ascent + o.descent + r)),
                    }
                  );
                }
                function h(e, t, n, i) {
                  var r = i['font-size'] || v,
                    s = u(i);
                  return {
                    top: t - Math.round((1 + s.ascent) * r),
                    bottom: t + Math.round(s.descent * r),
                    left: e - Math.round(s.left * r) - 1,
                    right: e + n + Math.round(s.right * r) + 2,
                  };
                }
                function p(e, t) {
                  var n = e.value;
                  return 'symbol' === e.type
                    ? o.mfs.symMap[n.toUpperCase()] || 'x'
                    : n;
                }
                function f(e) {
                  function t(e) {
                    var t;
                    (t = n[e.type]), t && t(e);
                  }
                  var n = {},
                    i = 0,
                    r = 0,
                    s = 0,
                    o = 0,
                    a = '';
                  return (
                    (n.horizontal = function(e) {
                      for (var n = 0; n < e.value.length; ++n) t(e.value[n]);
                    }),
                    (n.style = function(e) {
                      for (var n = 0; n < e.value.length; n += 1)
                        !e.value[n].code && e.value[n].type && t(e.value[n]);
                    }),
                    (n.sub = function(e) {
                      o < ++s && (o = s), t(e.value[0]), t(e.value[1]), --s;
                    }),
                    (n.super = function(e) {
                      r < ++i && (r = i), t(e.value[0]), t(e.value[1]), --i;
                    }),
                    (n.text = function(e) {
                      a += p(e);
                    }),
                    (n.symbol = n.text),
                    t(e),
                    { maxSubscript: o, maxSuperscript: r, text: a }
                  );
                }
                function m(e, n, i) {
                  function s(e, t) {
                    var n;
                    (n = a[e.type]),
                      n
                        ? n(e, t)
                        : o.log('MFS-Canvas-Render does not support ' + e.type);
                  }
                  var a = {},
                    c = { left: P, top: C, right: P, bottom: C };
                  return (
                    (a.horizontal = function(e, t) {
                      for (var n = 0; n < e.value.length; ++n) s(e.value[n], t);
                    }),
                    (a.style = function(n, i) {
                      var r,
                        o,
                        a,
                        c,
                        u,
                        d = t.extend({}, i),
                        h = {},
                        p = [];
                      for (r = 0; r < n.value.length; r += 1)
                        n.value[r].code
                          ? (h[n.value[r].code] = n.value[r].value)
                          : n.value[r].type && p.push(n.value[r]);
                      h.fontFamily &&
                        i.fontTable &&
                        ((o = i.fontTable[parseInt(h.fontFamily, 16)]),
                        o && (d['font-family'] = o)),
                        h.fontSize
                          ? (d['font-size'] = parseInt(h.fontSize, 16) + 'px')
                          : 2 === Number(h.fontWeight) &&
                            (d['font-weight'] = 'bold'),
                        2 === Number(h.fontStyle) &&
                          (d['font-style'] = 'italic'),
                        2 === Number(h.underbar) &&
                          (d['text-decoration'] = 'underline'),
                        (h.red || h.green || h.blue) &&
                          ((a = h.red ? parseInt(h.red, 16) - 1 : 0),
                          (c = h.green ? parseInt(h.green, 16) - 1 : 0),
                          (u = h.blue ? parseInt(h.blue, 16) - 1 : 0),
                          (d.color = 'rgb(' + a + ',' + c + ',' + u + ')')),
                        e.save(),
                        l(e, d),
                        s(p[0], d),
                        e.restore();
                    }),
                    (a.sub = function(n, i) {
                      var r = t.extend({}, i),
                        o = Math.round(x * r['font-size']);
                      s(n.value[0], r),
                        (C += o),
                        e.save(),
                        (r['font-size'] = Math.round(y * r['font-size'])),
                        l(e, r),
                        s(n.value[1], r),
                        e.restore(),
                        (C -= o);
                    }),
                    (a.super = function(n, i) {
                      var r = t.extend({}, i),
                        o = Math.round(x * r['font-size']);
                      s(n.value[0], r),
                        (C -= o),
                        e.save(),
                        (r['font-size'] = Math.round(y * r['font-size'])),
                        l(e, r),
                        s(n.value[1], r),
                        e.restore(),
                        (C += o);
                    }),
                    (a.text = function(t, n) {
                      var i = p(t),
                        s = e.measureText(i),
                        a = h(P, C, s.width, n);
                      if (
                        (e.fillText(i, P, C),
                        'underline' === n['text-decoration'])
                      ) {
                        var l = Math.round(C + 2) + 0.5;
                        r(e, { x: P, y: l }, { x: P + s.width, y: l }),
                          (a.bottom = Math.max(a.bottom, l + 1));
                      }
                      (c = o.Geom.unionRects(c, a)), (P += s.width);
                    }),
                    (a.symbol = a.text),
                    s(n, i),
                    c
                  );
                }
                function g() {
                  return {
                    fontTable: a.fontTable,
                    'font-weight': a['font-weight'],
                    'font-style': a['font-style'],
                    'text-decoration': a['text-decoration'],
                    'font-size': a['font-size'],
                    'font-family': a['font-family'],
                    color: a.color,
                  };
                }
                var b = s.context,
                  v = 18,
                  y = 0.7,
                  x = 0.2,
                  w = Math.round(c.x),
                  k = Math.round(c.y) - 4,
                  P = w,
                  C = k;
                if (c.renderable) {
                  var S,
                    A,
                    T = c.useDrawImage ? null : b,
                    M = e.devicePixelRatio || 1,
                    I = a['font-size'] || v;
                  if (
                    ((c.constraintFrame !== a.constraintFrame ||
                      c.forceDomParse) &&
                      (c.parsedMFS !== a.parsedMFS &&
                        ((a.parsedMFS = c.parsedMFS),
                        c.useDrawImage &&
                          (a.mfsImage ||
                            (a.mfsImage = i.createElement('canvas')),
                          (S = g()),
                          (A = d(b, S, a.parsedMFS)),
                          (a.mfsImage.width = Math.round(A.width * M)),
                          (a.mfsImage.height = Math.round(A.height * M)),
                          (T = a.mfsImage.getContext('2d')),
                          T.scale(M, M))),
                      (a.constraintFrame = c.constraintFrame)),
                    a.parsedMFS && T)
                  ) {
                    S || (S = g());
                    var F = u(S);
                    c.useDrawImage &&
                      ((a.imageOffset = {
                        x: Math.round(I * F.left),
                        y: Math.round(I * F.ascent),
                      }),
                      (P = a.imageOffset.x),
                      (C = a.imageOffset.y)),
                      c.useDrawImage ||
                        (b.save(), (b.globalAlpha *= c.opacity)),
                      l(T, S),
                      (T.textBaseline = 'alphabetic'),
                      (C += I),
                      (a.baseRenderBounds = m(T, a.parsedMFS, S)),
                      c.useDrawImage || b.restore();
                  }
                  c.useDrawImage && a.mfsImage
                    ? ((w -= a.imageOffset.x),
                      (k -= a.imageOffset.y),
                      b.save(),
                      1 !== M && b.scale(1 / M, 1 / M),
                      b.drawImage(a.mfsImage, w * M, k * M),
                      (a.renderBounds = o.Geom.offsetRect(
                        a.baseRenderBounds,
                        w,
                        k
                      )),
                      b.restore())
                    : (a.renderBounds = a.baseRenderBounds);
                }
              },
              cleanup: function(e, t, n) {},
            },
            Picture: { prepare: b, draw: v, cleanup: y },
            Axis: {
              prepare: function(e, t) {},
              draw: function(e, t, i) {
                function s(e, t) {
                  if (0 >= t) return e;
                  var n = e,
                    i = 18,
                    r = 0.8,
                    s = 0.8,
                    o = 6;
                  for (e >= i && (n *= r); t > 0; --t) n *= s;
                  return Math.max(Math.round(n), o);
                }
                function a() {
                  S.save(),
                    S.setLineDash(i.lineDash || []),
                    'horizontal' === i.orientation
                      ? r(S, { x: y, y: v }, { x: x, y: v })
                      : r(S, { x: v, y: y }, { x: v, y: x }),
                    S.restore();
                }
                function c() {
                  var e,
                    t,
                    n,
                    s,
                    o = i.majorTickLength;
                  for (
                    n = ~~((y - b) / A), s = ~~((x - b) / A), t = n;
                    s >= t;
                    ++t
                  )
                    (e = b + t * A),
                      0 !== t &&
                        ('horizontal' === i.orientation
                          ? r(S, { x: e, y: v - o }, { x: e, y: v + o })
                          : r(S, { x: v - o, y: e }, { x: v + o, y: e }));
                }
                function l(e, t) {
                  if (e !== ~~e) {
                    var n = Math.pow(10, t);
                    return Math.round(e * n) / n;
                  }
                  return e;
                }
                function u(e) {
                  var t = e.toExponential(i.precisionInfo.precision),
                    n = t.indexOf('e'),
                    r = (+t.substr(0, n)).toString(),
                    s = '+' === t[n + 1] ? n + 2 : n + 1,
                    o = t.substr(s);
                  return {
                    type: 'exponential',
                    primary: r + '●10',
                    secondary: o.toString(),
                  };
                }
                function d(e, t) {
                  var n,
                    r,
                    s,
                    a,
                    c = 72,
                    u = o.math.reduceFraction(Math.abs(e), M);
                  if (u.denominator > 1 && u.denominator <= c) {
                    var d = '';
                    1 !== u.numerator && (d += u.numerator),
                      (a = {
                        type: 'fraction',
                        negative: 0 > e,
                        primary: d,
                        secondary: u.denominator.toString(),
                        pi: !0,
                      });
                  } else
                    u.denominator < 72
                      ? ((n = l(t / Math.PI, i.precisionInfo.precision)),
                        (r = 0 > n ? '-' : ''),
                        (n = Math.abs(n)),
                        (s = r),
                        1 !== n && (s += n),
                        (a = { type: 'simple', primary: s, pi: !0 }))
                      : ((n = l(t, i.precisionInfo.precision)),
                        (a = { type: 'simple', primary: n.toString() }));
                  return a;
                }
                function h(e, t) {
                  var n,
                    r = t,
                    s = Math.abs(r);
                  return (
                    s < i.precisionInfo.smallExponentBound ||
                    s > i.precisionInfo.largeExponentBound
                      ? (n = u(r))
                      : 'trigonometric' === i.tickNumbering
                      ? (n = d(e, t))
                      : ((r = l(r, i.precisionInfo.precision)),
                        (n = { type: 'simple', primary: r.toString() })),
                    n.primary && (n.primary = n.primary.replace('-', O)),
                    n
                  );
                }
                function p(e, t, n) {
                  var o,
                    a,
                    c,
                    l,
                    u,
                    d = e.primary && S.measureText(e.primary),
                    h = 1,
                    p = 2,
                    f = S.textBaseline,
                    m = {};
                  if (
                    (e.pi &&
                      (k || (k = I + 'px Symbol'),
                      P ||
                        ((S.font = k), (P = S.measureText(j)), (S.font = F))),
                    (a = d ? d.width : 0),
                    e.pi && (a && (a += h), (a += P.width)),
                    'simple' === e.type)
                  )
                    (c = I),
                      'horizontal' === i.orientation
                        ? ((m.x = t), (m.y = Math.round(v + n + c / 2) - 0.5))
                        : ((m.x = v - n - a / 2), (m.y = Math.round(t) - 1.5)),
                      (l = m.x - a / 2),
                      (u = m.y + I / 2 + 2),
                      (S.textBaseline = 'bottom'),
                      e.primary &&
                        (S.fillText(e.primary, l, u), (l += d.width + h)),
                      e.pi && ((S.font = k), S.fillText(j, l, u), (S.font = F));
                  else if ('exponential' === e.type) {
                    var g = s(i['font-size'], 2),
                      b = 1,
                      y = {};
                    w || (w = g + 'px ' + i['font-family']),
                      (S.font = w),
                      (o = S.measureText(e.secondary)),
                      (a += b + o.width),
                      (c = I + g),
                      'horizontal' === i.orientation
                        ? ((m.x = t), (m.y = Math.round(v + n + c / 2) + 0.5))
                        : ((m.x = v - n - a / 2), (m.y = Math.round(t) + 0.5)),
                      (S.textBaseline = 'middle'),
                      (l = m.x - a / 2),
                      (y.x = l + d.width + b),
                      (y.y = m.y - I / 2),
                      S.fillText(e.secondary, y.x, y.y),
                      (S.font = F),
                      S.fillText(e.primary, l, m.y);
                  } else if ('fraction' === e.type) {
                    !C && e.negative && (C = S.measureText(O)),
                      (o = S.measureText(e.secondary));
                    var x,
                      A,
                      T,
                      M = a,
                      L = o.width,
                      G = Math.max(M, L) + 2,
                      D = 5,
                      R = (G - M) / 2,
                      N = (G - L) / 2;
                    (a = Math.max(M, L) + 2),
                      e.negative && (a += C.width + p),
                      (c = 2 * (E + 4)),
                      'horizontal' === i.orientation
                        ? ((m.x = t), (m.y = Math.round(v + n + c / 2) - 1.5))
                        : ((m.x = v - n - a / 2 - 1),
                          (m.y = Math.round(t) + 0.5)),
                      e.negative
                        ? ((S.textBaseline = 'middle'),
                          S.fillText(O, m.x - a / 2, m.y - 1),
                          (x = m.x - a / 2 + C.width + p))
                        : (x = m.x - a / 2),
                      (A = x + G),
                      (T = (x + A) / 2),
                      (S.lineWidth = 1),
                      r(S, { x: x, y: m.y }, { x: A, y: m.y }),
                      (l = x + R),
                      (u = m.y - D - 1),
                      (S.textBaseline = 'alphabetic'),
                      e.primary &&
                        (S.fillText(e.primary, l, u), (l += d.width + h)),
                      e.pi && ((S.font = k), S.fillText(j, l, u), (S.font = F)),
                      (l = x + N),
                      (u = m.y + D - Math.round(I / 6)),
                      (S.textBaseline = 'top'),
                      S.fillText(e.secondary, l, u);
                  }
                  S.textBaseline = f;
                }
                function f() {
                  var e,
                    t,
                    n,
                    r,
                    s,
                    o,
                    a = A * i.tickSpacing.largeIntervalsPerText,
                    c = i.majorTickLength + 3;
                  for (
                    n = ~~((y - b) / a) - 1,
                      r = ~~((x - b) / a) + 1,
                      S.font = F,
                      S.textAlign = 'left',
                      t = n;
                    r >= t;
                    ++t
                  )
                    if (0 !== t) {
                      var l = t * i.tickSpacing.largeIntervalsPerText;
                      (e = b + t * a),
                        (s = (t * a) / i.unitPixels),
                        i.isPolar
                          ? ((l = Math.abs(l)), (s = Math.abs(s)))
                          : 'vertical' === i.orientation &&
                            ((l = -l), (s = -s)),
                        (o = h(l, s)),
                        p(o, e, c);
                    }
                }
                var m,
                  g,
                  b,
                  v,
                  y,
                  x,
                  w,
                  k,
                  P,
                  C,
                  S = e.context,
                  A =
                    i.tickSpacing.pixelsBetweenTicks *
                    i.tickSpacing.largeTickInterval,
                  T = Math.PI * i.unitPixels,
                  M = Math.round(T / A),
                  I = s(i['font-size'], 1),
                  F = I + 'px ' + i['font-family'],
                  E = I,
                  j = 'π',
                  O = '−';
                'horizontal' === i.orientation
                  ? ((m = i.sketchRect.left),
                    (g = i.sketchRect.right),
                    (b = i.origin.x),
                    (v = i.origin.y))
                  : ((m = i.sketchRect.top),
                    (g = i.sketchRect.bottom),
                    (b = i.origin.y),
                    (v = i.origin.x)),
                  (y = m - 1),
                  (x = g + 1),
                  i.renderable &&
                    (S.save(),
                    n !== i.width && (S.lineWidth = i.width),
                    n !== i.color &&
                      ((S.fillStyle = i.color), (S.strokeStyle = i.color)),
                    n !== i.opacity && (S.globalAlpha *= i.opacity),
                    a(),
                    c(),
                    'auto' === i.tickNumberStyle && f(),
                    S.restore());
              },
              cleanup: function(e, t, n) {},
            },
            CoordSys: {
              prepare: function(e, t) {},
              draw: function(e, t, i) {
                function s(e) {
                  r(y, { x: C, y: e }, { x: S, y: e });
                }
                function o(e) {
                  for (h = p; f >= h; ++h)
                    (d = i.origin.x + h * i.gridSpacing.x),
                      a(y, { x: d, y: e }, i.radius);
                }
                function c() {
                  if ('gridlines' === i.grid)
                    for (h = p; f >= h; ++h)
                      (d = i.origin.x + h * i.gridSpacing.x),
                        r(y, { x: d, y: A }, { x: d, y: T });
                  var e = s;
                  for (
                    'dotted' === i.grid && ((e = o), (y.fillStyle = i.color)),
                      g = b;
                    v >= g;
                    ++g
                  )
                    (m = i.origin.y + g * i.gridSpacing.y), e(m);
                }
                function l() {
                  function e(e, t, n) {
                    var r,
                      s = { x: 0, y: 0 },
                      o = i.radius,
                      c = [
                        { cos: 1, sin: 0 },
                        { cos: 0.96592582628907, sin: 0.25881904510252 },
                        { cos: 0.86602540378444, sin: 0.5 },
                        { cos: 0.70710678118655, sin: 0.70710678118655 },
                        { cos: 0.5, sin: 0.86602540378444 },
                        { cos: 0.25881904510252, sin: 0.96592582628907 },
                        { cos: 0, sin: 1 },
                      ];
                    for (e.fillStyle = i.color, r = 0; 7 > r; ++r)
                      (s.x = n.x * c[r].cos),
                        (s.y = n.y * c[r].sin),
                        a(e, { x: t.x + s.x, y: t.y - s.y }, o),
                        r > 0 &&
                          6 > r &&
                          a(e, { x: t.x - s.x, y: t.y - s.y }, o),
                        a(e, { x: t.x - s.x, y: t.y + s.y }, o),
                        r > 0 &&
                          6 > r &&
                          a(e, { x: t.x + s.x, y: t.y + s.y }, o);
                  }
                  function t(e, t, n, i) {
                    return 0 === e
                      ? i.min <= t[0][n] && t[0][n] <= i.max
                      : e > 0
                      ? t[0][n] > i.max
                        ? t[1][n] <= i.max
                        : t[0][n] >= i.min
                      : 0 > e
                      ? t[0][n] < i.min
                        ? t[1][n] >= i.min
                        : t[0][n] <= i.max
                      : void 0;
                  }
                  for (
                    var n = Math.max(Math.abs(p), Math.abs(f)),
                      s = Math.max(Math.abs(b), Math.abs(v)),
                      o = 1,
                      c = n + s,
                      l = n * n + s * s,
                      d = i.gridSpacing.y / i.gridSpacing.x,
                      h = 0 >= p * f,
                      m = 0 >= b * v;
                    c * c > l;

                  )
                    --c;
                  if ((++c, !h || !m)) {
                    var g = Math.min(Math.abs(p), Math.abs(f)),
                      x = Math.min(Math.abs(b), Math.abs(v));
                    if (h) o = x;
                    else if (m) o = g;
                    else {
                      for (var w = g * g + x * x; w >= o * o; ) ++o;
                      --o;
                    }
                  }
                  var k,
                    P = 'dotted' === i.grid ? e : u;
                  for (k = 1; c >= k; ++k) {
                    var M = { x: k * i.gridSpacing.x, y: k * i.gridSpacing.y };
                    P(y, i.origin, M);
                  }
                  if ('gridlines' === i.grid) {
                    var I,
                      F,
                      E = Math.PI / 12,
                      j = -2 * E,
                      O = { x: i.origin.x, y: i.origin.y },
                      L = { x: i.origin.x, y: i.origin.y },
                      G = [
                        { x: O.x, y: O.y },
                        { x: L.x, y: L.y },
                      ];
                    for (
                      O = { x: C - i.origin.x, y: i.origin.y },
                        G[0].x = C,
                        L.x = S - i.origin.x,
                        G[1].x = S,
                        k = 0;
                      5 > k;
                      ++k
                    )
                      (I = j + k * E),
                        (F = -Math.tan(I) * d),
                        (G[0].y = i.origin.y + O.x * F),
                        (G[1].y = i.origin.y + L.x * F),
                        t(I, G, 'y', { min: A, max: T }) && r(y, G[0], G[1]);
                    for (
                      d = 1 / d,
                        O.y = A - i.origin.y,
                        G[0].y = A,
                        L.y = T - i.origin.y,
                        G[1].y = T,
                        j = 3 * E,
                        k = 0;
                      7 > k;
                      ++k
                    )
                      (I = j - k * E),
                        (F = -Math.tan(I) * d),
                        (G[0].x = i.origin.x + O.y * F),
                        (G[1].x = i.origin.x + L.y * F),
                        t(I, G, 'x', { min: C, max: S }) && r(y, G[0], G[1]);
                  }
                }
                var d,
                  h,
                  p,
                  f,
                  m,
                  g,
                  b,
                  v,
                  y = e.context,
                  x = i.sketchRect.left,
                  w = i.sketchRect.right,
                  k = i.sketchRect.top,
                  P = i.sketchRect.bottom,
                  C = x - 1,
                  S = w + 1,
                  A = k - 1,
                  T = P + 1;
                i.renderable &&
                  ((p = ~~((C - i.origin.x) / i.gridSpacing.x)),
                  (f = ~~((S - i.origin.x) / i.gridSpacing.x)),
                  (b = ~~((A - i.origin.y) / i.gridSpacing.y)),
                  (v = ~~((T - i.origin.y) / i.gridSpacing.y)),
                  y.save(),
                  n !== i.width && (y.lineWidth = i.width),
                  n !== i.color && (y.strokeStyle = i.color),
                  n !== i.opacity && (y.globalAlpha *= i.opacity),
                  'polar' === i.shape ? l() : c(),
                  y.restore());
              },
              cleanup: function(e, t, n) {},
            },
            AngleMarker: function(e, t, n) {
              if (n.renderable) {
                var i,
                  r,
                  s,
                  o = e.context,
                  a = n.firstArc,
                  c = a.radius,
                  l = n.isRight,
                  u = l ? g : m,
                  d = 0.7071067811865475,
                  h = l ? d : 1;
                for (
                  o.save(),
                    o.globalAlpha *= n.fadeOpacity,
                    o.strokeStyle = n.color,
                    o.fillStyle = n.color,
                    o.lineWidth = n.width,
                    o.setLineDash(n.lineDash || []),
                    i = 0;
                  i < n.strokes;
                  i += 1
                )
                  (r = c * h + i * (n.radialSpacing + n.width)),
                    (s = 'none'),
                    i + 1 === n.strokes &&
                      n['show-angle-direction'] &&
                      (s = 'head'),
                    u(o, a, r, n.width, s, 0 === i, n.opacity);
                o.restore();
              }
            },
            PathMarker: function(e, t, n) {
              var i,
                r,
                s,
                a,
                c,
                l = e.context,
                u = n['tick-mark-style'],
                d = n.metrics,
                h = d.origin.copy();
              if (n.renderable) {
                if (
                  (l.save(),
                  (l.globalAlpha *= n.opacity),
                  (l.strokeStyle = n.color),
                  (l.fillStyle = n.color),
                  (l.lineWidth = n.width),
                  l.setLineDash(n.lineDash || []),
                  (l.lineCap = 'round'),
                  'Crossbar' === u)
                )
                  for (i = 0; i < n.strokes; i += 1, h = h.add(d.delta))
                    l.beginPath(),
                      (r = h.subtract(d.normal)),
                      (s = h.add(d.normal)),
                      l.moveTo(r.x, r.y),
                      l.lineTo(s.x, s.y),
                      l.stroke();
                else
                  for (
                    a = o.GeometricPoint(
                      -d.normal.x - d.normal.y,
                      d.normal.x - d.normal.y
                    ),
                      c = o.GeometricPoint(
                        -d.normal.x + d.normal.y,
                        -d.normal.x - d.normal.y
                      ),
                      i = 0;
                    i < n.strokes;
                    i += 1, h = h.add(d.delta)
                  )
                    l.beginPath(),
                      (r = h.add(a)),
                      (s = h.subtract(c)),
                      l.moveTo(r.x, r.y),
                      l.lineTo(h.x, h.y),
                      l.lineTo(s.x, s.y),
                      'OpenArrow' === u
                        ? l.stroke()
                        : 'HollowArrow' === u
                        ? (l.closePath(), l.stroke())
                        : l.fill();
                n.isFocusable && this.Rectangle(e, t, n), l.restore();
              }
            },
            ContinuousPointVector: function(e, t, n) {
              function i(e, t, n, i, r, s) {
                var a = o.GeometricPoint(e, t),
                  c = o.GeometricPoint(n, i),
                  l = c
                    .subtract(a)
                    .unit()
                    .multiply(r);
                return f(a.add(l), a, s);
              }
              if (n.renderable) {
                var r,
                  c,
                  l = e.context,
                  u = n.samples,
                  h = u.length,
                  p = h / 2;
                l.save(),
                  (l.globalAlpha *= n.opacity),
                  (l.lineWidth = n.width),
                  n.color && (l.strokeStyle = n.color),
                  s(l, u, n.discontinuities, n.colors, n.closedPath),
                  'endpoint' === n.leftEndpoint
                    ? ((r = o.GeometricPoint(u[0], u[1])),
                      (l.fillStyle = n.colors ? n.colors[0] : n.color),
                      a(l, r, n.endpointRadius))
                    : 'arrowhead' === n.leftEndpoint &&
                      ((l.fillStyle = n.colors ? n.colors[0] : n.color),
                      (l.strokeStyle = n.colors ? n.colors[0] : n.color),
                      d(
                        l,
                        i(u[0], u[1], u[2], u[3], n.arrowheadRadius, n.width),
                        !0
                      )),
                  'endpoint' === n.rightEndpoint
                    ? ((c = o.GeometricPoint(u[h - 2], u[h - 1])),
                      (l.fillStyle = n.colors ? n.colors[p - 1] : n.color),
                      a(l, c, n.endpointRadius))
                    : 'arrowhead' === n.rightEndpoint &&
                      ((l.fillStyle = n.colors ? n.colors[p - 1] : n.color),
                      (l.strokeStyle = n.colors ? n.colors[p - 1] : n.color),
                      d(
                        l,
                        i(
                          u[h - 2],
                          u[h - 1],
                          u[h - 4],
                          u[h - 3],
                          n.arrowheadRadius,
                          n.width
                        ),
                        !0
                      )),
                  l.restore();
              }
            },
            DiscretePointVector: function(e, t, n) {
              if (n.renderable) {
                var i = e.context;
                i.save(),
                  (i.globalAlpha *= n.opacity),
                  n.color && (i.fillStyle = n.color),
                  l(i, n.samples, n.numSamples, n.radius, n.colors),
                  i.restore();
              }
            },
            SegmentVector: function(e, t, n) {
              if (n.renderable) {
                var i,
                  r,
                  s,
                  o,
                  a,
                  c = e.context,
                  l = 4,
                  u = n.numSamples;
                for (
                  c.save(),
                    c.globalAlpha *= n.opacity,
                    c.lineWidth = n.width,
                    c.strokeStyle = n.color,
                    c.setLineDash(n.lineDash || []),
                    i = 0;
                  u > i;
                  i++
                )
                  (r = n.samples[i * l]),
                    (s = n.samples[i * l + 1]),
                    (o = n.samples[i * l + 2]),
                    (a = n.samples[i * l + 3]),
                    n.colors && (c.strokeStyle = n.colors[i]),
                    c.beginPath(),
                    c.moveTo(r, s),
                    c.lineTo(o, a),
                    (c.lineCap = 'round'),
                    c.stroke();
                c.setLineDash([]), c.restore();
              }
            },
            ArcVector: function(e, t, n) {
              if (n.renderable) {
                var i,
                  r,
                  s = e.context,
                  a = n.numSamples,
                  l = n.arcType,
                  u = 'arc' !== l;
                for (
                  s.save(),
                    s.globalAlpha *= n.opacity,
                    u
                      ? (s.fillStyle = n.color)
                      : ((s.lineWidth = n.width),
                        (s.strokeStyle = n.color),
                        s.setLineDash(n.lineDash || [])),
                    i = 0;
                  a > i;
                  i++
                )
                  (r = o.GeometricArc.FromPackedSampleArray(n.samples, i)),
                    n.colors &&
                      (u
                        ? (s.fillStyle = n.colors[i])
                        : (s.strokeStyle = n.colors[i])),
                    c(s, r),
                    'arcSegment' === l
                      ? s.closePath()
                      : 'arcSector' === l &&
                        (s.lineTo(r.center.x, r.center.y), s.closePath()),
                    u ? s.fill() : s.stroke();
                s.setLineDash([]), s.restore();
              }
            },
            CircleVector: function(e, t, n) {
              if (n.renderable) {
                var i,
                  r,
                  s,
                  o,
                  a,
                  c = e.context,
                  l = 3,
                  u = n.numSamples,
                  d = n.isInterior;
                for (
                  c.save(),
                    c.globalAlpha *= n.opacity,
                    d
                      ? (c.fillStyle = n.color)
                      : ((c.lineWidth = n.width), (c.strokeStyle = n.color)),
                    c.setLineDash(n.lineDash || []),
                    i = 0;
                  u > i;
                  i++
                )
                  (r = i * l),
                    (s = n.samples[r]),
                    (o = n.samples[r + 1]),
                    (a = n.samples[r + 2]),
                    n.colors &&
                      (d
                        ? (c.fillStyle = n.colors[i])
                        : (c.strokeStyle = n.colors[i])),
                    c.beginPath(),
                    c.arc(s, o, a, 0, 2 * Math.PI, !0),
                    d ? c.fill() : c.stroke();
                c.setLineDash([]), c.restore();
              }
            },
            PolygonVector: function(e, t, n) {
              var i,
                r,
                s = e.context,
                o = n.samples,
                a = n.numVertices,
                c = n.numSamples,
                l = 0;
              if (n.renderable) {
                for (
                  s.save(),
                    s.fillStyle = n.color,
                    s.globalAlpha *= n.opacity,
                    i = 0;
                  c > i;
                  i++
                ) {
                  for (
                    n.colors && (s.fillStyle = n.colors[i]),
                      s.beginPath(),
                      s.moveTo(o[l], o[l + 1]),
                      l += 2,
                      r = 1;
                    a > r;
                    r++
                  )
                    s.lineTo(o[l], o[l + 1]), (l += 2);
                  s.closePath(), s.fill('evenodd');
                }
                s.restore();
              }
            },
            PictureVector: {
              prepare: b,
              draw: function(e, t, n) {
                for (
                  var i = n.transformSamples, r = n.numSamples, s = 0;
                  r > s;
                  ++s
                )
                  (n.transform = o.AffineTransform.fromPackedSampleArray(i, s)),
                    (n.clipPolygon = n.clipPolygons && n.clipPolygons[s]),
                    v(e, t, n);
              },
              cleanup: y,
            },
          },
        };
      })(),
      (function() {
        function e(e, t, n, i) {
          var r;
          try {
            return (r = o.mfs.makeHTMLFromMFSParseTree(e, t, n, i));
          } catch (e) {
            o.signalCaughtError(e);
          }
        }
        function i(i, r, s, o) {
          function a(e) {
            var t,
              n,
              i = o,
              r = e[0].style;
            if (r && r.length > 0)
              for (i = {}, t = 0; t < r.length; t++) (n = r[t]), (i[n] = r[n]);
            return i;
          }
          var c,
            l,
            u,
            d,
            h = r.lastRealizedFrame,
            p = !1;
          if (i && r)
            for (c in r)
              if (r.hasOwnProperty(c) && i.hasOwnProperty(c))
                for (l = i[c], u = 0; u < l.length; u += 1)
                  (h && h.hasOwnProperty(c) && h[c] === r[c]) ||
                    ('text' === r[c].type
                      ? ((d = r[c].value), t(l[u]).text(d))
                      : (l[u].empty(), e(r[c], l[u], s, a(l[u]))),
                    r[c].referenceId !== n &&
                      (l[u].toggleClass('wsp-mfs-reference', !0),
                      l[u].data('wsp-mfs-reference-id', r[c].referenceId)),
                    (p = !0));
          if (p) {
            r.lastRealizedFrame = n;
            var f = t.extend(!0, {}, r);
            r.lastRealizedFrame = f;
          }
          return p;
        }
        function s(e, n, i) {
          function r(e, t) {
            c.forEach(function(n, i) {
              n.indexOf(e) > -1 && (c[i] = t);
            });
          }
          var s,
            a = '',
            c = [],
            l = [];
          (this.speakableText = e),
            this.speakableText && (l = this.speakableText.split(' ')),
            l.forEach(function(e, t) {
              e.indexOf('<%') > -1 && c.push(e);
            });
          for (s in n)
            if (
              this.speakableText &&
              this.speakableText.indexOf('<%' + s + '>') > -1
            ) {
              (a =
                'text' === n[s].type
                  ? n[s].value
                  : o.mfs.makeSpeakableTextFromMFSParseTree(n[s])),
                this.isCompositeText && r(s, a);
              var u = '<%' + s + '>',
                d = new RegExp(u, 'g');
              this.speakableText = this.speakableText.replace(d, a);
            }
          var h = '';
          (h =
            'Text' === this.kind ||
            'Expression' === this.kind ||
            'Measure' === this.kind ||
            'Button' === this.kind
              ? this.speakableText
              : this.kind +
                ' ' +
                (this.genus ? o.mfs.updatedGenus[this.genus] + ' ' : '') +
                this.speakableText),
            this.mfsElementSrOnly
              ? (this.mfsElementSrOnly.text(h).attr('aria-label', h),
                this.isParameter &&
                  i
                    .find('.mfs-input')
                    .attr(
                      'aria-label',
                      a + ' editable. Click or double tap to edit.'
                    ),
                this.isCompositeText &&
                  i
                    .find('.mfs-param')
                    .each(function(e) {
                      t(this).attr('aria-label', c[e]);
                    })
                    .attr({ tabindex: 0, role: 'button' }))
              : i.attr('aria-label', h),
            this.lastSpeakableText ||
              (this.lastSpeakableText = this.speakableText);
        }
        var a = r.userAgent.toLowerCase().indexOf('firefox') > -1,
          c = {
            initWithAttrs: function(e) {
              (this.fontTable = e.fontTable),
                (this.baseStyles = {
                  color: e.color,
                  'font-family': e['font-family'],
                  'font-style': e['font-style'],
                  'font-weight': e['font-weight'],
                  'font-size': e['font-size'],
                  'text-decoration': e['text-decoration'],
                });
            },
            width: function() {
              return t(this.element).outerWidth();
            },
            height: function() {
              return t(this.element).outerHeight();
            },
            draw: function(e, t) {
              var i,
                r = this.element,
                s = 'visible' === t.visibility,
                o = s || t.measurable;
              !r && o && (r = this.createAndAddElement(e)),
                r &&
                  o &&
                  ((i = t.zIndex),
                  i !== n && r.css('z-index') != i && r.css('z-index', i),
                  (t.constraintFrame !== this.constraintFrame ||
                    t.forceDomParse) &&
                    (this.updateFromModel(t),
                    (this.constraintFrame = t.constraintFrame)),
                  this.updateModelToViewTransform(e.modelToViewTransform),
                  this.prepareToShow(r, t),
                  this.setOpacity(r, t),
                  r.outerWidth(t.width ? t.width : ''),
                  r.outerHeight(t.height ? t.height : '')),
                this.visible !== s && (r && r.toggle(s), (this.visible = s));
            },
            prepareToShow: function(e, t) {},
            didShow: function(e) {},
            setOpacity: function(e, t) {
              e.css({ opacity: t.opacity });
            },
            updateModelToViewTransform: function(e) {
              var t,
                n = this.element;
              a && e.isTranslation()
                ? n.css({ left: this.left + e.m20, top: this.top + e.m21 })
                : ((t = e.toStringCSS()),
                  n.css({ left: this.left, top: this.top, transform: t }));
            },
            createAndAddElement: function() {
              throw o.createError(
                'capability not implemented (createAndAddElement)'
              );
            },
            updateFromModel: function() {
              throw o.createError(
                'capability not implemented (updateFromModel)'
              );
            },
          },
          l = Object.create(c);
        (l.createAndAddElement = function(e, n) {
          var i = e.layer,
            r = '',
            s = 'div';
          n
            ? ((r = 'type="button" role="button" tabindex="0"'), (s = 'button'))
            : this.isParameter ||
              this.isCompositeText ||
              (r = 'role="text" tabindex="0"');
          var a = t(
              '<' +
                s +
                ' wsp-id="' +
                this.id +
                '" class="wsp-accessible wsp-' +
                this.kind +
                '" ' +
                r +
                '/>'
            ),
            c = a;
          if (
            (n &&
              ((c = t('<div class="wsp-Button-label"></div>')),
              c.wrap('<div class="wsp-Button-label-frame"></div>'),
              a.append(
                t(
                  '<span class="wsp-Button-row"><span class="wsp-Button-drag-handle"></span></span>'
                ).append(c.parent())
              )),
            (this.element = a),
            (this.mfsElement = c),
            a.css(this.css),
            a.hide(),
            (this.visible = !1),
            a.appendTo(i),
            this.isEditableByCalculator)
          ) {
            var l = o.getConfigValue(
              'NumberpadManager.delegates.registerCalculatorElement'
            );
            l(a);
          }
          return a;
        }),
          (l.updateFromModel = function(n) {
            var r, a, c;
            if (
              (n.parsedMFS &&
                this.parsedMFS !== n.parsedMFS &&
                ((this.parsedMFS = n.parsedMFS),
                this.mfsElement.empty(),
                (this.isParameter || this.isCompositeText) &&
                  ((this.mfsElementSrOnly = t(
                    '<div class="wsp-parameter-sr-only" tabindex="0" role="text" />'
                  )),
                  this.mfsElement.prepend(this.mfsElementSrOnly)),
                (this.valueMap = e(
                  this.parsedMFS,
                  this.mfsElement,
                  this.fontTable,
                  this.baseStyles
                )),
                (this.speakableTextMap = o.mfs.makeSpeakableTextFromMFSParseTree(
                  this.parsedMFS
                ))),
              n.MFSValues &&
                i.call(
                  this,
                  this.valueMap,
                  n.MFSValues,
                  this.fontTable,
                  this.baseStyles
                ),
              s.call(this, this.speakableTextMap, n.MFSValues, this.mfsElement),
              'center' === this.attrs['text-align']
                ? ((r = this.width() / 2), (c = n.x - r))
                : (c = n.x),
              'middle' === this.attrs['vertical-align']
                ? ((r = this.height() / 2), (a = n.y - r))
                : (a = n.y),
              'bottom' === this.attrs['vertical-align'])
            ) {
              var l = parseInt(t(this.element).css('padding-bottom'), 10),
                u = t(this.element).height();
              a = n.y - (u - l);
            }
            (this.isParameter || this.isCompositeText) &&
              this.mfsElementSrOnly &&
              this.mfsElement.find('.mfs-text').attr('aria-hidden', 'true'),
              (this.left = c),
              (this.top = a);
          });
        var u = Object.create(l);
        (u.createAndAddElement = function(e) {
          return l.createAndAddElement.call(this, e, !0);
        }),
          (u.dragHandleWidth = function() {
            return t('.wsp-Button-drag-handle', this.element).outerWidth();
          }),
          (u.prepareToShow = function(e, n) {
            e.toggleClass('wsp-appearance-active', !!n.isHighlight),
              e.toggleClass('wsp-appearance-pressed', !!n.inClick),
              e.toggleClass(
                'wsp-appearance-drag',
                !!n.isDragging && n.selectable
              ),
              e.toggleClass('wsp-appearance-short', e.outerHeight() < 28),
              e.toggleClass('wsp-appearance-unselectable', !n.selectable),
              t('.wsp-Button-drag-handle', e).css({
                'background-color': n['handle-color'],
              });
          }),
          (u.setOpacity = function(e, t) {
            e.css('opacity', '');
            var n = e.css('opacity');
            (n = n ? parseFloat(n) : 1),
              (n = isNaN(n) ? 1 : n),
              e.css({ opacity: t.opacity * n });
          });
        var d = Object.create(l);
        (d.didShow = function(e) {}),
          (d.prepareToShow = function(e, t) {
            e.toggleClass(
              'wsp-text-target-highlight',
              t.targetHighlight === !0
            ),
              e.toggleClass(
                'wsp-text-unmatched-given',
                t.unmatchedGiven === !0
              ),
              e.toggleClass('wsp-text-fancy-pulse', t.fancyPulse === !0);
          });
        var h = {
            createWithAttrs: function(e, n) {
              var i = Object.create(n ? u : d);
              return (
                i.initWithAttrs(e),
                (i.id = e.id),
                (i.kind = e.kind),
                (i.isEditableByCalculator = e.isEditableByCalculator),
                (i.selectable = e.selectable),
                (i.genus = e.genus),
                (i.isParameter = e.isParameter),
                (i.isCompositeText = e.isCompositeText),
                (i.wspSays = e.wspSays),
                (i.attrs = {
                  'text-align': e['text-align'],
                  'vertical-align': e['vertical-align'],
                }),
                (i.baseStyles['line-height'] = e['line-height']),
                (i.baseStyles.opacity = e.opacity),
                (i.css = { padding: e.padding }),
                t.extend(i.css, i.baseStyles),
                n &&
                  ((i.attrs['highlight-color'] = e['highlight-color']),
                  (i.attrs['handle-color'] = e['background-color'] || 'white')),
                i
              );
            },
          },
          p = Object.create(c);
        (p.createAndAddElement = function(e) {
          var n = t('<div tabindex="0" class="wsp-Table wsp-accessible"/>');
          return (
            (this.element = n),
            n.hide(),
            (this.visible = !1),
            n.appendTo(e.layer),
            n
          );
        }),
          (p.updateFromModel = function(n) {
            function i(n, i) {
              var r,
                s,
                a = t('<tr/>');
              for (s = 0; s < i.length; s++)
                (r = t('<' + n + '/>')),
                  y(r),
                  a.append(r),
                  e(i[s], r, m, g),
                  r
                    .children()
                    .attr({
                      role: 'text',
                      'aria-label': o.mfs.makeSpeakableTextFromMFSParseTree(
                        i[s]
                      ),
                    }),
                  r
                    .children()
                    .children()
                    .attr('aria-hidden', 'true');
              b.append(a);
            }
            var r,
              s,
              a,
              c = n.kind + ' ' + n.genus,
              l = n.label ? 'aria-label="' + n.label + '"' : '',
              u = n.rowsMFS,
              d = n.headersMFS,
              h = n.finalRowMFS,
              p = this.attrs['border-color'],
              f = this.element,
              m = this.fontTable,
              g = this.baseStyles,
              b = t('<table aria-labelledby="wsp-id-' + n.id + '" />'),
              v = t('<div role="document" tabindex="0" ' + l + ' />'),
              y = function(e) {
                e.addClass('wsp-responsive-borderwidth'),
                  e.css('border-color', p);
              },
              x =
                this.headersMFS !== d ||
                this.rowsMFS !== u ||
                this.finalRowMFS !== h;
            if (
              ((this.headersMFS = d),
              (this.rowsMFS = u),
              (this.finalRowMFS = h),
              f.attr({ 'wsp-id': n.id, 'aria-label': c, id: 'wsp-id-' + n.id }),
              x)
            ) {
              for (
                f.empty(),
                  y(f),
                  f.css('background-color', n['background-color']),
                  y(b),
                  b.css('font-size', g['font-size']),
                  i('th', d),
                  a = 0;
                a < u.length;
                a++
              )
                i('td', u[a]);
              h && i(u.length > 0 ? 'td class="wsp-final-row-cell"' : 'td', h),
                v.append(b),
                f.append(v);
            }
            (s = n.x), (r = n.y), (this.left = s), (this.top = r);
          });
        var f = {
          createWithAttrs: function(e) {
            var t = Object.create(p);
            return (
              t.initWithAttrs(e),
              (t.attrs = {
                'border-color': e['border-color'],
                opacity: e.opacity,
              }),
              t
            );
          },
        };
        o.draw.availableEngines.html = {
          create: function(e) {
            var n = e.rootNode,
              i = t('<div class="wsp-text-layer"></div>').appendTo(t(n));
            return (
              i.css({ width: '100%', height: '100%' }),
              { layer: i, modelToViewTransform: null }
            );
          },
          destroy: function(e) {},
          prepareFrame: function(e, t, n, i) {
            e.modelToViewTransform = i;
          },
          cleanupFrame: function(e) {},
          clear: function(e) {
            e.layer.remove();
          },
          primitives: {
            Text: {
              prepare: function(e, t) {
                return h.createWithAttrs(t);
              },
              draw: function(e, t, n) {
                return t.draw(e, n);
              },
              cleanup: function(e, n, i) {
                t(n.element).remove();
              },
            },
            Button: {
              prepare: function(e, t) {
                return h.createWithAttrs(t, !0);
              },
              draw: function(e, t, n) {
                return t.draw(e, n);
              },
              cleanup: function(e, n, i) {
                t(n.element).remove();
              },
            },
            Table: {
              prepare: function(e, t) {
                return f.createWithAttrs(t);
              },
              draw: function(e, t, n) {
                return t.draw(e, n);
              },
              cleanup: function(e, n, i) {
                t(n.element).remove();
              },
            },
            Point: {
              prepare: function(e, n) {
                var i = {
                  rendered: !1,
                  element: t(
                    '<div class="wsp-' +
                      n.kind +
                      '" id="' +
                      n.id +
                      '">&#x2b24;</div>'
                  ),
                };
                return i.element.css({ visibility: 'hidden' }), i;
              },
              draw: function(e, n, i) {
                var r,
                  s,
                  o,
                  a = n.element,
                  c = i.renderable ? 'visible' : 'hidden';
                n.rendered ||
                  'visible' !== c ||
                  ((o = e.layer), (n.rendered = !0), t(o).append(a)),
                  n.rendered && a.css({ visibility: c }),
                  i.renderable &&
                    ((r = a.width()),
                    (s = a.height()),
                    a.css({
                      left: i.cx - r / 2,
                      top: i.cy - s / 2,
                      color: i.color,
                    }));
              },
              cleanup: function(e, t, n) {
                t.element.remove();
              },
            },
          },
        };
      })(),
      (o.Locale = (function() {
        return { current: null, locales: {} };
      })()),
      (o.Strings = (function() {
        return {
          format: function(e, t) {
            var n,
              i = e,
              r = t.length;
            if (i && r) for (n = 0; r > n; ++n) i = i.replace('%@', t[n]);
            return i;
          },
          fmt: function(e) {
            var t = Array.prototype.slice.call(arguments, 1);
            return o.Strings.format(e, t);
          },
          loc: function(e) {
            var t = Array.prototype.slice.call(arguments, 1),
              n = o.Locale.current && o.Locale.current[e];
            return (
              n
                ? (n = o.Strings.format(n, t))
                : null == n &&
                  (o.signalErrorWithMessage(
                    'Localized string ' + e + ' not found.',
                    'GSP.Error.localeStringNotFound'
                  ),
                  (n = e)),
              n
            );
          },
        };
      })()),
      (o.Locale.locales.en = {
        'GSP.Error.incompatibleSketchVersion':
          "Web Sketchpad version '%@' cannot load a document created for version '%@'.",
        'GSP.Error.invalidSketchVersion':
          "Cannot compare WSP version '%@' with sketch version '%@'.",
        'GSP.Error.invalidSketch':
          'The specified sketch appears to be empty or invalid.',
        'GSP.Error.invalidSwitchPage': "The page requested doesn't exist.",
        'GSP.Error.loadSketchFailed':
          'An error occurred when loading the sketch.',
        'GSP.Error.invalidDocDelta': 'The document delta could not be applied.',
        'GSP.Error.invalidSketchDelta':
          'The sketch delta could not be applied.',
        'GSP.Error.invalidGeomBounds':
          'Invalid geom bounds for object: %@ (%@)',
        'GSP.Error.constraintException': 'Error constraining object: %@ (%@)',
        'GSP.Error.destroyObjectException':
          "Exception destroying object ('%@' (%@)): %@",
        'GSP.Error.touchStartException':
          "Exception in Sketch.handleTouchStart (touch.identifier='%@')",
        'GSP.Error.touchMoveException':
          "Exception in Sketch.handleTouchMove (touch.identifier='%@')",
        'GSP.Error.touchEndException':
          "Exception in Sketch.handleTouchEnd (touch.identifier='%@')",
        'GSP.Error.renderBoundsException':
          "Exception rendering object bounds ('%@' (%@))",
        'GSP.Error.renderObjectException':
          "Exception rendering object ('%@' (%@)): %@",
        'GSP.Error.renderLabelException':
          "Exception rendering object label ('%@' (%@)): %@",
        'GSP.Error.renderPrepareException':
          "Exception in renderPrepare ('%@' (%@)): %@",
        'GSP.Error.renderCleanupException':
          "Exception in renderCleanup ('%@' (%@)): %@",
        'GSP.Error.invalidSketchStart':
          'Sketch.start called for running sketch',
        'GSP.Error.invalidSketchResume':
          'Sketch.resume called for running sketch',
        'GSP.Error.invalidSketchStop': 'Sketch.stop called for stopped sketch',
        'GSP.Measure.arcLength': 'Length',
        'GSP.UI.undo': 'Undo',
        'GSP.UI.redo': 'Redo',
        'GSP.UI.ok': 'OK',
        'GSP.UI.cancel': 'Cancel',
        'GSP.Label.ShowButton': 'Show %@ %@',
        'GSP.Label.HideButton': 'Hide %@ %@',
        'GSP.Label.ShowButtonSwap': 'Show',
        'GSP.Label.HideButtonSwap': 'Hide',
        'GSP.Label.MoveButton': 'Move %@ → %@',
      }),
      (o.Locale.current = o.Locale.locales.en),
      (o.Tool = (function() {
        function e(e, t, n) {
          (this.transactionSpec = t),
            (this.mutable = e),
            (this.original = null),
            (this.matchedGiven = n);
        }
        function i(e) {
          e.expressionAndParentsWereUpdated();
        }
        function r(e) {
          e.descendantGraphHasChanged();
        }
        function s(e) {
          e.children.forEach(function(e) {
            e.descendantGraphHasChanged();
          });
        }
        function a(e, t) {
          var n,
            i,
            r,
            s = e.matchedGiven.mergeCandidate,
            o = s.parentsList,
            a = e.mutable.parentsList;
          if (s.constraint === e.mutable.constraint && o.length === a.length)
            for (r = 0; r < a.length; r++)
              (n = o[r]),
                (i = a[r]),
                'fromCandidate' === t && n.hasLabel && i.hasLabel
                  ? !n.label &&
                    i.label &&
                    (e.candParLabelEmpty || (e.candParLabelEmpty = []),
                    (e.candParLabelEmpty[r] = !0),
                    (n.label = i.label))
                  : n.label &&
                    e.candParLabelEmpty &&
                    e.candParLabelEmpty[r] &&
                    delete n.label;
        }
        function c(e) {
          return o.isParameter(e) || o.isCalculation(e);
        }
        function l(e, t) {
          var i;
          e.getNameMFS && e.sQuery
            ? ((t.nameMFSOverride = {}),
              (t.nameMFSOverride.mfs = e.getNameMFS()),
              (i = e.sQuery.sketch.getDisplayObjForGObj(e)),
              (t.nameMFSOverride.width = i && i.width()),
              (t.nameMFSOverride.height = i && i.height()),
              (i = t.sQuery.sketch.getDisplayObjForGObj(t)),
              (t.nameMFSOverride.originalWidth = i && i.width()),
              (t.nameMFSOverride.originalHeight = i && i.height()))
            : (t.nameMFSOverride = n);
        }
        function u(e) {
          return e.isOfKind('Point');
        }
        function d(e, t) {
          for (var n = 0; n < w.length; n++)
            if (w[n].testMutable(e) && (!t || w[n].testCandidate(t)))
              return w[n];
          return null;
        }
        var h = {
            sketch: null,
            objectGraph: null,
            givenArray: null,
            completion: null,
            constructedObjects: null,
            resetPlayback: function() {
              function e(e, t) {
                'CoordSys' === t.genus &&
                  ((t.kind = 'CoordSys'), (t.constraint = 'CoordSys'));
                var n = o.gobjPrototype(t.kind, t.constraint),
                  i = n.createDefaultSpec && n.createDefaultSpec(e, t);
                if (i) {
                  var r = o.ObjectGraph.getNextFreeIdNumber(
                      e.gobjList.constraintList
                    ),
                    s = o.ObjectGraph.convertObjectSpec(i);
                  s.forEach(function(e) {
                    (e.id = '' + r), ++r;
                  });
                  var a = o.ObjectGraph.createSpecFromGraph(s),
                    c = e.constructGObjects(a, {
                      speculative: !0,
                      autoplace: !0,
                    }),
                    l = s[s.length - 1].id;
                  return { constructedObjects: c, matched: c[l] };
                }
              }
              function n(e, n) {
                function r(e, n) {
                  var r,
                    s,
                    a = {};
                  return e.isOfKind(n.kind) && e.isOfGenus(n.genus)
                    ? !0
                    : (t.extend(a, n),
                      delete a.children,
                      (s = o.gobjectsFromSpec({ copy: a }, e.sQuery).copy),
                      (r = i.getLegalMatchesForGiven(s, [e], !0)),
                      r.length > 0);
                }
                var s,
                  a,
                  c = e.gobjList.constraintList,
                  l = n.label;
                if ('CoordSys' === n.genus) return e.findExistingCoordSys(n);
                l && (l = l.trim());
                for (var u = c.length - 1; u >= 0; --u)
                  if (
                    ((a = c[u]), a.label && a.label.trim() === l && r(a, n))
                  ) {
                    if (!a.style.hidden) return a;
                    s || (s = a);
                  }
                return s;
              }
              var i = this,
                r = o.ObjectGraph.copy(this.objectGraph),
                s = r.filter(function(e) {
                  return [
                    'given',
                    'givenParent',
                    'constructibleGiven',
                  ].includes(e.toolRole)
                    ? !0
                    : !1;
                }),
                a = 'toolplay' + Date.now();
              r.forEach(function(e) {
                e.id += a;
              }),
                (this.givenArray = s),
                (this.constructedObjects = {}),
                (this.existingMatches = {});
              var c = r.filter(function(e) {
                return 'assumed' === e.toolRole ? (delete e.toolRole, !0) : !1;
              });
              if (!((s && s.length) || (c && c.length)))
                throw o.createError('This tool has no givens or assumeds');
              c.forEach(function(r) {
                var s = n(i.sketch, r);
                if (s) i.existingMatches[s.id] = s;
                else {
                  var a = e(i.sketch, r);
                  if (!a)
                    throw (o.log(
                      'Missing non-constructable assumed: ' + r.label
                    ),
                    o.createError(
                      'Missing non-constructable assumed: ' + r.label
                    ));
                  t.extend(i.constructedObjects, a.constructedObjects),
                    (s = a.matched);
                }
                r.id = s.id;
              }),
                (this.assumedArray = c);
            },
            setRelativePositions: function() {
              function e() {
                t.each(c.constructedObjects, function(e, t) {
                  t.supportsAutoplacement() &&
                    l.avoidableGObject(t) &&
                    d.push({ gobj: t, relPos: null });
                });
              }
              function n(e) {
                for (var t = 0; t < d.length; t++)
                  if (d[t].gobj === e) return !0;
                return !1;
              }
              function i(e) {
                l.autoplaceGObj(e.gobj, { ignoreConflictIf: n }),
                  e.gobj.invalidateGeom(),
                  l.renderPrepare(),
                  l.constrainAndRedraw();
              }
              function r() {
                function e() {
                  l.constrainAndRedraw();
                  var e = d.map(function(e) {
                      return l.getGObjGeomBounds(e.gobj);
                    }),
                    t = e.reduce(o.Geom.unionRects);
                  return {
                    topLeft: o.GeometricPoint(t.left, t.top),
                    width: t.right - t.left,
                    height: t.bottom - t.top,
                  };
                }
                if (
                  ((s = e()),
                  d.forEach(function(e) {
                    e.relPos = s.topLeft.subtract(e.gobj.geom.loc);
                  }),
                  (a = l.findPositionForBoundingBox({
                    boxDimensions: { width: s.width, height: s.height },
                    mustAvoid: function(e) {
                      return e.autoplacementType && !n(e);
                    },
                    metrics: {
                      gObjTopMargin: 3,
                      sketchLeftMargin: h,
                      sketchTopMargin: p,
                      rightIsolation: s.width,
                      bottomIsolation: s.height,
                    },
                    start: o.GeometricPoint(u.left + h, u.top + p),
                    placingOneGobjOnly: !1,
                  })),
                  a.success)
                )
                  d.forEach(function(e) {
                    (e.gobj.geom.loc = a.position.subtract(e.relPos)),
                      e.gobj.invalidateGeom();
                  });
                else for (; d.length; ) i(d[0]), d.shift();
              }
              var s,
                a,
                c = this,
                l = this.sketch,
                u = l.sketchRect(),
                d = [],
                h = 10,
                p = 5;
              switch ((e(), d.length)) {
                case 0:
                  return;
                case 1:
                  return void i(d[0]);
                default:
                  r();
              }
            },
            _playGiven: function(e, n, i, r) {
              var s = t.extend(
                  !1,
                  {},
                  this.constructedObjects,
                  this.existingMatches
                ),
                a = o.ObjectGraph.subgraphFromNode(e, s),
                c = {};
              n &&
                (a = a.filter(function(t) {
                  return t !== e;
                }));
              var l = this.sketch.gobjList.constraintList,
                u = o.ObjectGraph.getNextFreeIdNumber(l);
              a.forEach(function(e) {
                (e.id = '' + u), (c[e.id] = e), ++u;
              });
              var d =
                !e.label &&
                ('Function' === e.genus ||
                  'namedFromLabel' === e.style.nameOrigin);
              d &&
                (e.label = this.sketch.labelPool.generateLabel(
                  e.kind,
                  e.genus,
                  e.id
                ));
              var h = {},
                p = o.ObjectGraph.createSpecFromGraph(a);
              for (var f in p)
                p.hasOwnProperty(f) &&
                  p[f].style.layerOrder &&
                  (p[f].style.layerOrder += this.nextLayerOrder);
              var m = e.id;
              if (!n) {
                var g = {};
                (g[m] = p[m]),
                  (p[m].geom = { loc: { x: i.x, y: i.y } }),
                  delete p[m],
                  (h = this.sketch.constructGObjects(g, {
                    forceConstrain: !0,
                  }));
              }
              var b = this.sketch.constructGObjects(p, { speculative: r });
              return (
                t.extend(this.constructedObjects, h, b),
                this.sketch.gobjList.gobjects[m]
              );
            },
            playAssumeds: function() {
              for (var e = this.assumedArray.shift(); e; )
                this._playGiven(e, !0, null, !0),
                  (e = this.assumedArray.shift());
              this.completion && this.isComplete() && this.completion();
            },
            getNextGiven: function() {
              return this.givenArray.shift();
            },
            playGiven: function(e, t, n) {
              this.labelStateSaved ||
                (this.sketch.labelPool.saveState(this),
                (this.labelStateSaved = !0));
              var i = this._playGiven(e, !1, t, n);
              return (
                this.completion && this.isComplete() && this.completion(), i
              );
            },
            addCompletionHandler: function(e) {
              this.completion = e;
            },
            getLegalMatchesForGiven: function(e, t, n) {
              function i(t) {
                if (!t || (t.style.hidden && !n)) return !1;
                switch (r) {
                  case 'Point':
                    return 'Point' === t.kind || (t.isAPath() && !n);
                  case 'Straight':
                    return (
                      t.isOfKind('Straight') &&
                      (t.constraint === e.constraint || !s)
                    );
                  case 'Circle':
                  case 'Arc':
                    return (
                      t.kind === e.kind && (t.constraint === e.constraint || !s)
                    );
                  case 'Polygon':
                    return (
                      t.isOfKind('Polygon') &&
                      ((t.constraint === e.constraint &&
                        e.parentsList.length === t.parentsList.length) ||
                        !s)
                    );
                  case 'Expression':
                    if ('Function' === e.genus) return t.isOfGenus('Function');
                    if (e.genus.match(/Parameter/))
                      return e.getLegalMatchForParam(t);
                    if ('Calculation' === e.constraint) {
                      if (e.parentsList.length)
                        throw o.createError(
                          'getLegalMatchesForGiven: given is a calculation with parents.'
                        );
                      return t.matchesAssumedSpec && t.matchesAssumedSpec(e);
                    }
                    throw o.createError(
                      'getLegalMatchesForGiven: given is of an unexpected genus.'
                    );
                  default:
                    return !1;
                }
              }
              var r = e.kind,
                s = !1,
                a = t || this.sketch.gobjList.renderList;
              if (e.parentsList)
                for (var c = 0; c < e.parentsList.length; c++) {
                  e.parentsList[c].children.length > 1 && (s = !0);
                  break;
                }
              return a.filter(i);
            },
            isComplete: function() {
              return 0 === this.givenArray.length;
            },
            abortPlayback: function() {
              this.matchedGivens.forEach(function(e) {
                e.preexistingTransaction &&
                  e.preexistingTransaction.restoreMutable(),
                  e.clearMatches();
              }),
                this.sketch.gobjList.removeGObjects(
                  this.constructedObjects,
                  this.sketch
                ),
                (this.constructedObjects = {}),
                this.labelStateSaved &&
                  ((this.labelStateSaved = !1),
                  this.sketch.labelPool.restoreSavedState(),
                  (this.generatedLabels = n));
            },
            confirmPlayback: function(e) {
              var i,
                r,
                s = this;
              this.matchedGivens.forEach(function(e) {
                e.preFinalize(s);
              }),
                this.matchedGivens.forEach(function(e) {
                  e.finalize(s);
                });
              for (i in this.constructedObjects)
                this.constructedObjects.hasOwnProperty(i) &&
                  ((r = this.constructedObjects[i]),
                  r.setRenderState('none'),
                  r.toolRole && delete r.toolRole,
                  r.onLoad(s.sketch, 'toolDone'));
              (this.matchedGivens = []),
                (this.constructedObjects = {}),
                this.labelStateSaved &&
                  ((this.labelStateSaved = !1),
                  this.sketch.labelPool.forgetSavedState(),
                  (this.generatedLabels = n)),
                e && !t('.wsp-Calculator').is(':visible') && e.presentUI();
            },
            addGObjAsMatchedGiven: function(e) {
              function t(e) {
                var t;
                return (
                  r.matchedGivens.forEach(function(n, i) {
                    return n.given === e ? ((t = i), !1) : !0;
                  }),
                  t
                );
              }
              var n,
                i,
                r = this;
              return (
                (i = o.Tool.createMatchedGiven(e, this)),
                (n = t(e)),
                n
                  ? (r.matchedGivens[n].unsnapFromCandidate(),
                    (r.matchedGivens[n] = i))
                  : this.matchedGivens.push(i),
                i
              );
            },
            findExistingMatchedGivenWithProperty: function(e, t) {
              var n;
              return (
                this.matchedGivens.every(function(i) {
                  return i[e] === t ? ((n = i), !1) : !0;
                }),
                n
              );
            },
            existingMatchedGivenForGObj: function(e) {
              return this.findExistingMatchedGivenWithProperty('given', e);
            },
            existingMatchedGivenForMergeCandidate: function(e) {
              return this.findExistingMatchedGivenWithProperty(
                'mergeCandidate',
                e
              );
            },
            arrayOfMatchedGivenGObjs: function() {
              return this.matchedGivens.map(function(e) {
                return e.given;
              });
            },
          },
          p = {
            objectGraph: null,
            $element: null,
            createSession: function(e) {
              var t = Object.create(h);
              return (
                (t.sketch = e),
                (t.objectGraph = this.objectGraph),
                (t.givenArray = []),
                (t.constructedObjects = {}),
                (t.matchedGivens = []),
                t.resetPlayback(),
                (t.nextLayerOrder = 0),
                t
              );
            },
          },
          f = {
            setProp: function(e, i, r) {
              e[r] !== n &&
                (this.transactionSpec.properties[r] &&
                this.transactionSpec.properties[r].copy
                  ? (i[r] = t.extend(!0, {}, e[r]))
                  : (i[r] = e[r]));
            },
            setMutableFrom: function(e) {
              var t,
                n,
                i,
                r,
                s = this.mutable;
              for (t in this.transactionSpec.properties)
                if (this.transactionSpec.properties.hasOwnProperty(t)) {
                  if ('constraint' === t && s.constraint !== e.constraint) {
                    (n = Object.getPrototypeOf(e)),
                      Object.setPrototypeOf(s, n),
                      (i = o.gConstraints[e.constraint].doc.properties);
                    for (r in i)
                      'style' !== r &&
                        i.hasOwnProperty(r) &&
                        this.setProp(e, s, r);
                  }
                  this.transactionSpec.properties[t].setter
                    ? this.transactionSpec.properties[t].setter(e, s)
                    : this.setProp(e, s, t);
                }
            },
            postProcessMutable: function() {
              this.transactionSpec.postProcessMutable &&
                this.transactionSpec.postProcessMutable(this.mutable);
            },
            preProcess: function(e) {
              this.transactionSpec.preProcess &&
                this.transactionSpec.preProcess(this, e);
            },
            snapGivenToCandidate: function() {
              function e() {
                t.preProcess('fromCandidate'),
                  t.setMutableFrom(n),
                  'Point' === i.kind &&
                    'Point' === n.kind &&
                    ((i.geom.loc = o.GeometricPoint(
                      n.geom.loc.x,
                      n.geom.loc.y
                    )),
                    i.invalidateGeom()),
                  t.postProcessMutable();
              }
              var t = this,
                n = this.matchedGiven.mergeCandidate,
                i = this.matchedGiven.given;
              if (!this.transactionSpec.testCandidate(n))
                throw o.createError(
                  'snapGivenToCandidate cannot snap ' +
                    i.kind +
                    i.id +
                    ' to ' +
                    n.kind +
                    n.id
                );
              e(), this.matchedGiven.startWatchingCandidate(e);
            },
            saveMutable: function() {
              var e, t;
              if (null === this.original) {
                this.original = {};
                for (e in this.transactionSpec.properties)
                  this.transactionSpec.properties.hasOwnProperty(e) &&
                    ('constraint' === e &&
                      ((t = Object.getPrototypeOf(this.mutable)),
                      Object.setPrototypeOf(this.original, t)),
                    this.setProp(this.mutable, this.original, e));
              }
            },
            restoreMutable: function() {
              null !== this.original &&
                (this.preProcess('fromOriginal'),
                this.setMutableFrom(this.original),
                this.postProcessMutable()),
                (this.original = null);
            },
          };
        e.prototype = f;
        var m = {
            testMutable: u,
            testCandidate: u,
            properties: {
              parents: {},
              genus: '',
              constraint: '',
              label: '',
              value: 0,
              scaleFactor: 0,
              angle: 0,
              offset: {},
              distance: 0,
              offsetX: 0,
              offsetY: 0,
            },
            postProcessMutable: r,
          },
          g = {
            testMutable: o.isParameter,
            testCandidate: function(e) {
              return c(e) || e.isOfKind('Measure');
            },
            properties: {
              value: {
                setter: function(e, t) {
                  t.setParameterValue(e.uValue);
                },
              },
              uValue: {},
              nameMFSOverride: { setter: l },
              blank: {},
            },
            postProcessMutable: r,
          },
          b = {
            testMutable: o.isFunction,
            testCandidate: o.isFunction,
            properties: {
              nameMFSOverride: { setter: l },
              functionExpr: { copy: !0 },
              expressionType: {},
              parents: {},
              expression: {},
            },
            postProcessMutable: i,
          },
          v = {
            testMutable: o.isCalculation,
            testCandidate: c,
            properties: {
              parents: {},
              nameMFSOverride: { setter: l },
              expression: {
                setter: function(e, t) {
                  e.prepareToSerialize && e.prepareToSerialize(),
                    (t.expression = e.expression);
                },
              },
            },
            postProcessMutable: i,
          },
          y = {
            testMutable: o.isAPath,
            testCandidate: function(e) {
              return e.isOfKind('Axis');
            },
            properties: {
              kind: '',
              genus: '',
              constraint: '',
              parents: {},
              style: {},
              orientation: '',
            },
            preProcess: a,
            postProcessMutable: s,
          },
          x = {
            testMutable: o.isAPath,
            testCandidate: o.isAPath,
            properties: { kind: '', genus: '', constraint: '', parents: {} },
            preProcess: a,
            postProcessMutable: s,
          },
          w = [g, b, v, y, x, m],
          k = {
            given: null,
            mergeCandidate: null,
            intersectInfo: null,
            transactionSpec: null,
            clearMatches: function() {
              this.clearIntersectInfo(),
                this.stopWatchingCandidate(),
                this.proxy &&
                  (this.proxy.setRenderState('none'), delete this.proxy),
                this.mergeCandidate &&
                  this.mergeCandidate.setRenderState('none'),
                (this.mergeCandidate = null);
            },
            updateDeltaToGiven: function(e) {
              var t,
                n,
                i,
                r = this.given,
                s = e,
                a = this.session.sketch.currentTouchRegime();
              return (
                (r.isOfKind('ArcInterior') || r.isOfKind('Sampler')) &&
                  o.signalErrorWithMessage(
                    'Tool tracker: current matchedGiven may not support mapPositionToPathValue'
                  ),
                (t =
                  'Point' === r.kind || r.isOfKind('Text')
                    ? r.geom.loc
                    : r.isAPath()
                    ? a.pointInRegion(e, r)
                      ? e
                      : r.mapPositionToPathPosition(e)
                    : o.GeometricPoint(0, 0)),
                (this.deltaToGiven = e.subtract(t)),
                r.nameMFSOverride &&
                  ((i = r.nameMFSOverride),
                  (n = o.GeometricPoint(
                    (this.deltaToGiven.x * i.originalWidth) / i.width,
                    (this.deltaToGiven.y * i.originalHeight) / i.height
                  )),
                  (s = e.add(n.subtract(this.deltaToGiven))),
                  (this.deltaToGiven = n)),
                console.log(
                  'updateDeltaToGiven: new value = ',
                  this.deltaToGiven
                ),
                s
              );
            },
            prepareTransactionsForSnap: function() {
              var t,
                n = this.given,
                i = this.mergeCandidate;
              if (i) {
                if (
                  (n.isOfKind('Text') &&
                    'Pegged' === i.constraint &&
                    (i = i.parents.text),
                  !(
                    (this.givenTransaction &&
                      this.givenTransaction.transactionSpec.testCandidate(i)) ||
                    ((this.givenTransaction = null),
                    (this.givenTransactionSpec = d(n, i)),
                    this.givenTransactionSpec)
                  ))
                ) {
                  if ('Point' !== n.kind || !i.isAPath())
                    throw o.createError(
                      "prepareTransactionsForSnap couldn't find a matching transaction for " +
                        n.kind +
                        ' and ' +
                        i.kind
                    );
                  this.snapPointToPath();
                }
                this.givenTransaction ||
                  ((this.givenTransaction = new e(
                    n,
                    this.givenTransactionSpec,
                    this
                  )),
                  this.givenTransaction.saveMutable()),
                  (t = d(i)),
                  t &&
                    ((this.preexistingTransaction = new e(i, t, this)),
                    this.preexistingTransaction.saveMutable());
              }
            },
            snapPointToPath: function(e) {
              var t = this.mergeCandidate,
                n = this.given,
                i = e || n.geom.loc,
                r = this.getSnappedPosition(i);
              (n.geom.loc = r),
                n.invalidateGeom(),
                t.setRenderState('targetHighlit');
            },
            snapToCandidate: function(e) {
              var t = this.given,
                n = this.mergeCandidate;
              n &&
                (t.isOfKind('Text') &&
                  'Pegged' === n.constraint &&
                  (n = n.parents.text),
                n.isOfGenus('Path') && 'Point' === t.kind
                  ? (e || (e = t.geom.loc), this.snapPointToPath(e))
                  : (this.givenTransaction || this.prepareTransactionsForSnap(),
                    this.givenTransaction.snapGivenToCandidate(),
                    n.invalidateGeom()),
                n.isAPath() ||
                  (t.setRenderState('invisible'),
                  n.setRenderState('targetHighlit')));
            },
            unsnapFromCandidate: function(e) {
              var t,
                n = this.given;
              this.givenTransaction &&
                (this.givenTransaction.restoreMutable(),
                delete this.givenTransaction,
                this.preexistingTransaction.restoreMutable(),
                delete this.preexistingTransaction),
                this.clearMatches(),
                e &&
                  (n.isOfKind('Text')
                    ? ((t = n.sQuery.sketch.renderRefCon.gobj[n.id].element[0]),
                      (e = e.subtract(
                        o.GeometricPoint(t.clientWidth / 2, t.clientHeight / 2)
                      )))
                    : 'Point' === n.kind && (e = e.add(this.deltaToGiven)),
                  (n.geom.loc = e),
                  this.updateDeltaToGiven(n.geom.loc)),
                n.invalidateGeom(),
                n.setRenderState('matchedGiven');
            },
            setMergeCandidate: function(e, t) {
              var n = this.mergeCandidate;
              n !== e &&
                (n || e) &&
                (this.clearMatches(),
                n &&
                  this.session.existingMatchedGivenForMergeCandidate(n) &&
                  n.setRenderState('matchedGiven'),
                n && this.unsnapFromCandidate(),
                this.given.setRenderState('matchedGiven'),
                e &&
                  (t
                    ? (t.setRenderState('targetHighlit'), (this.proxy = t))
                    : e.setRenderState('targetHighlit'),
                  (this.mergeCandidate = e),
                  ('Point' === this.given.kind && e.isOfGenus('Path')) ||
                    this.prepareTransactionsForSnap()));
            },
            startWatchingCandidate: function(e) {
              var t = this.mergeCandidate.sQuery('#' + this.mergeCandidate.id);
              this._onUpdate && t.off('update', this._onUpdate),
                (this._onUpdate = e),
                t.on('update', this._onUpdate);
            },
            stopWatchingCandidate: function() {
              if (this._onUpdate) {
                if (!this.mergeCandidate)
                  throw o.createError(
                    'matched given is still updating a rejected candidate'
                  );
                this.given
                  .sQuery('#' + this.mergeCandidate.id)
                  .off('update', this._onUpdate),
                  (this._onUpdate = null);
              }
            },
            setIntersectInfo: function(e) {
              var t = e,
                n = this.intersectInfo;
              n && t.path1 === n.path1 && t.path2 === n.path2
                ? (n.location = t.location)
                : (this.clearMatches(),
                  t.path1.setRenderState('targetHighlit'),
                  t.path2.setRenderState('targetHighlit'),
                  (this.intersectInfo = t));
            },
            clearIntersectInfo: function() {
              this.intersectInfo &&
                (this.intersectInfo.path1.setRenderState('none'),
                this.intersectInfo.path2.setRenderState('none'),
                (this.intersectInfo = null));
            },
            getSnappedPosition: function(e) {
              var t = this.mergeCandidate;
              if (this.intersectInfo) return this.intersectInfo.location;
              if (t) {
                if ('Point' === t.kind) return t.geom.loc;
                if (t.isAPath()) return t.mapPositionToPathPosition(e);
                if (t.isOfKind('Text'))
                  return t.geom.loc.add(this.deltaToGiven);
                throw o.createError(
                  'getSnappedPosition cannot map ' +
                    this.given.kind +
                    this.given.id +
                    ' to ' +
                    t.kind +
                    t.id
                );
              }
            },
            completeMatch: function(e) {
              var t = this.given,
                n = this.mergeCandidate;
              this.intersectInfo &&
                (this.intersectInfo.path1.setRenderState('none'),
                this.intersectInfo.path2.setRenderState('none')),
                n &&
                  (n.isAPath() && t.isOfKind('Point')
                    ? (n.setRenderState('none'),
                      (t.geom.loc = n.mapPositionToPathPosition(e)),
                      t.invalidateGeom())
                    : n.setRenderState('matchedGiven'));
            },
            preFinalize: function() {
              if (this.mergeCandidate) {
                var e = this.mergeCandidate;
                'Point' === this.given.kind &&
                  e.isAPath() &&
                  (this.value = e.mapPositionToPathValue(this.given.geom.loc)),
                  e.prepareToSerialize();
              }
            },
            finalize: function(e) {
              function t(e) {
                o.parentsList.forEach(function(t, n) {
                  var i = s.parentsList[n];
                  e.sketch.mergeGobjToCandidate(t, i, {
                    skipDescendantUpdate: !0,
                  });
                }),
                  (r = !0);
              }
              function n() {
                s.parentsList.forEach(function(e, t) {
                  e.descendantGraphHasChanged(),
                    e.descendantLabelGraphHasChanged();
                });
              }
              function i(t) {
                var n = {};
                e.generatedLabels &&
                  (t.labelPool.restoreSavedState(), t.labelPool.saveState(e)),
                  o.parentsList.forEach(function(t) {
                    (n[t.id] = t),
                      (t.children = []),
                      (e.generatedLabels[t.id] = !1);
                  }),
                  (o.parentsList = []),
                  (o.parents = {}),
                  t.gobjList.removeGObjects(n, t);
              }
              var r,
                s = this.mergeCandidate,
                o = this.given;
              if (this.intersectInfo)
                e.sketch.putGivenOnIntersection(o, this.intersectInfo);
              else {
                if (!s) return;
                'Point' === s.kind ||
                s.isOfKind('Text') ||
                (s.isAPath() && o.isAPath())
                  ? (e.sketch.mergeGobjToCandidate(o, s), r && n(s))
                  : s.isAPath() && e.sketch.putGivenOnPath(o, s, this.value),
                  'constructibleGiven' === this.given.toolRole &&
                    (o.constraint === s.constraint &&
                    o.parentsList.length === s.parentsList.length
                      ? t(e)
                      : i(e.sketch));
              }
              this.clearMatches();
            },
          };
        return {
          createWithSpec: function(e) {
            var n = Object.create(p),
              i = e.objects;
            if (
              ((n.metadata = t.extend(!0, {}, e.metadata)),
              'Label' === n.metadata.name)
            )
              return n;
            var r = !1;
            for (var s in i)
              if (
                i.hasOwnProperty(s) &&
                [
                  'given',
                  'givenParent',
                  'constructibleGiven',
                  'assumed',
                ].includes(i[s].toolRole)
              ) {
                r = !0;
                break;
              }
            if (!r)
              throw o.createError('Attempting to create a tool with no givens');
            return (
              (n.objectGraph = o.ObjectGraph.convertObjectSpec(
                t.extend(!0, {}, i)
              )),
              n
            );
          },
          createMatchedGiven: function(e, t) {
            var n = Object.create(k);
            return (
              (n.given = e),
              (n.session = t),
              (n.givenTransactionSpec = d(e)),
              e.setRenderState('matchedGiven'),
              n
            );
          },
        };
      })()),
      (o.ToolController = (function() {
        var e = {
          _getUndoRedoContainer: function() {
            var e,
              t = this.sketch.getAuthorPreference('toolplayNewLook');
            return (e = t
              ? this.sketch.baseNode.find('.wsp-sketch-container')
              : this.sketch.baseNode
                  .find('.wsp-ok-cancel-container')
                  .filter(':visible'));
          },
          _clearOutActiveTool: function() {
            var e = this._getUndoRedoContainer();
            this.activeTool &&
              (this.activeTool.$element.removeClass('wsp-tool-active'),
              (this.activeTool = null)),
              this.sketch.canvasNode.toggleClass('wsp-tool-background', !1),
              this.$closeBox &&
                (this.$closeBox.remove(), (this.$closeBox = null)),
              this.$okBox && (this.$okBox.remove(), (this.$okBox = null)),
              e.toggleClass('wsp-ok-cancel-mode', !1);
          },
          abortActiveTool: function() {
            var e = this.activeRegime,
              t = o._get(this.activeTool, 'metadata.name');
            e && this.sketch.popAllTouchRegimesIncluding(e),
              this.sketch.event('ToolAborted', {}, { tool: { name: t } });
          },
          confirmActiveTool: function() {
            var e = this,
              t = this.sketch,
              n = this.activeRegime;
            if (this.activeTool) {
              this.activeTool.$element.removeClass('wsp-tool-active');
              var i = function(i) {
                var r,
                  s = e.activeTool,
                  o = n.sticky;
                i &&
                  (r = t.document.pushConfirmedSketchOpDelta(e.preToolDelta)),
                  t.popAllTouchRegimesIncluding(n),
                  t.event(
                    'ToolPlayed',
                    {},
                    { delta: r, tool: { name: s.metadata.name } }
                  ),
                  o && e.setActiveTool(s, o);
              };
              n
                ? n.confirmActiveTool(i)
                : o.log(
                    'confirmActiveTool called when there is no active tool regime'
                  );
            }
          },
          regimeDidPop: function(e) {
            return e !== this.activeRegime
              ? void o.log('regimeDidPop called with wrong active regime')
              : ((this.activeRegime = null),
                e.doCleanup(),
                this._clearOutActiveTool(),
                void this.sketch.document.changedUIMode());
          },
          createToolRegime: function() {
            var e;
            return (
              (e =
                'Label' === this.activeTool.metadata.name
                  ? o.LabelRegime
                  : o.ToolRegime),
              e.createWithTool(this.sketch, this.activeTool)
            );
          },
          setActiveTool: function(e, n) {
            function i(e, n) {
              var i = t(
                '<button><div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
                  o.Strings.loc(e) +
                  '</div></button>'
              );
              return i.addClass('wsp-ok-cancel-button'), i.addClass(n), i;
            }
            var r;
            (this.preToolDelta = this.sketch.document.getRecentChangesDelta()),
              this.sketch.event(
                'WillPlayTool',
                {},
                {
                  tool: { name: e.metadata.name },
                  preToolDelta: this.preToolDelta,
                }
              ),
              (this.activeTool = e),
              e.$element.addClass('wsp-tool-active');
            try {
              var s = this,
                a = !this.$closeBox,
                c = this._getUndoRedoContainer(),
                l = [];
              if (
                ((r = this.createToolRegime()),
                t.each(r.toolplaySession.constructedObjects, function() {
                  l.push(this.id);
                }),
                this.sketch.event(
                  'ToolPlayBegan',
                  {},
                  { tool: { name: e.metadata.name }, newObjIds: l }
                ),
                (r.delegate = s),
                this.sketch.pushTouchRegime(r),
                (this.activeRegime = r),
                !r.confirmToolWhenReady())
              ) {
                if (((r.sticky = n), this.sketch.document.changedUIMode(), a)) {
                  var u = i('GSP.UI.cancel', 'wsp-tool-cancel');
                  c.append(u),
                    u.on('click', function() {
                      return s.sketch.touchRegimeBlocksOtherButtons()
                        ? !1
                        : (s.abortActiveTool(),
                          void o.blurDocumentActiveElement(s.sketch.baseNode));
                    }),
                    (this.$closeBox = u);
                  var d = i('GSP.UI.ok', 'wsp-tool-ok');
                  c.append(d),
                    d.on('click', function() {
                      return s.sketch.touchRegimeBlocksOtherButtons()
                        ? !1
                        : (o.blurDocumentActiveElement(s.sketch.baseNode),
                          void s.confirmActiveTool());
                    }),
                    (this.$okBox = d);
                }
                this.sketch.canvasNode.toggleClass('wsp-tool-background', !0),
                  c.toggleClass('wsp-ok-cancel-mode', !0);
              }
            } catch (e) {
              o.signalCaughtError(e),
                r && r.isPushed
                  ? this.abortActiveTool()
                  : this._clearOutActiveTool();
            }
          },
          toggleTool: function(e, t) {
            if (this.sketch.touchRegimeBlocksOtherButtons()) return !1;
            o.blurDocumentActiveElement(this.sketch.baseNode);
            var n = this.activeTool,
              i = 500,
              r = this.activeRegime;
            if (n) {
              if (n === e && t - r.startTime < i)
                return (
                  (r.sticky = !0), void e.$element.addClass('wsp-tool-active')
                );
              if (
                (r.toolplaySession.matchedGivens.length
                  ? this.confirmActiveTool()
                  : this.abortActiveTool(),
                n === e)
              )
                return !0;
            }
            this.setActiveTool(e, !1),
              this.activeRegime && (this.activeRegime.startTime = t);
          },
        };
        return {
          createInSketch: function(t) {
            var n = Object.create(e);
            return (n.sketch = t), n;
          },
        };
      })()),
      (o.Genus = (function() {
        return {};
      })()),
      (o.genera.Path = o.makeClass(o.Genus, {
        genus: 'Path',
        mapPositionToPathValue: function(e) {
          throw o.createError('mapPositionToPathValue not Implemented');
        },
        mapPathValueToPosition: function(e) {
          throw o.createError('mapPathValueToPosition not Implemented');
        },
        mapVectorPathValuesToPositions: function(e) {
          var t,
            n = e.length,
            i = [];
          for (t = 0; n > t; t++) i[t] = this.mapPathValueToPosition(e[t]);
          return i;
        },
        mapPositionToPathPosition: function(e) {
          var t = this.mapPositionToPathValue(e);
          return this.mapPathValueToPosition(t);
        },
        getAnimationRange: function() {
          return { min: 0, max: 1 };
        },
        unitLength: function() {
          var e = this.getAnimationRange();
          return this.pathLength() / (e.max - e.min);
        },
        constrainRange: function(e) {
          return e;
        },
        isValueInBounds: function(e) {
          return o.math.isFiniteScalar(e);
        },
        pathLength: function() {
          throw o.createError('pathLength not Implemented');
        },
        constrainLabelForPath: function() {
          var e = this.style.label,
            t = this.state,
            n = this.getAnimationRange(),
            i = e.labelParam;
          'undefined' == typeof i &&
            (i = (n.max - n.min) * this.getDefaultLabelPathParam() + n.min),
            t.exists &&
              e.showLabel &&
              (this.labelSpec.location = this.mapPathValueToPosition(i));
        },
        constrainLabel: function() {
          this.constrainLabelForPath();
        },
        getDefaultLabelPathParam: function() {
          return 0.25;
        },
        setLineDash: function(e) {
          return (
            o.modifyRenderAttrsForLineStyle(this.style['line-style'], e), e
          );
        },
        openMotionPathProto: {
          advance: function(e) {
            var t = this.start,
              n = this.path.unitLength(),
              i = e / n;
            return (
              this.start < this.end
                ? (t = Math.min(this.end, this.start + i))
                : this.end < this.start &&
                  (t = Math.max(this.end, this.start - i)),
              t
            );
          },
          getDistance: function() {
            return Math.abs(this.end - this.start) * this.path.pathLength();
          },
        },
        closedMotionPathProto: {
          getArcLength: function() {
            var e = this.end - this.start;
            return e > 0.5 && (e -= 1), -0.5 > e && (e += 1), e;
          },
          advance: function(e) {
            var t = this.start,
              n = this.path.pathLength(),
              i = e / n,
              r = this.getArcLength();
            return (
              Math.abs(r) < i ? (t = this.end) : 0 > r ? (t -= i) : (t += i),
              (t -= Math.floor(t))
            );
          },
          getDistance: function() {
            return Math.abs(this.getArcLength()) * this.path.pathLength();
          },
        },
        makeMotionPath: function(e, t) {
          var n = Object.create(
            this.closedPath
              ? this.closedMotionPathProto
              : this.openMotionPathProto
          );
          return (n.path = this), (n.start = e), (n.end = t), n;
        },
        pathValidationString: function(e) {
          function t(e) {
            return e ? o.GeometricPoint(e.x, e.y) : o.GeometricPoint.UNDEFINED;
          }
          function n(e, t, n) {
            var i = e && e.isDefined() && e.isFinite(),
              r = t && t.isDefined() && t.isFinite();
            return i && r ? o.GeometricPoint.expect(e, t, n) : i === r;
          }
          var i = '',
            r = this;
          return (
            [
              {
                name: 'Zero',
                value: 0,
                expectedPosition: e.zeroPosition,
                expectedDerivative: e.zeroDerivative,
              },
              {
                name: 'Middle',
                value: 0.5,
                expectedPosition: e.middlePosition,
                expectedDerivative: e.middleDerivative,
              },
              {
                name: 'One',
                value: 1,
                expectedPosition: e.onePosition,
                expectedDerivative: e.oneDerivative,
              },
            ].forEach(function(e) {
              var s,
                o,
                a = {},
                c = t(e.expectedPosition),
                l = t(e.expectedDerivative);
              (s = r.mapPathValueToPosition(e.value, a)),
                (o = a.derivative),
                n(s, c) ||
                  (i +=
                    e.name +
                    ' Path Position: <span class="error">' +
                    s +
                    '</span>(<span class="expected">' +
                    c +
                    '</span>)'),
                l &&
                  l.l1Norm() < 100 &&
                  !n(o, l, 1) &&
                  (i +=
                    e.name +
                    ' Path Derivative: <span class="error">' +
                    o +
                    '</span>(<span class="expected">' +
                    l +
                    '</span>)');
            }),
            i
          );
        },
        makeParentalLabel: function(e, t) {
          var n,
            i,
            r,
            s,
            a = ['namedByPrime', 'namedByFullFn', 'namedByShortFn'],
            c = this.getParentLabel('labelParent', { create: !0 });
          if (a.indexOf(e) < 0) s = this.label;
          else {
            if (!c)
              throw o.createError(
                'makeParentalLabel() call to findParentLabel() failed.'
              );
            if (((n = this.parentsList[0]), (i = n.parents.source), !i))
              throw o.createError(
                "makeParentalLabel() didn't find a parent's preimage."
              );
            (r = i.label),
              (i.label = c),
              (s = n.makeParentalLabel(e, t)),
              r ? (i.label = r) : delete i.label;
          }
          return s;
        },
      })),
      (o.genera.Point = (function() {
        var e = Object.create(o.Genus);
        return e;
      })()),
      (o.genera.Interior = o.makeClass(o.Genus, {
        genus: 'Interior',
        modifyRenderAttrsForInterior: function(e, t) {
          switch (t) {
            case 'speculative':
              e.color = o.speculativeColor;
              break;
            case 'targetHighlit':
              (e.drawBorder = !0),
                (e.borderColor = o.targetHighlightColor),
                (e.borderWidth = 3 + o.targetHighlightPathBolding);
              break;
            case 'targetOnFocus':
              (e.isFocusable = !0),
                (e.opacity = 1),
                (e.color = o.targetFocusColor);
          }
        },
      })),
      (o.mixins.labelBase = {
        doc: {
          properties: {
            label: {
              description: 'Text for the label, if any.',
              type: 'String',
            },
            style: {
              properties: {
                label: {
                  description:
                    'Properties that influence the appearance of a Label. Overrides of the GObject style, and as follows.',
                  properties: {
                    color: {
                      description: 'The color of label text',
                      type: 'Color',
                    },
                    'font-family': {
                      description:
                        'The basis font family for text in this GObject. See GSP.getFontFamilyFromStyle() for supported formats.',
                      type: 'FontFamily',
                    },
                    'font-size': {
                      description:
                        'The basis font size for text in this GObject',
                      type: 'FontSize',
                    },
                    'font-style': {
                      description:
                        'The basis font style (slant) for text in this GObject',
                      type: 'FontStyle',
                    },
                    'font-weight': {
                      description:
                        'The basis font weight (boldness) for text in this GObject',
                      type: 'FontWeight',
                    },
                    labelOffsetX: {
                      description:
                        'Horizontal offset of the upper left corner of the label, in pixels.',
                      type: 'Number',
                      required: !1,
                    },
                    labelOffsetY: {
                      description:
                        'Vertical offset of the upper left corner of the label, in pixels.',
                      type: 'Number',
                      required: !1,
                    },
                    labelParam: {
                      description:
                        'Position on the path where a label will be placed.',
                      type: 'Number',
                      required: !1,
                    },
                    'letter-spacing': {
                      description:
                        'The basis font letter spacing for text in this GObject',
                      type: 'LetterSpacing',
                    },
                    showLabel: {
                      description:
                        'Whether or not a label should accompany the gObject.',
                      type: 'Boolean',
                    },
                    'text-decoration': {
                      description:
                        'line-through, underlines, and other variations on the label text',
                      type: 'TextDecoration',
                    },
                  },
                },
              },
            },
          },
        },
        style: { label: {} },
      }),
      (o.mixins.label = o.makeClass(o.mixins.labelBase, {
        getLabelSpec: function() {
          return t.isEmptyObject(this.labelSpec) ? n : this.labelSpec;
        },
        getLabelBounds: function(e) {
          return this.labelRenderBounds || o.Geom.kInfiniteRect;
        },
        ensureLabelMFS: function(e) {
          if (this.parsedMFS) return this.parsedMFS;
          try {
            this.label
              ? (this.parsedMFS = o.labels.parseLabelExpression(this.label, e))
              : (this.parsedMFS = this.getNameMFSForLabel());
          } catch (e) {
            (e.message =
              'Error parsing label: "' + this.label + '": ' + e.message),
              o.signalCaughtError(e);
          }
          return this.parsedMFS;
        },
        renderLabelPrepare: function(e, t) {
          if (this.hasLabel) {
            var n = o.getFontFamilyFromStyle(this.style.label, this.sQuery()),
              i = this.style.label;
            return (
              (t.id = String(this.id) + '-label'),
              (t.kind = 'Label'),
              (t.color = i.color),
              (t['font-family'] = n),
              (t['font-style'] = i['font-style']),
              (t['font-weight'] = i['font-weight']),
              (t['font-size'] = i['font-size']),
              (t['text-decoration'] = i['text-decoration']),
              (t['text-align'] = 'left'),
              e.prepareText(t)
            );
          }
        },
        labelPreRenderJITPrepare: function(e, t) {
          var n, i;
          this.hasLabel &&
            !this.state.labelPreRenderJITPrepareDone &&
            ((n = this.measureLabel(e, t)),
            this.hasLabelOffset() || this.initLabelOffset(n),
            this.restrictLabelOffset(n),
            (i = this.getLabelTopLeft()),
            (t.renderBounds = {
              top: i.y,
              bottom: i.y + n.height,
              left: i.x,
              right: i.x + n.width,
            }),
            this.sQuery.sketch.invalidateRect(t.renderBounds),
            (this.labelRenderBounds = {
              top: i.y,
              bottom: i.y + n.height,
              left: i.x,
              right: i.x + n.width,
            }),
            (this.sQuery.sketch.renderRefCon.labelBounds[this.id] = {
              top: i.y,
              bottom: i.y + n.height,
              left: i.x,
              right: i.x + n.width,
            }),
            (this.state.labelPreRenderJITPrepareDone = !0));
        },
        restrictLabelOffset: function(e) {
          var t = 8,
            n = 5,
            i = 5,
            r = this.style.label;
          (r.labelOffsetX = Math.max(r.labelOffsetX, -e.width - t)),
            (r.labelOffsetX = Math.min(r.labelOffsetX, t + i)),
            (r.labelOffsetY = Math.max(r.labelOffsetY, -e.height - n)),
            (r.labelOffsetY = Math.min(r.labelOffsetY, n + i));
        },
        measureLabel: function(e, t, n) {
          var i = { width: 0, height: 0 };
          return (
            this.hasLabel &&
              (i = e.measureText(t, {
                parsedMFS: this.ensureLabelMFS(this.getMathItalicization()),
              })),
            i
          );
        },
        getLabelOrigin: function() {
          return this.labelSpec.location || this.geom.loc;
        },
        getLabelTopLeft: function() {
          var e = this.style.label,
            t = this.getLabelOrigin();
          return o.GeometricPoint(t.x + e.labelOffsetX, t.y + e.labelOffsetY);
        },
        getLabelCornerDelta: function(e) {
          var t = this.getLabelTopLeft();
          return o.GeometricPoint(e.x - t.x, e.y - t.y);
        },
        setLabelPosition: function(e, t) {
          var n, i, r;
          this.mapPositionToPathValue &&
            (this.mapPositionToLabelPathParam
              ? ((this.userSetLabelPathParam = this.mapPositionToLabelPathParam(
                  e
                )),
                this.constrainLabel())
              : ((this.style.label.labelParam = this.mapPositionToPathValue(e)),
                (this.labelSpec.location = this.mapPathValueToPosition(
                  this.style.label.labelParam
                )))),
            (n = this.getLabelOrigin()),
            (i = o.GeometricPoint(e.x - t.x, e.y - t.y)),
            (r = this.style.label),
            (r.labelOffsetX = i.x - n.x),
            (r.labelOffsetY = i.y - n.y),
            this.restrictLabelOffset({
              width: this.labelRenderBounds.right - this.labelRenderBounds.left,
              height:
                this.labelRenderBounds.bottom - this.labelRenderBounds.top,
            });
        },
        renderLabel: function(e, t, n) {
          if (this.hasLabel) {
            var i,
              r,
              s,
              o = this.style.label,
              a = this.isRenderable() && this.style.label.showLabel,
              c = a ? 'visible' : 'hidden',
              l = this.getMathItalicization();
            a &&
              (this.ensureLabelMFS(l),
              (t.parsedMFS = this.parsedMFS),
              this.labelPreRenderJITPrepare(e, t),
              (i = this.getLabelOrigin()),
              (r = i.x + o.labelOffsetX),
              (s = i.y + o.labelOffsetY)),
              e.drawText(t, {
                x: r,
                y: s,
                renderable: a,
                visibility: c,
                opacity: this.calculateFadeOpacity(),
                parsedMFS: this.parsedMFS,
                label: this.label,
                useDrawImage: !1,
                constraintFrame: this.state.constraintFrame,
              }),
              a && (this.labelRenderBounds = t.renderBounds);
          }
        },
        renderLabelCleanup: function(e, t) {
          e.cleanupText(t);
        },
        hideExistingLabel: function() {
          this.labelExists() &&
            ((this.style.label.showLabel = !1), this.invalidateAppearance());
        },
        showExistingLabel: function() {
          return this.labelExists()
            ? ((this.style.label.showLabel = !0),
              this.invalidateAppearance(),
              !0)
            : void 0;
        },
        useTransformLabel: function() {
          function e(e, t) {
            function n(n) {
              return e[n] === t[n];
            }
            return (
              n('m00') &&
              n('m10') &&
              n('m10') &&
              n('m11') &&
              n('m20') &&
              n('m21')
            );
          }
          function i(s) {
            function a() {
              var e,
                t = u.state;
              if (c)
                (t = u.state),
                  (s.state.labelParent = u),
                  t.labelChildren || (t.labelChildren = []),
                  t.labelChildren.indexOf(s) < 0 && t.labelChildren.push(s),
                  i(u);
              else if (u) {
                if (((e = t.labelChildren.indexOf(s)), 0 > e))
                  throw o.createError(
                    "WIDGETS.fixConnections() couldn't find gobj in labelParent's array."
                  );
                t.labelChildren.splice(e, 1),
                  0 === t.labelChildren.length && delete t.labelChildren,
                  delete s.state.labelParent;
              }
            }
            var c,
              l,
              u,
              d = [];
            return (
              (c = r.indexOf(s.constraint) >= 0),
              c &&
                t.each(s.parentsList, function(t, n) {
                  return !n.isTransformationConstraint ||
                    (l && !e(l, n.getTransformer().getAffineTransform()))
                    ? ((c = !1), !1)
                    : (l || (l = n.getTransformer().getAffineTransform()),
                      void d.push(n.getParent('source')));
                }),
              c &&
                (t.each(d[0].children, function(e, t) {
                  var i,
                    r,
                    o = t.parentsList.indexOf(d[0]),
                    a = t.parentsList.length;
                  if (
                    t.constraint === s.constraint &&
                    a === s.parentsList.length &&
                    o >= 0
                  ) {
                    for (u = t, i = 1, r = o; a > i; i++)
                      if (((r = (r + 1) % a), d[i] !== t.parentsList[r])) {
                        u = n;
                        break;
                      }
                    if (!u)
                      for (u = t, i = a - 1, r = o; i > 0; i--)
                        if (((r = (r + 1) % a), d[i] !== t.parentsList[r])) {
                          u = n;
                          break;
                        }
                  }
                  return u ? !1 : void 0;
                }),
                u ? a() : (c = !1)),
              c
            );
          }
          var r = ['PolygonFromPoints', 'Segment', 'Ray', 'Line'];
          return this.isTransformationConstraint || i(this);
        },
        setLabel: function(e, t) {
          var i;
          if (((t = t || {}), '' === e))
            throw o.createError('Cannot set Label to empty string');
          (this.style.label = this.style.label || {}),
            (i = this.style.label),
            t && t.show !== n && (i.showLabel = t.show),
            this.label !== e &&
              t &&
              t.wasUserInitiated &&
              (this.shouldAutogenerateLabel = !1),
            (this.label = e),
            (this.parsedMFS = n),
            (this.state.labelPreRenderJITPrepareDone = !1),
            (t && t.init) || this.descendantLabelGraphHasChanged();
        },
        getLabel: function(e) {
          var t = this.label;
          return (
            (e = e || {}),
            !t &&
              (e.show || e.create || e.constrain) &&
              ((this.isTransformationConstraint &&
                this.style.nameOrigin &&
                'namedFromLabel' !== this.style.nameOrigin) ||
              this.state.labelParent
                ? ((t = this.getParentLabel('source', e) + "'"),
                  (this.style.nameOrigin = 'namedByPrime'))
                : (t = this.sQuery.sketch.labelPool.generateLabel(
                    this.kind,
                    this.genus,
                    this.id
                  )),
              this.setLabel(t, e)),
            e.show &&
              !this.style.label.showLabel &&
              ((this.style.label.showLabel = !0),
              e.init || this.constrainLabel(),
              this.style.hidden || this.invalidateAppearance()),
            this.label
          );
        },
        getParentLabel: function(e, t) {
          var n,
            i = '';
          return (
            (n = this.state.labelParent
              ? this.state.labelParent
              : this.getParent(e)),
            n && (n.getLabel ? (i = n.getLabel(t)) : n.label && (i = n.label)),
            i
          );
        },
        getVisibleParentLabel: function(e, t) {
          var n,
            i = this.getParent(e);
          return i && i.hasLabel
            ? ((n = i.label),
              t && (t.show || t.constrain)
                ? (n || (n = this.getParentLabel(e, t)),
                  i.showExistingLabel(),
                  n)
                : i.style.label.showLabel
                ? n
                : '')
            : '';
        },
      })),
      (o.mixins.transformable = {
        doc: {},
        getTransform: function() {
          return function(e) {
            return e.copy();
          };
        },
        getScalarTransform: function() {
          return function(e) {
            return e;
          };
        },
        getTransformer: function() {
          return this.getParent('source').createTransformer(this);
        },
      }),
      (o.createFloatVector = function(t) {
        return t > 0
          ? e.Float64Array
            ? new Float64Array(t)
            : new Array(t)
          : [];
      }),
      (o.mixins.vector = {
        doc: {},
        createVectorContext: function(e, t, n) {
          throw o.createError('createVectorContext not Implemented');
        },
        resetVectorSamples: function(e) {
          (e.geomBounds = null), (e.filledSampleCount = 0);
        },
        fillSingleSample: function(e, t) {
          throw o.createError('fillSingleSample not Implemented');
        },
        getGeomBoundsVector: function(e) {
          return {
            left: Number.NEGATIVE_INFINITY,
            top: Number.NEGATIVE_INFINITY,
            right: Number.POSITIVE_INFINITY,
            bottom: Number.POSITIVE_INFINITY,
          };
        },
        hitTestVector: function(e, t) {
          throw o.createError('hitTestVector not Implemented');
        },
        getVectorRenderingLayer: function(e) {
          throw o.createError('getVectorRenderingLayer not Implemented');
        },
        renderVector: function(e, t, n, i, r) {
          throw o.createError('renderVector not Implemented');
        },
        prepareVectorRendering: function(e, t, n) {
          throw o.createError('prepareVectorRendering not Implemented');
        },
        cleanupVectorRendering: function(e, t) {
          throw o.createError('cleanupVectorRendering not Implemented');
        },
        positionToPathValueForVector: function(e, t) {
          o.signalErrorWithMessage(
            'path API called on a non-path object vector'
          );
        },
        pathLengthForVector: function(e) {
          o.signalErrorWithMessage(
            'path API called on a non-path object vector'
          );
        },
      }),
      (o.mixins.pointVector = o.makeClass(o.mixins.vector, {
        doc: {},
        isPathSampleGObj: !0,
        createVectorContext: function(e, t, n) {
          return {
            numSamples: e,
            samples: o.createFloatVector(2 * e),
            colors: n ? [] : null,
            lineWidth: t.style.width,
            radius: t.style.radius || 4,
            endpointRadius: t.style.endpointRadius,
            arrowheadRadius: t.style.arrowheadRadius,
            closedPath: t.closedPath,
            isContinuous: !0,
            isDiscrete: 'IterateImage' === t.kind ? !0 : t.isDiscrete,
            discontinuities: [],
          };
        },
        fillSingleSample: function(e, t) {
          var i = 2 * t;
          e.filledSampleCount++,
            this.state.exists
              ? ((e.samples[i] = this.geom.loc.x),
                (e.samples[i + 1] = this.geom.loc.y),
                e.colors && (e.colors[t] = this.style.color),
                (e.geomBounds = o.Geom.unionRectPoint(
                  e.geomBounds,
                  this.geom.loc
                )))
              : ((e.samples[i] = n), (e.samples[i + 1] = n));
        },
        getGeomForSample: function(e, t) {
          var n = 2 * t;
          return { loc: o.GeometricPoint(e.samples[n], e.samples[n + 1]) };
        },
        getGeomBoundsVector: function(e) {
          var t = 0;
          return e.geomBounds
            ? (e.lineWidth && (t = Math.max(t, e.lineWidth / 2)),
              e.radius && (t = Math.max(t, e.radius)),
              e.endpointRadius && (t = Math.max(t, e.endpointRadius)),
              e.arrowheadRadius && (t = Math.max(t, e.arrowheadRadius)),
              o.Geom.insetRect(e.geomBounds, -t))
            : void 0;
        },
        hitTestVector: function(e, t) {
          function n() {
            var n,
              i = e.filledSampleCount,
              r = 2,
              s = e.samples,
              o = e.radius || e.lineWidth / 2;
            for (n = 0; i > n; n++) {
              var a = {
                left: s[n * r] - o,
                right: s[n * r] + o,
                top: s[n * r + 1] - o,
                bottom: s[n * r + 1] + o,
              };
              if (
                !(
                  a.right < t.left ||
                  a.left > t.right ||
                  a.bottom < t.top ||
                  a.top > t.bottom
                )
              )
                return !0;
            }
            return !1;
          }
          function i() {
            var n,
              i,
              r,
              s,
              a = 2 * e.filledSampleCount,
              c = e.samples,
              l = o.GeometricPoint(c[0], c[1]),
              u = e.discontinuities;
            if (((r = l), o.Geom.PointInRect(r, t))) return !0;
            for (n = 2, i = 1; a > n; n += 2, i++) {
              if (
                ((s = o.GeometricPoint(c[n], c[n + 1])),
                o.Geom.PointInRect(s, t))
              )
                return !0;
              if (
                !u[i] &&
                r.isFinite() &&
                s.isFinite() &&
                o.Geom.SegmentSectsRect(t, r, s)
              )
                return !0;
              r = s;
            }
            return e.closedPath &&
              !u[i] &&
              r.isFinite() &&
              l.isFinite() &&
              o.Geom.SegmentSectsRect(t, r, l)
              ? !0
              : void 0;
          }
          return e.isDiscrete ? n() : i();
        },
        getVectorRenderingLayer: function(e) {
          return e.isDiscrete ? 'DiscretePointVectors' : 'LinesCurves';
        },
        prepareVectorRendering: function(e, t, n) {
          return t.isDiscrete
            ? e.prepareDiscretePointVector(n)
            : e.prepareContinuousPointVector(n);
        },
        renderVector: function(e, i, r, s, o) {
          var a = t.extend(!0, {}, o);
          return (
            (a.samples = s.samples),
            (a.colors = a.suppressParametricColor ? n : s.colors),
            (a.numSamples = s.filledSampleCount),
            (a.radius = s.radius),
            s.isDiscrete
              ? e.drawDiscretePointVector(i, a)
              : ((a.discontinuities = s.discontinuities),
                (a.closedPath = s.closedPath),
                (a.width = o.width || 1),
                e.drawContinuousPointVector(i, a))
          );
        },
        cleanupVectorRendering: function(e, t, n) {
          return n.isDiscrete
            ? e.cleanupDiscretePointVector(t)
            : e.cleanupContinuousPointVector(t);
        },
        positionToPathValueForVector: function(e, t) {
          function i() {
            var e, i, r, s, a, c;
            for (e = 0; u > e; e++)
              o.math.isFiniteScalar(l[2 * e]) &&
                o.math.isFiniteScalar(l[2 * e + 1]) &&
                ((s = l[2 * e] - t.x),
                (a = l[2 * e + 1] - t.y),
                (i = s * s + a * a),
                (r === n || r > i) && ((r = i), (c = e)));
            return {
              point: o.GeometricPoint(l[2 * c], l[2 * c + 1]),
              index: c,
            };
          }
          function r(e, t) {
            var n = e.getX() - t.getX(),
              i = e.getY() - t.getY();
            return n * n + i * i;
          }
          function s(i) {
            var s,
              c,
              p,
              f,
              m,
              g,
              b,
              v,
              y,
              x,
              w = a.point,
              k = a.index,
              P = e.discontinuities,
              C = 1 / h;
            return (
              (b = t.subtract(i)),
              k > 0
                ? ((s = 2 * (k - 1)), (y = k))
                : d && ((s = 2 * (u - 1)), (y = e.numSamples)),
              s === n ||
                P[y] ||
                ((p = o.GeometricPoint(l[s], l[s + 1])),
                (p = p.isFinite() ? p.subtract(w) : n)),
              u - 1 > k
                ? ((c = 2 * (k + 1)), (y = k + 1))
                : d && ((c = 0), (y = u)),
              c === n ||
                P[y] ||
                ((f = o.GeometricPoint(l[c], l[c + 1])),
                (f = f.isFinite() ? f.subtract(w) : n)),
              f && p
                ? r(f, b) < r(p, b)
                  ? (m = !0)
                  : (g = !0)
                : f
                ? (m = !0)
                : p && (g = !0),
              m
                ? ((v = f.vLength2()),
                  v &&
                    ((x = f.dot(b) / f.vLength2()),
                    (x = Math.min(Math.max(0, x), 1))))
                : g &&
                  ((v = p.vLength2()),
                  v &&
                    ((x = -p.dot(b) / p.vLength2()),
                    (x = Math.min(Math.max(-1, x), 0)))),
              (x = x ? x : 0),
              x * C
            );
          }
          var a,
            c,
            l = e.samples,
            u = e.numSamples,
            d = e.closedPath,
            h = d ? u : u - 1;
          return (
            (a = i()), (c = a.index / h + s(a.point)), 0 > c && (c += 1), c
          );
        },
        pathLengthForVector: function(e) {
          var t,
            n,
            i,
            r,
            s,
            a = 0,
            c = e.samples,
            l = e.numSamples,
            u = c[0],
            d = c[1];
          for (t = 1; l > t; t++)
            (n = c[2 * t]),
              (i = c[2 * t + 1]),
              o.math.isFiniteScalar(n) &&
                o.math.isFiniteScalar(i) &&
                ((r = n - u),
                (s = i - d),
                (a += Math.sqrt(r * r + s * s)),
                (u = n),
                (d = i));
          return a;
        },
        isDiscontinuous: function(e, t, n, i) {
          var r = 0 > e ? -e : e,
            s = 0 > t ? -t : t,
            o = 0 > n ? -n : n,
            a = 0 > i ? -i : i,
            c = 25;
          if (
            !(
              (r > c &&
                ((e > 0 && 0 >= n) ||
                  (0 > e && n >= 0) ||
                  (o > 0 && r > 8 * o))) ||
              (s > c &&
                ((t > 0 && 0 >= i) ||
                  (0 > t && i >= 0) ||
                  (a > 0 && s > 8 * a)))
            )
          )
            return !1;
          if ((0 !== o && r > 10 * o) || (0 !== a && s > 10 * a)) return !0;
          if (0 === o && 0 === a) return !0;
          var l = e * n + t * i,
            u = t * n - e * i;
          return (u = 0 > u ? -u : u), 0 > l || 3 * u > 5 * l;
        },
        recomputeDiscontinuities: function(e) {
          if (!e.isDiscrete) {
            var t,
              n,
              i,
              r,
              s,
              o,
              a,
              c,
              l,
              u,
              d = e.samples,
              h = e.numSamples,
              p = [],
              f = !1;
            for (l = 0; h > l; ++l)
              (t = d[2 * l]),
                (n = d[2 * l + 1]),
                (u = !(isNaN(t) || isNaN(n))),
                u
                  ? (f
                      ? ((i = t - s),
                        (r = n - o),
                        this.isDiscontinuous(i, r, a, c)
                          ? (p[l] = 'discontinuous')
                          : ((p[l] = !1),
                            'nonexisting' === p[l - 1] ||
                            this.isDiscontinuous(a, c, i, r)
                              ? (p[l - 1] = 'discontinuous')
                              : (p[l - 1] = !1)),
                        (a = i),
                        (c = r))
                      : ((a = 0), (c = 0)),
                    (f = !0),
                    (s = t),
                    (o = n))
                  : ((p[l] = 'nonexisting'), (f = !1), (a = 0), (c = 0));
            e.closedPath &&
              ((t = d[0]),
              (n = d[1]),
              isNaN(t) ||
                isNaN(n) ||
                !f ||
                ((i = t - s),
                (r = n - o),
                (p[l] = this.isDiscontinuous(i, r, a, c)))),
              (e.discontinuities = p);
          }
        },
      })),
      (o.mixins.circleVector = o.makeClass(o.mixins.vector, {
        doc: {},
        createVectorContext: function(e, t, i) {
          var r = 'CircleInterior' === this.kind;
          return {
            numSamples: e,
            samples: o.createFloatVector(3 * e),
            colors: i ? [] : null,
            isInterior: r,
            lineWidth: r ? n : t.style.width,
          };
        },
        fillSingleSample: function(e, t) {
          var n = 3 * t;
          e.filledSampleCount++,
            (e.samples[n] = this.geom.c.x),
            (e.samples[n + 1] = this.geom.c.y),
            (e.samples[n + 2] = this.geom.r),
            e.colors && (e.colors[t] = this.style.color),
            (e.geomBounds = o.Geom.unionRects(
              e.geomBounds,
              o.Geom.insetRect(
                {
                  left: this.geom.c.x,
                  top: this.geom.c.y,
                  right: this.geom.c.x,
                  bottom: this.geom.c.y,
                },
                -this.geom.r
              )
            ));
        },
        getGeomBoundsVector: function(e) {
          var t = 0;
          return e.geomBounds
            ? (e.lineWidth && (t = e.lineWidth / 2),
              o.Geom.insetRect(e.geomBounds, -t))
            : void 0;
        },
        hitTestVector: function(e, t) {
          var n,
            i,
            r,
            s,
            a,
            c,
            l = 3,
            u = e.samples,
            d = e.filledSampleCount,
            h = e.isInterior;
          for (n = 0; d > n; n++)
            if (
              ((i = n * l),
              (s = u[i]),
              (a = u[i + 1]),
              (c = u[i + 2]),
              (r = o.GeometricPoint(s, a)),
              o.Geom.RectIntersectsCurve(t, {
                type: h ? 'circleInterior' : 'circle',
                curve: o.GeometricArc.FromCenterAndRadius(r, c),
              }))
            )
              return !0;
          return !1;
        },
        getVectorRenderingLayer: function(e) {
          return e.isInterior ? 'ExternalImagesAndInteriors' : 'LineLoci';
        },
        prepareVectorRendering: function(e, t, n) {
          return e.prepareCircleVector(n);
        },
        renderVector: function(e, n, i, r, s) {
          var o = t.extend(!0, {}, s);
          return (
            (o.samples = r.samples),
            (o.colors = r.colors),
            (o.isInterior = r.isInterior),
            (o.numSamples = r.filledSampleCount),
            e.drawCircleVector(n, o)
          );
        },
        cleanupVectorRendering: function(e, t) {
          return e.cleanupCircleVector(t);
        },
      })),
      (o.mixins.arcVector = o.makeClass(o.mixins.vector, {
        doc: {},
        createVectorContext: function(e, t, n) {
          var i;
          switch (this.genus) {
            case 'SimpleArc':
              i = 'arc';
              break;
            case 'ArcSector':
              i = 'arcSector';
              break;
            case 'ArcSegment':
              i = 'arcSegment';
          }
          return {
            numSamples: e,
            samples: o.createFloatVector(e * o.GeometricArc.packedSampleSize),
            colors: n ? [] : null,
            lineWidth: t.style.width,
            isInterior: 'SimpleArc' !== this.genus,
            type: i,
          };
        },
        fillSingleSample: function(e, t) {
          var n = this.geom.arc;
          n.packIntoSampleArray(e.samples, t),
            e.filledSampleCount++,
            e.colors && (e.colors[t] = this.style.color),
            (e.geomBounds = o.Geom.unionRects(
              e.geomBounds,
              this.getGeomBounds()
            ));
        },
        getGeomBoundsVector: function(e) {
          var t = 1.5;
          return e.geomBounds
            ? (e.lineWidth && (t += e.lineWidth / 2),
              o.Geom.insetRect(e.geomBounds, -t))
            : void 0;
        },
        hitTestVector: function(e, t) {
          var n,
            i,
            r = e.samples,
            s = e.filledSampleCount,
            a = e.type;
          for (n = 0; s > n; n++)
            if (
              ((i = o.GeometricArc.FromPackedSampleArray(r, n)),
              o.Geom.RectIntersectsCurve(t, { type: a, curve: i }))
            )
              return !0;
          return !1;
        },
        getVectorRenderingLayer: function(e) {
          return e.isInterior ? 'ExternalImagesAndInteriors' : 'LineLoci';
        },
        prepareVectorRendering: function(e, t, n) {
          return e.prepareArcVector(n);
        },
        renderVector: function(e, n, i, r, s) {
          var o = t.extend(!0, {}, s);
          return (
            (o.samples = r.samples),
            (o.colors = r.colors),
            (o.arcType = r.type),
            (o.numSamples = r.filledSampleCount),
            e.drawArcVector(n, o)
          );
        },
        cleanupVectorRendering: function(e, t) {
          return e.cleanupArcVector(t);
        },
      })),
      (o.TouchManager = (function() {
        var e = {};
        return {
          registerTouchWithTracker: function(t, n) {
            e[t] = n;
          },
          trackerForTouch: function(t) {
            return e[t];
          },
          deregisterTouch: function(t) {
            e[t] = n;
          },
        };
      })()),
      (o.TouchRegime = (function() {
        return {
          delegate: null,
          isPushed: !1,
          blocksOtherButtons: function() {
            return !1;
          },
          createTracker: function(e, t) {
            throw o.createError('Unimplemented required method: createTracker');
          },
          hitSlopForTouch: function(e) {
            return e.mouseEvent !== n ? 5 : 15;
          },
        };
      })()),
      (o.TouchTracker = {
        touchBegan: function(e, t) {},
        touchMoved: function(e, t) {},
        touchEnded: function(e, t) {},
        touchCancelled: function(e, t) {},
      }),
      (function() {
        var e = null,
          t = null,
          n = 500,
          i = 500;
        o.TapTracker = {
          startTime: null,
          endTime: null,
          kMaxTapMovement: 5,
          tapState: '',
          checkTapState: function(e) {
            var t = Date.now() - this.startTime > n,
              i = this.distanceMoved(e) > this.kMaxTapMovement;
            return (
              'potential' === this.tapState &&
                (t || i
                  ? (this.tapState = 'rejected')
                  : this.endTime &&
                    this.endTime - this.startTime <= n &&
                    (this.tapState = 'confirmed')),
              this.tapState
            );
          },
          isTap: function() {
            return (
              'potential' === this.tapState && this.checkTapState(this.pos),
              'confirmed' === this.tapState
            );
          },
          registerAsPossibleDoubleTap: function() {
            e &&
              e.endTime &&
              !e.maybeDouble &&
              e.isTap() &&
              this.startTime - e.endTime < i &&
              (this.maybeDouble = !0),
              (e = this);
          },
          isDoubleTap: function() {
            return this.maybeDouble && this.isTap() ? ((e = null), !0) : !1;
          },
          currentOverlapChoice: function(e) {
            return t &&
              t.gobj &&
              e.indexOf(t.gobj) >= 0 &&
              t.gobj.kind === e[0].kind
              ? t.gobj
              : e[0];
          },
          checkForOverlapCycleTap: function() {
            var e,
              n = this.gobjArr[0].kind;
            (this.gobj = this.gobjArr[0]),
              t &&
                (e = this.gobjArr.indexOf(t.gobj)) >= 0 &&
                t.gobj.kind === n &&
                (this.isTap() && (e += 1),
                e < this.gobjArr.length &&
                  this.gobjArr[e].kind === n &&
                  (this.gobj = this.gobjArr[e])),
              (t = this);
          },
        };
      })(),
      (function() {
        var e = 0,
          t = 3e3,
          n = function() {};
        (n.prototype.showModal = function(e, t) {
          var n,
            i = this;
          (i.sketch = e),
            (i.preToolDelta = e.document.getRecentChangesDelta()),
            (n = o.LabelRegime.createForGObject(e, t)),
            (n.delegate = i),
            e.pushTouchRegime(n),
            e.document.changedUIMode(),
            n.confirmActiveTool(function(t) {
              t && e.document.pushConfirmedSketchOpDelta(i.preToolDelta),
                e.popAllTouchRegimesIncluding(n);
            });
        }),
          (n.prototype.regimeDidPop = function(e) {
            this.sketch.document.changedUIMode();
          }),
          (o.LongPressTracker = {
            touchIsInProgress: !0,
            maxDisplacement: 0,
            trackMaxDisplacement: function() {
              var e = Math.max(
                Math.abs(this.lastX - this.origX),
                Math.abs(this.lastY - this.origY)
              );
              this.maxDisplacement = Math.max(this.maxDisplacement, e);
            },
            startLongPressJob: function() {
              function i() {
                !c.touchIsInProgress ||
                  c.maxDisplacement > e ||
                  ((c.touchIsInProgress = !1), new n().showModal(a, o));
              }
              var r,
                s,
                o = this.gobj,
                a = this.sketch,
                c = this;
              o.canEditLabel() &&
                ((s = a.document.getAuthorPreference('enablelabelediting')),
                (r = parseInt(a.metadata.id, 10)),
                'none' === s[0] ||
                  (!s.includes(r) && 'all' !== s[0]) ||
                  a.jobScheduler.addJob(i, { delay: t }));
            },
          });
      })(),
      (function() {
        var e = o.makeClass([o.TouchTracker], {
          touchEnded: function(e) {
            o.positionInElement(e, this.element) &&
              this.clickHandler &&
              this.clickHandler(e);
          },
        });
        o.ClickTracker = {
          createOnElement: function(t, n) {
            var i = Object.create(e);
            return (i.element = t), (i.clickHandler = n), i;
          },
        };
      })(),
      (function() {
        var e = o.makeClass([o.TouchTracker], {
          setDriftRenderState: function(e, n) {
            var i,
              r = this.sQ();
            return (
              this.hotTextRefs.each(function() {
                var s = t(this).data('wsp-mfs-reference-id'),
                  a = !1;
                !i &&
                  o.positionInElement(e, t(this)) &&
                  ((a = !0), (i = r.get(s))),
                  t(this).toggleClass('wsp-mfs-reference-hot', a && n);
              }),
              this.hotTextRefs.each(function() {
                var e = t(this).data('wsp-mfs-reference-id'),
                  s = r.get(e),
                  o = n && s === i ? 'hotTarget' : 'none';
                s.state.renderState !== o && s.setRenderState(o);
              }),
              i
            );
          },
          touchBegan: function(e) {
            this.element.toggleClass('wsp-mfs-reference-tracking', !0),
              this.setDriftRenderState(e, !0);
          },
          touchMoved: function(e) {
            this.setDriftRenderState(e, !0);
          },
          touchEnded: function(e) {
            var t = this.setDriftRenderState(e, !1);
            this.element.toggleClass('wsp-mfs-reference-tracking', !1),
              t && t.press && t.press(this.sQ.sketch);
          },
        });
        o.HotTextTracker = {
          referenceIsHit: function(e, n) {
            var i;
            return (
              n.each(function() {
                return o.positionInElement(e, t(this))
                  ? ((i = t(this)), !1)
                  : void 0;
              }),
              i
            );
          },
          createOnElement: function(t, n, i) {
            var r = Object.create(e);
            return (r.element = t), (r.hotTextRefs = n), (r.sQ = i), r;
          },
        };
      })(),
      (function() {
        o.AbstractToolTracker = o.makeClass(o.TouchTracker, {
          regime: null,
          dragTracker: null,
          possibleTargets: null,
          shouldSnap: function() {
            throw o.createError('shouldSnap not implemented');
          },
          findToolTarget: function(e, t) {
            var n,
              i,
              r =
                !this.matchedGiven || 'Point' === this.matchedGiven.given.kind;
            return (
              (n = this.regime.findHitGObj(
                e,
                this.possibleTargets,
                t,
                this.hitSlop,
                { interiorsPerimeterOnly: r }
              ).hitGObj),
              n
                ? (this.dragTracker.snappingPoints = !1)
                : ((this.dragTracker.snappingPoints = !0),
                  this.shouldSnap() &&
                    e.preferences.snapToGrid &&
                    (i = e.findExistingCoordSys()) &&
                    i.state.exists &&
                    i.snapPoint(t),
                  (n = this.regime.findHitGObj(
                    e,
                    this.possibleTargets,
                    t,
                    this.hitSlop,
                    { interiorsPerimeterOnly: r }
                  ).hitGObj)),
              n
            );
          },
        });
      })(),
      (function() {
        var e = o.makeClass([o.TouchTracker], {
            touchEnded: function(e, t) {
              this.controller.click(t, this.gobj);
            },
          }),
          i = o.makeClass(o.TouchRegime, {
            createTracker: function(t, i) {
              var r,
                s = this.gobj.sQuery.sketch;
              return (
                this.gobj.positionInEditBox(i)
                  ? ((r = Object.create(e)),
                    (r.gobj = this.gobj),
                    (r.controller = this.controller))
                  : (s.popAllTouchRegimesIncluding(this),
                    o.blurDocumentActiveElement(s.baseNode),
                    (r = n)),
                r
              );
            },
          });
        o.NumpadEditRegime = {
          createWithGObj: function(e) {
            var n = e.sQuery.sketch.getDisplayObjForGObj(e).element,
              r = t('.mfs-input', n).data('wsp-numfield-ctl'),
              s = Object.create(i);
            return (s.controller = r), (s.gobj = e), s;
          },
        };
      })(),
      (o.DisplayRegime = (function() {
        var e = o.makeClass(o.TouchRegime, {
          sketch: null,
          name: 'DisplayRegime',
          allowUnselectableTap: function(e) {
            this.unselectableTap = e;
          },
          createTracker: function(e, t) {
            var i,
              r,
              s,
              a,
              c,
              l,
              u,
              d,
              h,
              p = 1e3;
            return (
              (u = this.sketch.getAuthorPreference('enableLabelDragging')),
              (i = this.hitSlopForTouch(e)),
              (c = {
                left: t.x - i,
                top: t.y - i,
                bottom: t.y + i,
                right: t.x + i,
              }),
              (l = { left: t.x, top: t.y, bottom: t.y, right: t.x }),
              (r = this.sketch.hitGObj(c, {
                hotSpot: t,
                maxResults: p,
                unselectableTapOK: this.unselectableTap,
              })),
              (s = r.hitArray),
              s.length > 0 &&
                u &&
                o.Geom.isIntersectRects(l, s[0].getGeomBounds()) &&
                ('Point' === s[0].kind ||
                  'Button' === s[0].kind ||
                  s[0].isOfKind('Measure')) &&
                (a = s[0]),
              o.blurDocumentActiveElement(this.sketch.baseNode),
              (d = u && this.sketch.hitLabel(l)),
              d && !a
                ? o.LabelDragTracker.create(d)
                : s.length
                ? ((h = this.unselectableTap
                    ? { unselectableTap: this.unselectableTap }
                    : {}),
                  r.customTracker ||
                    o.DragTracker.createPotentialLongPress(s, h))
                : this.sketch.getAuthorPreference('disableScrolling')
                ? n
                : this.sketch.Scroll.createTracker()
            );
          },
        });
        return {
          createInSketch: function(t) {
            var n = Object.create(e);
            return (n.sketch = t), n;
          },
        };
      })()),
      (function() {
        var e = 1500,
          t = 3e3;
        o.DragMergeTracker = {
          setHighlights: function(e) {
            var t = e ? 'targetHighlit' : 'none',
              n = this.dmCurProxy;
            n &&
              (this.gobj.setRenderState(e ? 'unmatchedGiven' : 'none'),
              n.style && n.setRenderState(t),
              n.path1 &&
                (n.path1.setRenderState(t), n.path2.setRenderState(t)));
          },
          clearTimers: function() {
            this.dmTimer1 && clearTimeout(this.dmTimer1),
              (this.dmTimer1 = n),
              this.dmTimer2 && clearTimeout(this.dmTimer2),
              (this.dmTimer2 = n);
          },
          registerAsPossibleMerge: function(e) {
            function t(e, t) {
              l.push({ candidate: e, proxy: t });
            }
            function i(e) {
              e.each(function() {
                t(this, this);
              });
            }
            function r(e) {
              e('*').each(function() {
                this.isAPath() && t(this, this);
              });
            }
            function s(e) {
              e.sQuery('*').each(function() {
                var n = e.getLegalMatchForParam(this);
                n && t(n, this);
              });
            }
            function o(e, t) {
              var n;
              for (n = 0; n < t.length; n++)
                (t[n].proxy.style.hidden || t[n].candidate === e) &&
                  (t.splice(n, 1), n--);
              e.eachDescendant(function(e, i) {
                for (n = 0; n < t.length; n++)
                  t[n].candidate === i && t.splice(n, 1);
              });
            }
            var a = this,
              c = this.gobj.kind,
              l = [];
            if (!this.sketch.getAuthorPreference('enableDragMerging'))
              return !1;
            if (
              ((this.dmState = 'Probe'),
              (this.dmCandidates = []),
              (this.dmProxies = []),
              (l = this.dmCandidates),
              (this.dmCurProxy = null),
              (this.dmTimer1 = n),
              (this.dmTimer2 = n),
              (this.dmHitSlop = null),
              (this.dmPreDelta = null),
              'Free' !== this.gobj.constraint ||
                'DisplayRegime' !== this.sketch.currentTouchRegime().name)
            )
              return !1;
            if ('Point' === c)
              r(this.gobj.sQuery, l), i(this.gobj.sQuery(c), l);
            else {
              if (!this.gobj.isParameter || !this.gobj.isParameter()) return !1;
              s(this.gobj, l);
            }
            return (
              o(this.gobj, l),
              0 === l.length
                ? !1
                : ((this.dmHitSlop = this.sketch
                    .currentTouchRegime()
                    .hitSlopForTouch(e)),
                  (this.dmPreDelta = this.sketch.document.getRecentChangesDelta()),
                  (this.dmCandidates = l),
                  l.forEach(function(e) {
                    a.dmProxies.push(e);
                  }),
                  !0)
            );
          },
          getCandidateFromProxy: function(e) {
            var t;
            for (t = 0; t < this.dmCandidates.length; t++)
              if (this.dmCandidates[t].proxy === e)
                return this.dmCandidates[t].candidate;
            return e.constraint.match(/intersection/i)
              ? e
              : void console.log(
                  "getCandidateFromProxy couldn't find proxy: ",
                  e
                );
          },
          touchMoved: function(i, r) {
            function s(e, t) {
              return e === t
                ? !0
                : e &&
                  t &&
                  e.constraint &&
                  t.constraint &&
                  e.path1 &&
                  t.path1 &&
                  e.path2 &&
                  t.path2
                ? e.constraint === t.constraint &&
                  e.path1 === t.path1 &&
                  e.path2 === t.path2
                : !1;
            }
            function a(e) {
              return v.dmProxies.indexOf(e);
            }
            function c(e) {
              var t = v.dmCurProxy;
              return (
                s(e, t) ||
                  (v.clearTimers(), v.setHighlights(!1), (v.dmCurProxy = e)),
                v.dmCurProxy
              );
            }
            function l() {
              var e = a(v.dmCurProxy) + 1;
              return e >= b.length && (e = 0), c(b[e]);
            }
            function u() {
              'Probe' !== v.dmState &&
                (v.setHighlights(!1), v.clearTimers(), (v.dmState = 'Probe'));
            }
            function d() {
              function t() {
                (v.dmTimer1 = n), v.dmCurProxy ? h() : u();
              }
              'Pause' !== v.state &&
                (v.setHighlights(!1),
                v.dmTimer1 || (v.dmTimer1 = setTimeout(t, e)),
                (v.dmState = 'Pause'));
            }
            function h() {
              function e() {
                (v.dmTimer2 = n), l() ? d() : u();
              }
              v.dmCurProxy &&
                (v.dmTimer2 ||
                  ((v.dmTimer2 = setTimeout(e, t)), v.setHighlights(!0)),
                (v.dmState = 'PreMerge'));
            }
            function p() {
              'Point' === v.gobj.kind &&
                ((g = v.sketch.findIntersections(m.hitArray, x, v.dmHitSlop)),
                g &&
                  ((b = b.filter(function(e) {
                    return !e.isAPath || !e.isAPath();
                  })),
                  (b = b.concat(g)),
                  b.sort(function(e, t) {
                    function n(e) {
                      return 'Point' === e.kind
                        ? 0
                        : e.constraint.match(/Intersection/i)
                        ? 1
                        : e.isAPath && e.isAPath()
                        ? 2
                        : void 0;
                    }
                    return n(e) - n(t);
                  })));
            }
            function f() {
              var e,
                t = [];
              return (
                v.dmProxies.forEach(function(e) {
                  t.push(e.proxy);
                }),
                (e = { gobjArray: t, maxResults: 100 }),
                y && (e.gobjHitTestOptions = { interiorsPerimeterOnly: !0 }),
                (e.hotSpot = r),
                (m = v.sketch.hitGObj(k, e) || { hitArray: [] })
              );
            }
            var m,
              g,
              b,
              v = this,
              y = 'Point' === this.gobj.kind,
              x = o.GeometricPoint(i.x, i.y),
              w = this.dmHitSlop,
              k = {
                left: x.x - w,
                top: x.y - w,
                bottom: x.y + w,
                right: x.x + w,
              };
            return (
              (m = f()),
              (b = m.hitArray),
              0 === b.length
                ? (c(null), void u())
                : (p(),
                  void (
                    b.indexOf(v.dmCurProxy) < 0 && (u(), c(b[0]) ? d() : u())
                  ))
            );
          },
          touchEnded: function(e, t) {
            var n,
              i =
                'PreMerge' === this.dmState && this.dmCurProxy
                  ? this.getCandidateFromProxy(this.dmCurProxy)
                  : null,
              r = this.sketch.document,
              s = { gobjId: this.gobj.id };
            return (
              this.setHighlights(!1),
              this.clearTimers(),
              i
                ? ('Point' === this.gobj.kind && i.isAPath && i.isAPath()
                    ? ((s.pathValue = i.mapPositionToPathValue(
                        this.gobj.geom.loc
                      )),
                      (s.pathId = i.id),
                      (n = this.sketch.putGivenOnPath(
                        this.gobj,
                        i,
                        s.pathValue
                      )))
                    : i.path1
                    ? ((s.path1Id = i.path1.id),
                      (s.path2Id = i.path2.id),
                      (n = this.sketch.putGivenOnIntersection(this.gobj, i)))
                    : ((n = this.sketch.mergeGobjToCandidate(this.gobj, i, {
                        skipDescendantUpdate: !0,
                      })),
                      (s.mergeToId = i.id)),
                  (s.delta = r.pushConfirmedSketchOpDelta(this.dmPreDelta)),
                  n && (s.newId = n.id),
                  r.changedUIMode(),
                  this.sketch.event(
                    'MergeGobjs',
                    { gobj: this.gobj, mergeInfo: i },
                    s
                  ),
                  !0)
                : !1
            );
          },
        };
      })(),
      (o.DragTracker = (function() {
        function e(e) {
          var t,
            n = this.controlList,
            i = this.tracker.sketch,
            r = this.tracker.motionId;
          e &&
            ((t = new o.AffineTransform({
              m00: 1,
              m11: 1,
              m20: e.transform.dx,
              m21: e.transform.dy,
            })),
            i.MotionManager.ApplyTransformToControlList(i, t, n, {
              snapPoints: this.tracker.snappingPoints,
              onPathTracksIdealLoc: !0,
            }),
            i.MotionManager.UpdateRefCon(r, null));
        }
        function n() {
          var e = this;
          t.each(this.controlList, function(t, n) {
            n.isController &&
              (n.gobj.transformComplete(n.gobj.sQuery.sketch, e.tracker),
              n.gobj.sQuery.sketch.invalidateGeom(n.gobj));
          });
        }
        var i = o.makeClass(
          [
            o.TouchTracker,
            o.TapTracker,
            o.LongPressTracker,
            o.DragMergeTracker,
          ],
          {
            gobj: null,
            origX: null,
            origY: null,
            lastX: null,
            lastY: null,
            sketch: null,
            motionId: null,
            snappingPoints: !0,
            possibleMerge: !1,
            dragMergeBaseIndex: 3,
            touchBegan: function(t, i) {
              if (
                ((this.origX = this.lastX = t.x),
                (this.origY = this.lastY = t.y),
                (this.tapState = 'potential'),
                this.registerAsPossibleDoubleTap(),
                (this.possibleMerge =
                  'DisplayRegime' === this.sketch.currentTouchRegime().name &&
                  this.registerAsPossibleMerge(i)),
                this.gobj.style.selectable)
              ) {
                var r = this.bap.createControlList([this.gobj]),
                  s = {
                    applyMotion: e,
                    completeMotion: n,
                    controlList: r,
                    tracker: this,
                  };
                (this.motionId = this.motionManager.StartMotion(s)),
                  this.sendTouchEvents &&
                    this.sketch.event('StartDrag', {
                      gobj: this.gobj,
                      position: t,
                      touch: i,
                    }),
                  this.gobj.dragDidStart();
              }
            },
            touchMoved: function(e, n) {
              var i,
                r = this;
              if (this.touchIsInProgress) {
                if (
                  this.options.unselectableTap &&
                  !this.gobj.style.selectable &&
                  (!this.isTap() ||
                    this.distanceMoved(e) > this.kMaxTapMovement) &&
                  (t.each(this.gobjArr, function() {
                    return this.style.selectable && this !== r.gobj
                      ? ((i = this), !1)
                      : void 0;
                  }),
                  i)
                )
                  return (
                    (this.gobj = i),
                    this.touchBegan({ x: this.origX, y: this.origY }),
                    void this.touchMoved(e, n)
                  );
                this.dragConfirmed ||
                  'rejected' !== this.checkTapState() ||
                  ((this.dragConfirmed = !0),
                  this.sendTouchEvents &&
                    this.sketch.event('StartDragConfirmed', {
                      gobj: this.gobj,
                      position: e,
                      touch: n,
                    }));
                var s = {
                    transform: { dx: e.x - this.lastX, dy: e.y - this.lastY },
                    x: e.x,
                    y: e.y,
                  },
                  o = this.motionId,
                  a = this.motionManager.GetRefCon(o);
                a &&
                  ((s.transform.dx += a.transform.dx),
                  (s.transform.dy += a.transform.dy)),
                  this.trackMaxDisplacement(),
                  this.motionManager.UpdateRefCon(o, s),
                  this.possibleMerge &&
                    (
                      this.touchMoved.base[this.dragMergeBaseIndex] ||
                      arguments.callee.base
                    ).call(this, e, n),
                  this.sendTouchEvents &&
                    this.sketch.event('MoveDrag', {
                      gobj: this.gobj,
                      position: e,
                      touch: n,
                    }),
                  (this.lastX = e.x),
                  (this.lastY = e.y);
              }
            },
            distanceMoved: function(e) {
              return Math.max(
                Math.abs(this.lastX - this.origX),
                Math.abs(this.lastY - this.origY)
              );
            },
            touchEnded: function(e, t) {
              var n,
                i =
                  this.isTap() && this.distanceMoved(e) < this.kMaxTapMovement;
              this.gobj.style.selectable &&
                (this.motionManager.ApplyCurrent(),
                this.motionManager.EndMotion(this.motionId),
                this.sketch.invalidateGeom(this.gobj),
                this.gobj.dragDidEnd(),
                this.sendTouchEvents &&
                  (this.possibleMerge &&
                    (n = (
                      this.touchEnded.base[this.dragMergeBaseIndex] ||
                      arguments.callee.base
                    ).call(this, e, t)),
                  n ||
                    i ||
                    this.sketch.event('EndDrag', {
                      gobj: this.gobj,
                      position: e,
                      touch: t,
                    }))),
                this.checkForOverlapCycleTap(),
                this.isDoubleTap() && this.gobj.doubleClicked(t),
                this.sendTouchEvents &&
                  i &&
                  this.sketch.event('Tap', {
                    gobj: this.gobj,
                    position: e,
                    gobjArr: this.gobjArr,
                    touch: t,
                  }),
                (this.touchIsInProgress = !1);
            },
          }
        );
        return {
          create: function(e, t) {
            var n = Object.create(i),
              r = n.currentOverlapChoice(e),
              s = r.sQuery.sketch;
            return (
              (t = t || {}),
              (n.sendTouchEvents = t.sendTouchEvents === !1 ? !1 : !0),
              (n.gobj = r),
              (n.gobjArr = e),
              (n.sketch = s),
              (n.bap = s.Bap),
              (n.motionManager = s.MotionManager),
              (n.options = t),
              n
            );
          },
          createPotentialLongPress: function(e, t) {
            var n = this.create(e, t);
            return n.startLongPressJob(), n;
          },
        };
      })()),
      (o.KeyTracker = (function() {
        function e(e) {
          var t,
            n = this.controlList,
            i = this.tracker.sketch,
            r = this.tracker.motionId;
          e &&
            ((t = new o.AffineTransform({
              m00: 1,
              m11: 1,
              m20: e.transform.dx,
              m21: e.transform.dy,
            })),
            i.MotionManager.ApplyTransformToControlList(i, t, n, {
              snapPoints: this.tracker.snappingPoints,
              onPathTracksIdealLoc: !0,
            }),
            i.MotionManager.UpdateRefCon(r, null));
        }
        function n() {
          var e = this;
          t.each(this.controlList, function(t, n) {
            n.isController &&
              (n.gobj.transformComplete(n.gobj.sQuery.sketch, e.tracker),
              n.gobj.sQuery.sketch.invalidateGeom(n.gobj));
          });
        }
        var i = o.makeClass([], {
          gobj: null,
          sketch: null,
          motionId: null,
          bap: null,
          motionManager: null,
          options: null,
          motionStarted: !1,
          snappingPoints: !0,
          addEvents: function() {
            var e = this;
            this.gobj.htmlNode &&
              (this.gobj.htmlNode.keydown(function(t) {
                e.keyDown(t);
              }),
              this.gobj.htmlNode.keyup(function(t) {
                e.keyUp(t);
              }),
              this.gobj.htmlNode.focusin(function(t) {
                (e.sketch.focusedGobj = e.gobj),
                  e.gobj.setRenderState('targetOnFocus'),
                  e.gobj.handleFocusIn(t, e.sketch);
              }),
              this.gobj.htmlNode.focusout(function(t) {
                e.sketch.setGobjPositionInDocumentBound(),
                  (e.sketch.focusedGobj = ''),
                  'Button' !== e.gobj.kind &&
                    e.gobj.htmlNode.attr('aria-pressed', 'false'),
                  e.gobj.setRenderState('none'),
                  e.gobj.handleFocusOut(t, this.sketch);
              }),
              this.gobj.htmlNode.on('click', function(t) {
                e.sketch.focusedGobj
                  ? e.sketch.focusedGobj &&
                    e.sketch.focusedGobj.htmlNode &&
                    e.gobj.htmlNode &&
                    (e.gobj.htmlNode[0].isSameNode(
                      e.sketch.focusedGobj.htmlNode[0]
                    ) ||
                      e.gobj.htmlNode.focus())
                  : e.gobj.htmlNode && e.gobj.htmlNode.focus(),
                  'Button' !== e.gobj.kind &&
                    e.gobj.htmlNode.attr('aria-pressed', 'true'),
                  e.gobj.handleClick(t, e.sketch);
              }));
          },
          toggleSelectedText: function(e, t) {
            var n = e.text();
            t
              ? -1 === n.lastIndexOf(' selected') && e.text(n + ' selected')
              : -1 !== n.lastIndexOf(' selected') && e.text(n.slice(0, -9));
          },
          keyDown: function(t) {
            var i = '';
            this.sketch.preferences.snapToGrid &&
              (i = this.sketch.findExistingCoordSys()),
              this.sketch.toggleKeyPressClass(!0);
            var r = [37, 38, 39, 40];
            if (-1 !== r.indexOf(t.keyCode)) {
              if (!this.gobj.style.selectable) return;
              t.preventDefault();
              var s = this.bap.createControlList([this.gobj]),
                o = this.distanceMoved(t, i);
              if (this.motionStarted)
                this.motionManager.UpdateRefCon(this.motionId, {
                  transform: o,
                });
              else {
                var a = {
                  applyMotion: e,
                  completeMotion: n,
                  controlList: s,
                  tracker: this,
                };
                this.motionId = this.motionManager.StartMotion(a, {
                  transform: o,
                });
              }
              (this.sketch.gObjectUpdate = !0), (this.motionStarted = !0);
            }
            this.sendTouchEvents &&
              this.sketch.event('KeyDown', { gobj: this.gobj, event: t }),
              this.gobj.handleKeyDown(t, this.sketch);
          },
          distanceMoved: function(e, t) {
            var n = { dx: 0, dy: 0 },
              i = e.ctrlKey || e.metaKey ? 100 : e.shiftKey ? 10 : 1;
            switch (
              (t &&
                'UnitPoint' !== this.gobj.genus &&
                (i =
                  38 === e.keyCode || 40 === e.keyCode
                    ? t.geom.gridSpacing.y
                    : t.geom.gridSpacing.x),
              e.keyCode)
            ) {
              case 38:
                n.dy = -1 * i;
                break;
              case 37:
                n.dx = -1 * i;
                break;
              case 40:
                n.dy = i;
                break;
              case 39:
                n.dx = i;
            }
            return n;
          },
          keyUp: function(e) {
            var t = this;
            if (
              (this.sendTouchEvents &&
                this.sketch.event('KeyUp', { gobj: this.gobj, event: e }),
              null !== this.motionId)
            ) {
              (this.motionStarted = !1),
                this.motionManager.ApplyCurrent(),
                this.motionManager.EndMotion(this.motionId),
                this.sketch.invalidateGeom(this.gobj),
                (this.motionId = null),
                (this.sketch.gObjectUpdate = !1);
              var n = setTimeout(function() {
                t.sketch.updateSpeakableText(), clearTimeout(n);
              }, 300);
            }
            this.gobj.handleKeyUp(e, this.sketch);
          },
        });
        return {
          create: function(e, t) {
            var n = Object.create(i),
              r = e.sQuery().sketch;
            return (
              (t = t || {}),
              (n.gobj = e),
              (n.sketch = r),
              (n.bap = r.Bap),
              (n.motionManager = r.MotionManager),
              (n.options = t),
              n.addEvents(),
              n
            );
          },
        };
      })()),
      (o.LabelDragTracker = (function() {
        var e = o.makeClass([o.TouchTracker, o.TapTracker], {
          gobj: null,
          sketch: null,
          labelCornerDelta: null,
          origX: null,
          origY: null,
          startTime: null,
          endTime: null,
          touchBegan: function(e, t) {
            (this.labelCornerDelta = this.gobj.getLabelCornerDelta(e)),
              (this.origX = e.x),
              (this.origY = e.y),
              (this.startTime = t.mouseEvent.timeStamp);
          },
          touchMoved: function(e, t) {
            this.gobj.setLabelPosition(
              o.GeometricPoint(e.x, e.y),
              this.labelCornerDelta
            ),
              this.sketch.invalidateAppearance(this.gobj);
          },
          distanceMoved: function(e) {
            return Math.max(
              Math.abs(e.x - this.origX),
              Math.abs(e.y - this.origY)
            );
          },
          touchEnded: function(e, t) {
            (this.endTime = t.mouseEvent.timeStamp),
              this.isTap() && this.distanceMoved(e) < this.kMaxTapMovement
                ? this.sketch.event('Tap', {
                    gobj: this.gobj,
                    position: e,
                    gobjArr: this.gobjArr,
                    touch: t,
                    isLabelTap: !0,
                  })
                : this.sketch.event(
                    'EndLabelDrag',
                    { gobj: this.gobj },
                    {
                      newPos: o.GeometricPoint(e.x, e.y),
                      cornerDelta: this.labelCornerDelta,
                      action: 'Dragged',
                    }
                  ),
              (this.touchIsInProgress = !1);
          },
        });
        return {
          create: function(t, n) {
            var i = Object.create(e),
              r = t.sQuery.sketch;
            return (i.gobj = t), (i.sketch = r), i;
          },
        };
      })()),
      (function() {
        o.AbstractToolRegime = o.makeClass(o.TouchRegime, {
          findHitGObj: function(e, n, i, r, s) {
            var o = {
              hotSpot: i,
              assumeArrowSelectable: !0,
              gobjArray: n,
              gobjHitTestOptions: { interiorsPerimeterOnly: !1 },
            };
            return (
              s && t.extend(o.gobjHitTestOptions, s),
              e.hitGObj(
                {
                  left: i.x - r,
                  top: i.y - r,
                  bottom: i.y + r,
                  right: i.x + r,
                },
                o
              ) || {}
            );
          },
        });
      })(),
      (o.ToolRegime = (function() {
        function e(e, t) {
          function i(e) {
            return '' + e.x + '+' + e.y;
          }
          function r(e) {
            return d[i(e)] === n;
          }
          function s(e) {
            var t = h,
              n = h;
            u.right + t + p > c.right && ((t -= f - (g + 2 * p)), v++),
              u.bottom + n + p > c.bottom && ((n -= m - (b + 2 * p)), y++),
              (u.left += t),
              (u.right += t),
              (u.top += n),
              (u.bottom += n),
              e.forEach(function(e) {
                (e.x += t), (e.y += n);
              });
          }
          var a = e.filter(function(e) {
              return 'Point' === e.kind;
            }),
            c = t.metadata.sketchRect,
            l = a.map(function(e) {
              var t = { x: e.geom.loc.x + c.left, y: e.geom.loc.y + c.top };
              return t;
            }),
            u = o.Geom.boundingRect(l),
            d = {};
          t.eachGObj(function(e, t) {
            'Point' !== t.kind || t.style.hidden || (d[i(t.geom.loc)] = !0);
          });
          for (
            var h = 25,
              p = 10,
              f = c.right - c.left,
              m = c.bottom - c.top,
              g = u.right - u.left,
              b = u.bottom - u.top,
              v = 0,
              y = 0,
              x = !1;
            !(x || ((x = l.every(r)), v >= 2 && y >= 2));

          )
            x || s(l);
          if (!x) {
            var w = Math.random() * h,
              k = Math.random() * h;
            l.forEach(function(e) {
              (e.x += w), (e.y += k);
            });
          }
          for (var P = {}, C = 0; C < a.length; ++C) P[a[C].id] = l[C];
          return P;
        }
        function t(e, t) {
          e.presentUI(function(e) {
            'changesAccepted' === e
              ? t.toolController.confirmActiveTool()
              : t.toolController.abortActiveTool();
          });
        }
        function i(e, t) {
          var i = o.isNumber(e.givenSortOrder),
            r = o.isNumber(t.givenSortOrder);
          if (i && r) return o.compare(e.givenSortOrder, t.givenSortOrder);
          if (i) return -1;
          if (r) return 1;
          var s = e.label === n ? '' : e.label,
            a = t.label === n ? '' : t.label;
          return o.naturalSortCaseInsensitive(s, a);
        }
        var r = o.makeClass([o.AbstractToolTracker, o.TapTracker], {
            touchBegan: function(e) {
              var t,
                n,
                i = this.matchedGiven,
                r = i.given,
                s = this.regime,
                a = o.GeometricPoint(e.x, e.y);
              i && s.touchesDownOnGivens++,
                i &&
                  (this.registerAsPossibleDoubleTap(),
                  (this.possibleTargets = this.session.getLegalMatchesForGiven(
                    r,
                    this.possibleTargets
                  )),
                  'Point' === r.kind
                    ? ((this.isPointMatchedGiven = !0),
                      (t = r.geom.loc),
                      (n = o.Geom.insetRect(
                        { left: t.x, right: t.x, top: t.y, bottom: t.y },
                        -this.hitSlop
                      )),
                      o.Geom.PointInRect(a, n) && (a = i.updateDeltaToGiven(a)))
                    : (a = i.updateDeltaToGiven(a)),
                  (this.dragTracker = o.DragTracker.create([i.given], {
                    sendTouchEvents: !1,
                  })),
                  (this.adjustChaseTarget = s.startChasing(i, a)),
                  this.touchMoved(a));
            },
            findNewMergeCandidate: function(e) {
              function t() {
                var e,
                  t,
                  n,
                  i,
                  r = l.dragTracker;
                if (h.geom.loc) {
                  t = r.motionManager;
                  try {
                    for (e = 0; e < t.motionList.length; e++)
                      if (
                        ((n = t.motionSet[t.motionList[e]]),
                        (i = n.motion.controlList[0]),
                        'active' === n.state && i.gobj === h)
                      ) {
                        if (!i.idealLocation)
                          throw o.createError(
                            "adjustUnsnapPos() couldn't find given in controlList, "
                          );
                        i.idealLocation.loc = o.GeometricPoint(
                          r.lastX,
                          r.lastY
                        );
                      }
                  } catch (e) {
                    throw o.createError(
                      'findMergeCandidate() failed to clear idealLocation, ',
                      e
                    );
                  }
                }
              }
              var i,
                r,
                s,
                a,
                c,
                l = this,
                u = this.session.sketch,
                d = this.matchedGiven,
                h = d.given,
                p = this.findToolTarget(u, e),
                f = d.mergeCandidate;
              return (
                p &&
                  h.genus.includes('Parameter') &&
                  ((r = p),
                  (p = h.getLegalMatchForParam(p)),
                  r === p && (r = null)),
                p && p === d.unsnappingFrom
                  ? (p = n)
                  : !p && d.unsnappingFrom && delete d.unsnappingFrom,
                (s = p && h.isAPath() && p.isAPath()),
                (c = (p || f) && p !== f),
                c &&
                  f &&
                  ((a = o.GeometricPoint(
                    this.dragTracker.lastX,
                    this.dragTracker.lastY
                  )),
                  d.unsnapFromCandidate(a),
                  t()),
                p &&
                  p.isAPath() &&
                  'Point' === h.kind &&
                  (i = u.findPotentialIntersection(
                    p,
                    this.possibleTargets,
                    e,
                    this.hitSlop
                  )),
                i ? d.setIntersectInfo(i) : d.clearIntersectInfo(),
                c &&
                  !i &&
                  p &&
                  (d.setMergeCandidate(p, r),
                  s
                    ? this.regime.animatePathSnap(d)
                    : 'active' !== d.chase &&
                      ('paused' === d.chase
                        ? (this.adjustChaseTarget = this.regime.startChasing(
                            d,
                            e
                          ))
                        : d.snapToCandidate(e))),
                c
              );
            },
            touchMoved: function(e) {
              var t = this.matchedGiven,
                n = o.GeometricPoint(e.x, e.y),
                i = this.regime,
                r = t.given;
              if (!t)
                throw o.createError("touchMoved doesn't have a matched given");
              if (
                ('active' === t.chase &&
                  this.adjustChaseTarget &&
                  this.adjustChaseTarget(n),
                t.delayed)
              )
                o.Geom.PointInRect(n, t.dragRect) ||
                  ('givenParent' === r.toolRole ||
                  ('constructibleGiven' === r.toolRole && t.mergeCandidate)
                    ? ((this.matchedGiven = i.unsnapConstructibleGiven(t)),
                      (t = this.matchedGiven))
                    : 'constructibleGiven' === r.toolRole
                    ? (this.matchedGiven = i.recomposeConstructibleGiven(t))
                    : 'given' === r.toolRole &&
                      (this.matchedGiven = i._confirmDelayedMatchedGiven(t)));
              else if (!this.findNewMergeCandidate(n) && t.mergeCandidate) {
                if (r.isAPath() && t.mergeCandidate.isAPath()) return;
                if (r.geom.loc)
                  return (
                    (r.geom.loc = t.getSnappedPosition(n)),
                    void r.invalidateGeom()
                  );
              }
              t.isSnapping ||
                'active' === t.chase ||
                (this.dragTracker.started ||
                  (this.dragTracker.touchBegan(n),
                  (this.dragTracker.started = !0)),
                this.dragTracker.touchMoved(n));
            },
            shouldSnap: function() {
              return this.isPointMatchedGiven;
            },
            rejectDelayedMatchedGiven: function(e) {
              var t = this.unmatchedGivens[0];
              t &&
                ((this.possibleTargets = this.regime.sharedMergeCandidateList),
                (this.possibleTargets = this.session.getLegalMatchesForGiven(
                  t,
                  this.possibleTargets
                )),
                (this.matchedGiven = this.regime._addGObjAsMatchedGiven(t)),
                this.regime.snapGivenToPos(
                  this.matchedGiven,
                  o.GeometricPoint(e.x, e.y)
                ),
                this.findNewMergeCandidate(e),
                this.dragTracker.touchEnded(),
                (this.dragTracker = o.DragTracker.create([t], {
                  sendTouchEvents: !1,
                })),
                this.dragTracker.touchBegan(e));
            },
            touchEnded: function(e, t) {
              var i,
                r,
                s = o.GeometricPoint(e.x, e.y),
                a = this.regime;
              this.matchedGiven &&
                (this.matchedGiven.delayed && this.rejectDelayedMatchedGiven(s),
                (i = this.matchedGiven.given),
                (r = this.matchedGiven.mergeCandidate),
                this.dragTracker.started && this.dragTracker.touchEnded(),
                this.matchedGiven.completeMatch(s),
                i.isAPath() && a.forgetGivenParents(this.matchedGiven.given),
                (this.matchedGiven.deltaToGiven = n),
                a.touchesDownOnGivens--,
                a.confirmToolWhenReady() ||
                  (a.sequentialSnapping &&
                    this.unmatchedGivens.length > 0 &&
                    this.unmatchedGivens[0].setRenderState('unmatchedGiven')),
                this.isDoubleTap() &&
                  (r ? r.doubleClicked(t) : i && i.doubleClicked(t)));
            },
          }),
          s = o.makeClass(o.AbstractToolRegime, {
            name: 'ToolRegime',
            hitSlopForTouch: function(e) {
              return e.mouseEvent !== n ? 5 : 15;
            },
            _addGObjAsMatchedGiven: function(e) {
              var t,
                n = this.sharedUnmatchedGivens;
              if (((t = n.indexOf(e)), -1 === t))
                throw o.createError(
                  'Tool regime adding an unknown matched given'
                );
              var i = this.toolplaySession.addGObjAsMatchedGiven(e);
              return n.splice(t, 1), i;
            },
            getConstructibleChild: function(e) {
              var t, n, i;
              for (t = 0; t < e.children.length; t++)
                if (
                  ((n = e.children[t]), 'constructibleGiven' === n.toolRole)
                ) {
                  i = n;
                  break;
                }
              if (!i || 'givenParent' !== e.toolRole)
                throw o.createError(
                  'Asssumptions wrong in getConstructibleChild'
                );
              return i;
            },
            snapGivenToPos: function(e, t) {
              var n,
                i,
                r = e.given;
              if ('given' === r.toolRole || 'givenParent' === r.toolRole)
                (r.geom.loc = t), r.invalidateGeom();
              else {
                if ('constructibleGiven' !== r.toolRole)
                  throw o.createError(
                    'unrecognized toolRole in snapGivenToPos'
                  );
                (n = r.mapPositionToPathPosition(t)),
                  (i = o.GeometricPoint(t.x - n.x, t.y - n.y)),
                  r.parentsList.forEach(function(e) {
                    if ('givenParent' !== e.toolRole)
                      throw o.createError(
                        'unrecognized parent in snapGivenToPos'
                      );
                    (e.geom.loc.x += i.x),
                      (e.geom.loc.y += i.y),
                      e.invalidateGeom();
                  });
              }
            },
            _addGObjAsDelayedMatchedGiven: function(e, t, n) {
              var i = this.toolplaySession.existingMatchedGivenForGObj(e);
              return (
                i || (i = o.Tool.createMatchedGiven(e, this.toolplaySession)),
                (i.delayed = !0),
                (i.toolRole = e.toolRole ? e.toolRole : 'none'),
                (i.pos = t),
                (i.dragRect = {
                  left: t.x - n,
                  right: t.x + n,
                  top: t.y - n,
                  bottom: t.y + n,
                }),
                i
              );
            },
            _confirmDelayedMatchedGiven: function(e) {
              var t = e.given,
                n = e.mergeCandidate,
                i = this.sharedUnmatchedGivens,
                r = i.indexOf(t);
              return (
                n && (n.state.renderState = 'none'),
                0 > r && i.unshift(t),
                this._addGObjAsMatchedGiven(t)
              );
            },
            _matchedGivenAndTrackerForTouch: function(e, t) {
              function n(e, t) {
                var n = t.matchedGivens.findIndex(function(t) {
                  return t.given.id === e.id;
                });
                return n >= 0 && t.matchedGivens[n].mergeCandidate;
              }
              function i(e, t) {
                var i = p.getConstructibleChild(e);
                return n(i, t);
              }
              function r(e) {
                g.length
                  ? g[0].setRenderState('unmatchedGiven')
                  : f.toolController.confirmActiveTool();
              }
              function s() {
                p.cachedGivenParents &&
                  ((l = p.findHitGObj(f, p.cachedGivenParents, t, m)),
                  (u = l.hitGObj),
                  u &&
                    (i(u, h)
                      ? (d = p._addGObjAsDelayedMatchedGiven(u, t, m))
                      : (p.decomposeConstructibleGiven(u),
                        (d = p._addGObjAsMatchedGiven(u)))));
              }
              function o() {
                (l = p.findHitGObj(f, g, t, m, { onCompleteUI: r })),
                  (u = l.hitGObj),
                  u &&
                    (d =
                      p.sequentialSnapping && u !== g[0]
                        ? p._addGObjAsDelayedMatchedGiven(u, t, m)
                        : p._addGObjAsMatchedGiven(u));
              }
              function a() {
                (l = p.findHitGObj(f, h.arrayOfMatchedGivenGObjs(), t, 3)),
                  (u = l.hitGObj),
                  u &&
                    (('givenParent' === u.toolRole && i(u, h)) ||
                    ('constructibleGiven' === u.toolRole && n(u, h))
                      ? (d = p._addGObjAsDelayedMatchedGiven(u, t, m))
                      : ('givenParent' === u.toolRole &&
                          p.decomposeConstructibleGiven(u),
                        (d = h.existingMatchedGivenForGObj(u))));
              }
              function c() {
                (l = p.findHitGObj(f, p.cachedConstructibles, t, m)),
                  (u = l.hitGObj),
                  u &&
                    'constructibleGiven' === u.toolRole &&
                    (d = p._addGObjAsDelayedMatchedGiven(u, t, m));
              }
              var l,
                u,
                d,
                h = this.toolplaySession,
                p = this,
                f = h.sketch,
                m = this.hitSlopForTouch(e),
                g = this.sharedUnmatchedGivens;
              return (
                s(),
                d || o(),
                d || a(),
                d || c(),
                !d &&
                  p.sequentialSnapping &&
                  g.length &&
                  ((u = g[0]), (d = p._addGObjAsMatchedGiven(u))),
                g.length &&
                  g[0] !== u &&
                  p.sequentialSnapping &&
                  g[0].setRenderState('matchedGiven'),
                { matchedGiven: d, customTracker: l.customTracker }
              );
            },
            decomposeConstructibleGiven: function(e, t) {
              function n(e, t) {
                (r = t.indexOf(e)), r >= 0 && t.splice(r, 1);
              }
              var r,
                s,
                a,
                c,
                l = this.getConstructibleChild(e),
                u = this.sharedUnmatchedGivens,
                d = l.parentsList,
                h = [];
              if (-1 === this.cachedConstructibles.indexOf(l)) {
                for (
                  this.cachedConstructibles.push(l),
                    l.setRenderState('none'),
                    n(l, u),
                    a = this.toolplaySession.existingMatchedGivenForGObj(l),
                    t = t || (a && a.candidate),
                    n(a, this.toolplaySession.matchedGivens),
                    u[0] &&
                      u[0].setRenderState(
                        this.sequentialSnapping
                          ? 'matchedGiven'
                          : 'unmatchedGiven'
                      ),
                    s = 0;
                  s < d.length;
                  s++
                )
                  (c = d[s]),
                    (r = this.cachedGivenParents.indexOf(c)),
                    -1 !== r && this.cachedGivenParents.splice(r, 1),
                    h.push(c);
                for (h.sort(i), s = h.length - 1; s >= 0; s--)
                  if (
                    ((c = h[s]),
                    (r = u.indexOf(c)),
                    r > -1 && u.splice(r, 1),
                    u.unshift(c),
                    c !== e)
                  )
                    if (
                      (c.setRenderState(
                        this.sequentialSnapping
                          ? 'matchedGiven'
                          : 'unmatchedGiven'
                      ),
                      'Point' === c.kind && t)
                    )
                      (c.geom.loc.x += 10),
                        (c.geom.loc.y += 10),
                        c.invalidateGeom();
                    else if ('Point' !== c.kind)
                      throw o.createError(
                        "decomposeConstructibleGiven can't handle non-point given parents."
                      );
              }
            },
            recomposeConstructibleGiven: function(e) {
              var t,
                n,
                i,
                r,
                s = e.given,
                a = this.cachedConstructibles.indexOf(s);
              if ('constructibleGiven' !== s.toolRole)
                throw o.createError(
                  'Wrong role in recomposeConstructibleGiven.'
                );
              if (-1 !== a)
                for (
                  this.cachedConstructibles.splice(a, 1),
                    t = s.parentsList.length - 1;
                  t >= 0;
                  t--
                )
                  (n = s.parentsList[t]),
                    n.setRenderState(
                      this.sequentialSnapping
                        ? 'matchedGiven'
                        : 'unmatchedGiven'
                    ),
                    (i = this.toolplaySession.existingMatchedGivenForGObj(n)),
                    (a = this.toolplaySession.matchedGivens.indexOf(i)),
                    a >= 0 &&
                      ((r = this.toolplaySession.matchedGivens[a]
                        .mergeCandidate),
                      r && r.setRenderState('none'),
                      i.unsnapFromCandidate(),
                      this.toolplaySession.matchedGivens.splice(a, 1)),
                    (a = this.cachedGivenParents.indexOf(n)),
                    0 > a && this.cachedGivenParents.unshift(n);
              return this._confirmDelayedMatchedGiven(e);
            },
            unsnapConstructibleGiven: function(e) {
              var t,
                n,
                i,
                r,
                s = e.given,
                a = this.toolplaySession,
                c = a.matchedGivens,
                l = e.mergeCandidate;
              if (
                ((t =
                  'constructibleGiven' === s.toolRole
                    ? s
                    : this.getConstructibleChild(s)),
                !t.toolRole ||
                  'constructibleGiven' !== t.toolRole ||
                  !e.delayed)
              )
                throw o.createError('Wrong role in unsnapConstructibleGiven');
              return (
                (n = c.findIndex(function(e) {
                  return e.given.id === t.id;
                })),
                0 > n
                  ? t === s
                    ? this.recomposeConstructibleGiven(e)
                    : ((n = c.findIndex(function(e) {
                        return e.given.id === s.id;
                      })),
                      c.splice(n, 1),
                      e)
                  : ((i = c.splice(n, 1)[0]),
                    i.unsnapFromCandidate(),
                    this.sequentialSnapping &&
                      this.sharedUnmatchedGivens.length > 0 &&
                      this.sharedUnmatchedGivens[0].setRenderState('none'),
                    t === s
                      ? this.sharedUnmatchedGivens.unshift(t)
                      : this.decomposeConstructibleGiven(s, i.mergeCandidate),
                    (r = this._confirmDelayedMatchedGiven(e)),
                    (r.unsnappingFrom = l),
                    r)
              );
            },
            createTracker: function(e, t) {
              function n(n) {
                var i;
                return n && n.mergeCandidate && o.isParameter(n.mergeCandidate)
                  ? ((i = c.findHitGObj(
                      a.sketch,
                      [n.mergeCandidate],
                      t,
                      c.hitSlopForTouch(e)
                    )),
                    i.customTracker
                      ? o.ClickTracker.createOnElement(
                          i.hitGObj.getEditBoxElement(),
                          function() {
                            i.hitGObj.presentUI();
                          }
                        )
                      : !1)
                  : !1;
              }
              var i,
                s,
                a = this.toolplaySession,
                c = this;
              o.blurDocumentActiveElement(a.sketch.baseNode);
              var l = a.sketch.currentTouchRegime();
              if (l !== this)
                'ToolRegime' === l.name &&
                  l.toolplaySession.sketch.constrainAndRedraw(),
                  (i = l.createTracker(e, t));
              else {
                var u = this._matchedGivenAndTrackerForTouch(e, t);
                if (u.customTracker) i = u.customTracker;
                else {
                  if ((s = n(u.matchedGiven))) return s;
                  (i = Object.create(r)),
                    (i.session = a),
                    (i.regime = this),
                    (i.unmatchedGivens = this.sharedUnmatchedGivens),
                    (i.givenParents = this.cachedGivenParents),
                    (i.possibleTargets = this.sharedMergeCandidateList),
                    (i.hitSlop = this.hitSlopForTouch(e)),
                    (i.matchedGiven = u.matchedGiven);
                }
              }
              return i;
            },
            pointInRegion: function(e, t) {
              var n = 3;
              return (
                t.isOfGenus('Interior') &&
                t.hitTest(
                  {
                    left: e.x - n,
                    right: e.x + n,
                    top: e.y - n,
                    bottom: e.y + n,
                  },
                  e
                )
              );
            },
            forgetGivenParents: function(e) {
              var t = this.sharedUnmatchedGivens;
              e.parentsList.forEach(function(e) {
                var n = t.indexOf(e);
                n > -1 && t.splice(n, 1);
              });
            },
            animatePathSnap: function(e) {
              function t(e, t) {
                var n = t.x - e.x,
                  i = t.y - e.y;
                return n * n + i * i;
              }
              function n() {
                if (e.mergeCandidate !== m) return !1;
                var t,
                  n = Date.now();
                switch (((a = Math.min((n - s) / b, 1)), (t = 1 - a), f.kind)) {
                  case 'Straight':
                  case 'Polygon':
                  case 'Circle':
                  case 'Arc':
                    c.forEach(function(e, n) {
                      var i = l[n],
                        r = u[n];
                      i &&
                        r &&
                        ((e.geom.loc.x = t * i.x + a * r.x),
                        (e.geom.loc.y = t * i.y + a * r.y),
                        e.invalidateGeom());
                    });
                }
                return 1 !== a;
              }
              function i() {
                (d.pathAnimationJob = null),
                  (e.isSnapping = !1),
                  (b = 1),
                  n(),
                  e.snapToCandidate(),
                  d.confirmToolWhenReady();
              }
              function r() {
                (b = 1e3),
                  (s = Date.now()),
                  (a = 0),
                  (d.pathAnimationJob = p.jobScheduler.addJob(n, {
                    done: i,
                    delay: 50,
                    repeat: !0,
                  }));
              }
              var s,
                a,
                c = [],
                l = [],
                u = [],
                d = this,
                h = d.toolplaySession,
                p = h.sketch,
                f = e.given,
                m = e.mergeCandidate,
                g = f.state.renderState,
                b = 1e3;
              if (
                (d.clearAnimations(),
                f.isAPath() &&
                  'constructibleGiven' === f.toolRole &&
                  m.parentsList.length === f.parentsList.length)
              ) {
                switch (
                  (f.parentsList.forEach(function(e) {
                    'givenParent' === e.toolRole && c.push(e);
                  }),
                  m.kind)
                ) {
                  case 'Straight':
                  case 'Axis':
                    if (2 !== c.length)
                      throw o.createError(
                        'incorrect # of givenParent objects for a straight match.'
                      );
                    l.push(f.geom.p0),
                      l.push(f.geom.p1),
                      u.push(m.geom.p0),
                      u.push(m.geom.p1),
                      (f.isOfGenus('Ray') && m.isOfGenus('Ray')) ||
                        (t(l[0], u[0]) + t(l[1], u[1]) >
                          t(l[0], u[1]) + t(l[1], u[0]) &&
                          u.reverse());
                    break;
                  case 'Circle':
                    'CircleFromTwoPoints' === m.constraint
                      ? (l.push(f.parents.p0.geom.loc),
                        l.push(f.parents.p1.geom.loc),
                        u.push(m.parents.p0.geom.loc),
                        u.push(m.parents.p1.geom.loc))
                      : (l.push(f.parents.p0.geom.loc),
                        l.push(f.parents.p1.geom.loc),
                        u.push(m.geom.c),
                        u.push(
                          u[0].add(
                            l[1].subtract(l[0]).multiply(m.geom.r / f.geom.r)
                          )
                        ));
                    break;
                  case 'Polygon':
                    if (f.parentsList.length !== m.parentsList.length)
                      throw o.createError(
                        'incompatible polygons in doMatchAnimation().'
                      );
                    f.geom.points.forEach(function(e, t) {
                      l.push(e), u.push(m.geom.points[t]);
                    });
                    break;
                  case 'Arc':
                    var v,
                      y,
                      x = m.geom.arc;
                    if ('Arc3Points' !== f.constraint)
                      throw o.createError(
                        'animatePathSnap: wrong arc constraint.'
                      );
                    l.push(f.parents.p0.geom.loc),
                      l.push(f.parents.p1.geom.loc),
                      l.push(f.parents.p2.geom.loc),
                      u.push(x.finalPoint),
                      u.push(x.middlePoint),
                      (v = x.center.distance(x.initialPoint)),
                      (y = x.initialPoint
                        .subtract(x.center)
                        .multiply(x.radius / v)),
                      u.push(x.center.add(y));
                    break;
                  default:
                    throw o.createError('Unrecognized constructibleGiven');
                }
                f.setRenderState('matchedGiven'),
                  (e.isSnapping = !0),
                  r(),
                  f.setRenderState(g);
              }
            },
            startChasing: function(e, t) {
              function n(e, t) {
                return e.multiply(1 - d).add(t.multiply(d));
              }
              function i() {
                var e;
                y
                  ? ((e = h.subtract(C[0])),
                    (C[0] = h),
                    k.forEach(function(t, n) {
                      C[n] = C[n].add(e);
                    }))
                  : p
                  ? (C[0] = h.add(p))
                  : (C[0] = h),
                  (h = null);
              }
              function r() {
                return (
                  h && i(),
                  (d = Math.min((Date.now() - u) / S, 1)),
                  k.forEach(function(e, t) {
                    e && ((e.geom.loc = n(P[t], C[t])), e.invalidateGeom());
                  }),
                  1 > d
                );
              }
              function s() {
                (b.chaseAnimationJob = null),
                  1 > d
                    ? (e.chase = 'paused')
                    : (r(),
                      (e.chase = 'finished'),
                      e.mergeCandidate && e.snapToCandidate()),
                  b.confirmToolWhenReady();
              }
              function a() {
                (e.chase = 'active'),
                  (e.deltaToGiven = o.GeometricPoint(0, 0)),
                  (S = b.animateMatching ? 1e3 : 1),
                  (u = Date.now()),
                  (d = 0),
                  (b.chaseAnimationJob = w.jobScheduler.addJob(r, {
                    done: s,
                    delay: 20,
                    repeat: !0,
                  }));
              }
              function c(e) {
                h = e;
              }
              var l,
                u,
                d,
                h,
                p,
                f,
                m,
                g,
                b = this,
                v = e.given,
                y = 'constructibleGiven' === v.toolRole,
                x = b.toolplaySession,
                w = x.sketch,
                k = [],
                P = [],
                C = [],
                S = 1e3,
                A = 10;
              return (
                y
                  ? this.pointInRegion(t, v) ||
                    (p = t.subtract(v.mapPositionToPathPosition(t)))
                  : ((f = v.getGeomBounds()),
                    o.Geom.PointInRect(t, f) ||
                      ((m = o.GeometricPoint(
                        (f.left + f.right) / 2,
                        (f.top + f.bottom) / 2
                      )),
                      (p = v.geom.loc.subtract(m)))),
                p &&
                  (y
                    ? ((C[0] = t),
                      (P[0] = t.add(p)),
                      v.parentsList.forEach(function(e, t) {
                        (k[t + 1] = e),
                          (P[t + 1] = e.geom.loc),
                          (C[t + 1] = P[t + 1].add(p));
                      }))
                    : ((C[0] = t.add(p)),
                      (k[0] = v),
                      (P[0] = o.GeometricPoint(v.geom.loc.x, v.geom.loc.y))),
                  (l = Math.max(
                    Math.abs(P[0].x - C[0].x),
                    Math.abs(P[0].y - C[0].y)
                  )),
                  l > A && (a(), (g = c))),
                g
              );
            },
            clearAnimations: function() {
              this.pathAnimationJob &&
                (this.toolplaySession.sketch.jobScheduler.clearJob(
                  this.pathAnimationJob
                ),
                (this.pathAnimationJob = null)),
                this.chaseAnimationJob &&
                  (this.toolplaySession.sketch.jobScheduler.clearJob(
                    this.chaseAnimationJob
                  ),
                  (this.chaseAnimationJob = null)),
                this.confirmToolWhenReady();
            },
            confirmToolWhenReady: function() {
              var e =
                0 === this.sharedUnmatchedGivens.length &&
                0 === this.touchesDownOnGivens;
              return (
                e &&
                  this.toolplaySession &&
                  (this.pathAnimationJob ||
                    this.chaseAnimationJob ||
                    this.toolplaySession.sketch.toolController.confirmActiveTool()),
                e
              );
            },
            confirmActiveTool: function(e) {
              var t;
              this.sharedUnmatchedGivens.every(function(e) {
                return (
                  'Calculation' === e.constraint &&
                    '' === e.expression &&
                    (t = e),
                  !t
                );
              }),
                t ||
                  this.toolplaySession.matchedGivens.every(function(e) {
                    var n = e.given,
                      i = e.mergeCandidate;
                    return (
                      'Calculation' === n.constraint &&
                        '' === n.expression &&
                        ((t = n),
                        i && 'Calculation' === i.constraint && (t = i)),
                      !t
                    );
                  }),
                this.toolplaySession.confirmPlayback(t),
                (this.toolplaySession = null),
                e(!0);
            },
            doCleanup: function() {
              this.toolplaySession &&
                (this.sharedUnmatchedGivens.forEach(function(e) {
                  e.setRenderState('none');
                }),
                (this.sharedUnmatchedGivens = null),
                this.toolplaySession.abortPlayback(),
                (this.toolplaySession = null),
                (this.sharedMergeCandidateList = null));
            },
          });
        return {
          createWithTool: function(n, r) {
            var o,
              a,
              c = r.createSession(n),
              l = [],
              u = [],
              d = [],
              h = [],
              p = [],
              f = c.givenArray,
              m = Object.create(s),
              g = 1 === f.length && 1 === c.objectGraph.length;
            c.playAssumeds(),
              (m.sequentialSnapping = n.getAuthorPreference(
                'sequentialSnapping'
              )),
              (m.animateMatching = n.getAuthorPreference(
                'animateToolMatching'
              )),
              n.gobjList.renderList.forEach(function(e) {
                var t = e.style.layerOrder;
                e.style.hidden || l.push(e),
                  t && t >= c.nextLayerOrder && (c.nextLayerOrder = t + 1);
              });
            var b,
              v = e(f, n);
            for (o = c.getNextGiven(); o; )
              'constructibleGiven' === o.toolRole
                ? (a = n.gobjList.gobjects[o.id])
                : ((b = v[o.id] || { x: o.geom.loc.x, y: o.geom.loc.y }),
                  (a = c.playGiven(o, b, !0))),
                u.push(a),
                a.setRenderState(
                  m.sequentialSnapping ? 'matchedGiven' : 'unmatchedGiven'
                ),
                (o = c.getNextGiven());
            return (
              u.sort(i),
              (h = u.filter(function(e) {
                return 'constructibleGiven' === e.toolRole;
              })),
              h.forEach(function(e) {
                var t,
                  n = u.indexOf(e),
                  i = e.givenSortOrder,
                  r = !0;
                (i = i ? i : 1 / 0),
                  e.parentsList.forEach(function(e) {
                    return (
                      (t = e.givenSortOrder),
                      t && i > t ? void (r = !1) : void 0
                    );
                  }),
                  r
                    ? e.parentsList.forEach(function(e) {
                        var t = u.indexOf(e);
                        d.push(e), u.splice(t, 1);
                      })
                    : (p.push(e), u.splice(n, 1));
              }),
              c.setRelativePositions(),
              m.sequentialSnapping &&
                (u.sort(i), u[0] && u[0].setRenderState('unmatchedGiven')),
              (m.toolplaySession = c),
              (m.sharedUnmatchedGivens = u),
              (m.cachedGivenParents = d),
              (m.cachedConstructibles = p),
              (m.sharedMergeCandidateList = l),
              (m.touchesDownOnGivens = 0),
              g && t(a, n),
              m
            );
          },
        };
      })()),
      (o.LabelRegime = (function() {
        var e = o.makeClass([o.AbstractToolTracker], {
            shouldSnap: function() {
              return !1;
            },
            touchBegan: function(e) {
              var t = o.GeometricPoint(e.x, e.y);
              (this.possibleTargets = this.sketch.gobjList.renderList.filter(
                function(e) {
                  return e.canEditLabel();
                }
              )),
                (this.dragTracker = o.DragTracker.create([this.labelIcon])),
                this.dragTracker.touchBegan(t),
                this.touchMoved(e);
            },
            touchMoved: function(e) {
              var t,
                n = o.GeometricPoint(e.x, e.y);
              this.setToolTarget(this.findToolTarget(this.sketch, e)),
                (t = this.getSnappedPosition(n)),
                t && this.dragTracker.touchMoved(t);
            },
            touchEnded: function(e, t) {
              this.dragTracker && this.dragTracker.touchEnded(),
                this.toolTarget &&
                  (this.toolTarget.setRenderState('none'),
                  (this.regime.toolTarget = this.toolTarget),
                  this.sketch.toolController.confirmActiveTool());
            },
            clearToolTarget: function() {
              this.toolTarget &&
                (this.toolTarget.setRenderState('none'),
                (this.toolTarget = null));
            },
            setToolTarget: function(e) {
              e !== this.toolTarget &&
                (this.clearToolTarget(),
                e &&
                  ((this.toolTarget = e), e.setRenderState('targetHighlit')));
            },
            getSnappedPosition: function(e) {
              return this.toolTarget ? this.toolTarget.geom.loc : e;
            },
          }),
          n = o.makeClass(o.AbstractToolRegime, {
            name: 'LabelRegime',
            blocksOtherButtons: function() {
              return !!this.inModalDialog;
            },
            createTracker: function(t, n) {
              var i,
                r = this.sketch;
              return this.inModalDialog
                ? null
                : (o.blurDocumentActiveElement(r.baseNode),
                  (i = Object.create(e)),
                  (i.sketch = r),
                  (i.labelIcon = this.labelIcon),
                  (i.hitSlop = this.hitSlopForTouch(t)),
                  (i.regime = this),
                  this.sequentialSnapping &&
                    ((i.labelIcon.geom.loc = o.GeometricPoint(n.x, n.y)),
                    i.labelIcon.invalidateGeom()),
                  i);
            },
            addInputModal: function(e) {
              function n() {
                return t('.wsp-label-edit', f);
              }
              function i() {
                return t('.wsp-label-edit-ok', n());
              }
              function r() {
                return t('.wsp-label-edit-cancel', n());
              }
              function s() {
                return t('.wsp-label-edit-text', n());
              }
              function a() {
                return t('input[type="checkbox"]', n());
              }
              function c() {
                return (
                  !g.labelExists() || (g.style.label && g.style.label.showLabel)
                );
              }
              function l() {
                var e, i, r, s, a;
                0 === n().length &&
                  ((e = t('<div class="wsp-label-edit"></div>').css({
                    position: 'absolute',
                    left: '20px',
                    top: '10px',
                  })),
                  (r = t('<button class="wsp-label-edit-ok">ok</button>')),
                  (s = t(
                    '<button class="wsp-label-edit-cancel">cancel</button>'
                  )),
                  (i = t('<input class="wsp-label-edit-text"></input>').css({
                    width: '300px',
                  })),
                  i.appendTo(t('<div><span>Label: </span></div>').appendTo(e)),
                  (a = t('<div/>')),
                  t(
                    '<label><input type="checkbox"/>Show Label</label>'
                  ).appendTo(a),
                  r.appendTo(a),
                  s.appendTo(a),
                  a.appendTo(e),
                  e.appendTo(f),
                  o.FastClick.attach(e[0]),
                  e.hide());
              }
              function u() {
                n().hide(), i().off(), r().off(), s().off(), s().blur();
              }
              function d() {
                u(),
                  b(s().val(), a().prop('checked')),
                  m.sketch.labelPool.forgetSavedState();
              }
              function h() {
                u(), v(), m.sketch.labelPool.restoreSavedState();
              }
              function p() {
                (m.inModalDialog = !0),
                  n().show(),
                  a().prop('checked', c()),
                  i().on('click', d),
                  r().on('click', h),
                  m.sketch.labelPool.saveState(),
                  s().val(
                    g.label || m.sketch.labelPool.generateLabel(g.kind, g.genus)
                  ),
                  s().focus(),
                  s()[0].setSelectionRange(0, s().val().length),
                  s().on('keyup', function(e) {
                    13 === e.keyCode && d(), e.stopPropagation();
                  }),
                  s().on('blur', function() {
                    return s().focus(), !1;
                  });
              }
              var f = this.sketch.canvasNode.parent(),
                m = this,
                g = e.target,
                b = e.onAccept,
                v = e.onCancel;
              l(), p();
            },
            doCleanup: function() {
              this.toolTarget && this.toolTarget.setRenderState('none');
              var e = {};
              (e[this.labelIcon.id] = this.labelIcon),
                this.sketch.gobjList.removeGObjects(e, this.sketch);
            },
            confirmActiveTool: function(e) {
              function t(t) {
                e(t);
              }
              function n() {
                r.addInputModal({
                  target: i,
                  onCancel: function() {
                    t(!1);
                  },
                  onAccept: function(e, n) {
                    '' === e
                      ? i.hideExistingLabel()
                      : i.setLabel(e, { show: n, wasUserInitiated: !0 }),
                      t(!0);
                  },
                });
              }
              var i = this.toolTarget,
                r = this;
              if (i) {
                if (!i.canEditLabel())
                  throw o.createError('invalid label target');
                n();
              } else t(!1);
            },
            confirmToolWhenReady: function() {
              return !1;
            },
          });
        return {
          createWithTool: function(e, t) {
            function i() {
              var t = {
                  kind: 'Text',
                  genus: 'Caption',
                  constraint: 'Free',
                  geom: { loc: {} },
                  textMFS: "<VL<T'A'>>",
                  style: {
                    'font-size': 24,
                    'font-weight': 'bold',
                    'font-family': 'Times New Roman',
                    'font-style': 'normal',
                    'text-decoration': 'none',
                    'letter-spacing': 'none',
                    color: '#2052f3',
                  },
                },
                n = e.getCenterPoint(),
                i = e.gobjList.constraintList,
                r = '' + o.ObjectGraph.getNextFreeIdNumber(i),
                s = {},
                a = null;
              return (
                (t.geom.loc.x = n.x),
                (t.geom.loc.y = n.y),
                (s[r] = t),
                (a = e.constructGObjects(s, { forceConstrain: !0 })[r]),
                a.setRenderState('fancyPulse'),
                a
              );
            }
            var r = Object.create(n);
            return (
              (r.sketch = e),
              (r.labelIcon = i()),
              (r.sequentialSnapping = e.getAuthorPreference(
                'sequentialSnapping'
              )),
              r
            );
          },
          createForGObject: function(e, t) {
            var i = Object.create(n);
            return (
              (i.sketch = e), (i.toolTarget = t), (i.inModalDialog = !0), i
            );
          },
        };
      })()),
      (o.BackClickRegime = (function() {
        function e(e) {
          var n, i, r;
          for (n = 0; n < e.parentsList.length; n++)
            if (((i = e.parentsList[n]), t(i))) {
              if (r) return !1;
              r = i;
            }
          return r;
        }
        function t(n) {
          var i = null;
          return (
            n &&
              ((n.isOfKind('Measure') || n.isOfKind('Expression')) &&
              'invisible' !== n.state.renderState
                ? (i = n)
                : 'CompositeText' === n.constraint && e(n)
                ? (i = e(n))
                : 'Pegged' === n.constraint &&
                  2 === n.parentsList.length &&
                  n.parents.text &&
                  (i = t(n.parents.text))),
            i
          );
        }
        function i(e, i, r, s) {
          var o,
            a = {
              hotSpot: r,
              filter: function(r) {
                function s(e) {
                  var t;
                  if (r === e) return !1;
                  if (e.children === n || 0 === e.children.length) return !0;
                  for (t = 0; t < e.children.length; t++)
                    if (!s(e.children[t])) return !1;
                  return !0;
                }
                var o;
                return t(r) && s(i)
                  ? ((o = e.getGivenMatchedToCandidate(i)), o ? s(o) : !0)
                  : !1;
              },
            };
          return (
            (o = e.hitGObj(
              { left: r.x - s, top: r.y - s, bottom: r.y + s, right: r.x + s },
              a
            )),
            o ? { labelGObj: o.hitGObj, valueGObj: t(o.hitGObj) } : null
          );
        }
        var r = o.makeClass(o.TouchTracker, {
            touchBegan: function(e) {
              var t = this.regime.sketch,
                n = this.regime.editor.gobj,
                r = this.regime.editor,
                s = i(t, n, e, this.hitSlop),
                o = (this.hitParent = s.valueGObj);
              o &&
                (r.insertParent(o),
                s.labelGObj !== s.valueGObj &&
                  r.labelParents.indexOf(s) < 0 &&
                  r.labelParents.push(s),
                (this.lastRenderState = o.state.renderState),
                o.setRenderState('targetHighlit'),
                o.invalidateAppearance());
            },
            touchMoved: function(e) {},
            touchEnded: function() {
              var e = this.hitParent,
                t = this;
              e &&
                this.regime.sketch.jobScheduler.addJob(
                  function() {
                    e.setRenderState(t.lastRenderState);
                  },
                  { delay: 90 }
                );
            },
          }),
          s = o.makeClass(o.TouchRegime, {
            name: 'BackClickRegime',
            createTracker: function(e) {
              var t = Object.create(r);
              return (
                (t.regime = this), (t.hitSlop = this.hitSlopForTouch(e)), t
              );
            },
            blocksOtherButtons: function() {
              return !0;
            },
          });
        return {
          createWithEditor: function(e) {
            var t = Object.create(s);
            return (t.editor = e), (t.sketch = e.gobj.sQuery.sketch), t;
          },
        };
      })()),
      (o.gObjects.Kind = {
        doc: {
          description: 'All Kinds have the following properties.',
          refspec: {},
          supported: !0,
          properties: {
            kind: {
              description: 'Kind of GObject.',
              required: !0,
              type: 'Name',
            },
            constraint: {
              description:
                'Name of constraint governing geometry of the GObject.',
              required: !0,
              type: 'Name',
            },
            genus: {
              description: 'Genus of GObject',
              required: !0,
              type: 'Name',
            },
            toolRole: {
              description:
                "If this object is part of a tool, it may have a special role during playback(such as 'given' or 'assumed').",
              required: !1,
              type: 'String',
            },
            label: {
              description:
                'Text that may be used to name an object. Not required to be unique.',
              required: !1,
              type: 'String',
            },
            shouldAutogenerateLabel: {
              description: 'Whether the object should autogenerate its label',
              default: !1,
              type: 'Boolean',
            },
            latentVisibility: {
              description:
                'True if this object might become visibile, even if currently hidden. The standard export process will set this if the object has a show (or show/hide) button that might show it.',
              required: !1,
              type: 'Boolean',
            },
            style: {
              description:
                'Properties that influence the appearance of a GObject. Generally, these properties do not affect the placement of the object in the plane, nor the placement of other, dependent, objects.',
              properties: {
                color: {
                  description: 'Foreground color of the GObject.',
                  type: 'Color',
                  required: !1,
                },
                hidden: {
                  description: 'Whether the GObject is hidden.',
                  type: 'Boolean',
                },
                selectable: {
                  description: 'Whether the GObject is draggable.',
                  type: 'Boolean',
                },
                'text-align': {
                  description:
                    "The basis alignment (left, center, right) with respect to the text's bounding box for the text in this GObject.",
                  type: 'TextAlign',
                },
                traced: {
                  description: 'Whether the GObject should be traced.',
                  type: 'Boolean',
                  required: !1,
                },
              },
            },
            description: {
              description:
                'a description of the role of the gobject in the sketch.',
              required: !1,
              type: 'String',
            },
          },
        },
        shouldAutogenerateLabel: !1,
        prepareToSerialize: function() {},
        toSpecObj: function() {
          function e(e) {
            var n = {};
            return (
              t.each(e, function(e, t) {
                n[e] = t.id;
              }),
              n
            );
          }
          function i(e, n) {
            var i = {};
            return (
              t.each(e, function(e, r) {
                n[e] !== r &&
                  ('object' == typeof r
                    ? (i[e] = t.extend(!0, {}, r))
                    : (i[e] = r));
              }),
              i
            );
          }
          function r(e, n) {
            var r,
              s = a.createDefaultStyle();
            return (
              (r = i(e, s)),
              t.each(r, function(e) {
                var t;
                n.hasOwnProperty(e) &&
                  ((t = n[e]), t.suppressed && delete r[e]);
              }),
              e.label &&
                ((r.label = i(e.label, s.label)),
                t.isEmptyObject(r.label) && delete r.label),
              t.isEmptyObject(r) ? void 0 : r
            );
          }
          function s(i, a) {
            var c = {};
            return (
              t.each(i, function(t, i) {
                var l;
                if (a.hasOwnProperty(t)) {
                  if (((l = a[t]), l.suppressed)) return;
                  if (l.default !== n && l.default === i) return;
                  'parents' === t
                    ? (c[t] = e(i))
                    : 'style' === t
                    ? (c[t] = r(i, l.properties))
                    : 'autostart' === t
                    ? (c[t] = !1)
                    : l.properties
                    ? (c[t] = s(i, l.properties))
                    : 'string' == typeof i
                    ? (c[t] = i)
                    : 'number' == typeof i
                    ? (c[t] = i)
                    : 'boolean' == typeof i
                    ? (c[t] = i)
                    : 'Array' === l.type
                    ? (c[t] = i.slice())
                    : o.log('Omitted ' + t);
                }
              }),
              c
            );
          }
          var a = this;
          return this.prepareToSerialize(), s(this, this.doc.properties);
        },
        toString: function() {
          function e(t, n) {
            var i,
              r,
              s,
              o,
              a = [];
            for (i in t)
              t.hasOwnProperty(i) &&
                ((o = n[i]),
                (s = t[i]),
                'undefined' != typeof o &&
                  ((r = '"' + i + '":'),
                  o.properties
                    ? a.push(r + e(s, o.properties))
                    : 'string' == typeof s
                    ? a.push(r + '"' + s + '"')
                    : 'number' == typeof s
                    ? a.push(r + s)
                    : 'boolean' == typeof s && a.push(r + s)));
            return '{' + a.join() + '}';
          }
          return e(this, this.doc.properties);
        },
        kind: 'kind',
        constraint: 'constraint',
        genus: 'genus',
        style: { hidden: !1, selectable: !0, 'text-align': 'center' },
        state: { exists: !0, constraintFrame: 0, supported: !0 },
        hasLabel: !1,
        children: [],
        geom: {},
        labelSpec: {},
        htmlNode: '',
        getMathItalicization: function() {
          var e = this.sQuery.sketch.preferences,
            t = e && e.text,
            n = t && t.mathItalicization;
          return n;
        },
        createDefaultColorStyle: function(e) {
          return e;
        },
        createDefaultStyle: function() {
          var e,
            n = this.getColorableComponent(),
            i = this.getTextType(),
            r = this.sQuery.sketch.preferences;
          return (
            (e = t.extend(
              !0,
              {},
              o.gobjPrototype(this.kind, this.constraint).style
            )),
            n &&
              t.extend(
                !0,
                e,
                this.createDefaultColorStyle(r.colorableComponents[n])
              ),
            this.hasLabel &&
              (e.label || (e.label = {}),
              t.extend(!0, e.label, r.text.textTypes.Label)),
            i && t.extend(!0, e, r.text.textTypes[i]),
            e
          );
        },
        doPostReadFromSpec: function() {
          var e = this.createDefaultStyle();
          this.style = t.extend(!0, e, this.style);
        },
        kindSupportsSpecObj: function() {
          return !0;
        },
        init: function() {
          this.initKind(),
            this.initConstraint(),
            this.updateConstraintAncestry(),
            this.updateLabel({ init: !0 });
        },
        initKind: function() {
          this.needsRenderInit = !0;
        },
        updateLabel: function(e) {
          this.state.updatingLabel ||
            ((this.state.updatingLabel = !0),
            (e = e || { create: !0 }),
            this.updateLabelForKind(e),
            this.updateLabelForConstraint(e),
            this.state.labelParent &&
              (this.label = this.makeParentalLabel(this.style.nameOrigin, e)),
            this.state.updatingLabel && delete this.state.updatingLabel);
        },
        updateLabelForKind: function() {},
        graphHasChanged: function(e) {
          this.updateConstraintAncestry(),
            this.updateLabel(e),
            this.invalidateGeom();
        },
        descendantGraphHasChanged: function(e) {
          this.graphHasChanged(e),
            this.eachDescendant(function() {
              this.graphHasChanged(e);
            });
        },
        labelHasChanged: function() {
          var e,
            t = this.label;
          return (
            this.hasLabel || (this.state.forceDomParse = !0),
            this.updateLabel(),
            this.hasLabel && t === this.label
              ? !1
              : (this.parsedMFS &&
                  this.label !== t &&
                  ((this.parsedMFS = null),
                  (this.state.labelPreRenderJITPrepareDone = !1),
                  (this.needsRenderInit = !0)),
                this.getLabelBounds &&
                  ((e = this.getLabelBounds()),
                  (e.right = 1 / 0),
                  (e.bottom = 1 / 0)),
                void this.invalidateAppearance())
          );
        },
        descendantLabelGraphHasChanged: function() {
          function e(t) {
            t.state.labelChildren.forEach(function(t) {
              t.labelHasChanged(), t.state.labelChildren && e(t);
            });
          }
          this.labelHasChanged(),
            this.eachDescendant(function() {
              this.labelHasChanged();
            }),
            this.state.labelChildren && e(this);
        },
        initKindAccessibility: function(e) {},
        updateKindHTMLStyle: function() {
          if (this.htmlNode)
            this.isRenderable() ? this.htmlNode.show() : this.htmlNode.hide();
          else {
            if (
              !this.style.selectable ||
              'Map' === this.kind ||
              'IterateImage' === this.kind
            )
              return;
            this.createKindHTML();
          }
          if (
            this.parsedMFS &&
            this.label &&
            this.parsedMFS !== this.oldParsedMFS
          ) {
            var e =
              o.mfs.updatedGenus[this.genus] +
              ' ' +
              o.mfs.makeSpeakableTextFromMFSParseTree(this.parsedMFS);
            this.htmlNode.attr('aria-label', e),
              (this.oldParsedMFS = this.parsedMFS);
          }
        },
        createKindHTML: function() {
          var e =
              this.isGobjInsideDocumentBound() === !1
                ? 'aria-hidden="true"'
                : 'tabindex="0"',
            n =
              o.mfs.updatedGenus[this.genus] +
              (this.label ? ' ' + this.label : '');
          (this.htmlNode = t(
            '<button aria-pressed="false" type="button" wsp-id="' +
              this.id +
              '" class="wsp-accessible wsp-' +
              this.kind +
              ' wsp-sr-only" role="button" ' +
              e +
              '></button>'
          )),
            this.htmlNode.text(n),
            this.isRenderable() || this.htmlNode.hide(),
            this.sQuery.sketch.gobjAddKeyEvents(this),
            t('.wsp-text-layer').append(this.htmlNode);
        },
        onLoad: function(e, t) {
          var n = 'toolDone' === t && 'Axis' === this.kind;
          this.updateKindHTMLStyle(),
            this.htmlNode &&
              (n || this.isGobjInsideDocumentBound() === !1) &&
              (this.htmlNode.attr('aria-hidden', 'true'),
              this.htmlNode.removeAttr('tabindex'));
        },
        onUnload: function(e) {},
        doubleClicked: function() {},
        isOfKind: function(e) {
          return (
            e === this.kind ||
            (this.baseKinds && this.baseKinds.indexOf(e) >= 0)
          );
        },
        isOfGenus: function(e) {
          return (
            e === this.genus ||
            (this.baseGenera && this.baseGenera.indexOf(e) >= 0)
          );
        },
        isAPath: function() {
          return this.isOfGenus('Path');
        },
        matchesAssumedSpec: function(e) {
          return this.isOfKind(e.kind) && this.isOfGenus(e.genus);
        },
        eachParent: function(e, t) {
          var n, i, r;
          if (0 === this.numParents()) return this;
          if (t)
            for (
              n = this.numParents() - 1;
              n >= 0 &&
              ((i = this.parentsList[n]), (r = e.call(i, n, i)), r !== !1);
              n--
            );
          else
            for (
              n = 0;
              n < this.numParents() &&
              ((i = this.parentsList[n]), (r = e.call(i, n, i)), r !== !1);
              n++
            );
          return this;
        },
        numParents: function() {
          return this.parentsList ? this.parentsList.length : 0;
        },
        eachChild: function(e, t) {
          var n, i, r;
          if (!this.children || !this.children.length) return this;
          if (t)
            for (
              n = this.children.length - 1;
              n >= 0 &&
              ((i = this.children[n]), (r = e.call(i, n, i)), r !== !1);
              n--
            );
          else
            for (
              n = 0;
              n < this.children.length &&
              ((i = this.children[n]), (r = e.call(i, n, i)), r !== !1);
              n++
            );
          return this;
        },
        eachDescendant: function(e) {
          function t() {
            o[this.id] = !0;
          }
          var n,
            i,
            r,
            s,
            o = {};
          if (((n = this.sQuery.sketch.gobjList), !n)) return !1;
          for (
            n = n.constraintList, this.eachChild(t), r = 0;
            r < n.length;
            r++
          )
            if (((i = n[r]), o[i.id])) {
              if (((s = e.call(i, r, i)), s === !1)) break;
              i.eachChild(t);
            }
          return this;
        },
        hasDescendant: function(e) {
          var t = !1;
          return (
            this.eachDescendant(function(n) {
              return n === e ? ((t = !0), !1) : void 0;
            }),
            t
          );
        },
        checkParentsExist: function() {
          var e,
            t,
            n = !0;
          for (e = 0; e < this.numParents(); e++)
            if (((t = this.parentsList[e]), t.state && !t.state.exists)) {
              n = !1;
              break;
            }
          return (this.state.exists = n), n;
        },
        namedParentExists: function(e) {
          var t = this.getParent(e);
          return t && t.state && t.state.exists ? !0 : !1;
        },
        initializeClone: function(e) {
          e || (e = this.sQuery().get(this.id)),
            e.geom &&
              ((this.geom = {}), o.GeomTransformer.copyGeom(e.geom, this.geom)),
            e.style && (this.style = Object.create(e.style)),
            (this.state = {}),
            (this.state.exists = e.state.exists),
            (this.state.supported = e.state.supported);
        },
        invalidateAppearance: function() {
          this.sQuery.sketch.invalidateAppearance(this);
        },
        invalidateGeom: function() {
          this.sQuery.sketch.invalidateGeom(this);
        },
        getColorableComponent: function() {
          return n;
        },
        getTextType: function() {
          return n;
        },
        isRenderable: function() {
          return !this.style.hidden && this.state.exists;
        },
        isHittable: function() {
          return this.style.selectable && this.isRenderable();
        },
        getDocument: function() {
          return this.sQuery().sketch.document;
        },
        renderPrepare: function(e, t) {
          return n;
        },
        render: function(e, t, n) {
          throw o.createError(
            'Capability not implemented(render): id=' + this.id
          );
        },
        renderCleanup: function(e, t) {},
        calculateFadeOpacity: function() {
          var e = 1;
          return this.state.fade !== n && (e *= 1 - this.state.fade), e;
        },
        calculateOpacity: function() {
          var e = this.style.opacity;
          return n === e && (e = 1), (e *= this.calculateFadeOpacity());
        },
        getGeomBounds: function() {
          return this.state.exists
            ? {
                left: Number.NEGATIVE_INFINITY,
                top: Number.NEGATIVE_INFINITY,
                right: Number.POSITIVE_INFINITY,
                bottom: Number.POSITIVE_INFINITY,
              }
            : void 0;
        },
        getSignificantBounds: function(e) {
          var t = this.getGeomBounds(e);
          return o.Geom.isFiniteRect(t) || (t = null), t;
        },
        hitTest: function(e, t) {
          throw o.createError(
            'Capability not implemented(hitTest): id=' + this.id
          );
        },
        dragDidStart: function() {
          this.state.isDragging = !0;
        },
        dragDidEnd: function() {
          this.state.isDragging = !1;
        },
        transform: function(e, t) {
          throw o.createError(
            'Capability not implemented(transform): id=' + this.id
          );
        },
        transformComplete: function(e, t) {},
        createTransformer: function(e) {
          return new o.GeomTransformer({
            distance: e.getScalarTransform(),
            point: e.getTransform(),
          });
        },
        destroy: function() {
          this.htmlNode && this.htmlNode.remove();
        },
        hide: function(e) {
          e && 'byUser' === e
            ? (this.style.hidden = 'byUser')
            : (this.style.hidden = !0),
            this.updateKindHTMLStyle && this.updateKindHTMLStyle(),
            this.invalidateGeom();
        },
        show: function() {
          (this.style.hidden = !1),
            this.isOfKind('Text') && !this.parsedMFS && this.updateLabel(),
            this.updateKindHTMLStyle && this.updateKindHTMLStyle(),
            this.invalidateGeom();
        },
        toggleDisplay: function() {
          (this.style.hidden = !this.style.hidden),
            this.updateKindHTMLStyle && this.updateKindHTMLStyle(),
            this.invalidateGeom();
        },
        addAnimationJob: function(e, t, n) {
          function i(t) {
            e(t), u.invalidateAppearance();
          }
          function r() {
            t(), u.invalidateAppearance();
          }
          var s = n.frequencyInMs,
            a = n.steepness,
            c = n.offset || 0,
            l = Math.pow(2, a),
            u = this,
            d = c + Date.now();
          return u.sQuery.sketch.jobScheduler.addJob(
            function() {
              var e = Date.now(),
                t = (e - d) / s,
                n = Math.pow(Math.sin(o.math.TWO_PI * t) + 1, a) / l;
              i(n);
            },
            { repeat: !0, done: r }
          );
        },
        addJobForRenderState: function(e) {
          var t,
            i,
            r,
            s,
            a,
            c,
            l,
            u,
            d = this,
            h = d.style,
            p = this.isAPath(),
            f = this.isOfGenus('Interior'),
            m = this.isOfKind('Text');
          return (
            'hotTarget' === e || 'fadeInOut' === e
              ? ((s = 0),
                (i = this.style.hidden),
                'fadeInOut' === e
                  ? ((a = 0.4), (r = 800))
                  : ((a = 1), (this.style.hidden = !1), (r = 1e3)),
                (t = d.addAnimationJob(
                  function(e) {
                    d.state.fade = 1 - e;
                  },
                  function() {
                    (d.state.fade = n), (d.style.hidden = i);
                  },
                  { frequencyInMs: r, offset: s, steepness: a }
                )))
              : 'unmatchedGiven' === e &&
                ((l = p ? 6 : 4),
                m
                  ? ((c = 0.3), (l = 0.7))
                  : f
                  ? ((l = 0.6),
                    (u = h.opacity),
                    (c = Math.max(0, Math.min(1, u + l / 2) - l)))
                  : ((l = h['drag-expansion'] || l),
                    (u = h.width || h.radius),
                    (c = u)),
                'unmatchedGiven' === e
                  ? ((a = 5),
                    (r = d.getAuthorPreference('sequentialSnapping')
                      ? 500
                      : 3e3))
                  : ((a = 3), (r = m ? 750 : 1500)),
                (s = Math.random() * r),
                (l = h['drag-expansion'] || l),
                (t = d.addAnimationJob(
                  function(e) {
                    var t = c + e * l;
                    d.style.opacity
                      ? (d.style.opacity = t)
                      : d.style.width
                      ? (d.style.width = t)
                      : d.style.radius
                      ? (d.style.radius = t)
                      : (d.state.fade = t);
                  },
                  function() {
                    d.style.opacity
                      ? (d.style.opacity = u)
                      : d.style.width
                      ? (d.style.width = u)
                      : d.style.radius
                      ? (d.style.radius = u)
                      : d.state.fade
                      ? (d.state.fade = n)
                      : o.createError('Unknown kind for renderStateJob()');
                  },
                  { frequencyInMs: r, offset: s, steepness: a }
                ))),
            t
          );
        },
        renderStateWillChange: function(e) {
          this.state.renderStateJob &&
            this.state.renderStateJob.isActive &&
            (this.sQuery.sketch.jobScheduler.clearJob(
              this.state.renderStateJob
            ),
            (this.state.renderStateJob = null));
        },
        renderStateDidChange: function(e) {
          (this.state.renderStateJob = this.addJobForRenderState(e)),
            this.invalidateAppearance();
        },
        setRenderState: function(e) {
          this.renderStateWillChange(this.state.renderState),
            (this.state.renderState = e),
            this.renderStateDidChange(e);
        },
        getAuthorPreference: function(e) {
          return this.sQuery.sketch.getAuthorPreference(e);
        },
        modifyRenderAttrsForCurrentState: function(e) {
          var t = this.state.renderState;
          switch (t) {
            case 'hotTarget':
              o.isNumber(this.state.fade) &&
                this.state.fade < 0.3 &&
                (t = 'targetHighlit');
          }
          this.doModifyRenderAttrsForState(e, t);
        },
        doModifyRenderAttrsForState: function(e, t) {
          switch (t) {
            case 'speculative':
              (e.color = o.speculativeColor), (e.suppressParametricColor = !0);
              break;
            case 'targetHighlit':
              (e.color = o.targetHighlightColor),
                (e.suppressParametricColor = !0),
                this.isAPath() && (e.width += o.targetHighlightPathBolding);
              break;
            case 'unmatchedGiven':
            case 'matchedGiven':
            case 'none':
            case n:
              break;
            case 'targetOnFocus':
              (e.isFocusable = !0),
                'PathMarker' === this.kind
                  ? ((e.rect = this.sQuery.sketch.getGObjGeomBounds(this)),
                    (e.borderColor = o.targetFocusColor),
                    (e.borderWidth = 1 + o.targetFocusPathBolding))
                  : ((e.color = o.targetFocusColor),
                    this.isAPath() && (e.width += o.targetFocusPathBolding));
              break;
            default:
              o.log(
                'Unexpected render state: ' +
                  this.state.renderState +
                  ' for kind: ' +
                  this.kind
              );
          }
        },
        presentUI: function(e) {},
        getAutoplacementMetrics: function() {
          return this.supportsAutoplacement()
            ? o.AutoplacementMetrics[this.autoplacementType]
            : void 0;
        },
        getMFSAppearanceForVariant: function(e, t) {
          return (
            (t = t || {}),
            'byLabel' === e ? this.getNameMFSForLabel(t) : this.getNameMFS(t)
          );
        },
        getNameMFSForLabel: function(e) {
          return this.getNameMFS(e);
        },
        getStrippedMFSAppearanceForVariant: function(e, t) {
          var n = this.getMFSAppearanceForVariant(e, t);
          return null === n
            ? null
            : (o.mfs.walkNode(n, 'style', function(e) {
                e.value = e.value.filter(function(e) {
                  return 'fontFamily' !== e.code && 'fontSize' !== e.code;
                });
              }),
              n);
        },
        getLabelMFS: function(e) {
          var t = this.getMathItalicization(),
            i = null,
            r = this.label;
          return (
            (e = e || {}),
            r && e.show && this.getLabel && (r = this.getLabel(e)),
            r &&
              ('Button' === this.kind && (t = !1),
              (i = o.labels.parseLabelExpression(r, t))),
            !i &&
              this.style &&
              this.style.label &&
              this.style.label.text !== n &&
              (i = o.labels.parseLabelExpression(this.style.label.text, t)),
            !i &&
              this.getParentalNameMFS &&
              this.parentsList.length &&
              (i = this.getParentalNameMFS(e)),
            i ||
              e.init ||
              (i = o.labels.parseLabelExpression(this.getLabel(e), t)),
            i
          );
        },
        getNameMFS: function(e) {
          return this.nameMFSOverride
            ? this.nameMFSOverride.mfs
            : this.generateNameMFS(e);
        },
        generateNameMFS: function(e) {
          return this.getLabelMFS(e) || this.getParentalNameMFS(e);
        },
        getGObjRef: function(e) {
          return this.sQuery.sketch.gobjList.gobjects[e];
        },
        getParent: function(e) {
          return this.parents[e];
        },
        testConsistency: function(e, t, n) {
          var i = t === n || (null == t && null == n);
          return (
            i ||
              'number' != typeof t ||
              'number' != typeof n ||
              (i = o.math.expect(t, n)),
            i
              ? ''
              : e +
                ': <span class="error">' +
                t +
                '</span> (<span class="expected">' +
                n +
                '</span>)'
          );
        },
        verificationString: function(e, t) {
          function n(e) {
            var t,
              n = '',
              i = '',
              r = '';
            return (
              e.debug &&
                e.debug.controlList &&
                ((t = e.sQuery.sketch.Bap.createControlList([e])),
                (i = o.ControlList.toString(e.debug.controlList)),
                (r = o.ControlList.toString(t))),
              i !== r &&
                (n +=
                  'bapCheck: <div class="error">' +
                  r +
                  '</div>(<div class="expected">' +
                  i +
                  '</div>)'),
              n
            );
          }
          var i = '';
          return (
            (i += this.testConsistency('exists', this.state.exists, e.exists)),
            this.constraintVerificationString &&
              (i += this.constraintVerificationString(e)),
            this.debug &&
              this.debug.pathPositions &&
              (this.pathValidationString
                ? (i += this.pathValidationString(this.debug.pathPositions))
                : o.signalErrorWithMessage(
                    'GObj verification expects a path object'
                  )),
            (i += n(this))
          );
        },
        labelExists: function() {
          return (
            '' === this.label &&
              o.log('Object has empty string label: ' + this.id),
            o.isString(this.label)
          );
        },
        canEditLabel: function() {
          return this.label || this.hasLabel || this.style.nameOrigin;
        },
        hasLabelOffset: function() {
          var e = this.style.label;
          return o.isNumber(e.labelOffsetY) && o.isNumber(e.labelOffsetX);
        },
        initLabelOffset: function(e) {
          function t() {
            function e(e) {
              var i,
                s,
                a,
                c,
                l,
                u,
                d = [],
                h = 3;
              if (
                e.isOfKind('Straight') ||
                e.isOfKind('Circle') ||
                e.isOfKind('Arc')
              )
                d = o.getIntersectionPoints(r, e);
              else if (e.isOfKind('Polygon'))
                for (
                  a = e.getVertices(), c = 0;
                  c < a.length && d.length < h;
                  c++
                )
                  (u = c === a.length - 1),
                    (l = o.GeometricArc.FromStraightEndpoints(
                      a[c],
                      a[u ? 0 : c + 1]
                    )),
                    (i = o.Geom.CircleStraightIntersection(r, l)),
                    (d = d.concat(i));
              d &&
                ((s = d.map(function(e) {
                  var t = e.subtract(n);
                  return Math.atan2(t.y, t.x);
                })),
                (t = t.concat(s)));
            }
            var t = [],
              n = i.getLabelOrigin(),
              r = o.GeometricArc.FromCenterAndRadius(n, 2);
            e(i);
            for (var s = 0; s < i.numParents(); s++) e(i.parentsList[s]);
            return (
              i.eachChild(function(t, n) {
                e(n);
              }),
              t
            );
          }
          function n(t) {
            var n,
              i,
              r,
              s,
              a,
              c = 0.001,
              l = -3 * (Math.PI / 4),
              u = 0,
              d = 0,
              h = e.width / 2,
              p = e.height / 2,
              f = 8,
              m = 5;
            if (t.length > 0) {
              for (
                t.sort(o.compare), t.push(t[0] + 2 * Math.PI), n = 0;
                n < t.length;
                n++
              )
                (i = t[n + 1] - t[n]),
                  (r = (t[n + 1] + t[n]) / 2),
                  (s = i),
                  (a = r - l),
                  (a = Math.min(Math.abs(a), Math.abs(2 * Math.PI - a))),
                  (s += c * a),
                  s > u && ((u = s), (d = r));
              return {
                x: (h + f) * Math.cos(d) - h,
                y: (p + m) * Math.sin(d) - p,
              };
            }
            return { x: f, y: m };
          }
          var i = this,
            r = n(t()),
            s = this.style.label;
          (s.labelOffsetX = r.x), (s.labelOffsetY = r.y);
        },
        handleKeyDown: function(e, t) {},
        handleKeyUp: function(e, t) {},
        handleClick: function(e, t) {},
        handleFocusIn: function(e, t) {},
        handleFocusOut: function(e, t) {},
        isWSPSaysExist: function() {
          return this.sQuery.sketch.wspSaysAndTabsObjects.wspSaysExist;
        },
        isGobjInsideDocumentBound: function() {
          var e = this.sQuery.sketch.metadata.sketchRect,
            t = this.getGeomBounds();
          if (t) {
            if (t.left < e.left && t.right < e.left) return !1;
            if (t.left > e.right && t.right > e.right) return !1;
            if (t.top < e.top && t.bottom < e.top) return !1;
            if (t.top > e.bottom && t.bottom > e.bottom) return !1;
          }
          return !0;
        },
      }),
      (o.gObjects.Unknown = o.makeClass([o.gObjects.Kind, o.Genus], {
        doc: {
          description:
            'An unknown object generated as a result of some translation process. Will not be displayed.',
          inherits: 'Kind',
          refspec: {
            msg: 'A convenience of the design. No reference specification.',
          },
          properties: {
            kind: {
              description: 'Kind of GObject.',
              required: !0,
              type: 'Name',
            },
          },
        },
        kind: 'Unknown',
        hitTest: function(e, t) {
          return !1;
        },
        render: function(e, t, n) {},
        transform: function(e, t) {},
      })),
      (o.gObjects.Sampler = (function() {
        var e = (function() {
          var e = o.makeClass(o.TouchTracker, {
            functionPlot: null,
            dragWhichPoint: '',
            updateDriverDomain: function(e) {
              (this.functionPlot.driverDomain[this.dragWhichPoint] = e),
                (this.functionPlot.rawSamples = null),
                this.functionPlot.invalidateGeom();
            },
            swap: function() {
              var e = this.functionPlot.driverDomain,
                t = e.low;
              (e.low = e.high),
                (e.high = t),
                (this.dragWhichPoint =
                  'low' === this.dragWhichPoint ? 'high' : 'low');
            },
            shouldSwap: function(e) {
              var t = this.functionPlot.driverDomain;
              return (
                ('low' === this.dragWhichPoint && e > t.high) ||
                ('high' === this.dragWhichPoint && e < t.low)
              );
            },
            getAnchorNode: function() {
              return this.functionPlot.sQuery.sketch.anchorNode;
            },
            touchBegan: function() {
              this.getAnchorNode().css(
                'XofY_FunctionExprType' === this.functionPlot.getFunctionType()
                  ? { cursor: 'ns-resize' }
                  : { cursor: 'ew-resize' }
              );
            },
            touchEnded: function() {
              this.getAnchorNode().css({ cursor: 'default' });
            },
            touchMoved: function(e) {
              var t = this.functionPlot.getParent('coordSys'),
                n = t.locatePoint(o.GeometricPoint(e.x, e.y)),
                i =
                  'XofY_FunctionExprType' ===
                  this.functionPlot.getFunctionType()
                    ? 'y'
                    : 'x';
              this.shouldSwap(n[i]) && this.swap(),
                this.updateDriverDomain(n[i]);
            },
          });
          return {
            create: function(t, n) {
              var i = Object.create(e);
              return (i.functionPlot = t), (i.dragWhichPoint = n), i;
            },
          };
        })();
        return o.makeClass([o.gObjects.Kind, o.mixins.label, o.genera.Path], {
          doc: {
            description:
              'A collection made by sampling some geometric or numeric function',
            inherits: 'Kind',
            refspec: { gspKindRef: 'SamplerKind' },
            usage: {},
            supported: !0,
            properties: {
              numSamples: {
                description: 'The number of samples of the underlying object',
                type: 'Number',
              },
              driverDomain: {
                description:
                  'The lower bound when sampling with a numeric driver',
                properties: {
                  low: {
                    description: 'The lower bound of the domain when sampling',
                    type: 'Number',
                  },
                  high: {
                    description: 'The upper bound of the domain when sampling',
                    type: 'Number',
                  },
                },
              },
              isDiscrete: {
                description:
                  'For a point-based sampler, whether or not to connect the samples as a continuous path.',
                type: 'Boolean',
              },
              showEndpoints: {
                description:
                  'Whether to display endpoints/arrowheads of the locus',
                type: 'Boolean',
              },
              style: {
                description:
                  "Properties that influence the appearance of a GObject. Accepts style properties appropriate for the 'drivenObject' as well.",
                properties: {
                  endpointRadius: {
                    description: '',
                    type: 'Number',
                    required: !1,
                  },
                  arrowheadRadius: {
                    description: '',
                    type: 'Number',
                    required: !1,
                  },
                },
                regex: /^[a-zA-Z0-9-_]+$/,
              },
            },
          },
          kind: 'Sampler',
          hasLabel: !0,
          state: {},
          renderPrepare: function(e, t) {
            return (
              (t.kind = this.kind),
              (t.id = this.id),
              this.sampleGObj().prepareVectorRendering
                ? this.sampleGObj().prepareVectorRendering(
                    e,
                    this.vectorContext,
                    t
                  )
                : void 0
            );
          },
          renderCleanup: function(e, t) {
            return this.sampleGObj().cleanupVectorRendering
              ? this.sampleGObj().cleanupVectorRendering(
                  e,
                  t,
                  this.vectorContext
                )
              : void 0;
          },
          render: function(e, t, n) {
            var i,
              r = {
                leftEndpoint: null,
                rightEndpoint: null,
                radius: this.style.radius,
                renderable: this.isRenderable(),
                opacity: this.calculateOpacity(),
              };
            if (
              (this.state.mergeTarget
                ? ((r.width = this.style.width + o.targetHighlightPathBolding),
                  (r.color = o.targetHighlightColor),
                  (r.suppressParametricColor = !0))
                : ((r.width = this.style.width), (r.color = this.style.color)),
              this.showEndpoints)
            ) {
              if (((i = this.getParent('domainObject')), i && !i.closedPath))
                switch (i.genus) {
                  case 'Segment':
                  case 'SimpleArc':
                    (r.leftEndpoint = 'endpoint'),
                      (r.rightEndpoint = 'endpoint'),
                      (r.endpointRadius = this.style.endpointRadius);
                    break;
                  case 'Ray':
                  case 'Bisector':
                    (r.leftEndpoint = 'endpoint'),
                      (r.rightEndpoint = 'arrowhead'),
                      (r.endpointRadius = this.style.endpointRadius),
                      (r.arrowheadRadius = this.style.arrowheadRadius);
                    break;
                  default:
                    (r.leftEndpoint = 'arrowhead'),
                      (r.rightEndpoint = 'arrowhead'),
                      (r.arrowheadRadius = this.style.arrowheadRadius);
                }
              i ||
                ((r.leftEndpoint = 'arrowhead'),
                (r.rightEndpoint = 'arrowhead'),
                (r.arrowheadRadius = this.style.arrowheadRadius));
            }
            return (
              this.modifyRenderAttrsForCurrentState(r),
              this.setLineDash(r),
              this.sampleGObj().renderVector
                ? (this.updateKindHTMLStyle(),
                  this.sampleGObj().renderVector(
                    e,
                    t,
                    n,
                    this.vectorContext,
                    r
                  ))
                : void 0
            );
          },
          getColorableComponent: function() {
            switch (this.constraint) {
              case 'ParametricPolarCurvePlot':
              case 'ParametricCartesianCurvePlot':
              case 'FunctionPlot':
                return 'Plot';
              default:
                return 'PointLocus';
            }
          },
          getGeomBounds: function() {
            return this.sampleGObj().getGeomBoundsVector
              ? this.sampleGObj().getGeomBoundsVector(this.vectorContext)
              : void 0;
          },
          hitTest: function(t) {
            function n() {
              function n(n) {
                var r = i.samplerPathValueToPosition(i.driverDomain[n]);
                return o.Geom.PointInRect(r, t) ? e.create(i, n) : !1;
              }
              var i = r;
              return i.plottingInfo.polar ? !1 : n('high') || n('low') || !1;
            }
            function i() {
              return r.sampleGObj().hitTestVector
                ? r.sampleGObj().hitTestVector(r.vectorContext, t)
                : void 0;
            }
            var r = this;
            return 'FunctionPlot' === this.constraint ? n() || i() : i();
          },
          transform: function(e, t) {},
          getRenderingLayer: function() {
            var e = this.sampleGObj && this.sampleGObj();
            return e && e.getVectorRenderingLayer
              ? e.getVectorRenderingLayer(this.vectorContext)
              : 'NeverVisible';
          },
          initializeClone: function e(t) {
            (e.base || arguments.callee.base).call(this, t), this.init();
          },
          isAPath: function() {
            var e = this.sampleGObj && this.sampleGObj();
            return (e && e.isPathSampleGObj) || !1;
          },
          mapPathValueToPosition: function(e, t) {
            return this.samplerPathValueToPosition
              ? this.samplerPathValueToPosition(e, t)
              : void o.signalErrorWithMessage(
                  'This sampler constraint does not implement the path API'
                );
          },
          mapPositionToPathValue: function(e) {
            return this.samplerPositionToPathValue
              ? this.samplerPositionToPathValue(e)
              : void o.signalErrorWithMessage(
                  'This sampler constraint does not implement the path API'
                );
          },
          constrainRange: function(e) {
            if (this.samplerConstrainRange)
              return this.samplerConstrainRange(e);
            var t = e,
              n = 0,
              i = 1;
            return e > i && (t = i), n > e && (t = n), t;
          },
          isValueInBounds: function(e) {
            return this.samplerIsValueInBounds
              ? this.samplerIsValueInBounds(e)
              : e >= 0 && 1 >= e;
          },
          constrainLabel: function e() {
            (e.base || arguments.callee.base).call(this);
          },
          pathLength: function() {
            return this.samplerPathLength ? this.samplerPathLength() : void 0;
          },
          getDefaultLabelPathParam: function() {
            return 0.5;
          },
          getAnimationRange: function e() {
            var t;
            return (t = this.driverDomain
              ? { min: this.driverDomain.low, max: this.driverDomain.high }
              : (e.base || arguments.callee.base).call(this));
          },
          verificationString: function e(t, n) {
            var i = e.base.call(this, t, n),
              r = this.sampleGObj();
            if (this.state.exists && t.exists && r.getGeomForSample) {
              var s,
                a,
                c = r.getGeomForSample(this.vectorContext, 0),
                l = r.getGeomForSample(this.vectorContext, this.numSamples - 1);
              'nonexisting' !== t.firstSamplePoint &&
                ((s = o.GeometricPoint(
                  t.firstSamplePoint.x,
                  t.firstSamplePoint.y
                )),
                o.GeometricPoint.expect(c.loc, s) ||
                  (i +=
                    'firstSample: <span class="error">' +
                    c.loc +
                    '</span>(<span class="expected">' +
                    s +
                    '</span>)')),
                'nonexisting' !== t.lastSamplePoint &&
                  ((a = o.GeometricPoint(
                    t.lastSamplePoint.x,
                    t.lastSamplePoint.y
                  )),
                  o.GeometricPoint.expect(l.loc, a) ||
                    (i +=
                      'lastSample: <span class="error">' +
                      l.loc +
                      '</span>(<span class="expected">' +
                      a +
                      '</span>)'));
            }
            return i;
          },
        });
      })()),
      (o.gObjects.Map = o.makeClass([o.gObjects.Kind, o.Genus], {
        doc: {
          description: 'A Map.',
          inherits: 'Kind',
          refspec: { gspKindRef: 'MapKind' },
          supported: !0,
          usage: {},
          properties: {
            rerandomizePointsOnPaths: {
              description: '',
              required: !1,
              type: 'Boolean',
            },
            finalIterationOnly: {
              description: '',
              required: !1,
              type: 'Boolean',
            },
          },
        },
        kind: 'Map',
        style: {},
        state: {},
        hasLabel: !1,
        initializeClone: function e(t) {
          (e.base || arguments.callee.base).call(this, t), this.init();
        },
        geom: {},
        getGeomBounds: function() {},
        getColorableComponent: function() {
          return '';
        },
        isHittable: function() {
          return !1;
        },
        hitTest: function(e, t) {},
        render: function(e, t, n) {},
        getRenderingLayer: function() {
          return 'NeverVisible';
        },
        testConsistency: function e(t, n, i) {
          return 'exists' === t
            ? ''
            : (e.base || arguments.callee.base).call(this);
        },
      })),
      (o.gObjects.IterateImage = o.makeClass([o.gObjects.Kind, o.Genus], {
        doc: {
          description: '',
          refspec: { gspRef: 'IterateImageKind' },
          supported: !0,
          properties: {
            description: {
              description:
                'a description of the role of the gobject in the sketch.',
              required: !1,
              type: 'String',
            },
            style: {
              description:
                "Properties that influence the appearance of a GObject. Accepts style properties appropriate for the 'source' as well.",
              regex: /^[a-zA-Z0-9-_]+$/,
            },
          },
        },
        kind: 'IterateImage',
        clonedGObj: n,
        initializeSampleBuffer: function() {
          function e(e, t) {
            var n, i, r;
            if (1 === t) return e;
            for (r = 0, n = t, i = 0; e > i; i++) (r += n), (n *= t);
            return r;
          }
          var t = this.getParent('map'),
            n = this.clonedGObj,
            i = 0;
          t.currentDepth &&
            (i = t.finalIterationOnly
              ? Math.pow(t.numMaps, t.currentDepth)
              : e(t.currentDepth, t.numMaps));
          try {
            this.vectorContext = n.createVectorContext(
              i,
              this,
              n.constraintChangesColor
            );
          } catch (e) {
            o.log('Object ' + n.id + ' failed to create vector context: ' + e),
              (this.state.exists = !1);
          }
          this.numSamples = i;
        },
        generateNameMFS: function e(t) {
          var n = (e.base || arguments.callee.base).call(this, t);
          return o.mfs.makeHorizontalMFS(
            o.mfs.makeTextMFS('Iterated Image '),
            n
          );
        },
        initializeClone: function e(t) {
          (e.base || arguments.callee.base).call(this, t), this.init();
        },
        renderPrepare: function(e, t) {
          return (
            (t.kind = this.kind),
            (t.id = this.id),
            this.clonedGObj.prepareVectorRendering
              ? this.clonedGObj.prepareVectorRendering(e, this.vectorContext, t)
              : void 0
          );
        },
        renderCleanup: function(e, t) {
          return this.clonedGObj.cleanupVectorRendering
            ? this.clonedGObj.cleanupVectorRendering(e, t, this.vectorContext)
            : void 0;
        },
        render: function(e, t, n) {
          var i = {
            hidden: this.style.hidden,
            width: this.style.width,
            color: this.style.color,
            radius: this.style.radius,
            opacity: this.calculateOpacity(),
            renderable: !0,
            constraintFrame: this.state.constraintFrame,
          };
          return (
            this.style['line-style'] &&
              o.modifyRenderAttrsForLineStyle(this.style['line-style'], i),
            this.modifyRenderAttrsForCurrentState(i),
            this.clonedGObj.renderVector
              ? (this.updateKindHTMLStyle(),
                this.clonedGObj.renderVector(e, t, n, this.vectorContext, i))
              : void 0
          );
        },
        getGeomBounds: function() {
          return this.clonedGObj.getGeomBoundsVector
            ? this.clonedGObj.getGeomBoundsVector(this.vectorContext)
            : void 0;
        },
        hitTest: function(e) {
          return this.clonedGObj.hitTestVector
            ? this.clonedGObj.hitTestVector(this.vectorContext, e)
            : void 0;
        },
        transform: function(e, t) {},
        curSampleNum: 0,
        clearSamples: function() {
          (this.curSampleNum = 0),
            (this.terminalSampleIndex = n),
            this.clonedGObj.resetVectorSamples &&
              this.clonedGObj.resetVectorSamples(this.vectorContext);
        },
        sampleCountChanged: function() {
          this.initializeSampleBuffer();
        },
        collectSample: function() {
          this.clonedGObj.fillSingleSample &&
            this.clonedGObj.state.exists &&
            (this.clonedGObj.fillSingleSample(
              this.vectorContext,
              this.curSampleNum
            ),
            this.curSampleNum++);
        },
        stampTerminalSample: function() {
          this.terminalSampleIndex = this.curSampleNum - 1;
        },
        getRenderingLayer: function() {
          var e = this.clonedGObj;
          return e.getVectorRenderingLayer
            ? e.getVectorRenderingLayer(this.vectorContext)
            : 'NeverVisible';
        },
        getTerminalGeom: function() {
          var e = this.curSampleNum - 1,
            t = this.getParent('source'),
            n = {};
          return t.state.exists && -1 === this.terminalSampleIndex
            ? (o.GeomTransformer.copyGeom(t.geom, n), n)
            : this.clonedGObj.getGeomForSample && this.terminalSampleIndex === e
            ? this.clonedGObj.getGeomForSample(
                this.vectorContext,
                this.terminalSampleIndex
              )
            : null;
        },
        verificationString: function(e, t) {
          var n = '';
          return n;
        },
      })),
      (o.gObjects.Button = o.makeClass(
        [o.gObjects.Kind, o.mixins.labelBase],
        (function() {
          function e(e) {
            var n = Object.create(t);
            return (n.sketch = e.sQuery.sketch), (n.button = e), n;
          }
          var t = o.makeClass(o.TouchTracker, {
            sketch: null,
            button: null,
            touchBegan: function() {
              (this.button.state.inClick = ++this.button.state.inClick || 1),
                this.sketch.invalidateGeom(this.button);
            },
            touchEnded: function() {
              if (
                ((this.button.state.inClick = --this.button.state.inClick),
                this.sketch.invalidateGeom(this.button),
                this.button.state.inClick < 0)
              )
                throw o.createError(
                  'ButtonPressTracker: press count went negative!  Should be impossible'
                );
              0 === this.button.state.inClick &&
                (this.button.press(this.sketch),
                this.sketch.event(
                  'PressButton',
                  { gobj: this.button },
                  { buttonType: this.button.constraint }
                ));
            },
          });
          return {
            doc: {
              description: 'A control that initiates some action.',
              inherits: 'Kind',
              refspec: {
                gspKindRef: 'ActionKind',
                msg:
                  'Buttons have the appearance defined by their host browser. The appearance of buttons is meant to be familiar to browser users.',
              },
              defaultConstraint: 'ActionButton',
              existenceRule: 'Exists regardless of existence of parent.',
              usage: {},
              properties: {
                geom: {
                  description: 'The basic geometry of the GObject',
                  properties: {
                    loc: {
                      description: 'The position of the GObject',
                      properties: {
                        x: {
                          description:
                            'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                          type: 'Number',
                        },
                        y: {
                          description:
                            'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                          type: 'Number',
                        },
                      },
                    },
                  },
                },
                style: {
                  description: '',
                  properties: {
                    autostart: {
                      description:
                        'Whether the button should be executed at sketch start time.',
                      type: 'Boolean',
                    },
                    color: {
                      description:
                        'The background color. Text color is described by the label.color property.',
                      type: 'Color',
                    },
                    'highlight-color': {
                      description: '',
                      type: 'Color',
                      required: !1,
                    },
                    label: {
                      properties: {
                        showLabel: {
                          description:
                            "The label for a button is the text on the button. It's always shown, so the value of showLabel is ignored.",
                          required: !1,
                        },
                      },
                    },
                  },
                },
              },
            },
            kind: 'Button',
            style: { autostart: !1 },
            state: { isActive: !1, pressedDown: !1, pressedUp: !1 },
            autoplacementType: 'Button',
            createDefaultStyle: function e() {
              var t = this.getColorableComponent(),
                n = this.sQuery.sketch.preferences,
                i = (e.base || arguments.callee.base).call(this);
              return (
                t &&
                  n.colorableComponents[t].color &&
                  (i.color = n.colorableComponents[t].color),
                i
              );
            },
            doPostReadFromSpec: function e() {
              (e.base || arguments.callee.base).call(this),
                (this.geom.loc = o.GeometricPoint(
                  this.geom.loc.x,
                  this.geom.loc.y
                ));
            },
            onLoad: function(e, t) {
              this.style.autostart &&
                'undoRedo' !== t &&
                (this.press(e),
                'toolDone' === t && delete this.style.autostart),
                (this.state.firstTime = !1),
                this.htmlNode &&
                  this.isGobjInsideDocumentBound() === !1 &&
                  (this.htmlNode.attr('aria-hidden', 'true'),
                  this.htmlNode.removeAttr('tabindex'));
            },
            getColorableComponent: function() {
              return 'ActionButton';
            },
            getTextType: function() {
              return 'Action';
            },
            doModifyRenderAttrsForState: function(e, t) {
              switch (t) {
                case 'speculative':
                  e.opacity = o.speculativeOpacity;
                  break;
                case 'none':
                case n:
                  break;
                default:
                  o.log(
                    'Unexpected render state: ' +
                      this.state.renderState +
                      ' for kind: ' +
                      this.kind
                  );
              }
            },
            renderPrepare: function(e, t) {
              var n = this.style.label || {},
                i = o.getFontFamilyFromStyle(n, this.sQuery());
              return (
                (t.id = this.id),
                (t.kind = this.kind),
                (t.color = n.color || this.style.color),
                (t['background-color'] = this.style.color),
                (t['font-family'] = i),
                (t['font-style'] = n['font-style']),
                (t['font-weight'] = n['font-weight']),
                (t['font-size'] = n['font-size']),
                (t['text-decoration'] = n['text-decoration']),
                (t['text-align'] = 'left'),
                (t['vertical-align'] = 'top'),
                (t['highlight-color'] = this.style['highlight-color']),
                e.prepareButton(t)
              );
            },
            renderCleanup: function(e, t) {
              e.cleanupButton(t);
            },
            render: function(e, t, n) {
              var i = 0,
                r = 0,
                s = this.isRenderable(),
                a = s ? 'visible' : 'hidden',
                c = t,
                l = {
                  visibility: a,
                  constraintFrame: this.state.constraintFrame,
                  zIndex: n.zIndex,
                };
              if (
                (this.updateButtonSpeakableText(this.oldText, this.label), s)
              ) {
                if (
                  ((i = this.geom.loc.getX()),
                  isNaN(i) && (i = 0),
                  (r = this.geom.loc.getY()),
                  isNaN(r) && (r = 0),
                  (l.x = i),
                  (l.y = r),
                  this.oldText !== this.label)
                ) {
                  try {
                    this.parsedMFS = o.labels.parseLabelExpression(
                      this.label,
                      !1
                    );
                  } catch (e) {
                    (e.message = 'On Button ' + this.id + ': ' + e.message),
                      o.signalCaughtError(e);
                  }
                  (l.text = this.label),
                    (l.parsedMFS = this.parsedMFS),
                    (this.oldText = this.label),
                    (l.forceDomParse = !0);
                }
                (l.isHighlight = this.state.isActive),
                  (l.inClick = this.state.inClick),
                  (l.isDragging = this.state.isDragging),
                  (l.selectable = this.style.selectable),
                  (l['handle-color'] = this.style.color),
                  (l.opacity = this.calculateOpacity());
              }
              this.modifyRenderAttrsForCurrentState(l),
                e.drawButton(c, l),
                this.updateKindHTMLStyle();
            },
            checkParentsExist: function() {
              return !0;
            },
            isHittable: function() {
              return this.isRenderable();
            },
            hitTest: function(t, n) {
              var i,
                r,
                s,
                o = this.sQuery.sketch.getDisplayObjForGObj(this),
                a = !1,
                c = !1;
              return (
                o &&
                  ((i = {
                    left: this.geom.loc.getX(),
                    top: this.geom.loc.getY(),
                    width: o.width(),
                    height: o.height(),
                  }),
                  (r = {
                    left: i.left,
                    right: i.left + i.width,
                    top: i.top,
                    bottom: i.top + i.height,
                  }),
                  n
                    ? ((a =
                        n.x >= r.left &&
                        n.x <= r.right &&
                        n.y >= r.top &&
                        n.y <= r.bottom),
                      a &&
                        ((r.right = i.left + o.dragHandleWidth()),
                        (c = n.x <= r.right)))
                    : ((s = {
                        left: Math.max(t.left, r.left),
                        right: Math.min(t.right, r.right),
                        top: Math.max(t.top, r.top),
                        bottom: Math.min(t.bottom, r.bottom),
                      }),
                      (a = s.left < s.right && s.top < s.bottom))),
                c && this.style.selectable ? !0 : a ? e(this) : !1
              );
            },
            getGeomBounds: function() {
              function e(e, n) {
                var i,
                  r,
                  s,
                  o,
                  a = e.attrs;
                if (e && e.element)
                  return (
                    n || (n = t.geom.loc),
                    (i = e.width()),
                    (r = e.height()),
                    (s = n.getX()),
                    (o = n.getY()),
                    'center' === a['text-align'] && (s -= i / 2),
                    'middle' === a['vertical-align'] && (o -= r / 2),
                    { left: s, right: s + i, top: o, bottom: o + r }
                  );
              }
              var t = this,
                n = this.sQuery.sketch.getDisplayObjForGObj(this);
              return n && e(n);
            },
            transform: function(e, t) {
              (this.geom.loc = t.geom.loc.copy()),
                t.affine.transform(this.geom.loc);
            },
            handleClick: function(e, t) {
              this.press(t);
            },
            updateKindHTMLStyle: function() {
              var e = this.sQuery.sketch;
              if (!this.htmlNode) {
                var t = e.getDisplayObjForGObj(this);
                'element' in t &&
                  t.element &&
                  ((this.htmlNode = t.element), e.gobjAddKeyEvents(this));
              }
              this.oldLabel || (this.oldLabel = this.label);
            },
            updateButtonSpeakableText: function() {
              var e = this.sQuery.sketch;
              if (this.state.pressedDown || this.state.pressedUp) {
                if (
                  e.focusedGobj &&
                  !this.htmlNode[0].isSameNode(e.focusedGobj.htmlNode[0])
                )
                  return void e.setSpeakabletext('');
                if (
                  this.state.pressedDown &&
                  this.isGobjExistInWSPSays('wspButtonDownSaysGobjId')
                )
                  return (
                    (this.state.pressedDown = !1),
                    void e.updateWSPButtonDownSpeakableText(this)
                  );
                if (
                  this.state.pressedUp &&
                  this.isGobjExistInWSPSays('wspButtonUpSaysGobjId')
                )
                  return (
                    (this.state.pressedUp = !1),
                    void e.updateWSPButtonUpSpeakableText(this)
                  );
                (this.state.pressedDown = !1), (this.state.pressedUp = !1);
                var t = '';
                if (
                  'ActionButtonLinkURL' === this.constraint ||
                  'ActionButtonLinkPage' === this.constraint
                )
                  return (t = 'Switching Page'), void e.setSpeakabletext(t);
                if ('ActionButtonScroll' === this.constraint)
                  return (t = 'Done Scrolling'), void e.setSpeakabletext(t);
                if (
                  ('ActionButtonShow' === this.constraint ||
                    'ActionButtonHide' === this.constraint ||
                    'ActionButtonToggleHideShow' === this.constraint) &&
                  this.oldLabel === this.label
                )
                  return (
                    (t =
                      'Done. Press again to repeat the action ' + this.label),
                    void e.setSpeakabletext(t)
                  );
                this.oldLabel !== this.label
                  ? ((t = 'Done. Press button again to ' + this.label),
                    (this.oldLabel = this.label))
                  : (t = this.state.isActive
                      ? 'Started. Press again to stop the action ' + this.label
                      : 'Stopped. Press again to restart the action ' +
                        this.label),
                  e.setSpeakabletext(t);
              }
            },
            isGobjExistInWSPSays: function(e) {
              return this.sQuery.sketch.wspSaysAndTabsObjects[e][this.id]
                ? !0
                : !1;
            },
          };
        })()
      )),
      (o.gObjects.Circle = o.makeClass(
        [o.gObjects.Kind, o.mixins.label, o.mixins.circleVector, o.genera.Path],
        {
          doc: {
            description: 'The curve describing the limits of a circle.',
            inherits: 'Kind',
            refspec: { gspKindRef: 'CircleKind' },
            usage: {},
            properties: {
              style: {
                description: '',
                properties: {
                  'line-style': {
                    description: "Type of line: 'solid', 'dotted', 'dashed'",
                    type: 'String',
                    required: !1,
                  },
                  width: {
                    description: 'The width of the curve line in pixels.',
                    type: 'Number',
                  },
                },
              },
            },
          },
          kind: 'Circle',
          style: { hidden: !1, width: 3, selectable: !0 },
          hasLabel: !0,
          geom: {},
          getGeometricArc: function() {
            return (
              this.state.constraintCache || (this.state.constraintCache = {}),
              this.state.constraintCache.arc ||
                (this.state.constraintCache.arc = o.GeometricArc.FromCenterAndRadius(
                  this.geom.c,
                  this.geom.r
                )),
              this.state.constraintCache.arc
            );
          },
          doPostReadFromSpec: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.c = o.GeometricPoint.ORIGIN),
              (this.geom.r = 0);
          },
          getColorableComponent: function() {
            return 'Curves';
          },
          renderPrepare: function(e, t) {
            return (t.kind = this.kind), (t.id = this.id), e.prepareCircle(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupCircle(t);
          },
          render: function(e, t, n) {
            var i = this.isRenderable(),
              r = -100,
              s = -100,
              o = -100;
            i &&
              ((r = Number(this.geom.c.x)),
              isNaN(r) && (r = 0),
              (s = Number(this.geom.c.y)),
              isNaN(s) && (s = 0),
              (o = Number(this.geom.r)),
              isNaN(o) && (o = 0));
            var a = {
              renderable: i,
              cx: r,
              cy: s,
              r: o,
              color: this.style.color,
              width: this.style.width,
              opacity: this.calculateOpacity(),
            };
            this.modifyRenderAttrsForCurrentState(a),
              this.setLineDash(a),
              e.drawCircle(t, a),
              this.updateKindHTMLStyle();
          },
          getGeomBounds: function() {
            var e,
              t = this.style.width / 2 || 1.5;
            return (
              this.state.exists &&
                (e = o.Geom.insetRect(
                  {
                    left: this.geom.c.x,
                    top: this.geom.c.y,
                    right: this.geom.c.x,
                    bottom: this.geom.c.y,
                  },
                  -this.geom.r - t
                )),
              e
            );
          },
          hitTest: function(e, t) {
            return o.Geom.RectIntersectsCurve(e, {
              type: 'circle',
              curve: o.GeometricArc.FromCenterAndRadius(
                this.geom.c,
                this.geom.r
              ),
            });
          },
          transform: function(e, t) {},
          createTransformer: function(e) {
            var t = e.getTransform(),
              n = e.getScalarTransform();
            return {
              getAffineTransform: function() {
                return o.AffineTransform.fromPointTransform(t);
              },
              transformGeom: function(e, i) {
                (i.c = t(e.c)), (i.r = n(e.r));
              },
            };
          },
          mapPositionToPathValue: function(e) {
            var t = e.subtract(this.geom.c),
              n = Math.atan2(-t.getY(), t.getX()),
              i = n / (2 * Math.PI);
            return 0 > i && (i += 1), i;
          },
          mapPathValueToPosition: function(e, t) {
            var n = 2 * e * Math.PI,
              i = o.GeometricPoint(
                this.geom.r * Math.cos(n),
                -this.geom.r * Math.sin(n)
              );
            return (
              t && (t.derivative = o.GeometricPoint(i.y, -i.x)),
              this.geom.c.add(i)
            );
          },
          getAnimationRange: function() {
            return { min: 0, max: 1 - 1e-7 };
          },
          area: function() {
            return Math.PI * this.geom.r * this.geom.r;
          },
          circumference: function() {
            return 2 * Math.PI * this.geom.r;
          },
          pathLength: function() {
            return this.circumference();
          },
          radius: function() {
            return this.geom.r;
          },
          getDefaultLabelPathParam: function() {
            return 0.875;
          },
          closedPath: !0,
          verificationString: function e(t, n) {
            var i,
              r,
              s = (e.base || arguments.callee.base).call(this, t, n);
            return (
              '' === s &&
                this.state.exists &&
                ((i = o.GeometricPoint(t.c.x, t.c.y)),
                (r = t.r),
                o.GeometricPoint.expect(i, this.geom.c) ||
                  (s +=
                    'center: <span class="error">' +
                    this.geom.c +
                    '</span>(<span class="expected">' +
                    i +
                    '</span>)'),
                o.math.expect(r, this.geom.r) ||
                  (s +=
                    'radius: <span class="error">' +
                    this.geom.r +
                    '</span>(<span class="expected">' +
                    r +
                    '</span>)')),
              s
            );
          },
        }
      )),
      (o.gObjects.Picture = o.makeClass(
        [o.gObjects.Kind, o.Genus, o.mixins.vector],
        (function() {
          function e(e, t, n, i) {
            var r, s, a, c;
            return (
              (r = n.transform(o.GeometricPoint(0, t.height))),
              (s = n.transform(o.GeometricPoint(0, 0))),
              (a = n.transform(o.GeometricPoint(t.width, 0))),
              (c = o.Geom.ParallelogramSectsRect(e, r, s, a)),
              c && i && (c = o.Geom.RectSectsPolygon(e, i)),
              c
            );
          }
          return {
            doc: {
              description: 'An Image.',
              inherits: 'Kind',
              refspec: {
                gspKindRef: 'PictureKind',
                msg: 'An embedded picture',
              },
              usage: {},
              properties: {
                image: {
                  description: 'The source image of the picture',
                  required: !1,
                  type: 'Image',
                },
                style: {
                  description: '',
                  properties: {
                    layerOrder: {
                      description:
                        'z-index within the set of Interiors and Images',
                      type: 'Number',
                    },
                    opacity: {
                      description: '0 (transparent) to 1 (fully opaque)',
                      default: '0.5',
                      type: 'Number',
                    },
                  },
                },
              },
            },
            kind: 'Picture',
            style: { opacity: 0.5 },
            state: {},
            doPostReadFromSpec: function e() {
              (e.base || arguments.callee.base).call(this),
                this.geom.transform &&
                  (this.geom.transform = o.AffineTransform(
                    this.geom.transform
                  ));
            },
            getColorableComponent: function() {
              return 'Picture';
            },
            doModifyRenderAttrsForState: function(e, t) {
              switch (t) {
                case 'speculative':
                  e.opacity = o.speculativeOpacity;
                  break;
                case 'none':
                case n:
                  break;
                case 'targetOnFocus':
                  (e.isFocusable = !0),
                    (e.color = o.targetFocusColor),
                    (e.width = 3 + o.targetFocusPathBolding);
                  break;
                default:
                  o.log(
                    'Unexpected render state: ' +
                      this.state.renderState +
                      ' for kind: ' +
                      this.kind
                  );
              }
            },
            renderPrepare: function(e, t) {
              return (
                (t.kind = this.kind),
                (t.id = this.id),
                (t.image = this.getImage()),
                (t.onStateChange = (function(e) {
                  return function() {
                    e.sQuery().invalidateGeom(e);
                  };
                })(this)),
                (t.pictureCache = this.getDocument().pictureCache),
                e.preparePicture(t)
              );
            },
            renderCleanup: function(e, t) {
              return e.cleanupPicture(t);
            },
            render: function(e, t, n) {
              var i = {
                renderable: this.isRenderable(),
                transform: this.geom.transform,
                opacity: this.calculateOpacity(),
                clipPolygon: this.geom.clipVertices,
              };
              this.modifyRenderAttrsForCurrentState(i),
                e.drawPicture(t, i),
                this.updateKindHTMLStyle();
            },
            getGeomBounds: function() {
              var e,
                i,
                r = [],
                s = {};
              if (this.state.exists && (e = this.getImage()))
                return (
                  (i = this.geom.transform),
                  r.push(i.transform(o.GeometricPoint(0, e.height))),
                  r.push(i.transform(o.GeometricPoint(0, 0))),
                  r.push(i.transform(o.GeometricPoint(e.width, 0))),
                  r.push(i.transform(o.GeometricPoint(e.width, e.height))),
                  t.each(r, function(e, t) {
                    (s.left === n || t.x < s.left) && (s.left = t.x),
                      (s.right === n || t.x > s.right) && (s.right = t.x),
                      (s.top === n || t.y < s.top) && (s.top = t.y),
                      (s.bottom === n || t.y > s.bottom) && (s.bottom = t.y);
                  }),
                  o.Geom.insetRect(s, -1)
                );
            },
            hitTest: function(t) {
              var n = this.getImage();
              return e(t, n, this.geom.transform, this.geom.clipVertices);
            },
            transform: function(e, t) {
              this.geom.transform = t.geom.transform.compose(t.affine);
            },
            constrainLabel: function() {},
            getImage: function() {
              return null == this.image && this.parents && this.parents.source
                ? this.getParent('source').getImage()
                : 'number' == typeof this.image
                ? this.sQuery().getResource('pictures', this.image)
                : this.image;
            },
            verificationString: function e(i, r) {
              var s = (e.base || arguments.callee.base).call(this, i, r),
                a = this;
              return (
                '' === s &&
                  this.state.exists &&
                  t.each(o.AffineTransform.KeyNames, function() {
                    n === i[this] ||
                      o.math.expect(a.geom.transform[this], i[this]) ||
                      (s +=
                        this +
                        ': <span class="error">' +
                        a.geom.transform[this] +
                        '</span>(<span class="expected">' +
                        i[this] +
                        '</span>)');
                  }),
                s
              );
            },
            createVectorContext: function(e, t, n) {
              var i = {
                numSamples: e,
                parentSampler: t,
                samples: o.createFloatVector(
                  e * o.AffineTransform.packedSampleSize
                ),
              };
              return this.geom.clipVertices && (i.clipVerticesArray = []), i;
            },
            fillSingleSample: function(e, t) {
              var n = this.geom.transform;
              e.filledSampleCount++,
                n.packIntoSampleArray(e.samples, t),
                this.geom.clipVertices &&
                  (e.clipVerticesArray[t] = this.geom.clipVertices),
                (e.geomBounds = o.Geom.unionRects(
                  e.geomBounds,
                  this.getGeomBounds()
                ));
            },
            generateNameMFS: function e() {
              var t = (e.base || arguments.callee.base).call(this),
                n = 'Drawing' === this.genus ? 'Drawing ' : 'Picture ';
              return o.mfs.makeHorizontalMFS(o.mfs.makeTextMFS(n), t);
            },
            getGeomBoundsVector: function(e) {
              return e.geomBounds;
            },
            hitTestVector: function(t, n) {
              for (
                var i,
                  r,
                  s = this.getImage(),
                  a = t.samples,
                  c = t.filledSampleCount,
                  l = 0;
                c > l;
                ++l
              )
                if (
                  ((i = o.AffineTransform.fromPackedSampleArray(a, l)),
                  (r = t.clipVerticesArray && t.clipVerticesArray[l]),
                  e(n, s, i, r))
                )
                  return !0;
              return !1;
            },
            getVectorRenderingLayer: function(e) {
              return 'ExternalImagesAndInteriors';
            },
            prepareVectorRendering: function(e, t, n) {
              return (
                (n.kind = this.kind),
                (n.id = this.id),
                (n.image = this.getImage()),
                (n.onStateChange = (function(e) {
                  return function() {
                    e.sQuery().invalidateGeom(e);
                  };
                })(t.parentSampler)),
                (n.pictureCache = this.getDocument().pictureCache),
                e.preparePictureVector(n)
              );
            },
            renderVector: function(e, n, i, r, s) {
              var o = t.extend(!0, {}, s);
              (o.transformSamples = r.samples),
                (o.clipPolygons = r.clipVerticesArray),
                (o.numSamples = r.filledSampleCount),
                (o.renderable = !0),
                e.drawPictureVector(n, o);
            },
            cleanupVectorRendering: function(e, t) {
              return e.cleanupPictureVector(t);
            },
          };
        })()
      )),
      (o.gObjects.Point = o.makeClass(
        [o.gObjects.Kind, o.mixins.label, o.mixins.pointVector, o.Genus],
        {
          doc: {
            description: 'A location in the Euclidean plane.',
            inherits: 'Kind',
            refspec: { gspKindRef: 'PointKind' },
            usage: {},
            properties: {
              style: {
                description: '',
                properties: {
                  color: {
                    description: 'Foreground color of the Point.',
                    type: 'Color',
                  },
                  'drag-expansion': {
                    description:
                      'The Point expands by this number of pixels when dragged.',
                    type: 'Number',
                  },
                  radius: {
                    description:
                      'The radius of the filled circle that represents the Point.',
                    type: 'Number',
                  },
                  traced: {
                    description: 'Whether the point should be traced.',
                    type: 'Boolean',
                  },
                  tracedStyle: {
                    description: 'Style overrides for traced appearance.',
                    required: !1,
                    properties: {
                      color: {
                        description: 'Foreground color of the traced GObject.',
                        type: 'Color',
                      },
                      radius: { description: '.', type: 'Number' },
                    },
                  },
                },
              },
            },
          },
          kind: 'Point',
          style: {
            'drag-expansion': 5,
            hidden: !1,
            label: { showLabel: !1 },
            radius: 4,
            selectable: !0,
            traced: !1,
          },
          state: {},
          hasLabel: !0,
          doModifyRenderAttrsForState: function(e, t) {
            switch (t) {
              case 'speculative':
                e.color = o.speculativeColor;
                break;
              case 'hotTarget':
                e.radius = this.style.radius + this.style['drag-expansion'];
                break;
              case 'matchedGiven':
              case 'targetHighlit':
                (e.dropShadow = !0),
                  (e.radius = this.style.radius + this.style['drag-expansion']);
                break;
              case 'unmatchedGiven':
                e.dropShadow = !0;
                break;
              case 'invisible':
              case 'none':
              case n:
                break;
              case 'targetOnFocus':
                (e.isFocusable = !0),
                  (e.color = o.targetFocusColor),
                  (e.radius = this.style.radius + o.radiusExpansionOnFocus);
                break;
              default:
                o.log(
                  'Unexpected render state: ' +
                    this.state.renderState +
                    ' for kind: ' +
                    this.kind
                );
            }
          },
          geom: { loc: { x: 0, y: 0 } },
          doPostReadFromSpec: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.loc = o.GeometricPoint(
                this.geom.loc.x,
                this.geom.loc.y
              ));
          },
          getColorableComponent: function() {
            return 'Points';
          },
          renderPrepare: function(e, t) {
            return (t.kind = this.kind), (t.id = this.id), e.preparePoint(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupPoint(t);
          },
          matchesAssumedSpec: function(e) {
            return 'Point' === e.kind;
          },
          render: function(e, t, i) {
            var r,
              s,
              o,
              a,
              c,
              l,
              u,
              d = i.traced ? !0 : !1,
              h = 1,
              p = this.calculateOpacity(),
              f = this.style;
            'invisible' !== this.state.renderState &&
              ((s = f.radius),
              (o = f.color),
              (a = f['drag-expansion']),
              (r = this.isRenderable()),
              r
                ? ((c = this.geom.loc.getX()),
                  isNaN(c) && (c = 0),
                  (l = this.geom.loc.getY()),
                  isNaN(l) && (l = 0))
                : (c = l = -100),
              i.drag && (s += a),
              d &&
                ((s *= 0.75),
                (p *= 0.5),
                (h = 0),
                (f = f.tracedStyle),
                f &&
                  (n !== f.radius && (s = f.radius),
                  n !== f.color && (o = f.color))),
              (u = {
                renderable: r,
                cx: c,
                cy: l,
                radius: s,
                color: o,
                lineWidth: h,
                opacity: p,
              }),
              this.modifyRenderAttrsForCurrentState(u),
              e.drawPoint(t, u),
              this.updateKindHTMLStyle());
          },
          getGeomBounds: function() {
            var e,
              t = this.style.radius + this.style['drag-expansion'],
              n = {};
            return (
              this.modifyRenderAttrsForCurrentState(n),
              n.dropShadow && (t += 10),
              this.state.exists &&
                (e = o.Geom.insetRect(
                  {
                    left: this.geom.loc.x,
                    top: this.geom.loc.y,
                    right: this.geom.loc.x,
                    bottom: this.geom.loc.y,
                  },
                  -t
                )),
              e
            );
          },
          constrainLabel: function() {
            this.labelSpec.location = this.geom.loc;
          },
          hitTest: function(e, t) {
            var n = this.geom.loc.getX(),
              i = this.geom.loc.getY(),
              r = this.style.radius,
              s = { left: n - r, right: n + r, top: i - r, bottom: i + r };
            return !(
              s.right < e.left ||
              s.left > e.right ||
              s.bottom < e.top ||
              s.top > e.bottom
            );
          },
          transform: function(e, t) {
            (this.geom.loc = t.geom.loc.copy()),
              t.affine.transform(this.geom.loc);
          },
          createTransformer: function(e) {
            var t = e.getTransform();
            return {
              getAffineTransform: function() {
                return o.AffineTransform.fromPointTransform(t);
              },
              transformGeom: function(e, n) {
                n.loc = t(e.loc);
              },
            };
          },
          createDefaultSpec: function(e, t) {
            var n =
                (e.metadata.sketchRect.right - e.metadata.sketchRect.left) / 2,
              i =
                (e.metadata.sketchRect.bottom - e.metadata.sketchRect.top) / 2,
              r = (t && t.style) || {},
              s = (t && t.label) || '';
            return (
              t &&
                t.geom &&
                t.geom.loc &&
                ((n = e.metadata.sketchRect.left + t.geom.loc.x),
                (i = e.metadata.sketchRect.top + t.geom.loc.y)),
              {
                1: {
                  kind: 'Point',
                  genus: 'Point',
                  constraint: 'Free',
                  style: r,
                  label: s,
                  geom: { loc: { x: n, y: i } },
                },
              }
            );
          },
          verificationString: function e(t, n) {
            var i,
              r = (e.base || arguments.callee.base).call(this, t, n);
            return (
              '' === r &&
                this.state.exists &&
                ((i = o.GeometricPoint(t.loc.x, t.loc.y)),
                o.GeometricPoint.expect(i, this.geom.loc) ||
                  (r +=
                    'loc: <span class="error">' +
                    this.geom.loc +
                    '</span>(<span class="expected">' +
                    i +
                    '</span>)')),
              r
            );
          },
        }
      )),
      (o.gObjects.Polygon = o.makeClass(
        [
          o.gObjects.Kind,
          o.mixins.label,
          o.mixins.vector,
          o.genera.Path,
          o.genera.Interior,
        ],
        {
          doc: {
            description:
              'The planar area bound by connecting a series of points by straight line segments.',
            inherits: 'Kind',
            refspec: { gspKindRef: 'PolygonKind' },
            usage: {},
            properties: {
              style: {
                description: '',
                properties: {
                  'line-style': {
                    description: "Type of line: 'solid', 'dotted', 'dashed'",
                    type: 'String',
                    required: !1,
                  },
                  width: {
                    description: 'Width of the strokes in pixels',
                    type: 'Number',
                    required: !1,
                  },
                  opacity: {
                    description: '0 (transparent) to 1 (fully opaque)',
                    type: 'Number',
                  },
                  layerOrder: {
                    description:
                      'z-index within the set of Interiors and Images',
                    type: 'Number',
                  },
                  framePerimeter: {
                    description:
                      'Display with a frame that shows the perimeter',
                    type: 'Boolean',
                    required: !1,
                  },
                },
              },
            },
          },
          kind: 'Polygon',
          style: { hidden: !1, framePerimeter: !1, width: 3, opacity: 0.5 },
          state: {},
          hasLabel: !0,
          getColorableComponent: function() {
            return 'Interior';
          },
          doModifyRenderAttrsForState: function(e, t) {
            this.modifyRenderAttrsForInterior(e, t);
          },
          renderPrepare: function(e, t) {
            return e.preparePolygon({});
          },
          renderCleanup: function(e, t) {
            return e.cleanupPolygon(t);
          },
          render: function(e, t, n) {
            var i = this.isRenderable(),
              r = {
                renderable: i,
                points: this.geom.points,
                opacity: this.calculateOpacity(),
                color: this.style.color,
              };
            this.style.framePerimeter &&
              ((r.drawBorder = !0),
              (r.borderColor = this.style.color),
              (r.borderWidth = this.style.width),
              (r.fadeOpacity = this.calculateFadeOpacity())),
              this.modifyRenderAttrsForCurrentState(r),
              e.drawPolygon(t, r),
              this.updateKindHTMLStyle();
          },
          getNumVertices: function() {
            for (var e = this; e && e.parents && e.parents.source !== n; )
              e = e.parents.source;
            return e.numParents();
          },
          getGeomBounds: function() {
            var e,
              i,
              r,
              s,
              a = {},
              c = this.style.width || 0;
            if (
              this.state.exists &&
              (t.each(this.geom.points, function(t, o) {
                o.x !== n &&
                  o.y !== n &&
                  ((e === n || o.x < e) && (e = o.x),
                  (r === n || o.y < r) && (r = o.y),
                  (i === n || o.x > i) && (i = o.x),
                  (s === n || o.y > s) && (s = o.y));
              }),
              a.left + a.top !== n)
            )
              return (
                (a.left = e),
                (a.top = r),
                (a.right = i),
                (a.bottom = s),
                o.Geom.insetRect(a, -c)
              );
          },
          hitTest: function(e, t, n) {
            var i = this.geom.points,
              r = n && n.interiorsPerimeterOnly;
            return r
              ? o.Geom.RectSectsPolygonPerimeter(e, i)
              : o.Geom.RectSectsPolygon(e, i);
          },
          transform: function(e, t) {
            t.affine.transform(this.geom.points);
          },
          createTransformer: function(e) {
            var t = e.getTransform();
            return {
              getAffineTransform: function() {
                return o.AffineTransform.fromPointTransform(t);
              },
              transformGeom: function(e, n) {
                var i;
                for (
                  n.points || (n.points = []), i = 0;
                  i < e.points.length;
                  i++
                )
                  n.points[i] = t(e.points[i]);
              },
            };
          },
          mapPositionToPathValue: function(e) {
            var t,
              n,
              i,
              r,
              s,
              a,
              c,
              l = 1 / 0,
              u = 0,
              d = this.geom.points,
              h = 0;
            for (s = 0; s < d.length; s += 1)
              (n = d[s]),
                (t = d[(s + 1) % d.length]),
                (i = n.subtract(t)),
                (r = i.vLength()),
                (a = o.GeometricPoint.mapPointToLine(n, t, e, {
                  returnPoint: !0,
                  clampP0: !0,
                  clampP1: !0,
                })),
                (c = a.point.subtract(e).vLength2()),
                l > c && ((u = h + a.param * r), (l = c)),
                (h += r);
            return u / h;
          },
          mapPathValueToPosition: function(e, t) {
            var n,
              i,
              r,
              s,
              a,
              c = this.perimeter(),
              l = this.geom.points,
              u = 0;
            if (!this.isValueInBounds(e)) return o.GeometricPoint.UNDEFINED;
            for (e -= Math.floor(e), e *= c, a = 0; a < l.length; a += 1) {
              if (
                ((i = l[a]),
                (n = l[(a + 1) % l.length]),
                (r = n.subtract(i)),
                (s = r.vLength()),
                u + s >= e)
              )
                return (
                  t &&
                    (t.derivative = o.GeometricPoint(
                      r.x / (s / c),
                      r.y / (s / c)
                    )),
                  i.add(r.multiply((e - u) / s))
                );
              u += s;
            }
            return (
              t &&
                (t.derivative = o.GeometricPoint(r.x / (s / c), r.y / (s / c))),
              i
            );
          },
          mapPathValueToCharacteristic: function(e) {
            var t,
              n,
              i,
              r,
              s,
              o = this.perimeter(),
              a = this.geom.points,
              c = 0;
            for (e *= o, s = 0; s < a.length; s += 1) {
              if (
                ((n = a[s]),
                (t = a[(s + 1) % a.length]),
                (i = t.subtract(n)),
                (r = i.vLength()),
                c + r > e)
              )
                return { baseVertex: s, baseValue: (e - c) / r };
              c += r;
            }
            return { baseVertex: 0, baseValue: 1 };
          },
          perimeter: function() {
            var e,
              t,
              n,
              i,
              r = this.geom.points,
              s = 0;
            for (i = 0; i < r.length; i += 1)
              (t = r[i]),
                (e = r[(i + 1) % r.length]),
                (n = e.subtract(t).vLength()),
                (s += n);
            return s;
          },
          pathLength: function() {
            return this.perimeter();
          },
          getAnimationRange: function() {
            return { min: 0, max: 1 - 1e-7 };
          },
          area: function() {
            var e,
              t,
              n,
              i,
              r = this.geom.points,
              s = 0;
            for (i = 0; i < r.length; i += 1)
              (t = r[i]),
                (e = r[(i + 1) % r.length]),
                (n = t.x * e.y - t.y * e.x),
                (s += n);
            return Math.abs(s / 2);
          },
          closedPath: !0,
          getVertices: function() {
            return this.geom.points;
          },
          createVectorContext: function(e, t, n) {
            var i = this.getNumVertices();
            return {
              numSamples: e,
              samples: o.createFloatVector(2 * e * i),
              numVertices: i,
              colors: n ? [] : null,
            };
          },
          fillSingleSample: function(e, t) {
            var n,
              i = e.numVertices,
              r = e.samples,
              s = 2 * t * i;
            for (e.filledSampleCount++, n = 0; i > n; ++n)
              (r[s + 2 * n] = this.geom.points[n].x),
                (r[s + 2 * n + 1] = this.geom.points[n].y);
            e.colors && (e.colors[t] = this.style.color),
              (e.geomBounds = o.Geom.unionRects(
                e.geomBounds,
                this.getGeomBounds()
              ));
          },
          getGeomBoundsVector: function(e) {
            var t = 0;
            return e.geomBounds
              ? (e.lineWidth && (t = e.lineWidth / 2),
                o.Geom.insetRect(e.geomBounds, -t))
              : void 0;
          },
          hitTestVector: function(e, t) {
            var n,
              i,
              r = [],
              s = 0,
              a = e.samples,
              c = e.filledSampleCount,
              l = e.numVertices;
            for (n = 0; c > n; ++n) {
              for (r = [], i = 0; l > i; ++i)
                r.push(o.GeometricPoint(a[s], a[s + 1])), (s += 2);
              if (o.Geom.RectSectsPolygon(t, r)) return !0;
            }
            return !1;
          },
          getVectorRenderingLayer: function(e) {
            return 'ExternalImagesAndInteriors';
          },
          prepareVectorRendering: function(e, t, n) {
            return e.preparePolygonVector(n);
          },
          renderVector: function(e, n, i, r, s) {
            var o = t.extend(!0, {}, s);
            return (
              (o.samples = r.samples),
              (o.colors = r.colors),
              (o.numVertices = r.numVertices),
              (o.numSamples = r.filledSampleCount),
              e.drawPolygonVector(n, o)
            );
          },
          cleanupVectorRendering: function(e, t) {
            return e.cleanupPolygonVector(t);
          },
        }
      )),
      (o.gObjects.Straight = o.makeClass(
        [o.gObjects.Kind, o.mixins.label, o.genera.Path, o.mixins.vector],
        {
          doc: {
            description:
              'Any of the family of straight geometric figures: rays, segments, or lines.',
            inherits: 'Kind',
            refspec: { gspKindRef: 'StraightKind' },
            usage: {},
            properties: {
              style: {
                description: '',
                properties: {
                  color: { type: 'Color' },
                  width: {
                    description: 'Width of the strokes in pixels',
                    type: 'Number',
                  },
                  'line-style': {
                    description: "Type of line: 'solid', 'dotted', 'dashed'",
                    type: 'String',
                    required: !1,
                  },
                },
              },
              debug: {
                properties: {
                  p0: {
                    description:
                      'The first reference point defining the straight.',
                    required: !1,
                    properties: {
                      x: {
                        description:
                          'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                        required: !0,
                        type: 'Number',
                      },
                      y: {
                        description:
                          'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                        required: !0,
                        type: 'Number',
                      },
                    },
                  },
                  p1: {
                    description: 'The second reference point.',
                    required: !1,
                    properties: {
                      x: {
                        description:
                          'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                        required: !0,
                        type: 'Number',
                      },
                      y: {
                        description:
                          'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                        required: !0,
                        type: 'Number',
                      },
                    },
                  },
                },
              },
            },
          },
          kind: 'Straight',
          style: { hidden: !1, width: 3, 'line-style': 'solid' },
          hasLabel: !0,
          geom: {},
          straightGenus: function() {
            var e,
              t = ['Segment', 'Ray', 'Line'],
              n = t.indexOf(this.genus);
            if (n >= 0) e = t[n];
            else
              switch (((e = 'Line'), this.constraint)) {
                case 'Segment':
                  e = 'Segment';
                  break;
                case 'Ray':
                case 'AngleBisector':
                  e = 'Ray';
              }
            return e;
          },
          constrainRange: function(e) {
            var t = e;
            switch (this.straightGenus()) {
              case 'Segment':
                e > 1 && (t = 1), 0 > e && (t = 0);
                break;
              case 'Ray':
                0 > e && (t = 0);
            }
            return t;
          },
          doPostReadFromSpec: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.p0 = o.GeometricPoint.ORIGIN),
              (this.geom.p1 = o.GeometricPoint.ORIGIN);
          },
          collapseDoubledParent: function(e) {
            var t = this.sQuery.sketch;
            this.children.forEach(function(n) {
              ('Midpoint' === n.constraint || 'PointOnPath' === n.constraint) &&
                t.mergeGobjToCandidate(n, e);
            }),
              t.gobjList.removeGObjAndDescendants(this);
          },
          getColorableComponent: function() {
            return 'Straights';
          },
          renderPrepare: function(e, t) {
            return (t.kind = this.kind), (t.id = this.id), e.prepareSegment(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupSegment(t);
          },
          render: function(e, t, n) {
            function i(e) {
              var t = Number(e);
              return isNaN(e) && (t = 0), t;
            }
            var r,
              s,
              o,
              a,
              c,
              l = this.isRenderable();
            l &&
              ((r = i(this.geom.xp0.x)),
              (s = i(this.geom.xp0.y)),
              (o = i(this.geom.xp1.x)),
              (a = i(this.geom.xp1.y))),
              (c = {
                renderable: l,
                p0x: r,
                p0y: s,
                p1x: o,
                p1y: a,
                width: this.style.width,
                color: this.style.color,
                opacity: this.calculateOpacity(),
              }),
              this.modifyRenderAttrsForCurrentState(c),
              this.setLineDash(c),
              e.drawSegment(t, c),
              this.updateKindHTMLStyle();
          },
          getGeomBounds: function() {
            var e,
              t,
              n,
              i,
              r,
              s,
              a,
              c = this.style.width;
            if (
              !this.state.exists ||
              ((t = this.mapPathValueToPosition(
                this.constrainRange(Number.NEGATIVE_INFINITY)
              )),
              (n = this.mapPathValueToPosition(
                this.constrainRange(Number.POSITIVE_INFINITY)
              )),
              (t.x = isNaN(t.x) ? this.geom.p0.x : t.x),
              (t.y = isNaN(t.y) ? this.geom.p0.y : t.y),
              (n.x = isNaN(n.x) ? this.geom.p1.x : n.x),
              (n.y = isNaN(n.y) ? this.geom.p1.y : n.y),
              (i = Math.min(t.x, n.x)),
              (r = Math.max(t.x, n.x)),
              (s = Math.min(t.y, n.y)),
              (a = Math.max(t.y, n.y)),
              (e = o.Geom.insetRect(
                { left: i, top: s, right: r, bottom: a },
                -c
              )),
              o.Geom.isValidRect(e))
            )
              return e;
          },
          hitTest: function(e, t) {
            return o.Geom.SegmentSectsRect(e, this.geom.xp0, this.geom.xp1);
          },
          getSignificantBounds: function() {
            var e,
              t,
              n,
              i,
              r,
              s,
              a = null,
              c = this.style.width;
            return (
              this.state.exists &&
                ((e = this.geom.p0),
                (t = this.geom.p1),
                (n = Math.min(e.x, t.x)),
                (i = Math.max(e.x, t.x)),
                (r = Math.min(e.y, t.y)),
                (s = Math.max(e.y, t.y)),
                (a = o.Geom.insetRect(
                  { left: n, top: r, right: i, bottom: s },
                  -c
                ))),
              a
            );
          },
          transform: function(e, t) {},
          createTransformer: function(e) {
            var t = e.getTransform();
            return {
              getAffineTransform: function() {
                return o.AffineTransform.fromPointTransform(t);
              },
              transformGeom: function(e, n) {
                (n.p0 = t(e.p0)),
                  (n.p1 = t(e.p1)),
                  (n.xp0 = t(e.xp0)),
                  (n.xp1 = t(e.xp1));
              },
            };
          },
          getZeroPoint: function() {
            return this.geom.p0;
          },
          getUnitPoint: function() {
            return this.geom.p1;
          },
          getP0: function() {
            return this.geom.p0;
          },
          getP1: function() {
            return this.geom.p1;
          },
          mapPositionToPathValue: function(e) {
            return this.constrainRange(this.mapPositionToExtendedPathValue(e));
          },
          mapPositionToExtendedPathValue: function(e) {
            return o.GeometricPoint.mapPointToLine(
              this.getZeroPoint(),
              this.getUnitPoint(),
              e
            ).param;
          },
          mapPathValueToPosition: function(e, t) {
            var n = this.getZeroPoint(),
              i = this.getUnitPoint(),
              r = i.subtract(n);
            return (
              t && (t.derivative = this.getP1().subtract(this.getP0())),
              r.multiply(e).add(n)
            );
          },
          mapVectorPathValuesToPositions: function(e) {
            var t,
              n = this.getZeroPoint(),
              i = this.getUnitPoint(),
              r = i.subtract(n),
              s = e.length,
              o = [];
            for (t = 0; s > t; t++) o[t] = r.multiply(e[t]).add(n);
            return o;
          },
          getAnimationRange: function() {
            var e,
              t,
              n,
              i,
              r,
              s,
              a,
              c = this.straightGenus(),
              l = 'Ray' === c;
            return 'Segment' === c
              ? { min: 0, max: 1 }
              : ((e = this.sQuery.sketch),
                (t = e.sketchRect()),
                (n = o.Geom.IntersectionsOfRectAndSegment(
                  t,
                  this.geom.xp0,
                  this.geom.xp1
                )),
                n.length > 0 && (s = this.mapPositionToPathValue(n[0])),
                2 === n.length && (a = this.mapPositionToPathValue(n[1])),
                1 === n.length && l
                  ? ((i = 0), (r = s))
                  : 2 === n.length
                  ? ((i = Math.min(s, a)), (r = Math.max(s, a)))
                  : ((i = l ? 0 : -1), (r = 2)),
                { min: i, max: r });
          },
          unitLength: function() {
            return this.getUnitPoint()
              .subtract(this.getZeroPoint())
              .vLength();
          },
          pathLength: function() {
            var e = this.getAnimationRange(),
              t = this.mapPathValueToPosition(e.min),
              n = this.mapPathValueToPosition(e.max);
            return n.subtract(t).vLength();
          },
          getPointOnPath: function(e, t) {
            return this.getPointOnLine(e, t);
          },
          getPointOnLine: function(e, t) {
            var n, i;
            return (
              (n = e.p1.subtract(e.p0)),
              (i = n.vLength()),
              n.multiply(t / i).add(e.p0)
            );
          },
          getPointOnRay: function(e, t) {
            var n, i;
            return 0 >= t
              ? e.p0
              : ((n = e.p1.subtract(e.p0)),
                (i = n.vLength()),
                n.multiply(t / i).add(e.p0));
          },
          getPointOnSegment: function(e, t) {
            var n, i;
            return 0 >= t
              ? e.p0
              : ((n = e.p1.subtract(e.p0)),
                (i = n.vLength()),
                t >= i ? e.p1 : n.multiply(t / i).add(e.p0));
          },
          getClosestPointOnLine: function(e, t) {
            var n, i, r, s;
            return (
              (n = t.subtract(e.p0)),
              (i = e.p1.subtract(e.p0)),
              i.isZeroLength()
                ? (s = e.p0)
                : ((r = n.dot(i) / i.dot(i)), (s = i.multiply(r).add(e.p0))),
              s
            );
          },
          pointIsInBounds: function(e, t) {
            var i,
              r = this.straightGenus(),
              s = t === n ? 1.5e-21 : t;
            return ('Segment' === r || 'Ray' === r) &&
              ((i = e.subtract(this.getP0()).vLength2()), s > i)
              ? !0
              : 'Segment' === r &&
                ((i = e.subtract(this.getP1()).vLength2()), s > i)
              ? !0
              : this.isValueInBounds(this.mapPositionToExtendedPathValue(e));
          },
          isValueInBoundsLineGenus: function(e) {
            return !0;
          },
          isValueInBoundsSegmentGenus: function(e) {
            var t = 1.000000000000002,
              n = -2e-15;
            return e >= n && t >= e;
          },
          isValueInBoundsRayGenus: function(e) {
            var t = -2e-15;
            return e >= t;
          },
          isValueInBounds: function(e) {
            var t = this.straightGenus(),
              n = {
                Line: this.isValueInBoundsLineGenus,
                Ray: this.isValueInBoundsRayGenus,
                Segment: this.isValueInBoundsSegmentGenus,
              }[t];
            return o.math.isFiniteScalar(e) && n ? n.call(this, e) : !1;
          },
          createVectorContext: function(e, t, n) {
            return {
              numSamples: e,
              samples: o.createFloatVector(4 * e),
              colors: n ? [] : null,
              lineWidth: t.style.width,
            };
          },
          fillSingleSample: function(e, t) {
            var n = 4 * t;
            e.filledSampleCount++,
              (e.samples[n] = this.geom.xp0.x),
              (e.samples[n + 1] = this.geom.xp0.y),
              (e.samples[n + 2] = this.geom.xp1.x),
              (e.samples[n + 3] = this.geom.xp1.y),
              e.colors && (e.colors[t] = this.style.color),
              (e.geomBounds = o.Geom.unionRectPoint(
                e.geomBounds,
                this.geom.xp0
              )),
              (e.geomBounds = o.Geom.unionRectPoint(
                e.geomBounds,
                this.geom.xp1
              ));
          },
          getGeomBoundsVector: function(e) {
            var t = 0;
            return e.geomBounds
              ? (e.lineWidth && (t = e.lineWidth / 2),
                o.Geom.insetRect(e.geomBounds, -t))
              : void 0;
          },
          hitTestVector: function(e, t) {
            var n,
              i,
              r,
              s,
              a = e.filledSampleCount,
              c = e.samples,
              l = 4;
            for (n = 0; a > n; n++)
              if (
                ((s = l * n),
                (i = o.GeometricPoint(c[s], c[s + 1])),
                (r = o.GeometricPoint(c[s + 2], c[s + 3])),
                o.Geom.SegmentSectsRect(t, i, r))
              )
                return !0;
            return !1;
          },
          getVectorRenderingLayer: function(e) {
            return 'LineLoci';
          },
          prepareVectorRendering: function(e, t, n) {
            return e.prepareSegmentVector(n);
          },
          renderVector: function(e, n, i, r, s) {
            var o = t.extend(!0, {}, s);
            return (
              (o.samples = r.samples),
              (o.colors = r.colors),
              (o.numSamples = r.filledSampleCount),
              e.drawSegmentVector(n, o)
            );
          },
          cleanupVectorRendering: function(e, t) {
            return e.cleanupSegmentVector(t);
          },
          closedPath: !1,
          verificationString: function e(t, n) {
            var i,
              r,
              s = (e.base || arguments.callee.base).call(this, t, n);
            return (
              '' === s &&
                this.state.exists &&
                ((i = o.GeometricPoint(t.p0.x, t.p0.y)),
                (r = o.GeometricPoint(t.p1.x, t.p1.y)),
                (o.GeometricPoint.expect(i, this.getP0()) &&
                  o.GeometricPoint.expect(r, this.getP1())) ||
                  (s +=
                    'geom: <span class="error">' +
                    this.getP0() +
                    ' -> ' +
                    this.getP1() +
                    '</span>(<span class="expected">' +
                    i +
                    ' -> ' +
                    r +
                    '</span>)')),
              s
            );
          },
        }
      )),
      (o.gObjects.DOMKind = o.makeClass([o.gObjects.Kind], {
        doc: {
          description:
            'Common base class for kinds, such as Text and Table, that are represented as rectangular DOM elements containing text.',
          inherits: 'Kind',
          properties: {
            geom: {
              description: 'The basic geometry of the GObject',
              properties: {
                loc: {
                  description: 'The position of the GObject',
                  properties: {
                    x: {
                      description:
                        'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                    y: {
                      description:
                        'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                  },
                },
              },
            },
            style: {
              description: '',
              properties: {
                color: {
                  description: 'Foreground color of the traced GObject.',
                  type: 'Color',
                },
                'font-family': {
                  description:
                    'The basis font family for text in this GObject. See GSP.getFontFamilyFromStyle() for supported formats',
                  type: 'FontFamily',
                },
                'font-size': {
                  description: 'The basis font size for text in this GObject',
                  type: 'FontSize',
                },
                'font-style': {
                  description:
                    'The basis font style (slant) for text in this GObject',
                  type: 'FontStyle',
                },
                'font-weight': {
                  description:
                    'The basis font weight (boldness) for text in this GObject',
                  type: 'FontWeight',
                },
                'text-decoration': {
                  description:
                    'line-through, underlines, and other variations on the label text',
                  type: 'TextDecoration',
                },
              },
            },
          },
        },
        kind: 'DOMKind',
        geom: { loc: { x: 0, y: 0 } },
        getRectFromDisplayObject: function(e, t) {
          var n,
            i,
            r,
            s,
            o = e.attrs;
          if (e && e.element)
            return (
              t || (t = this.geom.loc),
              (n = e.width()),
              (i = e.height()),
              (r = t.getX()),
              (s = t.getY()),
              'center' === o['text-align'] && (r -= n / 2),
              'middle' === o['vertical-align'] && (s -= i / 2),
              { left: r, right: r + n, top: s, bottom: s + i }
            );
        },
        prepareToRenderStyles: function(e) {
          var t = o.getFontFamilyFromStyle(this.style, this.sQuery()),
            n = this.sQuery().getSketch(),
            i = n.document.resources.fontList || this.sQuery().prefs().fontList;
          (e.color = this.style.color),
            (e.fontTable = i),
            (e['font-family'] = t),
            (e['font-style'] = this.style['font-style']),
            (e['font-weight'] = this.style['font-weight']),
            (e['font-size'] = this.style['font-size']),
            (e['text-decoration'] = this.style['text-decoration']),
            o.mfs.normalizeFont(t, function(t, n) {
              e[t] = n;
            });
        },
        doPostReadFromSpec: function e() {
          (e.base || e.callee.base).call(this),
            (this.geom.loc = o.GeometricPoint(
              this.geom.loc.x,
              this.geom.loc.y
            ));
        },
        hitTest: function(e) {
          var t = this.sQuery.sketch.getDisplayObjForGObj(this),
            n = this.getRectFromDisplayObject(t);
          return o.Geom.isIntersectRects(n, e);
        },
        transform: function(e, t) {
          (this.geom.loc = t.geom.loc.copy()),
            t.affine.transform(this.geom.loc);
        },
        getGeomBounds: function() {
          var e = this.sQuery.sketch.getDisplayObjForGObj(this);
          return e && this.getRectFromDisplayObject(e);
        },
      })),
      (o.gObjects.Text = o.makeClass(
        [o.gObjects.DOMKind, o.Genus, o.mixins.vector],
        (function() {
          var e = {
            _prepareCommon: function(e, t) {
              e.prepareToRenderStyles(t),
                (t.kind = e.kind),
                (t['text-align'] = e.style['text-align']),
                (t['vertical-align'] = e.style['vertical-align']),
                (t.padding = e.style.padding),
                (t.selectable = e.style.selectable),
                (t.genus = e.genus);
              var n = o.mfs.getLineHeight(t['font-family'], t['font-size']);
              n && (t['line-height'] = n);
            },
            create: function(e, t, n) {
              return (
                this._prepareCommon(e, n),
                (n.id = e.id),
                (n.wspSays = e.isGobjExistInWSPSays()),
                (n.isParameter = e.isParameter && e.isParameter()),
                (n.isCompositeText = e.isCompositeText()),
                t.prepareText(n)
              );
            },
            createVector: function(e, n, i, r) {
              var s,
                o,
                a = {};
              this._prepareCommon(e, r),
                (a.initialArgs = t.extend(!0, {}, r)),
                (a.sampleRefCons = []),
                (a.parentId = e.id);
              for (var c = 0; c < n.numSamples; c++)
                (s = {}),
                  (o = t.extend(!0, {}, r)),
                  (o.id = a.parentId + 'vector' + c),
                  (s.object = i.prepareText(o)),
                  (s.visible = !0),
                  (a.sampleRefCons[c] = s);
              return a;
            },
            updateVector: function(e, n, i) {
              var r,
                s,
                o,
                a = i.sampleRefCons.length,
                c = e.filledSampleCount;
              for (o = 0; a > o; ++o) i.sampleRefCons[o].visible = c > o;
              for (o = a; c > o; ++o)
                (r = {}),
                  (s = t.extend(!0, {}, i.initialArgs)),
                  (s.id = i.parentId + 'vector' + o),
                  (s.parsedMFS = e.parsedMFSValues[o]),
                  (r.object = n.prepareText(s)),
                  (r.visible = !0),
                  (i.sampleRefCons[o] = r);
            },
            cleanupVector: function(e, t) {
              var n,
                i = t && t.sampleRefCons ? t.sampleRefCons.length : 0;
              for (n = 0; i > n; ++n) e.cleanupText(t.sampleRefCons[n].object);
            },
          };
          return {
            doc: {
              description: 'A displayable message.',
              inherits: 'DOMKind',
              refspec: { gspKindRef: 'TextKind' },
              usage: {},
              properties: {
                style: {
                  description: '',
                  properties: {
                    'letter-spacing': {
                      description:
                        'The basis font letter spacing for text in this GObject',
                      type: 'LetterSpacing',
                    },
                  },
                },
                text: {
                  description: 'The message.',
                  required: !1,
                  type: 'String',
                },
                textMFS: {
                  description: 'The message formatted as an MFS string.',
                  required: !1,
                  type: 'String',
                },
              },
            },
            kind: 'Text',
            style: { 'text-align': 'left', 'vertical-align': 'top' },
            state: {},
            autoplacementType: 'Measurement',
            updateLabelForKind: function e() {
              (e.base || e.callee.base).call(this),
                this.textMFS
                  ? (this.parsedMFS = o.mfsParser.parse(this.textMFS))
                  : this.text &&
                    (this.parsedMFS = o.mfs.makeTextMFS(this.text));
            },
            getColorableComponent: function() {
              return 'TextGObject_BackgroundContrast';
            },
            getTextType: function() {
              return 'Caption';
            },
            doModifyRenderAttrsForState: function(e, t) {
              switch (t) {
                case 'speculative':
                  e.opacity = o.speculativeOpacity;
                  break;
                case 'targetHighlit':
                case 'matchedGiven':
                  e.targetHighlight = !0;
                  break;
                case 'invisible':
                  e.opacity = 0;
                  break;
                case 'unmatchedGiven':
                  e.unmatchedGiven = !0;
                  break;
                case 'fancyPulse':
                  e.fancyPulse = !0;
                  break;
                case 'none':
                case n:
                  break;
                default:
                  o.log(
                    'Unexpected render state: ' +
                      this.state.renderState +
                      ' for kind: ' +
                      this.kind
                  );
              }
            },
            renderPrepare: function(t, n) {
              return e.create(this, t, n);
            },
            renderCleanup: function(e, t) {
              e.cleanupText(t);
            },
            radiansOrScalar: function() {
              return this.unitPowers &&
                1 === this.unitPowers.angle &&
                'rad' === this.sQuery().prefs().units.angle
                ? 'rad'
                : 'scalar';
            },
            render: function(e, t, n) {
              var i = 0,
                r = 0,
                s = this.isRenderable(),
                o = s ? 'visible' : 'hidden',
                a = this.radiansOrScalar(),
                c = {
                  visibility: o,
                  measurable: s || this.latentVisibility,
                  constraintFrame: this.state.constraintFrame,
                  opacity: this.calculateOpacity(),
                  zIndex: n.zIndex,
                  wspSays: this.isGobjExistInWSPSays(),
                  isParameter: this.isParameter && this.isParameter(),
                  isCompositeText: this.isCompositeText(),
                };
              this.nameMFSOverride &&
                ((c.width = this.nameMFSOverride.width),
                (c.height = this.nameMFSOverride.height)),
                this.state.selected ||
                  (c.measurable &&
                    ((i = this.geom.loc.getX()),
                    isNaN(i) && (i = 0),
                    (r = this.geom.loc.getY()),
                    isNaN(r) && (r = 0),
                    (c.x = i),
                    (c.y = r),
                    (c.parsedMFS = this.parsedMFS),
                    this.state.forceDomParse &&
                      ((c.forceDomParse = !0), (this.state.forceDomParse = !1)),
                    'undefined' != typeof this.uValue &&
                      ((c.MFSValues = {
                        value: this.formatNumberAsMFS(
                          this.uValue,
                          this.style.precision,
                          a
                        ),
                      }),
                      (this.uValueLast = this.uValue)),
                    this.isCompositeText() &&
                      (c.MFSValues = this.parentMFSValues),
                    this.isMultimeasure &&
                      (c.MFSValues = this.getValuesAsMFS()),
                    c.MFSValues && (this.MFSValues = c.MFSValues)),
                  this.modifyRenderAttrsForCurrentState(c),
                  e.drawText(t, c),
                  this.postRenderFunc && this.postRenderFunc(),
                  this.updateKindHTMLStyle());
            },
            determineParentalBlank: function() {
              var e,
                t = this.parentsList;
              if (!t) return !1;
              for (e in t) if (t.hasOwnProperty(e) && t[e].blank) return !0;
              return !1;
            },
            formatNumberAsMFS: function(e, t, n, i) {
              function r(e, t) {
                var n = e.toFixed(t);
                return n.replace('.', h);
              }
              function s(e) {
                var t = 6;
                return Math.log(Math.abs(e)) * Math.LOG10E >= t;
              }
              function a(e, t) {
                var n = Math.abs(e),
                  i = Math.floor(Math.log(n) * Math.LOG10E),
                  s = Math.pow(10, i),
                  a = e / s,
                  c = o.mfs.makeHorizontalMFS(
                    o.mfs.makeTextMFS(r(a, t)),
                    { type: 'symbol', value: 'B4' },
                    {
                      type: 'super',
                      value: [o.mfs.makeTextMFS('10'), o.mfs.makeTextMFS(i)],
                    }
                  );
                return c;
              }
              function c(e) {
                var n,
                  i,
                  s,
                  a,
                  c,
                  l = o.math.getSimplePiFraction(e);
                return (
                  l
                    ? ((s = l.numerator),
                      (i = l.denominator),
                      0 === s
                        ? (n = o.mfs.makeTextMFS('0'))
                        : ((a = Math.abs(s)),
                          (c =
                            1 === a
                              ? { type: 'symbol', value: '70' }
                              : o.mfs.makeHorizontalMFS(o.mfs.makeTextMFS(a), {
                                  type: 'symbol',
                                  value: '70',
                                })),
                          1 === i
                            ? (n = c)
                            : ((n = {
                                type: 'fraction',
                                value: [
                                  o.mfs.makeHorizontalMFS(c),
                                  o.mfs.makeTextMFS(i),
                                ],
                              }),
                              0 > s &&
                                (n = o.mfs.makeHorizontalMFS(
                                  o.mfs.makeTextMFS('−'),
                                  n
                                )))))
                    : (n = o.mfs.makeTextMFS(r(e, t))),
                  n
                );
              }
              function l(e) {
                var t;
                return (
                  (t = d.getUnitsMFS && d.getUnitsMFS()),
                  t ? o.mfs.makeHorizontalMFS(e, t) : e
                );
              }
              var u,
                d = this,
                h = this.sQuery.sketch.document.formatOptions.decimalSeparator;
              return (
                this.blank
                  ? (u = o.mfs.makeTextMFS(' '))
                  : isNaN(e)
                  ? (u = o.mfs.makeTextMFS('undefined'))
                  : isFinite(e)
                  ? 'rad' === n
                    ? (u = c(e))
                    : s(e)
                    ? (u = a(e, t))
                    : ((u = r(e, t)),
                      (u = u.replace(/^-(0(\.0+)?)$/, '$1')),
                      (u = o.mfs.makeTextMFS(u.replace('-', '−'))))
                  : (u =
                      e === Number.NEGATIVE_INFINITY
                        ? o.mfs.makeHorizontalMFS(
                            { type: 'symbol', value: '103' },
                            { type: 'symbol', value: 'A5' }
                          )
                        : { type: 'symbol', value: 'A5' }),
                i ? l(u) : u
              );
            },
            isCompositeText: function() {
              return this.parentMFSValues !== n;
            },
            isHittable: function() {
              return (
                (this.style.selectable || this.isCompositeText()) &&
                this.isRenderable()
              );
            },
            hitTest: function(e, n, i) {
              var r,
                s = this.sQuery.sketch.getDisplayObjForGObj(this),
                a = this.getRectFromDisplayObject(s),
                c = o.Geom.isIntersectRects(a, e);
              return (
                c &&
                  ((r = t('.wsp-mfs-reference', t(s.element))),
                  r.length > 0
                    ? (!this.style.selectable ||
                        o.HotTextTracker.referenceIsHit(n, r)) &&
                      (c = o.HotTextTracker.createOnElement(
                        t(s.element),
                        r,
                        this.sQuery
                      ))
                    : (c = this.isCompositeText()
                        ? this.style.selectable
                        : !0)),
                c
              );
            },
            getMFSAppearanceForVariant: function() {
              if (!this.state.exists) return null;
              var e = t.extend(!0, {}, this.parsedMFS);
              return (
                this.isCompositeText() &&
                  o.mfs.realizeParamNodes(e, this.parentMFSValues),
                this.isMultimeasure &&
                  o.mfs.realizeParamNodes(e, this.getValuesAsMFS()),
                (e = o.mfs.replaceNodes(
                  e,
                  'vertical',
                  o.mfs.flattenVerticalNode
                ))
              );
            },
            constrainLabel: function() {},
            createTransformer: function(e) {
              var t = e.getTransform();
              return {
                getAffineTransform: function() {
                  return o.AffineTransform.fromPointTransform(t);
                },
                transformGeom: function(e, n) {
                  n.loc = t(e.loc);
                },
              };
            },
            createVectorContext: function(e, t, n) {
              var i = {
                numSamples: e,
                samples: o.createFloatVector(2 * e),
                parsedMFSValues: [],
              };
              return 'undefined' != typeof this.uValue && (i.uValues = []), i;
            },
            fillSingleSample: function(e, t) {
              e.filledSampleCount++,
                (e.samples[2 * t] = this.geom.loc.x),
                (e.samples[2 * t + 1] = this.geom.loc.y),
                (e.parsedMFSValues[t] = this.parsedMFS),
                'undefined' != typeof e.uValues && (e.uValues[t] = this.uValue);
            },
            getGeomBoundsVector: function(e) {
              if (!e.geomBounds) {
                var t,
                  n,
                  i = e.samples,
                  r = this.sQuery.sketch.getDisplayObjForGObj(this),
                  s = r && r.sampleRefCons,
                  a = e.filledSampleCount;
                if (!s || !s.length) return null;
                for (var c = 0; a > c; ++c)
                  (t = o.GeometricPoint(i[2 * c], i[2 * c + 1])),
                    s[c] &&
                      ((n = this.getRectFromDisplayObject(s[c].object, t)),
                      (e.geomBounds = o.Geom.unionRects(e.geomBounds, n)));
              }
              return e.geomBounds;
            },
            hitTestVector: function(e, t) {
              var n,
                i,
                r = e.samples,
                s = this.sQuery.sketch.getDisplayObjForGObj(this),
                a = s && s.sampleRefCons,
                c = e.filledSampleCount;
              if (!a || !a.length) return !1;
              for (var l = 0, u = c; u > l; ++l)
                if (
                  ((n = o.GeometricPoint(r[2 * l], r[2 * l + 1])),
                  (i = this.getRectFromDisplayObject(a[l].object, n)),
                  o.Geom.isIntersectRects(i, t))
                )
                  return !0;
              return !1;
            },
            getVectorRenderingLayer: function(e) {
              return 'Text';
            },
            prepareVectorRendering: function(t, n, i) {
              return e.createVector(this, n, t, i);
            },
            renderVector: function(t, n, i, r, s) {
              var o,
                a,
                c = n,
                l = c.sampleRefCons,
                u = !s.hidden,
                d = 'undefined' != typeof r.uValues,
                h = d ? this.radiansOrScalar() : 'scalar',
                p = { constraintFrame: s.constraintFrame };
              for (
                e.updateVector(r, t, c), o = l ? l.length : 0, a = 0;
                o > a;
                a++
              )
                (p.visibility = u && l[a].visible ? 'visible' : 'hidden'),
                  (p.x = r.samples[2 * a]),
                  (p.y = r.samples[2 * a + 1]),
                  (p.parsedMFS = r.parsedMFSValues[a]),
                  d &&
                    (p.MFSValues = {
                      value: this.formatNumberAsMFS(
                        r.uValues[a],
                        this.style.precision,
                        h
                      ),
                    }),
                  t.drawText(l[a].object, p);
            },
            cleanupVectorRendering: function(t, n) {
              e.cleanupVector(t, n);
            },
            onLoad: function(e, t) {
              this.isGobjInsideDocumentBound() === !1 &&
                this.htmlNode &&
                (this.htmlNode
                  .find('.wsp-parameter-sr-only, .mfs-param')
                  .attr('aria-hidden', 'true')
                  .removeAttr('tabindex'),
                this.htmlNode
                  .find('.mfs-input')
                  .attr({ 'aria-hidden': 'true', tabindex: '-1' }));
            },
            isGobjExistInWSPSays: function() {
              return (
                this.sQuery.sketch.wspSaysAndTabsObjects.wspSaysGobjsId.indexOf(
                  this.id
                ) > -1
              );
            },
            updateKindHTMLStyle: function() {
              var e = this,
                n = this.sQuery.sketch;
              if (!this.htmlNode) {
                var i = n.getDisplayObjForGObj(this);
                'element' in i &&
                  i.element &&
                  ((this.htmlNode = i.element), n.gobjAddKeyEvents(this));
              }
              if (
                (this.htmlNode &&
                  this.isParameter &&
                  this.isParameter() &&
                  t(this.htmlNode).find('.mfs-input').length &&
                  !this.parameterEventAttached &&
                  (t(this.htmlNode)
                    .find('.mfs-input')
                    .click(function() {
                      e.presentUI();
                    }),
                  (this.parameterEventAttached = !0)),
                this.htmlNode &&
                  this.isCompositeText &&
                  this.isCompositeText() &&
                  t(this.htmlNode).find('.mfs-param').length &&
                  !this.compositeEventAttached)
              ) {
                var r = !1;
                t(this.htmlNode)
                  .find('.mfs-param')
                  .each(function() {
                    var n = t(this).data('wsp-mfs-reference-id'),
                      i = e.sQuery().get(n);
                    t(this)
                      .focusin(function(e) {
                        (r = !0),
                          i.setRenderState('hotTarget'),
                          t(this).addClass('wsp-mfs-reference-hot');
                      })
                      .keydown(function(t) {
                        (13 === t.which || 32 === t.which) &&
                          i &&
                          i.press &&
                          i.press(e.sQuery().sketch);
                      })
                      .blur(function() {
                        r &&
                          ((r = !1),
                          i.setRenderState('none'),
                          t(this).removeClass('wsp-mfs-reference-hot'));
                      });
                  }),
                  (this.compositeEventAttached = !0);
              }
            },
          };
        })()
      )),
      (o.gObjects.Table = o.makeClass([o.gObjects.DOMKind], {
        doc: {
          description: 'A table of rows and columns',
          inherits: 'DOMKind',
          refspec: { gspKindRef: 'TableKind' },
          usage: {},
          properties: {
            rows: {
              description: 'the rows of the table, as arrays of mfs strings',
              type: 'Array',
              required: !1,
            },
            hasLivePreview: {
              description: 'Whether the final row updates dynamically or not',
              type: 'Boolean',
              default: !0,
            },
            style: {
              description:
                'Properties that influence the appearance of a GObject.',
              properties: {
                'border-color': {
                  description: 'Color of the table and cell borders',
                  type: 'Color',
                },
              },
            },
          },
        },
        kind: 'Table',
        autoplacementType: 'Table',
        hasLivePreview: !0,
        style: {},
        hasLabel: !1,
        headers: [],
        renderPrepare: function(e, t) {
          return (
            this.prepareToRenderStyles(t),
            (t['border-color'] = this.style['border-color']),
            e.prepareTable(t)
          );
        },
        createDefaultColorStyle: function(e) {
          return { 'border-color': e.color };
        },
        doPostReadFromSpec: function e() {
          (e.base || e.callee.base).call(this);
          var t, i;
          if (((this.rowsMFS = []), this.rows !== n))
            for (t = 0; t < this.rows.length; t++)
              for (this.rowsMFS.push([]), i = 0; i < this.rows[t].length; i++)
                this.rowsMFS[t].push(o.mfsParser.parse(this.rows[t][i]));
        },
        prepareToSerialize: function() {
          var e,
            t,
            n,
            i,
            r,
            s,
            a = 'UserTabulation' === this.constraint;
          if (a) {
            for (
              i = this.rows || [], n = i.length, e = n;
              e < this.rowsMFS.length;
              e++
            ) {
              for (s = this.rowsMFS[e], r = [], t = 0; t < s.length; t++)
                r.push(o.mfs.makeMFSFromMFSParseTree(s[t]));
              i.push(r);
            }
            i.length && (this.rows = i);
          }
        },
        getColorableComponent: function() {
          return 'TextGObject_BackgroundContrast';
        },
        getTextType: function() {
          return 'Table';
        },
        getColumnLabelMFS: function(e) {
          function t(e) {
            return e.isMultimeasure
              ? e.getMultiMeasureParentLabelMFS()
              : ((n = e.getNameMFS()),
                o.mfs.isEmptyTextMFS(n) ? e.getLabelMFS() : n);
          }
          var n,
            i,
            r = 0;
          return (
            e.isCompositeText() &&
              e.eachParent(function(e, t) {
                (t.isOfKind('Measure') || t.isMultimeasure) && (r++, (i = t));
              }),
            t(1 === r ? i : e)
          );
        },
        render: function(e, t, n) {
          var i = this.isRenderable(),
            r = i ? 'visible' : 'hidden',
            s = {
              visibility: r,
              constraintFrame: this.state.constraintFrame,
              opacity: this.calculateOpacity(),
              zIndex: n.zIndex,
            };
          (s.x = this.geom.loc.getX()),
            (s.y = this.geom.loc.getY()),
            (s.headersMFS = this.headersMFS),
            (s.rowsMFS = this.rowsMFS),
            (s.id = this.id),
            (s.kind = this.kind),
            (s.genus = o.mfs.updatedGenus[this.genus]),
            (s.label = this.label),
            this.hasLivePreview && (s.finalRowMFS = this.finalRowMFS),
            (s.style = this.style),
            (s[
              'background-color'
            ] = this.sQuery().getSketch().preferences.colorableComponents.Background.color),
            e.drawTable(t, s),
            this.updateKindHTMLStyle();
        },
        renderCleanup: function(e, t) {
          e.cleanupTable(t);
        },
        updateKindHTMLStyle: function() {
          if (!this.htmlNode) {
            var e = this.sQuery.sketch.getDisplayObjForGObj(this);
            'element' in e &&
              e.element &&
              ((this.htmlNode = e.element),
              this.sQuery.sketch.gobjAddKeyEvents(this));
          }
        },
      })),
      (o.gObjects.Arc = o.makeClass(
        [o.gObjects.Kind, o.mixins.label, o.mixins.arcVector, o.genera.Path],
        {
          doc: {
            description: '',
            inherits: 'Kind',
            refspec: { gspKindRef: 'ArcKind' },
            usage: {},
            properties: {
              style: {
                description: '',
                properties: {
                  'line-style': {
                    description: "Type of line: 'solid', 'dotted', 'dashed'",
                    type: 'String',
                    required: !1,
                  },
                  width: {
                    description: 'The width of the curve line in pixels.',
                    type: 'Number',
                  },
                },
              },
            },
          },
          kind: 'Arc',
          style: { hidden: !1, width: 3 },
          hasLabel: !0,
          geom: {},
          getGeometricArc: function() {
            return this.geom.arc;
          },
          radius: function() {
            return this.geom.arc.radius;
          },
          doPostReadFromSpec: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.arc = o.GeometricArc.FromCenterAndRadius(
                o.GeometricPoint.ORIGIN,
                0
              ));
          },
          getColorableComponent: function() {
            return 'Curves';
          },
          renderPrepare: function(e, t) {
            return (t.kind = this.kind), (t.id = this.id), e.prepareArc(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupArc(t);
          },
          render: function(e, t, n) {
            var i = {
              renderable: this.isRenderable(),
              arc: this.geom.arc,
              color: this.style.color,
              width: this.style.width,
              opacity: this.calculateOpacity(),
            };
            this.modifyRenderAttrsForCurrentState(i),
              this.setLineDash(i),
              e.drawArc(t, i),
              this.updateKindHTMLStyle();
          },
          getArcBounds: function(e, t) {
            var n = e.center,
              i = e.radius,
              r = {};
            return (
              e.pointIsInBounds(o.GeometricPoint(n.x + 1, n.y))
                ? (r.right = n.x + i)
                : (r.right = Math.max(e.initialPoint.x, e.finalPoint.x)),
              e.pointIsInBounds(o.GeometricPoint(n.x - 1, n.y))
                ? (r.left = n.x - i)
                : (r.left = Math.min(e.initialPoint.x, e.finalPoint.x)),
              e.pointIsInBounds(o.GeometricPoint(n.x, n.y - 1))
                ? (r.top = n.y - i)
                : (r.top = Math.min(e.initialPoint.y, e.finalPoint.y)),
              e.pointIsInBounds(o.GeometricPoint(n.x, n.y + 1))
                ? (r.bottom = n.y + i)
                : (r.bottom = Math.max(e.initialPoint.y, e.finalPoint.y) + t),
              o.Geom.insetRect(r, -t)
            );
          },
          getGeomBounds: function() {
            if (this.state.exists) {
              var e = this.geom.arc,
                t = this.style.width;
              return this.getArcBounds(e, t);
            }
          },
          hitTest: function(e, t) {
            return o.Geom.RectIntersectsCurve(e, {
              type: 'arc',
              curve: this.geom.arc,
            });
          },
          transform: function(e, t) {},
          mapPositionToPathValue: function(e) {
            return this.geom.arc.mapPositionToPathValue(e, this.genus);
          },
          mapPathValueToPosition: function(e, t) {
            return this.geom.arc.mapPathValueToPosition(e, this.genus, t);
          },
          area: function() {
            return 0;
          },
          pathLength: function() {
            return this.geom.arc.getCache(this.genus).perimeterLength;
          },
          closedPath: !1,
        }
      )),
      (function() {
        var e = 5,
          t = 3.5,
          n = 2.5 * t,
          i = 27,
          r = 2.5 * i,
          s = 1.25,
          a = 500,
          c = 15,
          l = [
            {
              expansionFactor: 2,
              diminishmentFactor: 2,
              largeTickInterval: 5,
              largeIntervalsPerText: 4,
            },
            {
              expansionFactor: 2.5,
              diminishmentFactor: 2,
              largeTickInterval: 5,
              largeIntervalsPerText: 5,
            },
            {
              expansionFactor: 2,
              diminishmentFactor: 2.5,
              largeTickInterval: 2,
              largeIntervalsPerText: 10,
            },
          ],
          u = [
            {
              expansionFactor: 2,
              diminishmentFactor: 2,
              largeTickInterval: 5,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 2.5,
              diminishmentFactor: 2,
              largeTickInterval: 5,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 2,
              diminishmentFactor: 2.5,
              largeTickInterval: 2,
              largeIntervalsPerText: 5,
            },
          ],
          d = [
            {
              expansionFactor: 2,
              diminishmentFactor: 2,
              largeTickInterval: 6,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 1.5,
              diminishmentFactor: 2,
              largeTickInterval: 6,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 4 / 3,
              diminishmentFactor: 1.5,
              largeTickInterval: 6,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 1.5,
              diminishmentFactor: 4 / 3,
              largeTickInterval: 6,
              largeIntervalsPerText: 2,
            },
            {
              expansionFactor: 2,
              diminishmentFactor: 1.5,
              largeTickInterval: 6,
              largeIntervalsPerText: 2,
            },
          ],
          h = {
            24: {
              decimal: {
                precision: 6,
                smallExponentBound: 9.9e-7,
                largeExponentBound: 9999999,
              },
              trigonometric: {
                precision: 3,
                smallExponentBound: 999e-6,
                largeExponentBound: 9999,
              },
            },
            48: {
              decimal: {
                precision: 3,
                smallExponentBound: 999e-6,
                largeExponentBound: 9999,
              },
              trigonometric: {
                precision: 3,
                smallExponentBound: 999e-6,
                largeExponentBound: 9999,
              },
            },
          },
          p = function(e, t) {
            return 'trigonometric' === e ? d : 'vertical' === t ? u : l;
          },
          f = function(e, t, n, i, r) {
            var o = p(e, t),
              a = n,
              c = i,
              l = r,
              u = 0;
            if (
              ('trigonometric' === e && ((a *= Math.PI), (c *= s), (l *= s)),
              a > 0)
            )
              for (; c > a; )
                (a *= o[u].expansionFactor), (u = (u + 1) % o.length);
            for (; a > l; )
              (a /= o[u].diminishmentFactor), --u < 0 && (u = o.length - 1);
            return {
              pixelsBetweenTicks: a,
              largeTickInterval: o[u].largeTickInterval,
              largeIntervalsPerText: o[u].largeIntervalsPerText,
            };
          };
        o.gObjects.Axis = o.makeClass([o.gObjects.Straight], {
          doc: {
            description: 'A one dimensional coordinate line.',
            inherits: 'Straight',
            refspec: { gspKindRef: 'AxisKind' },
            usage: {},
            properties: {
              orientation: {
                description:
                  "Orientation of the axis: 'horizontal' or 'vertical'.",
                type: 'String',
              },
              style: {
                description: '',
                properties: {
                  tickNumbering: {
                    description:
                      "Tick mark numbering system: 'decimal' or 'trigonometric'.",
                    type: 'String',
                    required: !1,
                  },
                  tickNumberStyle: {
                    description:
                      "Style of tick numbers: 'auto' for default behavior (show them), 'none' to hide them",
                    type: 'String',
                    required: !1,
                  },
                },
              },
            },
          },
          orientation: 'horizontal',
          kind: 'Axis',
          straightGenus: function() {
            return 'Line';
          },
          style: { tickNumbering: 'decimal', tickNumberStyle: 'auto' },
          geom: {},
          getColorableComponent: function() {
            return 'Axis';
          },
          renderPrepare: function(e, t) {
            return e.prepareAxis(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupAxis(t);
          },
          render: function(t, n, i) {
            var r = this.style['font-size'],
              s = this.getTickNumberPrecisionInfo(r, this.style.tickNumbering),
              o = {
                renderable: this.isRenderable(),
                origin: this.geom.origin,
                orientation: this.orientation,
                unitPixels: this.getUnitPixels(),
                isPolar: this.isPolar(),
                color: this.style.color,
                'line-style': this.style['line-style'],
                tickNumbering: this.style.tickNumbering,
                tickSpacing: this.getTickSpacing(),
                majorTickLength: e,
                width: this.style.width,
                tickNumberStyle: this.style.tickNumberStyle,
                'font-family': this.style['font-family'],
                'font-size': r,
                precisionInfo: s,
                sketchRect: this.sQuery.sketch.sketchRect(),
                opacity: this.calculateOpacity(),
              };
            this.modifyRenderAttrsForCurrentState(o),
              this.setLineDash(o),
              t.drawAxis(n, o),
              this.updateKindHTMLStyle();
          },
          hitTest: function e(t, n) {
            return (e.base || arguments.callee.base).call(this, t, n);
          },
          transform: function e(t, n) {
            (e.base || arguments.callee.base).call(this, t, n);
          },
          getZeroPoint: function() {
            return this.geom.origin;
          },
          getUnitPoint: function() {
            return this.geom.unit;
          },
          getUnitPixels: function() {
            return 'horizontal' === this.orientation
              ? this.geom.unit.x - this.geom.origin.x
              : -(this.geom.unit.y - this.geom.origin.y);
          },
          isPolar: function() {
            function e(e) {
              'CoordSys' === e.kind &&
                (++t, e.shape && 'polar' === e.shape && ++n);
            }
            var t = 0,
              n = 0;
            return this.children.forEach(e), t > 0 && t === n;
          },
          getTickSpacing: function() {
            return f(
              this.style.tickNumbering,
              this.orientation,
              this.getUnitPixels(),
              t,
              n
            );
          },
          getLineSpacing: function() {
            return f(
              this.style.tickNumbering,
              this.orientation,
              this.getUnitPixels(),
              i,
              r
            );
          },
          getPolarSpacing: function(e) {
            var t = p(this.style.tickNumbering, this.orientation),
              n = { x: e.x, y: e.y },
              i = 0;
            for (
              'trigonometric' === this.style.tickNumbering &&
              ((n.x *= Math.PI), (n.y *= Math.PI));
              n.x * n.y > a;

            )
              (n.x /= t[i].diminishmentFactor),
                (n.y /= t[i].diminishmentFactor),
                --i < 0 && (i = t.length - 1);
            if (n.x > 0 && n.y > 0)
              for (; n.x * n.y < a || n.x < c || n.y < c; )
                (n.x *= t[i].expansionFactor),
                  (n.y *= t[i].expansionFactor),
                  ++i >= t.length && (i = 0);
            return {
              pixelsBetweenTicks: { x: n.x, y: n.y },
              largeTickInterval: t[i].largeTickInterval,
              intervalsPerText:
                t[i].largeTickInterval * t[i].largeIntervalsPerText,
            };
          },
          getTextType: function() {
            return 'AxisTicksAndOptionalLabel';
          },
          getTickNumberPrecisionInfo: function(e, t) {
            var n,
              i,
              r = 0,
              s = 1024;
            for (n in h)
              (i = Number(n)), i > e && s > i ? (s = i) : i > r && (r = i);
            s >= 1024 && (s = r);
            var o = 1024 > s ? h[s] : null,
              a = o && o[t];
            return a;
          },
          getGeomBounds: function t() {
            var n = 3,
              i = 0.65,
              r = 2.5,
              s = 2,
              a = e,
              c = Math.round(this.style['font-size'] * i),
              l = 'trigonometric' === this.style.tickNumbering ? r : s,
              u = this.getTickNumberPrecisionInfo(c, this.style.tickNumbering),
              d = (2 + u.precision) * c,
              h = (t.base || arguments.callee.base).call(this);
            return (
              (h = o.Geom.insetRect(h, -a)),
              (h.left -= d + n),
              (h.bottom += c * l + n),
              h
            );
          },
          pathLength: function() {
            return this.geom.unit.subtract(this.geom.origin).vLength();
          },
          getDefaultLabelPathParam: function() {
            return 'horizontal' === this.orientation ? 0.05 : 0.95;
          },
          getPointOnPath: function e(t, n) {
            return (e.base || arguments.callee.base).call(this, t, n);
          },
          getClosestPointOnLine: function e(t, n) {
            return (e.base || arguments.callee.base).call(this, t, n);
          },
          pointIsInBounds: function e(t) {
            return (e.base || arguments.callee.base).call(this, t);
          },
        });
      })(),
      (o.gObjects.CircleInterior = o.makeClass(
        [o.gObjects.Circle, o.genera.Interior],
        {
          doc: {
            description: 'The region comprising the interior of a circle.',
            inherits: 'Circle',
            refspec: { gspKindRef: 'CircleInteriorKind' },
            usage: {},
            properties: {
              style: {
                properties: {
                  layerOrder: {
                    description:
                      'z-index within the set of Interiors and Images',
                    type: 'Number',
                  },
                  opacity: {
                    description: '0 (transparent) to 1 (fully opaque)',
                    default: '0.5',
                    type: 'Number',
                  },
                },
              },
            },
          },
          style: { hidden: !1, 'line-style': 'solid', opacity: 0.5, width: 1 },
          state: {},
          kind: 'CircleInterior',
          getColorableComponent: function() {
            return 'Interior';
          },
          doModifyRenderAttrsForState: function(e, t) {
            this.modifyRenderAttrsForInterior(e, t);
          },
          renderPrepare: function(e, t) {
            return (
              (t.kind = this.kind), (t.id = this.id), e.prepareCircleInterior(t)
            );
          },
          renderCleanup: function(e, t) {
            return e.cleanupCircleInterior(t);
          },
          render: function(e, t, n) {
            var i,
              r,
              s,
              o = this.isRenderable();
            o
              ? ((i = Number(this.geom.c.x)),
                isNaN(i) && (i = 0),
                (r = Number(this.geom.c.y)),
                isNaN(r) && (r = 0),
                (s = Number(this.geom.r)),
                isNaN(s) && (s = 0))
              : (i = r = s = -100);
            var a = {
              renderable: o,
              cx: i,
              cy: r,
              r: s,
              color: this.style.color,
              opacity: this.calculateOpacity(),
            };
            this.modifyRenderAttrsForCurrentState(a),
              e.drawCircleInterior(t, a),
              this.updateKindHTMLStyle();
          },
          hitTest: function(e, t, n) {
            var i = n && n.interiorsPerimeterOnly;
            return o.Geom.RectIntersectsCurve(e, {
              type: i ? 'circle' : 'circleInterior',
              curve: o.GeometricArc.FromCenterAndRadius(
                this.geom.c,
                this.geom.r
              ),
            });
          },
          transform: function(e, t) {},
        }
      )),
      (o.gObjects.ArcInterior = o.makeClass(
        [o.gObjects.Arc, o.genera.Interior],
        {
          doc: {
            description: 'The region comprising the interior of an arc.',
            inherits: 'Arc',
            refspec: {},
            usage: {},
            properties: {
              style: {
                properties: {
                  layerOrder: {
                    description:
                      'z-index within the set of Interiors and Images',
                    type: 'Number',
                  },
                  opacity: {
                    description: '0 (transparent) to 1 (fully opaque)',
                    default: '0.5',
                    type: 'Number',
                  },
                },
              },
            },
          },
          style: { hidden: !1, 'line-style': 'solid', opacity: 0.5, width: 1 },
          state: {},
          kind: 'ArcInterior',
          perimeter: function() {
            return this.geom.arc.getCache(this.genus).perimeterLength;
          },
          area: function() {
            var e = this.geom.arc,
              t = e.radius * e.radius,
              n = e.arcAngle * t;
            return (
              'ArcSegment' === this.genus && (n -= t * Math.sin(e.arcAngle)),
              n / 2
            );
          },
          getColorableComponent: function() {
            return 'Interior';
          },
          doModifyRenderAttrsForState: function(e, t) {
            this.modifyRenderAttrsForInterior(e, t);
          },
          renderPrepare: function(e, t) {
            return (
              (t.kind = this.kind), (t.id = this.id), e.prepareArcInterior(t)
            );
          },
          renderCleanup: function(e, t) {
            return e.cleanupArcInterior(t);
          },
          render: function(e, t, n) {
            var i = {
              renderable: this.isRenderable(),
              arc: this.geom.arc,
              genus: this.genus,
              opacity: this.calculateOpacity(),
              color: this.style.color,
            };
            this.modifyRenderAttrsForCurrentState(i),
              e.drawArcInterior(t, i),
              this.updateKindHTMLStyle();
          },
          getGeomBounds: function e() {
            var t = (e.base || arguments.callee.base).call(this);
            return t && (t = o.Geom.unionRectPoint(t, this.geom.arc.center)), t;
          },
          hitTest: function(e, t, n) {
            var i = n && n.interiorsPerimeterOnly,
              r = 'ArcSector' === this.genus ? 'arcSector' : 'arcSegment';
            return o.Geom.RectIntersectsCurve(e, {
              type: i ? r + 'Perimeter' : r,
              curve: this.geom.arc,
            });
          },
          transform: function(e, t) {},
          closedPath: !0,
        }
      )),
      (function() {
        o.gObjects.CoordSys = o.makeClass([o.gObjects.Kind, o.Genus], {
          doc: {
            description: 'A Coordinate System.',
            inherits: 'Kind',
            refspec: { gspKindRef: 'CoordSysKind' },
            usage: {},
            properties: {
              shape: {
                description:
                  "Type or coordinate system: 'polar', 'square', or 'rectangular'.",
                type: 'String',
              },
              style: {
                description: '',
                properties: {
                  grid: {
                    description:
                      "Appearance of the coordinate system grid: 'gridlines' or 'dotted'",
                    type: 'String',
                  },
                  width: {
                    description:
                      "Line width for 'gridlines' coordinate systems",
                    type: 'Number',
                  },
                  radius: {
                    description:
                      "Radius of points for 'dotted' coordinate systems",
                    type: 'Number',
                  },
                },
              },
            },
          },
          kind: 'CoordSys',
          style: { width: 0.5, radius: 1.5 },
          geom: {},
          doPostReadFromSpec: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.origin = o.GeometricPoint.ORIGIN),
              (this.geom.unit0 = o.GeometricPoint.ORIGIN),
              (this.geom.unit1 = o.GeometricPoint.ORIGIN);
          },
          getColorableComponent: function() {
            return 'CoordSys';
          },
          renderPrepare: function(e, t) {
            return e.prepareCoordSys(t);
          },
          renderCleanup: function(e, t) {
            return e.cleanupCoordSys(t);
          },
          render: function(e, t, n) {
            var i = {
              renderable: this.isRenderable(),
              origin: this.geom.origin,
              shape: this.shape,
              grid: this.style.grid,
              gridSpacing: this.geom.gridSpacing,
              radius: this.style.radius,
              opacity: this.calculateOpacity(),
              color: this.style.color,
              width: this.style.width,
              sketchRect: this.sQuery.sketch.sketchRect(),
            };
            this.modifyRenderAttrsForCurrentState(i),
              e.drawCoordSys(t, i),
              this.updateKindHTMLStyle();
          },
          hitTest: function(e, t) {
            var n = function(e, t) {
              var n,
                i,
                r,
                s = [
                  { cos: 1, sin: 0 },
                  { cos: 0.96592582628907, sin: 0.25881904510252 },
                  { cos: 0.86602540378444, sin: 0.5 },
                  { cos: 0.70710678118655, sin: 0.70710678118655 },
                  { cos: 0.5, sin: 0.86602540378444 },
                  { cos: 0.25881904510252, sin: 0.96592582628907 },
                  { cos: 0, sin: 1 },
                ];
              for (n = 0; 7 > n; n++) {
                if (
                  ((i = s[n].cos * t),
                  (r = s[n].sin * t),
                  o.Geom.PointInRect(o.GeometricPoint(i, r), e))
                )
                  return !0;
                if (o.Geom.PointInRect(o.GeometricPoint(i, -r), e)) return !0;
                if (o.Geom.PointInRect(o.GeometricPoint(-i, r), e)) return !0;
                if (o.Geom.PointInRect(o.GeometricPoint(-i, -r), e)) return !0;
              }
              return !1;
            };
            if ('polar' === this.shape) {
              var i,
                r,
                s,
                a,
                c,
                l = {
                  x: this.geom.unit0.x - this.geom.origin.x,
                  y: -(this.geom.unit1.y - this.geom.origin.y),
                },
                u = this.getParent('axisX').getPolarSpacing(l)
                  .pixelsBetweenTicks,
                d = u.y / u.x,
                h = {
                  left: (e.left - this.geom.origin.x) * d,
                  right: (e.right - this.geom.origin.x) * d,
                  top: e.top - this.geom.origin.y,
                  bottom: e.bottom - this.geom.origin.y,
                };
              if (o.Geom.PointInRect(o.GeometricPoint(0, 0), h)) return !0;
              for (
                i = h.top * h.top + h.left * h.left,
                  r = i,
                  s = h.top * h.top + h.right * h.right,
                  r = s > r ? s : r,
                  i = r > s ? s : i,
                  s = h.bottom * h.bottom + h.left * h.left,
                  r = s > r ? s : r,
                  i = r > s ? s : i,
                  s = h.bottom * h.bottom + h.right * h.right,
                  r = s > r ? s : r,
                  i = i > s ? s : i,
                  a = u.y,
                  c = a * a;
                i > c;

              )
                (a += u.y), (c = a * a);
              for (; r > c; ) {
                if (n(h, a)) return !0;
                (a += u.y), (c = a * a);
              }
              return !1;
            }
            var p = {
                left: e.left - this.geom.origin.getX(),
                right: e.right - this.geom.origin.getX(),
                top: e.bottom - this.geom.origin.getY(),
                bottom: e.top - this.geom.origin.getY(),
              },
              f = this.getParent('axisX').getLineSpacing().pixelsBetweenTicks,
              m = Math.floor(p.left / f) * f,
              g = p.right - m;
            if (f > g) return !1;
            var b = this.getParent('axisY').getLineSpacing().pixelsBetweenTicks,
              v = Math.floor(p.bottom / b) * b,
              y = p.top - v;
            return b > y ? !1 : !0;
          },
          locatePlot: function(e, t) {
            var n = this.geom.unit0.x - this.geom.origin.x,
              i = this.geom.origin.x,
              r = this.geom.unit1.y - this.geom.origin.y,
              s = this.geom.origin.y;
            return o.GeometricPoint(e * n + i, t * r + s);
          },
          vectorLocatePlot: function(e) {
            var t,
              n,
              i,
              r = e.length,
              s = o.createFloatVector(r),
              a = this.geom.unit0.x - this.geom.origin.x,
              c = this.geom.origin.x,
              l = this.geom.unit1.y - this.geom.origin.y,
              u = this.geom.origin.y;
            for (s.set ? s.set(e) : (s = e.concat()), t = 0; r > t; t += 2)
              (n = s[t]),
                (i = s[t + 1]),
                (s[t] = n * a + c),
                (s[t + 1] = i * l + u);
            return s;
          },
          locatePoint: function(e) {
            var t = this.geom.unit0.subtract(this.geom.origin),
              n = this.geom.unit1.subtract(this.geom.origin),
              i = e.subtract(this.geom.origin),
              r = i.x / t.x,
              s = i.y / n.y;
            return o.GeometricPoint(r, s);
          },
          snapPoint: function(e, t) {
            var i = this.geom.origin.x,
              r = this.geom.origin.y,
              s = this.geom.unit0.x - this.geom.origin.x,
              o = this.geom.unit1.y - this.geom.origin.y,
              a = e.x,
              c = e.y;
            if ((n === t && (t = 100), 'polar' === this.shape)) {
              var l = (e.x - i) / s,
                u = (e.y - r) / o,
                d = Math.round(Math.sqrt(l * l + u * u)),
                h = 0;
              if (0 !== d) {
                var p = Math.PI / 12;
                (h = Math.atan2(-u, l)), (h = Math.round(h / p) * p);
              }
              (a = i + s * d * Math.cos(h)), (c = r - o * d * Math.sin(h));
            } else
              (a = Math.round((e.x - i) / s) * s + i),
                (c = Math.round((e.y - r) / o) * o + r);
            var f = Math.abs(a - e.x),
              m = Math.abs(c - e.y);
            (!t || (t > f && t > m)) && ((e.x = a), (e.y = c));
          },
          createDefaultSpec: function(e, t) {
            var n = (t && t.origin && t.origin.style) || {},
              i = (t && t.xUnitPoint && t.xUnitPoint.style) || {},
              r = (t && t.xAxis && t.xAxis.style) || {},
              s = (t.yUnitPoint && t.yUnitPoint.style) || {},
              o = (t && t.yAxis && t.yAxis.style) || {},
              a = (t && t.shape) || 'square',
              c = (t && t.style) || {},
              l = 'rectangular' === a,
              u = {
                1: {
                  kind: 'Point',
                  genus: 'OriginPoint',
                  constraint: 'Free',
                  style: n,
                },
                2: {
                  kind: 'Point',
                  genus: 'UnitPoint',
                  parents: { origin: '1' },
                  value: 28.346456692913385,
                  constraint: 'HorizontalUnitPoint',
                  style: i,
                },
                3: {
                  kind: 'Axis',
                  genus: 'Axis',
                  parents: { origin: '1', unitPoint: '2' },
                  constraint: 'AxisInternalDist',
                  orientation: 'horizontal',
                  label: 'x',
                  style: r,
                },
                4: {
                  kind: 'Point',
                  genus: 'UnitPoint',
                  parents: { unitPoint: '2' },
                  constraint: 'UnitPointInternalSquare',
                  style: s,
                },
                5: {
                  kind: 'Axis',
                  genus: 'Axis',
                  parents: { origin: '1', unitPoint: '4' },
                  constraint: 'AxisInternalDist',
                  orientation: 'vertical',
                  label: 'y',
                  style: o,
                },
                6: {
                  kind: 'CoordSys',
                  genus: 'CoordSys',
                  parents: { axisX: '3', axisY: '5' },
                  constraint: 'CoordSys',
                  shape: a,
                  style: c,
                },
              },
              d =
                (e.metadata.sketchRect.right - e.metadata.sketchRect.left) / 2,
              h =
                (e.metadata.sketchRect.bottom - e.metadata.sketchRect.top) / 2;
            return (
              (u[1].geom = { loc: { x: d, y: h } }),
              l &&
                ((u[4].constraint = 'UnitPointInternalRectangle'),
                (u[4].unitDistance = 28.346456692913364)),
              u
            );
          },
        });
      })(),
      (o.gObjects.Measure = o.makeClass([o.gObjects.Text, o.mixins.labelBase], {
        doc: {
          description: 'A message rendered in to a sketch canvas.',
          inherits: 'Text',
          properties: {
            label: {
              description:
                'Text that describes or identifies the value of this object.',
              type: 'String',
              required: !1,
            },
            style: {
              properties: {
                precision: {
                  description:
                    'The number of digits to display after the decimal point.',
                  type: 'Number',
                  required: !1,
                },
                nameOrigin: {
                  description: 'What identifying value to display.',
                  type: 'NameOrigin',
                  required: !1,
                },
                showUnits: {
                  description: 'Do we show the unit measurement?',
                  required: !1,
                },
              },
            },
            blank: {
              description:
                'a display property indicating that the value or result of the calculation should be blank',
              type: 'Boolean',
              default: !1,
              required: !1,
            },
            debug: {
              properties: {
                value: {
                  description: 'The numeric value of a measure',
                  required: !1,
                  type: 'Number',
                },
                defined: {
                  description: 'Whether the measure is defined',
                  required: !1,
                  type: 'Boolean',
                },
              },
            },
          },
        },
        kind: 'Measure',
        style: { precision: n, showUnits: !0 },
        unitPowers: { scalar: 1 },
        initPrecision: function() {
          var e,
            t = 'scalar',
            i = this.unitsObject.hasOwnProperty('length'),
            r = this.unitsObject.hasOwnProperty('angle');
          return (
            (i && r) || (i && (t = 'length'), r && (t = 'angle')),
            (e =
              this.style.precision !== n
                ? this.style.precision
                : this.sQuery().prefs().precision[t])
          );
        },
        initKind: function e() {
          (e.base || arguments.callee.base).call(this),
            this.initMeasure(),
            (this.style.precision = this.initPrecision(this.sQuery().prefs()));
        },
        postInit: function(e) {
          !this.style.hidden &&
            e &&
            e.speculative &&
            'namedFromTemplate' === this.style.nameOrigin &&
            ((this.state.updatingLabel = !0),
            this.eachParent(function(e, t) {
              t.state.updatingLabel = !0;
            }),
            this.eachParent(function(e, t) {
              t.getLabel && t.getNameMFS({ show: !0 });
            }),
            this.eachParent(function(e, t) {
              delete t.state.updatingLabel;
            }),
            delete this.state.updatingLabel,
            this.updateLabel({ show: !0 }));
        },
        updateLabelForKind: function e(t) {
          (e.base || arguments.callee.base).call(this),
            t &&
              t.init &&
              !this.style.hidden &&
              ('speculative' === this.state.renderState
                ? (t.show = !0)
                : (t.create = !0)),
            this.generateMeasureMFS(t);
        },
        initMeasure: function() {
          this.setUnits(this.unitPowers),
            this.value !== n &&
              (this.uValue = o.units.convertFromBaseToUnitObject(
                this.value,
                this.unitsObject
              ));
        },
        matchesAssumedSpec: function(e) {
          if ('Expression' === e.kind || 'Measure' === e.kind) {
            if (e.genus.includes('Scalar'))
              return (
                this.genus.includes('Scalar') ||
                (this.genus.includes('Angle') && 'rad' === this.unit) ||
                (1 === e.children.length &&
                  'PlottedPoint' === e.children[0].genus)
              );
            if (e.genus.includes('Distance'))
              return this.genus.includes('Distance');
            if (e.genus.includes('Angle'))
              return (
                this.genus.includes('Angle') ||
                (this.genus.includes('Scalar') && 'rad' === e.unit)
              );
            if ('Function' === e.genus) return 'Function' === this.genus;
          }
          return !1;
        },
        generateMeasureMFS: function(e) {
          var t,
            n,
            i = [];
          if ('namedFromFixedString' === this.style.nameOrigin)
            return void (this.parsedMFS = o.mfs.makeTextMFS(this.label));
          if (!this.style.hidden || this.isGobjExistInWSPSays()) {
            if (
              ((t = this.getNameMFS(e)),
              'noVisibleName' !== this.style.nameOrigin)
            ) {
              if (!t && e.init) return;
              i.push(t), i.push(o.mfs.makeTextMFS(' = '));
            }
            i.push(this.getValueMFS()),
              (n = this.getUnitsMFS()),
              null !== n && i.push(n),
              this.style.suffix && i.push(o.mfs.makeTextMFS(this.style.suffix)),
              (this.parsedMFS = o.mfs.makeHorizontalMFS.apply(this, i));
          }
        },
        getValueMFS: function() {
          return { type: 'parameter', value: 'value' };
        },
        generateNameMFS: function(e) {
          function t(e, t) {
            var n, i, r;
            if (e.value)
              for (n = 0; n < e.value.length; n++)
                (i = e.value[n]),
                  'switch' === i.type &&
                    i.value &&
                    ((r = i.value[0]),
                    'parameter' === r.type && (e.value[n] = t[r.value]));
          }
          function n(e) {
            var n, i, r;
            if (a.style.hidden) {
              for (i = 0; i < e.length; i++)
                if ('CompositeText' === e[i].constraint && !e[i].style.hidden) {
                  n = e[i];
                  break;
                }
              if (n && n.parsedMFS)
                for (
                  r = JSON.parse(JSON.stringify(n.parsedMFS)), i = 0;
                  i < r.value.length;
                  i++
                )
                  'text' === r.value[i].type &&
                    r.value[i].value.match(/=/) &&
                    (r.value.splice(i, r.value.length),
                    t(r, n.MFSValues || n.parentMFSValues));
              return r;
            }
          }
          var i,
            r,
            s = this.style.nameOrigin,
            a = this;
          switch (
            ('noVisibleName' === s && e && e.force && (s = 'namedFromLabel'), s)
          ) {
            case 'namedFromLabel':
              (i = this.label ? this.label.replace(/ += +$/, '') : ''),
                (r = o.labels.parseLabelExpression(
                  i,
                  this.getMathItalicization()
                ));
              break;
            case 'noVisibleName':
              r = o.mfs.makeTextMFS('');
              break;
            case 'namedFromTemplate':
              r = this.getParentalNameMFS(e);
              break;
            case 'namedFromCustom':
              if ((r = n(this.children))) break;
            default:
              (r = null),
                o.signalErrorWithMessage(
                  "Measure.getNameMFS() doesn't know how to do nameOrigin" + s
                );
          }
          return r;
        },
        setUnits: function(e) {
          (this.unitPowers = e),
            (this.unitsObject = o.units.makeUnitObjectFromUnitsAndPowers(
              this.sQuery().prefs().units,
              e
            ));
        },
        getUnitsMFS: function() {
          return this.style.showUnits === !1
            ? o.mfs.makeTextMFS('')
            : o.units.getMFSForUnitObject(this.unitsObject);
        },
        getRawValue: function() {
          return this.value;
        },
        getColorableComponent: function() {
          return 'TextGObject_BackgroundContrast';
        },
        getTextType: function() {
          return 'Measurement';
        },
        getMFSAppearanceForVariant: function(e) {
          function t() {
            var e = r.radiansOrScalar();
            return r.formatNumberAsMFS(r.uValue, r.style.precision, e, !0);
          }
          var n,
            i,
            r = this,
            s = [];
          switch (e) {
            case 'valueAsAddend':
              return this.state.exists
                ? (r.uValue < 0
                    ? (s.push(o.mfs.makeTextMFS(' ')),
                      s.push({ type: 'symbol', value: '103' }),
                      s.push(o.mfs.makeTextMFS(' ')))
                    : s.push(o.mfs.makeTextMFS(' + ')),
                  (n = r.uValue),
                  (r.uValue = Math.abs(r.uValue)),
                  s.push(t()),
                  (i = o.mfs.makeHorizontalMFS.apply(this, s)),
                  (r.uValue = n),
                  i)
                : null;
            case 'byLabel':
              return this.getLabelMFS();
            case 'byName':
              return this.getParentalNameMFS();
            default:
              if (!this.state.exists) return null;
              var a =
                'default' === e && this.style.prefixWithLabel && this.label;
              if (a || this.style.suffix) {
                var c = [t()];
                return (
                  a && c.unshift(o.mfs.makeTextMFS(this.label)),
                  this.style.suffix &&
                    c.push(o.mfs.makeTextMFS(this.style.suffix)),
                  o.mfs.makeHorizontalMFS.apply(this, c)
                );
              }
              return t();
          }
        },
        verificationString: function e(t, n) {
          var i,
            r,
            s = (e.base || arguments.callee.base).call(this, t, n);
          return (
            t.exists &&
              this.state.exists &&
              'Function' !== this.genus &&
              (o.math.expect(this.uValue, t.value) ||
                (s +=
                  'value: <span class="error">' +
                  this.uValue +
                  '</span>(<span class="expected">' +
                  t.value +
                  '</span>)'),
              (i = this.unitPowers.length ? this.unitPowers.length : 0),
              o.math.expect(i, t.lengthPower) ||
                (s +=
                  'length power: <span class="error">' +
                  i +
                  '</span>(<span class="expected">' +
                  t.lengthPower +
                  '</span>)'),
              (r = this.unitPowers.angle ? this.unitPowers.angle : 0),
              o.math.expect(r, t.anglePower) ||
                (s +=
                  'length power: <span class="error">' +
                  r +
                  '</span>(<span class="expected">' +
                  t.anglePower +
                  '</span>)')),
            s
          );
        },
      })),
      (o.gObjects.Expression = o.makeClass(
        o.gObjects.Measure,
        (function() {
          return {
            doc: {
              description: 'A numeric expression.',
              inherits: 'Measure',
              properties: {
                expression: {
                  description: 'An infix expression',
                  type: 'String',
                },
                expressionType: {
                  description:
                    'The type of expression. Used mainly for interpreting functions.',
                  type: 'UnivExpressionType',
                },
                functionExpr: {
                  description:
                    'A set of properties used for function expressions.',
                  required: !1,
                  properties: {
                    notation: {
                      description:
                        "Display notation type of the function: 'function' (e.g. 'f(x)') or 'dependentVariable' (e.g. 'y =')",
                      type: 'String',
                      required: !1,
                    },
                    name: {
                      description:
                        "The name of the function, e.g. 'f' in 'y = f(x)'.",
                      type: 'String',
                      required: !1,
                    },
                    dependentVar: {
                      description:
                        "The name of the dependent variable, e.g. 'y' in 'y = f(x)'.",
                      type: 'String',
                      required: !1,
                    },
                    independentVar: {
                      description:
                        "The name of the independent variable, e.g. 'x' in 'y = f(x)'.",
                      type: 'String',
                      required: !1,
                    },
                  },
                },
                style: {
                  description:
                    'Properties that influence the appearance of a GObject.',
                  properties: {
                    contenteditable: {
                      description:
                        'Whether the element is inline-editable. Applicable only to Parameters.',
                      type: 'Boolean',
                    },
                  },
                },
              },
            },
            kind: 'Expression',
            expression: '',
            isExpressionDirty: !1,
            unitPowers: { scalar: 1 },
            notation: 'function',
            parsedInfix: n,
            style: { contenteditable: !1 },
            value: n,
            isFunction: function() {
              return 'UniMeasure_ExprType' !== this.expressionType;
            },
            isParameter: function() {
              return (
                'ScalarParameter' === this.genus ||
                'AngleParameter' === this.genus ||
                'DistanceParameter' === this.genus
              );
            },
            renderPrepare: function e(t, n) {
              return (
                this.isParameter() || (n.isEditableByCalculator = !0),
                (e.base || arguments.callee.base).apply(this, arguments)
              );
            },
            initMeasure: function() {
              var e = this.sQuery().prefs().units;
              (this.unit = ''),
                'AngleParameter' === this.genus
                  ? (this.setUnits({ angle: 1 }), (this.unit = e.angle))
                  : 'DistanceParameter' === this.genus &&
                    (this.setUnits({ length: 1 }), (this.unit = e.length)),
                this.parseInfixExpression();
            },
            initPrecision: function e() {
              return this.isFunction()
                ? n
                : (e.base || arguments.callee.base).call(this);
            },
            getValueMFS: function() {
              return this.isFunction()
                ? o.mfs.makeMFSFromParsedInfix(
                    this.parsedInfix,
                    this.parentsList,
                    !0,
                    this.getMathItalicization()
                  )
                : this.isEditableSimpleExpression()
                ? { type: 'input', value: 'value' }
                : { type: 'parameter', value: 'value' };
            },
            isHittable: function() {
              return (
                this.isRenderable() &&
                (this.style.contenteditable || this.style.selectable)
              );
            },
            matchesAssumedSpec: function(e) {
              if ('Expression' === e.kind || 'Measure' === e.kind) {
                if (e.genus.includes('Scalar'))
                  return (
                    this.genus.includes('Scalar') ||
                    (this.genus.includes('Angle') && 'rad' === this.unit) ||
                    (1 === e.children.length &&
                      'PlottedPoint' === e.children[0].genus)
                  );
                if (e.genus.includes('Distance'))
                  return this.genus.includes('Distance');
                if (e.genus.includes('Angle'))
                  return (
                    this.genus.includes('Angle') ||
                    (this.genus.includes('Scalar') && 'rad' === e.unit)
                  );
                if ('Function' === e.genus) return 'Function' === this.genus;
              }
              return !1;
            },
            createDefaultSpec: function(e, t) {
              var n =
                  (e.metadata.sketchRect.right - e.metadata.sketchRect.left) /
                  2,
                i =
                  (e.metadata.sketchRect.bottom - e.metadata.sketchRect.top) /
                  2,
                r = (t && t.style) || {},
                s = (t && t.label) || '';
              return 'Free' !== t.constraint ||
                [
                  'ScalarParameter',
                  'AngleParameter',
                  'DistanceParameter',
                ].indexOf(t.genus) < 0
                ? void 0
                : (t &&
                    t.geom &&
                    t.geom.loc &&
                    ((n = e.metadata.sketchRect.left + t.geom.loc.x),
                    (i = e.metadata.sketchRect.top + t.geom.loc.y)),
                  {
                    1: {
                      kind: 'Expression',
                      genus: t.genus,
                      constraint: 'Free',
                      expressionType: 'UniMeasure_ExprType',
                      expression: t.expression,
                      style: r,
                      label: s,
                      geom: { loc: { x: n, y: i } },
                    },
                  });
            },
            getEditBoxElement: function() {
              var e = this.sQuery.sketch.getDisplayObjForGObj(this);
              return t('.mfs-input', t(e.element));
            },
            positionInEditBox: function(e) {
              return 'invisible' !== this.state.renderState
                ? o.positionInElement(e, this.getEditBoxElement())
                : !1;
            },
            hitTest: function(e, t, n) {
              var i = this.sQuery.sketch.getDisplayObjForGObj(this),
                r = {
                  left: this.geom.loc.getX(),
                  top: this.geom.loc.getY(),
                  width: i.width(),
                  height: i.height(),
                },
                s = {
                  left: r.left,
                  right: r.left + r.width,
                  top: r.top,
                  bottom: r.top + r.height,
                },
                a = o.Geom.RectsIntersect(r, s),
                c = this;
              return a && t && this.positionInEditBox(t)
                ? o.ClickTracker.createOnElement(
                    this.getEditBoxElement(),
                    function() {
                      c.presentUI(n && n.onCompleteUI);
                    }
                  )
                : a &&
                    (this.style.selectable || (n && n.assumeArrowSelectable));
            },
            presentUI: function(e) {
              var n,
                i = this.sQuery.sketch.getDisplayObjForGObj(this),
                r = i.mfsElement;
              (n = this.isParameter()
                ? t('.mfs-input', r).data('wsp-numfield-ctl')
                : t(r).data('wsp-numfield-ctl')),
                e &&
                  n.setListener(function(t) {
                    e(t), n.clearListener();
                  }),
                n.vFocus(this);
            },
            doubleClicked: function(e) {
              var n = this.sQuery.sketch.getDisplayObjForGObj(this).element,
                i = t(n).data('wsp-numfield-ctl');
              i && i.click(e, this);
            },
            makeFnFromInfixExpression: function() {
              var e = o.mfs.getParsedInfixAndFunction(this.expression);
              return (
                (this.parsedInfix = e.parsedInfix),
                this.setUnits(
                  o.mfs.determineUnit(this.parsedInfix, this.parentsList)
                ),
                (this.unitMultiplier = o.units.convertToBaseFromUnitObject(
                  1,
                  this.unitsObject
                )),
                o.isCalculation(this) &&
                  (1 !== this.unitPowers.angle || this.unitPowers.length
                    ? this.unitPowers.angle || 1 !== this.unitPowers.length
                      ? (this.genus = 'ScalarMeasure')
                      : (this.genus = 'DistanceMeasure')
                    : (this.genus = 'AngleMeasure')),
                e.func
              );
            },
            getUnitPowers: function(e) {
              return o.mfs.determineUnit(this.parsedInfix, this.parentsList, e);
            },
            curryReferences: function(e, t, n) {
              return function(i) {
                var r =
                  e.functionExpr && e.functionExpr.independentVar
                    ? e.functionExpr.independentVar
                    : 'x';
                return (t[r] = i), e.fnExpression(t, n);
              };
            },
            parseInfixExpression: function() {
              var e = this.sQuery().prefs().units;
              if (
                ((this.fnExpression = this.makeFnFromInfixExpression()),
                (this.fnUnits = e),
                'Free' === this.constraint)
              ) {
                if (this.isFunction()) {
                  var t = this;
                  (this.uValue = this.curryReferences(this, [], e)),
                    (this.value = function(e) {
                      return t.uValue(e) * t.unitMultiplier;
                    });
                } else
                  (this.uValue = this.fnExpression([], e)),
                    (this.value = this.uValue * this.unitMultiplier);
                this.isExpressionDirty = !1;
              }
            },
            expressionAndParentsWereUpdated: function() {
              var e = this.sQuery.sketch,
                t = e.gobjList;
              o.ObjectGraph.setParents(t.constraintList, this, this.parents),
                (this.parentsList = t.createCanonicalParentReferences(this)),
                this.descendantGraphHasChanged(),
                e.document.raiseSketchEvent(e.getPageId(), this.id, 'edit');
            },
            graphHasChanged: function e() {
              return (
                this.parseInfixExpression(),
                (e.base || arguments.callee.base).call(this)
              );
            },
            isEditableSimpleExpression: function() {
              return this.style.selectable || this.style.contenteditable
                ? (this.parsedInfix === n &&
                    (this.parsedInfix = o.mfs.getParsedInfix(this.expression)),
                  o.mfs.isSimpleExpression(this.parsedInfix))
                : !1;
            },
            getUnitsMFS: function e() {
              return this.isFunction()
                ? null
                : (e.base || arguments.callee.base).call(this);
            },
            generateNameMFS: function() {
              var e = this.getMathItalicization();
              if (this.functionExpr) {
                var t = this.getLabelMFS() || o.mfs.makeTextMFS('f', e),
                  n = o.mfs.makeTextMFS(
                    this.functionExpr.dependentVar || 'y',
                    e
                  ),
                  i = o.mfs.makeTextMFS(
                    this.functionExpr.independentVar || 'x',
                    e
                  ),
                  r =
                    'function' === this.functionExpr.notation
                      ? [t, { type: 'paren', value: [i] }]
                      : [n];
                return o.mfs.makeHorizontalMFS.apply(this, r);
              }
              var s,
                a,
                c = this.style.nameOrigin;
              switch (c) {
                case 'namedFromLabel':
                case 'noVisibleName':
                  (s = this.label ? this.label.replace(/ = $/, '') : ''),
                    (a = o.labels.parseLabelExpression(s, e));
                  break;
                case 'namedFromTemplate':
                  a = this.createMFSFromInfixExpression();
                  break;
                default:
                  a = o.mfs.makeTextMFS('Expression ' + this.id);
              }
              return a;
            },
            createMFSFromInfixExpression: function() {
              return (
                this.parsedInfix === n &&
                  (this.parsedInfix = o.mfs.getParsedInfix(this.expression)),
                o.mfs.makeMFSFromParsedInfix(
                  this.parsedInfix,
                  this.parentsList,
                  !1,
                  this.getMathItalicization()
                )
              );
            },
            getMFSAppearanceForVariant: function e(t) {
              function n() {
                var e = i.getMathItalicization();
                switch (t) {
                  case 'expressionOnly':
                    return (
                      i.parsedInfix || i.parseInfixExpression(),
                      o.mfs.makeMFSFromParsedInfix(
                        i.parsedInfix,
                        i.parentsList,
                        !0,
                        i.getMathItalicization()
                      )
                    );
                  case 'independentVariable':
                    return o.mfs.makeTextMFS(
                      i.functionExpr.independentVar || 'x',
                      e
                    );
                  case 'dependentVariable':
                    return o.mfs.makeTextMFS(
                      i.functionExpr.dependentVar || 'y',
                      e
                    );
                  case 'byLabel':
                    return i.getLabelMFS();
                  default:
                    return i.parsedMFS;
                }
              }
              var i = this;
              return this.isFunction()
                ? n()
                : 'byName' === t
                ? this.createMFSFromInfixExpression()
                : (e.base || arguments.callee.base).call(this, t);
            },
            updateValue: function(e) {
              if ('function' == typeof e || 'function' == typeof this.value)
                throw o.createError(
                  'Expression.updateValue() called on function or with value arg that is a function'
                );
              (this.value = e),
                (this.uValue = this.value / this.unitMultiplier),
                (this.isExpressionDirty = !0),
                (this.fnExpression = n),
                (this.parsedInfix = n),
                this.sQuery().invalidateGeom(this);
            },
            prepareToSerialize: function() {
              this.isExpressionDirty &&
                this.setParameterValue(this.uValue, this.unit);
            },
            setEditedValue: function(e) {
              var t,
                i,
                r = e.trim(),
                s = !1,
                a = s ? this.sQuery().prefs().units : n,
                c = '' === e,
                l = !1,
                u = this.sQuery.sketch;
              try {
                (i = o.mfs.getParsedInfixAndFunction(r)),
                  (t = i.func && i.func([], a)),
                  (l = o.math.isFiniteScalar(t));
              } catch (e) {}
              (l || c) &&
                (r !== this.expression &&
                  u.document.raiseSketchEvent(u.getPageId(), this.id, 'edit'),
                this.setParameterValue(r),
                (this.blank = c)),
                this.sQuery().invalidateGeom(this);
            },
            setParameterValue: function(e, i) {
              var r = this.fnExpression,
                s = this.expression,
                a = this.parsedInfix,
                c = i || this.unit;
              isNaN(e) && (e = ''),
                (this.expression = String(e)),
                c &&
                  (t.isNumeric(this.expression)
                    ? (this.expression += c)
                    : '' !== this.expression &&
                      (this.expression = '(' + this.expression + ')*1' + c)),
                (this.parsedInfix = n);
              try {
                this.fnExpression = this.makeFnFromInfixExpression();
              } catch (e) {
                (e.message =
                  "In expression: '" + this.expression + "': " + e.message),
                  o.signalCaughtError(e),
                  (this.fnExpression = r),
                  (this.expression = s),
                  (this.parsedInfix = a);
              }
              var l = this.sQuery().prefs().units;
              (this.uValue = this.fnExpression([], l)),
                (this.value = this.uValue * this.unitMultiplier),
                (this.isExpressionDirty = !1),
                this.sQuery().invalidateGeom(this);
            },
            getLegalMatchForParam: function(e) {
              function t(e) {
                var s;
                if (e.isOfKind('Measure')) {
                  if (e.matchesAssumedSpec(r))
                    return (i = e), n && i !== n ? !1 : (n = i);
                } else {
                  if ('Pegged' === e.constraint && 2 === e.parentsList.length)
                    return t(e.parents.text);
                  if ('CompositeText' === e.constraint) {
                    for (var o = 0; o < e.parentsList.length; o++)
                      if (
                        ((s = e.parentsList[o]),
                        (i = r.getLegalMatchForParam(s)))
                      ) {
                        if (n && i !== n) return !1;
                        n = i;
                      }
                    return n;
                  }
                }
                return !1;
              }
              var n,
                i,
                r = this;
              return this.genus.match(/Parameter/)
                ? e.isOfKind('Measure') && e.matchesAssumedSpec(this)
                  ? e
                  : 'Text' === e.kind
                  ? t(e)
                  : void 0
                : !1;
            },
            getColorableComponent: function() {
              return 'TextGObject_BackgroundContrast';
            },
            verificationString: function e(t, n) {
              var i = (e.base || arguments.callee.base).call(this, t, n);
              if (this.blank || /^isDefined\(/.test(this.expression))
                return 'NO_VERIFICATION';
              if (t.exists && this.state.exists && this.isFunction()) {
                var r = this.uValue(0),
                  s = this.uValue(1);
                o.math.expect(r, t.zeroValue) ||
                  (i +=
                    'Function zero value: <span class="error">' +
                    r +
                    '</span>(<span class="expected">' +
                    t.zeroValue +
                    '</span>)'),
                  o.math.expect(s, t.oneValue) ||
                    (i +=
                      'Function one value: <span class="error">' +
                      s +
                      '</span>(<span class="expected">' +
                      t.oneValue +
                      '</span>)');
              }
              return i;
            },
          };
        })()
      )),
      (o.gObjects.AngleMarker = o.makeClass(
        o.gObjects.Arc,
        (function() {
          var e = 0.001,
            i = 0.7071067811865475,
            r = 4;
          return {
            doc: {
              description:
                'Marks the span of an angle. In geometry, angle markers are used to assert congruency relationships.',
              inherits: 'Arc',
              refspec: { gspKindRef: 'AngleMarkerKind' },
              properties: {
                style: {
                  properties: {
                    'inner-radius': {
                      description:
                        'The arc radius contained within the angle marker, in pixels',
                      type: 'Number',
                    },
                    opacity: {
                      description: '0 (transparent) to 1 (fully opaque)',
                      type: 'Number',
                    },
                    'radial-spacing': {
                      description:
                        'The separation between arc strokes in an angle marker, in pixels',
                      type: 'Number',
                    },
                    'show-angle-direction': {
                      description: 'Whether to show a direction arrow.',
                      type: 'Boolean',
                    },
                    strokes: {
                      description:
                        'The number of strokes to draw for the marker.',
                      type: 'Number',
                    },
                  },
                },
              },
            },
            kind: 'AngleMarker',
            hasLabel: !0,
            geom: {},
            invertArrowhead: !1,
            style: {
              'show-angle-direction': !1,
              'inner-radius': 24,
              opacity: 0.25,
              'radial-spacing': 3,
              strokes: 1,
            },
            initLabelOffset: function(e) {
              var t = this.style.label;
              (t.labelOffsetX = -e.width / 2), (t.labelOffsetY = -e.height / 2);
            },
            mapPositionToLabelPathParam: function(e) {
              var t = this.getLabelPath(),
                n = o.GeometricPoint.mapPointToLine(t.oA, t.oB, e, {
                  clampP0: !0,
                  clampP1: !0,
                });
              return n.param;
            },
            getLabelPath: function() {
              var e,
                t,
                n,
                i = this.geom.arc,
                r = i.initialAngle + 0.5 * Math.abs(i.arcAngle),
                s = Math.cos(r),
                a = Math.sin(r),
                c = this.getParent('p1').geom.loc;
              return (
                (e = 1.3 * i.radius),
                (t = o.GeometricPoint(c.x - e * s, c.y - e * a)),
                (e = 1.8 * this.outerRadius()),
                (n = o.GeometricPoint(c.x + e * s, c.y + e * a)),
                { oA: t, oB: n }
              );
            },
            constrainLabel: function() {
              var e,
                t,
                i = 0.9;
              this.state.exists &&
                this.geom.arc &&
                (this.userSetLabelPathParam !== n &&
                  (i = this.userSetLabelPathParam),
                (e = this.getLabelPath()),
                (t = o.GeometricPoint(
                  e.oA.x + i * (e.oB.x - e.oA.x),
                  e.oA.y + i * (e.oB.y - e.oA.y)
                )),
                (t.x = Math.round(t.x)),
                (t.y = Math.round(t.y)),
                (this.labelSpec.location = t));
            },
            getAngleMarkerMFS: function(e, t) {
              var n,
                i = this.getParent('p0'),
                r = this.getParent('p1'),
                s = this.getParent('p2');
              return (
                i.label || i.getLabel(e),
                r.label || r.getLabel(e),
                s.label || s.getLabel(e),
                (n = [i.getNameMFS(), r.getNameMFS(), s.getNameMFS()]),
                o.mfs.makeHorizontalNamesMFS(
                  n,
                  t ? { type: 'symbol', value: 'd0' } : null
                )
              );
            },
            getNameMFSForLabel: function(e) {
              return this.getAngleMarkerMFS(e, !1);
            },
            getColorableComponent: function() {
              return 'AngleMarker';
            },
            renderPrepare: function(e, t) {
              return (
                (t = {
                  kind: this.kind,
                  id: this.id,
                  strokes: this.style.strokes,
                }),
                e.prepareAngleMarker(t)
              );
            },
            renderCleanup: function(e, t) {
              return e.cleanupAngleMarker(t);
            },
            render: function(t, n, i) {
              var r,
                s,
                a = this.getParent('p0'),
                c = this.getParent('p1'),
                l = this.getParent('p2'),
                u = a.geom.loc,
                d = c.geom.loc,
                h = l.geom.loc,
                p = o.Geom.ThreePointCollinear(u, d, h).orientation,
                f = this.geom.arc;
              f &&
                ((r = f.arcAngle <= Math.PI ? 0 > p : p >= 0),
                (s = {
                  color: this.style.color,
                  firstArc: f,
                  isRight: Math.abs(f.arcAngle - Math.PI / 2) < e,
                  opacity: this.style.opacity,
                  fadeOpacity: this.calculateFadeOpacity(),
                  radialSpacing: this.style['radial-spacing'],
                  renderable: this.isRenderable(),
                  'show-angle-direction': this.style['show-angle-direction'],
                  invertArrowhead: this.invertArrowhead,
                  strokes: this.style.strokes,
                  width: this.style.width,
                  swap: r,
                }),
                this.modifyRenderAttrsForCurrentState(s),
                t.drawAngleMarker(n, s),
                this.updateKindHTMLStyle());
            },
            outerRadius: function() {
              var t = this.geom.arc,
                n = this.style['radial-spacing'],
                r = this.style.strokes,
                s = this.style.width,
                o = Math.abs(t.arcAngle - Math.PI / 2) < e,
                a = o ? i : 1;
              return t.radius * a + (r - 1) * (n + s);
            },
            getGeomBounds: function() {
              if (this.state.exists && this.geom.arc) {
                var i,
                  s,
                  a,
                  c,
                  l = this.geom.arc,
                  u = this.style.width,
                  d = Math.abs(l.arcAngle - Math.PI / 2) < e,
                  h = this.outerRadius(),
                  p = [];
                return (
                  this.style['show-angle-direction'] && (u += r),
                  d
                    ? (p.push(l.center),
                      (i = l.initialPoint
                        .subtract(l.center)
                        .unit()
                        .multiply(h)),
                      p.push(l.center.add(i)),
                      p.push(l.center.add(new o.GeometricPoint(-i.y, i.x))),
                      p.push(p[2].add(i)),
                      (c = {}),
                      t.each(p, function(e, t) {
                        (c.left === n || c.left > t.x) && (c.left = t.x),
                          (c.top === n || c.top > t.y) && (c.top = t.y),
                          (c.right === n || c.right < t.x) && (c.right = t.x),
                          (c.bottom === n || c.bottom < t.y) &&
                            (c.bottom = t.y);
                      }),
                      (c = o.Geom.insetRect(c, -u)))
                    : ((i = l.initialPoint
                        .subtract(l.center)
                        .unit()
                        .multiply(h)
                        .add(l.center)),
                      (s = l.finalPoint
                        .subtract(l.center)
                        .unit()
                        .multiply(h)
                        .add(l.center)),
                      (a = o.GeometricArc.FromCenterAndEndpoints(
                        l.center,
                        i,
                        s
                      )),
                      (c = this.getArcBounds(a, u)),
                      (c = o.Geom.unionRectPoint(c, this.geom.arc.center))),
                  c
                );
              }
            },
            hitTest: function(t, n) {
              function r() {
                var e = o.GeometricArc.FromCenterAndEndpoints(
                  f.geom.arc.center,
                  c,
                  l,
                  1
                );
                return o.Geom.RectIntersectsCurve(t, {
                  type: 'arcSector',
                  curve: e,
                });
              }
              function s() {
                return o.Geom.ParallelogramSectsRect(
                  t,
                  c,
                  f.geom.arc.center,
                  l
                );
              }
              var a,
                c,
                l,
                u,
                d,
                h,
                p,
                f = this;
              return this.geom.arc
                ? ((u = Math.abs(this.geom.arc.arcAngle - Math.PI / 2) < e),
                  (d = u ? i : 1),
                  (a =
                    this.geom.arc.radius * d +
                    (this.style['radial-spacing'] + this.style.width) *
                      (this.style.strokes - 1)),
                  (h = o
                    .GeometricPoint(
                      Math.cos(this.geom.arc.initialAngle),
                      Math.sin(this.geom.arc.initialAngle)
                    )
                    .multiply(a)),
                  (p = o
                    .GeometricPoint(
                      Math.cos(this.geom.arc.finalAngle),
                      Math.sin(this.geom.arc.finalAngle)
                    )
                    .multiply(a)),
                  (c = h.add(this.geom.arc.center)),
                  (l = p.add(this.geom.arc.center)),
                  u ? s() : r())
                : !1;
            },
            verificationString: function e(t, n) {
              var i = (e.base || arguments.callee.base).call(this, t, n);
              return (
                t.exists &&
                  this.state.exists &&
                  (o.math.expect(this.value, t.value) ||
                    (i +=
                      'value: <span class="error">' +
                      this.value +
                      '</span>(<span class="expected">' +
                      t.value +
                      '</span>)')),
                i
              );
            },
          };
        })()
      )),
      (o.gObjects.PathMarker = o.makeClass([o.gObjects.Kind, o.Genus], {
        doc: {
          description: 'A location in the Euclidean plane.',
          inherits: 'Kind',
          refspec: { gspKindRef: 'PathMarkerKind' },
          usage: {},
          properties: {
            style: {
              description: '',
              properties: {
                color: {
                  description: 'Foreground color of the path marker.',
                  type: 'Color',
                },
                'tick-mark-style': {
                  description: 'type of tick marks',
                  type: 'TickMarkStyle',
                },
                'arrow-direction': {
                  description:
                    'The direction of the arrows of the path marker.',
                  type: 'ArrowDirection',
                },
                width: {
                  description: 'Width of the strokes in pixels',
                  type: 'Number',
                },
                strokes: {
                  description: 'The number of strokes to draw for the marker.',
                  type: 'Number',
                },
              },
            },
          },
        },
        kind: 'PathMarker',
        style: {
          hidden: !1,
          label: { showLabel: !1 },
          selectable: !0,
          traced: !1,
          width: 3,
          'tick-mark-style': 'Crossbar',
          strokes: 1,
          'arrow-direction': 'Forward',
        },
        state: {},
        renderPrepare: function(e, t) {
          return (t.kind = this.kind), (t.id = this.id), e.preparePathMarker(t);
        },
        renderCleanup: function(e, t) {
          return e.cleanupPathMarker(t);
        },
        render: function(e, t, n) {
          var i,
            r,
            s,
            o = this.calculateOpacity(),
            a = this.style;
          'invisible' !== this.state.renderState &&
            this.state.exists !== !1 &&
            ((r = a.color),
            (i = this.isRenderable()),
            (s = {
              renderable: i,
              metrics: this.state.renderMetrics,
              color: r,
              width: a.width,
              opacity: o,
              strokes: a.strokes,
              'tick-mark-style': a['tick-mark-style'],
            }),
            this.modifyRenderAttrsForCurrentState(s),
            e.drawPathMarker(t, s),
            this.updateKindHTMLStyle());
        },
        calculateRenderMetrics: function() {
          function e() {
            var e,
              n,
              i,
              r,
              s,
              o = t;
            p && 'Backward' === y && (o = t.multiply(-1)),
              (e = b.mapPathValueToPosition(1).add(o)),
              (n = b.mapPathValueToPosition(0).subtract(o)),
              b.isOfKind('Straight')
                ? ((i = b.mapPositionToExtendedPathValue(e)),
                  (r = b.mapPositionToExtendedPathValue(n)),
                  (s = b.mapPositionToExtendedPathValue(v)))
                : ((i = b.mapPositionToPathValue(e)),
                  (r = b.mapPositionToPathValue(n)),
                  (s = b.mapPositionToPathValue(v))),
              r > s && (s = r),
              s > i && !b.isOfGenus('Ray') && (s = i),
              r > i && (s = (i + r) / 2),
              (l.origin = b.mapPathValueToPosition(s).subtract(t));
          }
          var t,
            n,
            i,
            r,
            s,
            a,
            c,
            l = {},
            u = this.geom.normal,
            d = this.style['tick-mark-style'],
            h = this.style.strokes,
            p = 'Crossbar' !== d,
            f = 6 + 1.5 * this.style.width,
            m = f,
            g = h - 1,
            b = this.parents.path,
            v = this.geom.loc,
            y = this.style['arrow-direction'];
          switch (d) {
            case 'Crossbar':
              (m *= 0.5), (f *= 0.75);
              break;
            case 'OpenArrow':
              (m *= 0.75), g++;
              break;
            case 'HollowArrow':
            case 'SolidArrow':
              (m *= 1), g++;
          }
          return (
            (c = h * m),
            (l.delta = o.GeometricPoint(-m * u.y, m * u.x)),
            (l.normal = u.multiply(f)),
            (l.len = o.GeometricPoint(-c * u.y, c * u.x)),
            (l.diagonal = l.normal.add(l.len)),
            (t = l.delta.multiply(0.5 * g)),
            b.isOfGenus('Segment') ||
            b.isOfGenus('Ray') ||
            b.isOfGenus('SimpleArc')
              ? e()
              : (l.origin = v.subtract(t)),
            (n = l.origin),
            p || (n = n.subtract(l.delta.multiply(1.5))),
            (i = n.add(l.normal)),
            (r = n.subtract(l.normal)),
            (n = l.origin.add(l.len)),
            (n = n.add(l.delta.multiply(0.5))),
            (s = n.add(l.normal)),
            (a = n.subtract(l.normal)),
            (l.boundingQuad = { A: i, B: r, C: a, D: s }),
            (l.boundingRect = o.Geom.boundingRect(i, r, s, a)),
            l
          );
        },
        getGeomBounds: function() {
          var e,
            t = this.style.width / 2;
          return (
            this.state.exists &&
              (e = o.Geom.insetRect(this.state.renderMetrics.boundingRect, -t)),
            e
          );
        },
        hitTest: function(e, t) {
          var n = this.state.renderMetrics.boundingQuad;
          return o.Geom.ParallelogramSectsRect(e, n.A, n.B, n.C);
        },
        verificationString: function e(t, n) {
          var i,
            r = (e.base || arguments.callee.base).call(this, t, n);
          return (
            '' === r &&
              this.state.exists &&
              ((i = o.GeometricPoint(t.loc.x, t.loc.y)),
              o.GeometricPoint.expect(i, this.geom.loc) ||
                (r +=
                  'loc: <span class="error">' +
                  this.geom.loc +
                  '</span>(<span class="expected">' +
                  i +
                  '</span>)')),
            r
          );
        },
      })),
      (o.gConstraints.Constraint = {
        doc: {
          description: 'The parent class for all constraints.',
          refspec: {},
          usage: { abstract: !0 },
          supported: !0,
          properties: {},
        },
        constraintSupportsSpecObj: function() {
          return !0;
        },
        initConstraint: function() {},
        updateConstraintAncestry: function() {},
        supportsAutoplacement: function() {
          return n !== this.autoplacementType;
        },
        updateLabelForConstraint: function() {},
        constrain: function() {
          throw ((this.state.exists = !1),
          o.createError('Unimplemented method'));
        },
        getParentalNameMFS: function(e) {
          return o.mfs.makeTextMFS('');
        },
        constraintVerificationString: function(e) {
          return '';
        },
      }),
      (o.gConstraints.Unknown = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Placeholder for an unrecognized constraint.',
          inherits: 'Constraint',
          refspec: {
            msg: 'An artifact of convenience of the application design.',
          },
          usage: { abstract: !0 },
          properties: {},
        },
        constraint: 'Unknown',
        constrain: function() {
          (this.state.exists = !1), (this.state.supported = !1);
        },
      })),
      (o.gConstraints.Free = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'An object with a free constraint can be dragged anywhere in the sketch space and is not bound by any dependencies that affect its geometry.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'Free_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Free_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Point', 'Expression', 'Text'] },
          existenceRule: 'Exists iff the coordinates of its location exist.',
          properties: {
            geom: {
              description: 'The basic geometry of the GObject',
              properties: {
                loc: {
                  description: 'The position of the GObject',
                  properties: {
                    x: {
                      description:
                        'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                    y: {
                      description:
                        'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                  },
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Free_export.json',
        },
        constrain: function() {
          this.state.exists = this.geom.loc && this.geom.loc.isDefined();
        },
      })),
      (o.gConstraints.PictureFree = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'A free picture can be dragged anywhere in the sketch space and is not bound by any dependencies that affect its geometry.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'Free_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Free_C, when applied to Pictures in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Picture'] },
          existenceRule: 'Exists iff its image exists.',
          properties: {
            geom: {
              description: 'The basic geometry of the GObject',
              properties: {
                transform: {
                  description:
                    'Affine transform of picture from its original (0,0)x(width,height) position.',
                  type: 'AffineTransform',
                  properties: {
                    m00: { description: 'm00', type: 'Number' },
                    m01: { description: 'm01', type: 'Number' },
                    m10: { description: 'm10', type: 'Number' },
                    m11: { description: 'm11', type: 'Number' },
                    m20: { description: 'm20', type: 'Number' },
                    m21: { description: 'm21', type: 'Number' },
                  },
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Picture-Misc_export.json',
        },
        constrain: function() {
          this.state.exists = !0;
        },
      })),
      (o.gConstraints.PictureNonFree = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Abstract base class for picture constraints.',
          inherits: 'Constraint',
          refspec: {
            msg:
              "This class is an internal object and doesn't have an independent source of requirements.",
          },
          usage: { abstract: !0, kinds: ['Picture'] },
        },
      })),
      (o.gConstraints.DriveChain = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'A virtual base class for constraints that have drive-chains',
          inherits: 'Constraint',
          refspec: {},
          usage: { abstract: !0 },
          properties: {
            parents: {
              description: '',
              type: 'Object',
              properties: {
                driverObject: {
                  description: 'The object which originates the drive-chain',
                  kind: 'Point|Expression',
                },
                drivenObject: {
                  description:
                    'The object being driven whose location use used in the constraint',
                  kind:
                    'Point|Expression|Text|Arc|Circle|Picture|Polygon|Straight|ArcInterior|CircleInterior',
                },
              },
              regex: /^[0-9]+$/,
            },
          },
        },
        clonedDriverGObj: n,
        clonedSampleGObj: n,
        sampleGObj: function() {
          return this.parents.drivenObject;
        },
        updateConstraintAncestry: function() {
          var e,
            t,
            n = this.sQuery.sketch,
            i = [],
            r = 0,
            s = this.getParent('driverObject'),
            o = this.getParent('drivenObject').id;
          for (
            i.push(this.getParent('driverObject'));
            this.parents.hasOwnProperty(r);

          )
            i.push(this.getParent(r)), r++;
          for (
            i.sort(function(e, t) {
              return Number(e.topologicalIndex) - Number(t.topologicalIndex);
            }),
              e = n.cloneGObjects(i),
              r = 0;
            r < e.length;
            r++
          )
            if (e[r].id === s.id) {
              (this.clonedDriverGObj = e[r]), e.splice(r, 1);
              break;
            }
          for (r = 0; r < e.length; r++)
            if (e[r].id === o) {
              (t = e[r]), (this.driveChain = e), (this.clonedSampleGObj = t);
              break;
            }
          this.clonedDriverGObj.state.exists = !0;
        },
      })),
      (o.gConstraints.Locus = o.makeClass(o.gConstraints.DriveChain, {
        doc: {
          description: 'A virtual base class for locus subclasses',
          inherits: 'DriveChain',
          refspec: {},
          usage: { abstract: !0 },
          existenceRule: 'Exists if any samples exist',
        },
        constraintSupportsSpecObj: function(e, t) {
          var n = this.doc.properties.parents.properties.drivenObject.kind,
            i = t[e.parents.drivenObject].kind;
          return null === n.match(i) ? !1 : !0;
        },
        updateConstraintAncestry: function e() {
          (e.base || arguments.callee.base).call(this),
            (this.vectorContext = this.clonedSampleGObj.createVectorContext(
              this.numSamples,
              this,
              this.clonedSampleGObj.constraintChangesColor
            )),
            (this.lastSampleCount = this.numSamples);
        },
        prepareDriverWalkInfo: function() {
          o.signalErrorWithMessage(
            'Locus subclasses must implement prepareDriverWalkInfo'
          );
        },
        advanceDriver: function(e, t, n) {
          o.signalErrorWithMessage(
            'Locus subclasses must implement advanceDriver'
          );
        },
        moveDriverForValue: function(e, t) {
          o.signalErrorWithMessage(
            'Locus subclasses must implement moveDriverForValue'
          );
        },
        constrain: function(e) {
          var t,
            n,
            i,
            r = this.driveChain,
            s = this.clonedSampleGObj,
            o = this.clonedDriverGObj,
            a = this.numSamples,
            c = this.lastSampleCount !== a;
          for (
            c &&
              ((this.vectorContext = s.createVectorContext(
                a,
                this,
                s.constraintChangesColor
              )),
              (this.lastSampleCount = a)),
              this.prepareDriverWalkInfo && (i = this.prepareDriverWalkInfo()),
              this.state.exists = !1,
              s.resetVectorSamples(this.vectorContext),
              n = 0,
              t = 0;
            a > t;
            t++
          )
            this.advanceDriver(o, i, t),
              e.constrainDriveChain(r),
              (s.state.exists || this.vectorContext.isContinuous) &&
                (s.fillSingleSample(this.vectorContext, n), n++),
              (this.state.exists = this.state.exists || s.state.exists);
          s.recomputeDiscontinuities &&
            s.recomputeDiscontinuities(this.vectorContext);
        },
        constrainSampleGObjToConvertedValue: function(e) {
          var t = this.driveChain,
            n = this.clonedSampleGObj,
            i = this.clonedDriverGObj;
          return (
            this.moveDriverForValue(i, e),
            this.sQuery.sketch.constrainDriveChain(t),
            n.state.exists ? n.geom.loc : o.GeometricPoint.UNDEFINED
          );
        },
        samplerPathValueToPosition: function(e, t) {
          var n,
            i = this.driverDomain.low,
            r = this.driverDomain.high,
            s = r - i,
            a = i + s * e,
            c = this;
          return (
            (n = this.constrainSampleGObjToConvertedValue(a)),
            t &&
              n.isDefined() &&
              (t.derivative = o.math.secantApproximationToDerivative(
                a,
                n,
                function(e) {
                  return r >= e && e >= i
                    ? c.constrainSampleGObjToConvertedValue(e)
                    : o.GeometricPoint.UNDEFINED;
                }
              )),
            n
          );
        },
        samplerPositionToPathValue: function(e) {
          return this.clonedSampleGObj.positionToPathValueForVector(
            this.vectorContext,
            e
          );
        },
        samplerPathLength: function() {
          return this.clonedSampleGObj.pathLengthForVector(this.vectorContext);
        },
      })),
      (o.gConstraints.GeomLocus = o.makeClass(o.gConstraints.Locus, {
        doc: {
          description:
            'A Geometric Locus of an object as a parent driver moves along a path.',
          inherits: 'Locus',
          refspec: { gspRef: 'GeomLocus_C' },
          usage: { abstract: !1, kinds: ['Sampler'] },
          supported: !0,
          properties: {
            parents: {
              properties: {
                domainObject: {
                  description: 'The drive path the driver travels along',
                  genus: 'Path',
                },
              },
            },
          },
        },
        updateConstraintAncestry: function e() {
          var t = this.getParent('domainObject');
          (this.closedPath = t.closedPath),
            (e.base || arguments.callee.base).call(this);
        },
        checkParentsExist: function() {
          return (
            (this.state.exists = this.namedParentExists('domainObject')),
            this.state.exists
          );
        },
        prepareDriverWalkInfo: function() {
          var e,
            t,
            n,
            i = this.numSamples,
            r = o.createFloatVector(i),
            s = this.getParent('domainObject'),
            a = this.driverDomain,
            c = a.low;
          for (
            n = s.closedPath ? (a.high - c) / i : (a.high - c) / (i - 1), t = 0;
            i > t;
            t++
          )
            r[t] = c + t * n;
          return (
            s.closedPath || (r[i - 1] = a.high),
            (e = s.mapVectorPathValuesToPositions(r))
          );
        },
        advanceDriver: function(e, t, n) {
          (e.geom.loc = t[n]), (e.state.exists = !0);
        },
        moveDriverForValue: function(e, t) {
          var n = this.getParent('domainObject');
          n.closedPath && (t %= 1),
            (e.geom.loc = n.mapPathValueToPosition(t)),
            (e.state.exists = !0);
        },
        canEditLabel: function() {
          return !1;
        },
      })),
      (o.gConstraints.CustomTransformedPoint = o.makeClass(
        o.gConstraints.DriveChain,
        {
          doc: {
            description: 'The image of a point by a custom trasform.',
            inherits: 'DriveChain',
            refspec: { gspRef: 'CustomTransformedPoint_C' },
            usage: { abstract: !1, kinds: ['Point'] },
            properties: {
              parents: {
                properties: {
                  domainObject: {
                    description: 'The point pre-image',
                    genus: 'Point',
                  },
                },
              },
            },
          },
          constrain: function(e) {
            var t = this.driveChain,
              n = this.clonedSampleGObj,
              i = this.clonedDriverGObj,
              r = this.getParent('domainObject');
            (i.geom.loc = r.geom.loc.copy()),
              e.constrainDriveChain(t),
              (this.geom.loc = n.geom.loc.copy()),
              (this.state.exists = n.state.exists);
          },
        }
      )),
      (o.gConstraints.CustomTransformedPath = o.makeClass(
        o.gConstraints.GeomLocus,
        {
          doc: {
            description:
              'A Geometric Locus of an object as a parent driver of the custom trasform moves along a path.',
            inherits: 'GeomLocus',
            refspec: { gspRef: 'CustomTransformedPath_C' },
          },
        }
      )),
      (o.gConstraints.ParametricLocus = o.makeClass(o.gConstraints.Locus, {
        doc: {
          description:
            'A Parametric Locus of an object as a driver parameter moves through a range of values.',
          inherits: 'Locus',
          refspec: { gspRef: 'ParametricLocus_C' },
          usage: { abstract: !1, kinds: ['Sampler'] },
          supported: !0,
          properties: {
            parents: {
              properties: {
                drivenObject: {
                  description:
                    'The object whose position changes as the driver moves along the path',
                },
                driverObject: {
                  description: 'The point to drive along the path',
                  kind: 'Expression',
                },
              },
            },
          },
        },
        checkParentsExist: function() {
          return (
            (this.state.exists = this.namedParentExists('driverObject')),
            this.state.exists
          );
        },
        prepareDriverWalkInfo: function() {
          var e,
            t = this.numSamples,
            n = o.createFloatVector(t),
            i = this.driverDomain,
            r = i.low,
            s = (i.high - r) / (t - 1);
          for (e = 0; t > e; e++) n[e] = r + e * s;
          return n;
        },
        advanceDriver: function(e, t, n) {
          e.updateValue(t[n]);
        },
        moveDriverForValue: function(e, t) {
          e.updateValue(t);
        },
        samplerPathValueToPosition: function e(t, n) {
          var i = this.driverDomain.high - this.driverDomain.low,
            r = i ? (t - this.driverDomain.low) / i : 0;
          return (e.base || arguments.callee.base).call(this, r, n);
        },
        samplerPositionToPathValue: function e(t) {
          var n = (e.base || arguments.callee.base).call(this, t),
            i = this.driverDomain.high - this.driverDomain.low;
          return this.driverDomain.low + n * i;
        },
        samplerConstrainRange: function(e) {
          var t = e,
            n = this.driverDomain.low,
            i = this.driverDomain.high;
          return e > i && (t = i), n > e && (t = n), t;
        },
        samplerIsValueInBounds: function(e) {
          return e >= this.driverDomain.low && e <= this.driverDomain.high;
        },
      })),
      (o.gConstraints.IterateMap = o.makeClass(
        o.gConstraints.Constraint,
        (function() {
          function e(e, n) {
            var i;
            return (
              t.each(e, function(e, t) {
                return t.id === n ? ((i = t), !1) : void 0;
              }),
              i
            );
          }
          function i(n, i) {
            var r = [];
            return (
              t.each(i, function(t, i) {
                r.push(e(n, i));
              }),
              r
            );
          }
          function r(e) {
            return {
              map: /map(\d+)/.exec(e)[1],
              image: /image(\d+)/.exec(e)[1],
            };
          }
          function s(e, n) {
            -1 === t.inArray(n, e) && e.push(n);
          }
          var o = /^preimage\d+$/,
            a = /^map\d+image\d+$/,
            c = /^\d+$/;
          return {
            doc: {
              description: 'Iteration Map.',
              inherits: 'Free',
              refspec: { gspRef: 'IterateMap_C' },
              usage: { abstract: !1, kinds: ['Map'] },
              properties: {
                parents: {
                  description: '',
                  type: 'Object',
                  properties: {
                    preimage0: {
                      description:
                        "The first preimage.  There can be an arbitrary number of preimages, with the form 'preimageX'",
                      kind: 'kind',
                    },
                    map0image0: {
                      description:
                        "The first postimage.  There can be an arbitrary number of post-images, with the form 'mapXimageY",
                      kind: 'kind',
                    },
                    0: {
                      description:
                        'The first object in the drive chain.  There may be many objects in the drivechain, numbered from 0 to N',
                      kind: 'kind',
                    },
                  },
                  regex: /^preimage[0-9]+$|^map[0-9]+image[0-9]+$|^[0-9]+$/,
                },
                currentDepth: {
                  description: 'The depth of the iteration',
                  required: !0,
                  type: 'Number',
                },
              },
            },
            imageArray: null,
            preImageClones: null,
            postImageMapArray: null,
            driveChain: null,
            randomValueCache: null,
            onPathPostImages: null,
            rerandomizeNow: !0,
            updateConstraintAncestry: function() {
              function e(e, t) {
                return Number(e.topologicalIndex) - Number(t.topologicalIndex);
              }
              var n,
                l = this.sQuery.sketch,
                u = [],
                d = this;
              (this.imageArray = []),
                (this.preImageClones = []),
                (this.postImageMapArray = []),
                (this.driveChain = []),
                this.rerandomizePointsOnPaths &&
                  ((this.randomValueCache = []), (this.onPathPostImages = [])),
                t.each(d.parents, function(e, t) {
                  var n, i;
                  if (o.test(e))
                    (n = e.match(/\d+/)[0]), (d.preImageClones[n] = t.id);
                  else if (a.test(e))
                    (i = r(e)),
                      d.postImageMapArray[i.map] ||
                        (d.postImageMapArray[i.map] = []),
                      (d.postImageMapArray[i.map][i.image] = t.id),
                      s(d.driveChain, t.id),
                      d.rerandomizePointsOnPaths &&
                        t.isFreePointOnPath &&
                        s(d.onPathPostImages, t.id);
                  else {
                    if (!c.test(e)) return;
                    s(d.driveChain, t.id);
                  }
                  s(u, t);
                }),
                u.sort(e),
                (n = l.cloneGObjects(u)),
                (d.preImageClones = i(n, d.preImageClones)),
                t.each(d.postImageMapArray, function(e, t) {
                  d.postImageMapArray[e] = i(n, d.postImageMapArray[e]);
                }),
                d.rerandomizePointsOnPaths &&
                  (d.onPathPostImages = i(n, d.onPathPostImages)),
                (d.driveChain = i(n, d.driveChain)),
                d.driveChain.sort(e),
                (d.numMaps = d.postImageMapArray.length);
            },
            registerImageAndGetClone: function(t) {
              var n = t.getParent('source');
              return this.imageArray.push(t), e(this.driveChain, n.id);
            },
            deregisterImage: function(e) {
              var n = t.inArray(e, this.imageArray);
              n >= 0 && this.imageArray.splice(n, 1);
            },
            checkParentsExist: function() {
              function e(e, t) {
                return !t.state || t.state.exists || c.test(e)
                  ? void 0
                  : ((n = !1), !1);
              }
              var n = !0;
              return t.each(this.parents, e), (this.state.exists = n), n;
            },
            constrain: function(e) {
              function i(e, t) {
                t.collectSample();
              }
              function s(e, t) {
                t.clearSamples();
              }
              function o(e, t) {
                (0 === p.currentDepth || t.clonedGObj.state.exists) &&
                  t.stampTerminalSample();
              }
              function c(e) {
                function n(e) {
                  return 'Point' === e.kind
                    ? { loc: e.geom.loc.copy(), exists: e.state.exists }
                    : { value: e.value, exists: e.state.exists };
                }
                var i,
                  r,
                  s = [];
                if (t.isArray(e)) {
                  for (r = e.length, i = 0; r > i; i++) s.push(n(e[i]));
                  return s;
                }
                return n(e);
              }
              function l(e, t) {
                var n,
                  i,
                  r = e.length;
                for (n = 0; r > n; n++)
                  (i = e[n]),
                    'Point' === i.kind
                      ? ((i.geom.loc = t[n].loc),
                        (i.state.exists = t[n].exists))
                      : (i.updateValue(t[n].value),
                        (i.state.exists = t[n].exists));
              }
              function u(e) {
                var t,
                  i,
                  r,
                  s,
                  o = e.onPathPostImages.length;
                for (t = 0; o > t; t++)
                  (i = e.onPathPostImages[t]),
                    e.randomValueCache[m] === n &&
                      ((r = i.getParent('path')),
                      (s = r.getAnimationRange()),
                      (e.randomValueCache[m] =
                        s.min + (s.max - s.min) * Math.random())),
                    i.updateValue(p.randomValueCache[m++]);
              }
              function d(n) {
                var s,
                  o = [];
                if (n === p.currentDepth)
                  t.each(p.parents, function(e, t) {
                    var n;
                    a.test(e) &&
                      ((n = r(e)),
                      o[n.map] || (o[n.map] = []),
                      (o[n.map][n.image] = c(t)));
                  });
                else for (s = 0; f > s; s++) o[s] = c(p.postImageMapArray[s]);
                for (s = 0; f > s; s++)
                  l(p.preImageClones, o[s]),
                    p.rerandomizePointsOnPaths && u(p),
                    e.constrainDriveChain(p.driveChain),
                    (h && 1 !== n) || t.each(p.imageArray, i),
                    n - 1 && d(n - 1);
              }
              var h = this.finalIterationOnly,
                p = this,
                f = this.numMaps,
                m = 0;
              this.rerandomizeNow && (this.randomValueCache = []),
                t.each(this.imageArray, s),
                this.currentDepth > 0 && d(this.currentDepth),
                t.each(p.imageArray, o),
                (this.rerandomizeNow = !1);
            },
          };
        })()
      )),
      (o.gConstraints.IterateMapByParametricDepth = o.makeClass(
        o.gConstraints.IterateMap,
        {
          doc: {
            description: 'Itereation Map by parametric depth.',
            inherits: 'IterateMap',
            refspec: { gspRef: 'IterateMapByParametricDepth_C' },
            usage: { abstract: !1, kinds: ['Map'] },
            properties: {
              parents: {
                description: '',
                type: 'Object',
                properties: {
                  depth: {
                    description:
                      'the depth to which the construction is iterated',
                    kind: 'Measure',
                  },
                },
              },
              currentDepth: { suppressed: !0 },
            },
          },
          constrain: function e(n) {
            var i = o.math.trunc(this.getParent('depth').uValue);
            0 > i && (i = 0),
              isFinite(i) || (i = null),
              i !== this.currentDepth &&
                ((this.currentDepth = i),
                (this.rerandomizeNow = !0),
                t.each(this.imageArray, function(e, t) {
                  t.sampleCountChanged();
                })),
              null !== this.currentDepth
                ? ((this.state.exists = !0),
                  (e.base || arguments.callee.base).call(this, n))
                : (this.state.exists = !1);
          },
          constraintVerificationString: function e(t) {
            var n = (e.base || arguments.callee.base).call(this);
            return (
              t &&
                (n += this.testConsistency(
                  'depth',
                  this.currentDepth,
                  t.depth
                )),
              n
            );
          },
        }
      )),
      (o.gConstraints.IterateImage = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: '',
          inherits: 'Constraint',
          refspec: { gspRef: 'IterateImage_C' },
          usage: { abstract: !1, kinds: ['IterateImage'] },
          existenceRule: '',
          properties: {
            parents: {
              description: '',
              type: 'Object',
              properties: {
                source: {
                  description: 'The preimage that is to be iterated',
                  kind:
                    'Point|Expression|Text|Arc|Circle|Picture|Polygon|Straight|ArcInterior|CircleInterior',
                },
                map: {
                  description: 'The iteration map defining the iteration',
                  kind: 'Map',
                },
              },
            },
          },
        },
        updateConstraintAncestry: function e() {
          (e.base || arguments.callee.base).call(this);
          var t = this.getParent('map'),
            n = t.registerImageAndGetClone(this);
          (this.clonedGObj = n), this.initializeSampleBuffer();
        },
        constrain: function() {
          this.state.exists = this.curSampleNum > 0;
        },
        checkParentsExist: function() {
          var e = this.state.exists;
          return (
            (this.state.exists = e && this.namedParentExists('map')),
            e && !this.state.exists && this.clearSamples(),
            this.state.exists
          );
        },
      })),
      (o.gConstraints.PointTerminalIteration = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description: 'The terminal point of an iterated image of points',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'TerminalIterationPoint_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Midpoint_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule: 'Exists if the parental image exists.',
            properties: {
              parents: {
                description: '',
                properties: {
                  image: { description: '', kind: 'IterateImage' },
                },
              },
            },
            example: '',
          },
          state: {},
          checkParentsExist: function() {
            var e = this.getParent('image');
            return (
              (this.state.exists = e && e.namedParentExists('map')),
              this.state.exists
            );
          },
          constrain: function() {
            var e = this.getParent('image'),
              t = e.getTerminalGeom();
            null === t
              ? ((this.state.exists = !1),
                (this.geom.loc = o.GeometricPoint.UNDEFINED))
              : ((this.geom = t), (this.state.exists = !0));
          },
        }
      )),
      (o.gConstraints.CompositeText = (function() {
        function e(e) {
          switch (e) {
            case 10:
              return 'byLabel';
            case 11:
              return 'byName';
            case 12:
              return 'byValue';
            case 13:
              return 'valueAsAddend';
            case 14:
              return 'expressionOnly';
            case 15:
              return 'independentVariable';
            case 16:
              return 'dependentVariable';
            case 17:
              return 'pictureIcon';
            default:
              return 'default';
          }
        }
        function n(t, n) {
          var r = parseInt(n, 16),
            s = (65535 & r) - 1,
            o = e((4294901760 & r) >> 16);
          return s + i + o;
        }
        var i = '-',
          r = new RegExp('\\d+' + i + '.*');
        return o.makeClass(o.gConstraints.Constraint, {
          doc: {
            description:
              'Defines a caption that has references to dynamically generated text from other objects.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'CompositeText_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, CompositeText_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Text'] },
            existenceRule: 'Exists iff parents exist.',
            properties: {
              parents: {
                description: 'Objects referenced in the caption',
                properties: {
                  0: {
                    description: 'Objects labeled "0", ..., "n"',
                    kind: 'kind',
                  },
                },
                regex: /^[0-9]+$/,
              },
            },
          },
          updateLabelForConstraint: function e(s) {
            function a(e) {
              var t = n(c, e.refCon);
              (e.visibleNode = 1),
                (e.value[0] = { type: 'parameter', value: t }),
                (c.parentMFSValues[t] = { type: 'text', value: 'unfilled' });
            }
            (e.base || arguments.callee.base).call(this);
            var c = this;
            (this.parentMFSValues = {}),
              o.mfs.walkNode(this.parsedMFS, 'switch', a),
              (c.state.exists = !0),
              t.each(c.parentMFSValues, function(e) {
                if (e.match(r)) {
                  var t = e.split(i),
                    n = t[0],
                    s = t[1],
                    o = c.parentsList[n],
                    a = !c.style.hidden,
                    l = { constrain: !0, show: a },
                    u = o.getStrippedMFSAppearanceForVariant(s, l);
                  if (null === u) return (c.state.exists = !1), !1;
                  (u.referenceId = o.id), (c.parentMFSValues[e] = u);
                }
              });
          },
          constrain: function() {
            this.updateLabelForConstraint();
          },
          checkParentsExist: function() {
            return !0;
          },
        });
      })()),
      (o.gConstraints.PictureAcrossThreePoints = o.makeClass(
        o.gConstraints.PictureNonFree,
        {
          doc: {
            description:
              'Defines a picture with upper left defined by a <span class="kind">Param</span>.',
            inherits: 'PictureNonFree',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent point exists.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: {
                    description:
                      'The location of the original bottom left of the picture',
                    kind: 'Point',
                  },
                  p1: {
                    description:
                      'The location of the original bottom right of the picture',
                    kind: 'Point',
                  },
                  p2: {
                    description:
                      'The location of the original top left of the picture',
                    kind: 'Point',
                  },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('p0').geom.loc,
              t = this.getParent('p1').geom.loc,
              n = this.getParent('p2').geom.loc,
              i = this.getImage(),
              r = o.AffineTransform.fromPointMapping(
                [
                  o.GeometricPoint(0, i.height),
                  o.GeometricPoint(i.width, i.height),
                  o.GeometricPoint(0, 0),
                ],
                [e, t, n]
              );
            r ? (this.geom.transform = r) : (this.state.exists = !1);
          },
        }
      )),
      (o.gConstraints.PictureBetweenTwoPoints = o.makeClass(
        o.gConstraints.PictureNonFree,
        {
          doc: {
            description:
              'Defines a picture with upper left defined by a <span class="kind">Param</span>.',
            inherits: 'PictureNonFree',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the parent points exist, and their rounded-to-integer coordinates differ in both x and y values.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: {
                    description:
                      'One corner of the rectangle in which the picture is presented',
                    kind: 'Point',
                  },
                  p1: {
                    description:
                      'The other corner of the rectangle in which the picture is presented',
                    kind: 'Point',
                  },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('p0').geom.loc.round(),
              t = this.getParent('p1').geom.loc.round(),
              n = t.subtract(e),
              i = this.getImage();
            (this.state.exists = 0 !== n.getX() && 0 !== n.getY()),
              this.state.exists &&
                (this.geom.transform = o.AffineTransform({
                  m20: n.getX() < 0 ? t.getX() : e.getX(),
                  m21: n.getY() < 0 ? t.getY() : e.getY(),
                  m00: Math.abs(n.getX()) / i.width,
                  m11: Math.abs(n.getY()) / i.height,
                }));
          },
        }
      )),
      (o.gConstraints.PictureCenteredOnOnePoint = o.makeClass(
        o.gConstraints.PictureNonFree,
        {
          doc: {
            description:
              'Defines a picture centered on a <span class="kind">Point</span>.',
            inherits: 'PictureNonFree',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent point exists.',
            properties: {
              parents: {
                description: '',
                properties: { p0: { description: '', kind: 'Point' } },
              },
              scaleX: {
                description: 'Horizontal scaling factor about center.',
                type: 'Number',
              },
              scaleY: {
                description: 'Vertical scaling factor about center.',
                type: 'Number',
              },
              angle: {
                description: 'Angle of rotation about center.',
                type: 'Number',
              },
            },
          },
          constrain: function() {
            var e = this.getParent('p0').geom.loc,
              t = this.scaleX,
              n = this.scaleY,
              i = this.angle,
              r = this.getImage();
            this.geom.transform = o.AffineTransform.Identity.translate(
              -r.width / 2,
              -r.height / 2
            )
              .scale(t, n)
              .rotate(i)
              .translate(e);
          },
        }
      )),
      (o.gConstraints.PictureCroppedByInterior = o.makeClass(
        o.gConstraints.PictureNonFree,
        {
          doc: {
            description:
              'Defines a picture cropped by an <span class="genus">Interior</span>.',
            inherits: 'PictureNonFree',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent point exists.',
            properties: {
              parents: {
                description: '',
                properties: {
                  source: {
                    description: 'Picture to be cropped',
                    kind: 'Picture',
                  },
                  cropInterior: {
                    description: 'Polygon to which picture will be cropped',
                    kind: 'Polygon',
                  },
                },
              },
            },
          },
          updateConstraintAncestry: function() {
            var e = this.getParent('cropInterior');
            this.geom.clipVertices = e.getVertices();
          },
          constrain: function() {
            function e() {
              var e,
                r = [],
                s = {
                  top: 0,
                  left: 0,
                  bottom: t.getImage().height,
                  right: t.getImage().width,
                },
                a = i.geom.transform.inverse();
              if (!a) return !1;
              for (e = 0; e < n.geom.points.length; e++)
                r.push(n.geom.points[e].copy());
              return a.transform(r), o.Geom.RectSectsPolygon(s, r);
            }
            var t = this.getParent('source'),
              n = this.getParent('cropInterior'),
              i = this;
            (this.geom.transform = t.geom.transform),
              (this.geom.clipVertices = n.getVertices()),
              (this.state.exists = e());
          },
        }
      )),
      (o.gConstraints.PictureHungOnOnePoint = o.makeClass(
        o.gConstraints.PictureNonFree,
        {
          doc: {
            description:
              'Defines a picture with upper left at a <span class="kind">Point</span>.',
            inherits: 'PictureNonFree',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent point exists.',
            properties: {
              parents: {
                description: '',
                properties: { p0: { description: '', kind: 'Point' } },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('p0').geom.loc;
            this.geom.transform = o.AffineTransform({
              m20: e.getX(),
              m21: e.getY(),
              m00: 1,
              m11: 1,
            });
          },
        }
      )),
      (o.gConstraints.PointOnPathBase = o.makeClass(o.gConstraints.Constraint, {
        value: 0.5,
        isFreePointOnPath: !0,
        constrain: function() {
          var e = this.getParent('path'),
            t = !1,
            n = o.GeometricPoint.UNDEFINED;
          e.isValueInBounds(this.value) &&
            ((n = e.mapPathValueToPosition(this.value)),
            n && n.isDefined() ? (t = !0) : (n = o.GeometricPoint.UNDEFINED)),
            (this.state.exists = t),
            (this.geom.loc = n);
        },
      })),
      (o.gConstraints.Straight = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'The base class for all straight constraints.',
          inherits: 'Constraint',
        },
        getStraightP0: function() {
          var e = this.getParent('p0');
          return e.geom.loc;
        },
        getStraightP1: function() {
          var e = this.getParent('p1');
          return e.geom.loc;
        },
        getOverBarType: function() {
          return this.overbarType;
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('p0').getNameMFS(e),
            n = this.getParent('p1').getNameMFS(e);
          return {
            type: 'overbar',
            variant: this.getOverBarType(),
            value: o.mfs.makeHorizontalNamesMFS([t, n]),
          };
        },
        canMergeTo: function(e) {
          var t = this.getParent('p0'),
            n = e.getParent('p0'),
            i = this.getParent('p1'),
            r = e.getParent('p1'),
            s = !1;
          return (
            t && n && i && r
              ? (s =
                  (t === n && i === r) ||
                  ('Ray' !== this.constraint && t === r && i === n))
              : o.signalErrorWithMessage(
                  'Straight canMergeTo() missing parents!'
                ),
            s &&
              t !== n &&
              e.children.forEach(function(e, t) {
                ('PointOnPath' === e.constraint ||
                  'PointOnPathPlotFixedValue' === e.constraint) &&
                  (e.value = 1 - e.value);
              }),
            s
          );
        },
      })),
      (o.gConstraints.Transform = o.makeClass(
        [o.gConstraints.Constraint, o.mixins.transformable],
        {
          doc: {
            description: 'The parent class for all transformations.',
            inherits: 'Constraint',
            refspec: {
              msg:
                "This class is an internal object and doesn't have an independent source of requirements.",
            },
            usage: {
              abstract: !0,
              kinds: [
                'Arc',
                'ArcInterior',
                'Circle',
                'CircleInterior',
                'Picture',
                'Point',
                'Polygon',
                'Straight',
              ],
            },
            properties: {
              parents: {
                description: '',
                properties: {
                  source: {
                    description: 'The source of the transformation',
                    kind: 'kind',
                    type: 'GObject',
                  },
                },
              },
            },
          },
          isTransformationConstraint: !0,
          determineExists: function() {
            return n;
          },
          getSourceGeom: function() {
            return this.getParent('source').geom;
          },
          constrain: function() {
            var e = this.getTransformer();
            e.transformGeom(this.getSourceGeom(), this.geom),
              (this.state.exists = this.determineExists());
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('source');
            return o.mfs.makeHorizontalMFS(
              t.getNameMFS(e),
              o.mfs.makeTextMFS("'")
            );
          },
          get3PtAngleText: function(e, t, n, i) {
            var r,
              s,
              o,
              a = this;
            switch (this.constraint) {
              case 'RotateAngleMarker':
                a = this.getParent('angle');
                break;
              case 'TranslateFixDistAngleMarker':
              case 'TranslateMeasureDistAngleMarker':
                a = this.getParent('marker');
            }
            return (
              (r = a.getVisibleParentLabel(e)),
              (s = a.getVisibleParentLabel(t, i)),
              (o = a.getVisibleParentLabel(n)),
              r && s && o ? '∠' + r + s + o : s ? '∠' + s : ''
            );
          },
          getAngleMarkerText: function(e, t) {
            var n = this.getParent(e),
              i = n.label;
            return (
              i ||
                ((i =
                  t && !n.style.hidden
                    ? this.getParentLabel(e, t)
                    : this.get3PtAngleText('p0', 'p1', 'p2', t)),
                !i && t && (i = this.getParentLabel(e, { show: !0 }))),
              i || (i = '1'),
              -1 === i.indexOf('∠') && (i = '∠' + i),
              i
            );
          },
          getFixedAngleText: function(e) {
            var t = this.sQuery.sketch.preferences,
              n = o.units.findUnit(t.units.angle),
              i = Math.pow(10, t.precision.angle),
              r = Math.round(-e * n.conversionFromBase * i) / i;
            return (0 > r ? '–' : '') + Math.abs(r) + n.symbol;
          },
          makeParentalLabel: function(e, t) {
            var n,
              i,
              r = '',
              s = "'";
            switch (
              (t.init &&
                this.style.label.showLabel &&
                this.style.nameOrigin === e &&
                (t.create = !0),
              (e = e || 'namedByPrime'))
            ) {
              case 'namedByFullFn':
              case 'namedByShortFn':
                (n = this.getParentLabel('source', t)),
                  this.makeFnLabelPrefix
                    ? ((r = this.makeFnLabelPrefix(e, t) + '('), (s = ')'))
                    : o.signalErrorWithMessage(
                        'makeFnLabelPrefix undefined for ' + this.constraint
                      );
                break;
              case 'namedFromLabel':
                return this.label;
              case 'namedByPrime':
                n = this.getParentLabel('source', t);
                break;
              default:
                return (
                  o.signalErrorWithMessage(
                    "makeParentalLabel doesn't recognize nameOrigin = " + e
                  ),
                  (this.style.nameOrigin = 'namedFromLabel'),
                  this.label
                );
            }
            return n && (i = r + n + s), i;
          },
          updateLabelForConstraint: function(e) {
            var t,
              n,
              i,
              r = this.getParent('source').label,
              s = this.style.nameOrigin;
            if (
              this.label ||
              (this.style.label && this.style.label.showLabel) ||
              (e && !e.init)
            ) {
              if (
                (e || s || (e.init = !0),
                this.baseGenera.includes('Path') &&
                  !e.init &&
                  this.constrainLabelForPath(),
                (e = e || { constrain: !0 }),
                s)
              )
                t = this.makeParentalLabel(s, e);
              else if (r) {
                for (
                  i = [
                    'namedByPrime',
                    'namedByShortFn',
                    'namedByFullFn',
                    'namedFromLabel',
                  ],
                    n = 0;
                  3 > n;
                  n++
                )
                  if (
                    ((t = this.makeParentalLabel(i[n], e)), t === this.label)
                  ) {
                    s = i[n];
                    break;
                  }
                3 === n &&
                  (this.shouldAutogenerateLabel
                    ? ((s = 'namedByPrime'), (t = this.makeParentalLabel(s, e)))
                    : ((s = 'namedFromLabel'), (t = this.label)));
              } else (s = 'namedFromLabel'), (t = this.label);
              t !== this.label &&
                (e.init ? (this.label = t) : this.setLabel(t, e)),
                'namedFromLabel' !== s && (this.shouldAutogenerateLabel = !0),
                (this.style.nameOrigin = s);
            }
          },
        }
      )),
      (o.gConstraints.Ray = o.makeClass(o.gConstraints.Straight, {
        doc: {
          description:
            'Defines a ray from two points. The first point, p0, is the base of the ray.',
          inherits: 'Straight',
          refspec: {
            gspRef: 'Ray_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Ray_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Straight'] },
          existenceRule:
            'Exists iff the parent points exist and are not coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: { description: 'The foot of the ray.', kind: 'Point' },
                p1: {
                  description: 'A point on the ray not incident with the foot.',
                  kind: 'Point',
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Ray_export.json',
        },
        overbarType: 3,
        getPointOnPath: function(e, t) {
          return this.getPointOnRay(e, t);
        },
        constrain: function() {
          var e, t, n, i, r, s;
          (e = this.getStraightP0()),
            (this.geom.p0 = e),
            (t = this.getStraightP1()),
            (this.geom.p1 = t),
            (n = t.subtract(e)),
            n.isZeroLength()
              ? ((this.geom.xp0 = o.GeometricPoint(0, 0)),
                (this.geom.xp1 = o.GeometricPoint(0, 0)))
              : ((i = n.vLength()),
                (r = 1e4 / i),
                (s = e.add(n.multiply(r))),
                (this.geom.xp0 = e),
                (this.geom.xp1 = s)),
            (this.state.exists = !n.isZeroLength());
        },
        canMergeTo: function(e) {
          return (
            'Ray' === e.constraint &&
            this.getParent('p0') === e.getParent('p0') &&
            this.getParent('p1') === e.getParent('p1')
          );
        },
      })),
      (o.gConstraints.AngleBisector = o.makeClass(o.gConstraints.Ray, {
        doc: {
          description:
            "Constrains a ray to bisect an angle. The ray's foot is the angle vertex.",
          usage: { abstract: !1, kinds: ['Straight'], genus: ['Ray'] },
          inherits: 'Ray',
          refspec: {
            gspRef: 'Bisector_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Bisector_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          properties: {
            parents: {
              properties: {
                A: { description: 'A point', kind: 'Point' },
                B: { description: 'A point', kind: 'Point' },
                C: { description: 'A point', kind: 'Point' },
                p0: { suppressed: !0 },
                p1: { suppressed: !0 },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-AngleBisector_export.json',
        },
        constrain: function() {
          var e,
            t,
            i,
            r,
            s,
            o = this.getParent('A').geom.loc,
            a = this.getParent('B').geom.loc,
            c = this.getParent('C').geom.loc;
          (this.geom.p0 = this.geom.p1 = this.geom.xp0 = this.geom.xp1 = n),
            o.equals(a) || a.equals(c)
              ? (this.state.exists = !1)
              : ((e = o.subtract(a)),
                (t = Math.sqrt(9e3 / e.dot(e))),
                (i = a.add(e.multiply(t))),
                (e = c.subtract(a)),
                (t = Math.sqrt(9e3 / e.dot(e))),
                (r = a.add(e.multiply(t))),
                (s = i.add(r).multiply(0.5)),
                (e = s.subtract(a)),
                Math.abs(e.x) > 0.01 || Math.abs(e.y) > 0.01
                  ? ((this.geom.p1 = s),
                    (this.geom.xp0 = this.geom.p0 = a),
                    (this.geom.xp1 = a.add(e.multiply(1e4))))
                  : (this.state.exists = !1));
        },
        getParentalNameMFS: function() {
          return o.mfs.makeTextMFS('AngleBisector ' + this.id);
        },
        canMergeTo: function(e) {
          var t = this.getParent('A'),
            n = e.getParent('A'),
            i = this.getParent('B'),
            r = e.getParent('B'),
            s = this.getParent('C'),
            o = e.getParent('C');
          return (
            'AngleBisector' === e.constraint &&
            i === r &&
            ((t === n && s === o) || (t === o && o === t))
          );
        },
      })),
      (o.gConstraints.ArcAroundPoint = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'Defines an arc centered about a point, counter-clockwise from the first selected bounding point to the second.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'ArcAroundPoint_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, ArcAroundPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Arc'] },
          existenceRule:
            'Exists iff parents exist, and parental points are not coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                center: {
                  description: 'Center of circle on which the arc is situated',
                  kind: 'Point',
                },
                p0: { description: 'First bounding point', kind: 'Point' },
                p1: { description: 'Second bounding point', kind: 'Point' },
              },
            },
          },
        },
        constrain: function() {
          var e = this.getParent('center').geom.loc,
            t = this.getParent('p0').geom.loc,
            n = this.getParent('p1').geom.loc;
          (this.geom.arc = o.GeometricArc.FromCenterAndEndpoints(e, t, n, -1)),
            (this.state.exists = this.geom.arc.exists);
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('p0'),
            n = this.getParent('p1');
          return (
            t.label || this.getParentLabel('p0', e),
            n.label || this.getParentLabel('p1', e),
            o.mfs.parentsHorizontalOverbar(this, ['p0', 'p1'])
          );
        },
      })),
      (o.gConstraints.Arc3Points = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Defines an arc from three points.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'Arc3Points_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Arc3Points_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Arc'] },
          existenceRule:
            'Exists iff parent points exist and are not pairwise coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: { description: 'Initial point', kind: 'Point' },
                p1: { description: 'Middle point', kind: 'Point' },
                p2: { description: 'Final point', kind: 'Point' },
              },
            },
          },
        },
        constrain: function() {
          var e = this.getParent('p0').geom.loc,
            t = this.getParent('p1').geom.loc,
            n = this.getParent('p2').geom.loc;
          (this.geom.arc = o.GeometricArc.FromThreePoints(e, t, n)),
            (this.state.exists = this.geom.arc.exists);
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('p0'),
            n = this.getParent('p1'),
            i = this.getParent('p2');
          return (
            t.label || t.getLabel(e),
            n.label || n.getLabel(e),
            i.label || i.getLabel(e),
            o.mfs.parentsHorizontalOverbar(this, ['p0', 'p1', 'p2'])
          );
        },
      })),
      (o.gConstraints.ArcInterior = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Base class for arc interiors: ArcSegment, ArcSector.',
          inherits: 'Constraint',
          usage: { abstract: !0, kinds: ['ArcInterior'] },
          existenceRule: 'Exists iff parents exist.',
          properties: {
            parents: {
              description: '',
              properties: { arc: { description: 'Defining arc', kind: 'Arc' } },
            },
          },
        },
        constrain: function() {
          var e = this.getParent('arc');
          (this.geom.arc = e.getGeometricArc()),
            (this.state.exists =
              e.state.exists && isFinite(this.geom.arc.radius));
        },
        getParentalNameMFS: function(e) {
          return this.getParent('arc').getNameMFS(e);
        },
      })),
      (o.gConstraints.ArcOnCircle = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'Defines an arc on circle, counter-clockwise from the first selected bounding point to the second.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'ArcOnCircle_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, ArcOnCircle_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Arc'] },
          existenceRule:
            'Exists iff parent points exist and are not coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                circle: {
                  description: 'Circle on which the arc is situated',
                  kind: 'Circle',
                },
                p0: { description: 'First bounding point', kind: 'Point' },
                p1: { description: 'Second bounding point', kind: 'Point' },
              },
            },
          },
        },
        constrain: function() {
          var e = this.getParent('circle').geom.c,
            t = this.getParent('p0').geom.loc,
            n = this.getParent('p1').geom.loc;
          (this.geom.arc = o.GeometricArc.FromCenterAndEndpoints(e, t, n, -1)),
            (this.state.exists = this.geom.arc.exists);
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('p0'),
            n = this.getParent('p1');
          return (
            t.label || this.getParentLabel('p0', e),
            n.label || this.getParentLabel('p1', e),
            o.mfs.parentsHorizontalOverbar(this, ['p0', 'p1'])
          );
        },
      })),
      (o.gConstraints.ActionButton = o.makeClass(o.gConstraints.Free, {
        doc: {
          description: 'The parent class of all action button constraints.',
          refspec: {},
          inherits: 'Free',
          usage: { abstract: !0, kinds: ['Button'] },
          existenceRule: 'Exists regardless of existence of parents.',
          properties: {
            messages: {
              description: 'First message is default button label',
              type: 'Array',
              required: !1,
            },
          },
        },
        constrain: function() {
          this.messages &&
            this.messages.length &&
            this.shouldAutogenerateLabel &&
            (this.label = this.messages[0]);
        },
        press: function(e, t) {
          o.log(
            'press() not implemented for this button; Constraint: ' +
              this.constraint
          );
        },
      })),
      (o.gConstraints.Calculation = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'A calculated expression',
          inherits: 'Constraint',
          refspec: { gspRef: 'CalculationM_C' },
          usage: { abstract: !1, kinds: ['Expression'] },
          existenceRule: 'Exists iff the parent points exist.',
          properties: {
            parents: {
              description:
                'An associative array of objects used in the expression.',
              type: 'Array',
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Expression-Calculation_export.json',
        },
        baseUnits: {
          angle: o.units.unitFamilies.angle.baseUnit,
          length: o.units.unitFamilies.length.baseUnit,
        },
        constrain: function() {
          this.parsedMFS || this.getNameMFS({ create: !0 }),
            (this.uValue = this.fnExpression(this.parentsList, this.fnUnits)),
            (this.blank =
              '' === this.expression ||
              (o.math.isDefined(this.uValue)
                ? !1
                : this.determineParentalBlank())),
            (this.value = this.uValue * this.unitMultiplier);
        },
      })),
      (o.gConstraints.CircleByRadius = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'Defines a circle from a center point and the length of a <span class="genus">Path</span>.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'CircleRadius_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, CircleRadius_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Circle'] },
          existenceRule:
            'Exists iff parent center point and path or measure exist and the length or the value is finite and positive.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: { description: 'The center point.', kind: 'Point' },
                radius: {
                  description:
                    'A parent whose length or value provides the radius.',
                  kind: 'Measure',
                  genus: 'Path',
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Circle-CircleByRadius_export.json',
        },
        constrain: function() {
          var e, t, n, i;
          (e = this.getParent('center')),
            e || (e = this.getParent('p0')),
            (t = e.geom.loc),
            (n = this.getParent('radius')),
            (i = n.pathLength ? n.pathLength() : n.value),
            (this.geom.c = t),
            (this.geom.r = i),
            (this.state.exists =
              this.geom.r > 0 && o.math.isFiniteScalar(this.geom.r));
        },
        canMergeTo: function(e) {
          var t = this.getParent('p0'),
            n = e.getParent('p0'),
            i = this.getParent('radius'),
            r = e.getParent('radius'),
            s = !1;
          return (
            t && n && i && r
              ? (s = t === n && i === r)
              : o.signalErrorWithMessage(
                  'Circle by center & radius canMergeTo() missing parents!'
                ),
            s
          );
        },
      })),
      (o.gConstraints.CircleFromTwoPoints = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'Defines a circle from a center point and a point on the circumference.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'Circle_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Circle_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Circle'] },
            existenceRule:
              'Exists iff parent points exist and are not coincident.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: {
                    description: 'The center of the circle',
                    kind: 'Point',
                  },
                  p1: { description: 'A point on the circle', kind: 'Point' },
                },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Circle-CircleFromTwoPoints_export.json',
          },
          constrain: function() {
            var e = this.getParent('p0').geom.loc,
              t = this.getParent('p1').geom.loc;
            (this.geom.c = e),
              (this.geom.r = t.subtract(e).vLength()),
              (this.state.exists = Boolean(this.geom.r));
          },
          getParentalNameMFS: function(e) {
            var t, n, i, r;
            return (
              (t = this.getParent('p0')),
              (n = this.getParent('p1')),
              t.label || t.getLabel(e),
              n.label || n.getLabel(e),
              (i = t.getNameMFS()),
              (r = n.getNameMFS()),
              o.mfs.makeHorizontalNamesMFS([i, r])
            );
          },
          canMergeTo: function(e) {
            var t = this.getParent('p0'),
              n = e.getParent('p0'),
              i = this.getParent('p1'),
              r = e.getParent('p1'),
              s = !1;
            return (
              t && n && i && r
                ? (s = t === n && i === r)
                : o.signalErrorWithMessage(
                    'Circle by two points canMergeTo() missing parents!'
                  ),
              s
            );
          },
          collapseDoubledParent: function(e) {
            var t = this.sQuery.sketch;
            this.children.forEach(function(n) {
              'PointOnPath' === n.constraint && t.mergeGobjToCandidate(n, e);
            }),
              t.gobjList.removeGObjAndDescendants(this);
          },
        }
      )),
      (o.gConstraints.CircleInterior = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Defines a circle interior from a circle.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'CircleInterior_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, CircleInterior_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['CircleInterior'] },
          existenceRule: 'Exists iff parents exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                circle: { description: 'The defining circle', kind: 'Circle' },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/CircleInterior-CircleInterior_export.json',
        },
        constrain: function() {
          var e = this.getParent('circle');
          (this.geom.c = e.geom.c), (this.geom.r = e.geom.r);
        },
        getParentalNameMFS: function(e) {
          return this.getParent('circle').getNameMFS(e);
        },
      })),
      (o.gConstraints.Colorize = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Defines a new GObject that is coincident to another GObject, but colored differently.',
          inherits: 'Transform',
          refspec: {
            gspRef: 'Colorization_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !0, subKinds: ['Picture'] },
          existenceRule: 'Exists iff the parent measures exist and are finite.',
          properties: {
            colorRange: {
              description:
                "Color Range: 'LimitToRange', 'WrapToRange', 'ReflectToRange'",
              type: 'String',
            },
            colorModel: {
              description:
                "Color model of parameters: 'UnivariateHue', 'UnivariateIntensity', 'TrivariateRGB', 'TrivariateHSV'",
              type: 'String',
            },
            parameterDomainFrom: {
              description: 'Lower bound of parameter domain.',
              type: 'Number',
            },
            parameterDomainTo: {
              description: 'Upper bound of parameter domain.',
              type: 'Number',
            },
            style: {
              type: 'Object',
              properties: { color: { suppressed: !0 } },
            },
          },
        },
        constraintChangesColor: !0,
        getTransform: function() {
          return function(e) {
            return e.copy();
          };
        },
        normalizeColorParameter: function(e) {
          var t, n;
          return (
            (n =
              (e - this.parameterDomainFrom) /
              (this.parameterDomainTo - this.parameterDomainFrom)),
            (t = Math.floor(n)),
            (n -= t),
            'LimitToRange' === this.colorRange &&
              (0 > t ? (n = 0) : t > 0 && (n = 1), (t = 0)),
            (t = Math.abs(t)),
            1 === t % 2 && 0 === n && (t--, (n = 1)),
            'ReflectToRange' === this.colorRange && 1 === t % 2 && (n = 1 - n),
            0 > n ? (n = 0) : n > 1 && (n = 1),
            n
          );
        },
        constrain: function e() {
          var t, n;
          (e.base || arguments.callee.base).call(this),
            (t = this.convertToColor()),
            t &&
              ((n = 'rgb('),
              (n += Math.floor(255 * t.red)),
              (n += ','),
              (n += Math.floor(255 * t.green)),
              (n += ','),
              (n += Math.floor(255 * t.blue)),
              (n += ')'),
              (this.style.color = n));
        },
        constraintVerificationString: function e(t) {
          var n = (e.base || arguments.callee.base).call(this);
          return (
            t &&
              t.color &&
              (n += this.testConsistency('color', this.style.color, t.color)),
            n
          );
        },
        makeFnLabelPrefix: function(e, t) {
          return 'C';
        },
      })),
      (o.gConstraints.Function = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'A calculated expression',
          inherits: 'Constraint',
          refspec: { gspRef: 'FunctionM_C' },
          usage: { abstract: !1, kinds: ['Expression'] },
          existenceRule: 'Exists iff the parent objects exist.',
          properties: {
            parents: {
              description:
                'An associative array of objects used in the expression.',
              type: 'Array',
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Expression-Function_export.json',
        },
        baseUnits: {
          angle: o.units.unitFamilies.angle.baseUnit,
          length: o.units.unitFamilies.length.baseUnit,
        },
        constrain: function() {
          var e = this;
          (this.uValue = this.curryReferences(
            this,
            this.parentsList,
            this.fnUnits
          )),
            (this.blank =
              '' === this.expression || this.determineParentalBlank()),
            (this.value = function(t) {
              return e.uValue(t) * e.unitMultiplier;
            });
        },
      })),
      (o.gConstraints.FunctionPlot = (function() {
        return o.makeClass([o.gConstraints.Constraint, o.mixins.pointVector], {
          doc: {
            description: 'A simple function plot',
            inherits: 'Constraint',
            refspec: { gspRef: 'FunctionPlot_C' },
            usage: { abstract: !1, kinds: ['Sampler'] },
            existenceRule:
              'Exists iff the parent function and coordinate system exist and at least one sample of the plot exists',
            properties: {
              parents: {
                properties: {
                  function: {
                    description: 'The function evaluated for x',
                    kind: 'Expression',
                  },
                  coordSys: {
                    description:
                      'The coordinate system in which the function is evaluated.',
                    kind: 'CoordSys',
                  },
                },
              },
            },
          },
          getFunctionType: function() {
            var e = this.getParent('function');
            return e && e.expressionType;
          },
          setPlottingInfo: function() {
            var e = this.getFunctionType(),
              t = this.sQuery.sketch.preferences.units.angle,
              n = {};
            'RofT_FunctionExprType' === e
              ? ((n.conversionFactor = o.units.convert(1, 'rad', t, 1)),
                (n.polar = !0),
                (n.invertXAndY = !1))
              : 'TofR_FunctionExprType' === e
              ? ((n.conversionFactor = o.units.convert(1, t, 'rad', 1)),
                (n.polar = !0),
                (n.invertXAndY = !0))
              : 'XofY_FunctionExprType' === e
              ? ((n.conversionFactor = 1), (n.polar = !1), (n.invertXAndY = !0))
              : 'YofX_FunctionExprType' === e &&
                ((n.conversionFactor = 1),
                (n.polar = !1),
                (n.invertXAndY = !1)),
              (this.plottingInfo = n);
          },
          updateConstraintAncestry: function() {
            this.setPlottingInfo(),
              (this.pseudoSampleGObj = o.makeClass(o.mixins.pointVector, {
                fillSingleSample: function() {
                  throw o.createError(
                    "fillSingleSample() should not be called on functionPlot's sample vector"
                  );
                },
                setAllSamples: function(e, t, n) {
                  if (t) {
                    (e.samples = t), (e.filledSampleCount = n);
                    for (
                      var i, r, s = null, o = null, a = null, c = null, l = 0;
                      l < t.length;
                      l += 2
                    )
                      (i = t[l]),
                        (r = t[l + 1]),
                        isFinite(i) &&
                          isFinite(r) &&
                          ((s = null === s || s > i ? i : s),
                          (a = null === a || a > r ? r : a),
                          (o = null === o || i > o ? i : o),
                          (c = null === c || r > c ? r : c));
                    e.geomBounds = { left: s, top: a, right: o, bottom: c };
                  } else
                    (e.samples = null),
                      (e.filledSampleCount = 0),
                      (e.geomBounds = null);
                },
              })),
              (this.vectorContext = this.pseudoSampleGObj.createVectorContext(
                this.numSamples,
                this,
                !1
              )),
              (this.vectorContext.isDiscrete = this.isDiscrete);
          },
          isSamplingRequired: function(e) {
            var t = this.getParent('function');
            return (
              !this.rawSamples ||
              this.state.constraintFrame <= t.state.constraintFrame
            );
          },
          xFunc: function(e) {
            return e;
          },
          computeSamples: function() {
            var e,
              t,
              n,
              i,
              r,
              s,
              a,
              c = this.getParent('function').uValue,
              l = this.driverDomain.low,
              u = this.driverDomain.high,
              d = this.numSamples,
              h = o.createFloatVector(2 * d),
              p = (u - l) / (d - 1),
              f = !1,
              m = this.plottingInfo.conversionFactor,
              g = this.plottingInfo.polar,
              b = this.plottingInfo.invertXAndY;
            for (i = 0; d > i; ++i)
              (e = p * i + l),
                (t = this.xFunc(e)),
                (n = c(e) * m),
                !f && isFinite(n) && (f = !0),
                b && ((r = t), (t = n), (n = r)),
                g &&
                  ((a = t),
                  (s = n),
                  (t = s * Math.cos(a)),
                  (n = s * Math.sin(a))),
                (h[2 * i] = t),
                (h[2 * i + 1] = n);
            return f && h;
          },
          updateDomain: function(e) {
            var t,
              n,
              i,
              r,
              s,
              o,
              a,
              c = this.getParent('coordSys'),
              l = this.driverDomain;
            (this.funcType = this.getFunctionType()),
              'RofT_FunctionExprType' === this.funcType
                ? ((l.low = 0), (l.high = 2 * Math.PI))
                : c.state.exists
                ? ((i = c.geom.origin),
                  'XofY_FunctionExprType' === this.funcType
                    ? ((s = c.geom.unit1),
                      (a = i.y - s.y),
                      (l.high = -(e.top - i.y) / a),
                      (l.low = -(e.bottom - i.y) / a))
                    : ((t = e.left),
                      (n = e.right),
                      (r = c.geom.unit0),
                      (o = r.x - i.x),
                      (l.high = (n - i.x) / o),
                      'TofR_FunctionExprType' === this.funcType
                        ? ((l.low = 0),
                          l.high < 0 && (l.high = (n - t) / 2 / o))
                        : (l.low = (t - i.x) / o)))
                : ((l.low = 10), (l.high = -10));
          },
          initConstraint: function() {
            this.funcType = this.getFunctionType();
          },
          parentsExist: function() {
            var e = this.getParent('function'),
              t = this.getParent('coordSys');
            return e && t && e.state.exists && t.state.exists;
          },
          domainNeedsUpdate: function() {
            return this.funcType !== this.getFunctionType();
          },
          constrain: function(e) {
            var t = this.getParent('coordSys'),
              n = this.parentsExist(),
              i = this.isSamplingRequired(e);
            if (n)
              if (
                (i &&
                  (this.domainNeedsUpdate() &&
                    this.updateDomain(e.sketchRect()),
                  (this.rawSamples = this.computeSamples())),
                this.rawSamples)
              ) {
                var r = t.vectorLocatePlot(this.rawSamples);
                this.pseudoSampleGObj.setAllSamples(
                  this.vectorContext,
                  r,
                  this.numSamples
                ),
                  i &&
                    this.pseudoSampleGObj.recomputeDiscontinuities(
                      this.vectorContext
                    );
              } else
                this.pseudoSampleGObj.setAllSamples(this.vectorContext, null);
            this.state.exists = this.rawSamples && n;
          },
          samplerPathLength: function() {
            return this.pseudoSampleGObj.pathLengthForVector(
              this.vectorContext
            );
          },
          getParentalNameMFS: function(e) {
            var t,
              n,
              i = this.getParent('function'),
              r = this.getParent('coordSys'),
              s = r.getParent('axisX'),
              a = r.getParent('axisY'),
              c = i.expressionType;
            return (
              'RofT_FunctionExprType' === c || 'YofX_FunctionExprType' === c
                ? ((t = s.getNameMFS(e)), (n = a.getNameMFS(e)))
                : ((n = s.getNameMFS(e)), (t = a.getNameMFS(e))),
              o.mfs.makeHorizontalMFS(
                n,
                o.mfs.makeTextMFS(' = '),
                i.getLabelMFS(),
                o.mfs.makeTextMFS('('),
                t,
                o.mfs.makeTextMFS(')')
              )
            );
          },
          sampleGObj: function() {
            return this.pseudoSampleGObj;
          },
          samplerPathValueToPosition: function(e, t) {
            function n(e) {
              var t,
                n,
                i,
                o = e,
                l = c.xFunc(o),
                u = r.uValue(o) * a.conversionFactor;
              return (
                a.invertXAndY && ((t = l), (l = u), (u = t)),
                a.polar &&
                  ((i = l),
                  (n = u),
                  (l = n * Math.cos(i)),
                  (u = n * Math.sin(i))),
                s.locatePlot(l, u)
              );
            }
            var i,
              r = this.getParent('function'),
              s = this.getParent('coordSys'),
              a = this.plottingInfo,
              c = this;
            return (
              (i = n(e)),
              t &&
                i.isDefined() &&
                (t.derivative = o.math
                  .secantApproximationToDerivative(e, i, n)
                  .multiply(this.driverDomain.high - this.driverDomain.low)),
              i
            );
          },
          samplerPositionToPathValue: function(e) {
            var t = this.pseudoSampleGObj.positionToPathValueForVector(
                this.vectorContext,
                e
              ),
              n = this.driverDomain.high - this.driverDomain.low;
            return this.driverDomain.low + t * n;
          },
          samplerConstrainRange: function(e) {
            var t = e,
              n = this.driverDomain.low,
              i = this.driverDomain.high;
            return e > i && (t = i), n > e && (t = n), t;
          },
          samplerIsValueInBounds: function(e) {
            return e >= this.driverDomain.low && e <= this.driverDomain.high;
          },
        });
      })()),
      (o.gConstraints.ParametricCurvePlot = (function() {
        return o.makeClass(o.gConstraints.FunctionPlot, {
          doc: {
            description:
              'A parametric plot graphs two functions on a coordinate system. Each plotted point (x, y) or (r, theta) corresponds to a particular value of an independent variable. This independent variable is used to evaluate each of the two functions.',
            inherits: 'FunctionPlot',
            usage: { abstract: !0, kinds: ['Sampler'] },
            existenceRule:
              'Exists iff both parent functions and the coordinate system exist and at least one sample of the plot exists',
            properties: {
              parents: {
                properties: {
                  xFunction: {
                    description: 'The function evaluated for x',
                    kind: 'Expression',
                  },
                },
              },
            },
          },
          xFunc: function(e) {
            return this.getParent('xFunction').uValue(e);
          },
          parentsExist: function e() {
            var t = this.getParent('xFunction'),
              n = (e.base || arguments.callee.base).call(this);
            return n && t && t.state.exists;
          },
          domainNeedsUpdate: function() {
            return !1;
          },
          isSamplingRequired: function e(t) {
            var n = this.getParent('xFunction');
            return (e.base || arguments.callee.base).call(this, t)
              ? !0
              : this.state.constraintFrame <= n.state.constraintFrame;
          },
          setPlottingInfo: function() {
            this.plottingInfo = {
              conversionFactor: 1,
              polar: this.isPolarCurve,
              invertXAndY: !1,
            };
          },
        });
      })()),
      (o.gConstraints.ParametricCartesianCurvePlot = (function() {
        return o.makeClass(o.gConstraints.ParametricCurvePlot, {
          doc: {
            description:
              'A parametric curve plotted using Cartesian coordinates',
            inherits: 'ParametricCurvePlot',
            refspec: {
              gspRef: 'ParametricCartesianCurvePlot_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ParametricCartesianCurvePlot_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          isPolarCurve: !1,
        });
      })()),
      (o.gConstraints.ParametricPolarCurvePlot = (function() {
        return o.makeClass(o.gConstraints.ParametricCurvePlot, {
          doc: {
            description: 'A parametric curve plotted using Polar coordinates',
            inherits: 'ParametricCurvePlot',
            refspec: {
              gspRef: 'ParametricCartesianCurvePlot_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ParametricPolarCurvePlot_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          isPolarCurve: !0,
        });
      })()),
      (o.gConstraints.Intersection = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'A point defined by the intersection of two <span class="kind">Straight</span> objects.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'InterLL_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, InterLL_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Point'] },
          existenceRule:
            'Exists iff parents exist and are not parallel and the intersection point is within the extent of both parents. E.g., the lines containing two segments might intersect outside the extent of the segments. In this case the intersection point for the segments would not exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                line0: { description: '', kind: 'Straight' },
                line1: { description: '', kind: 'Straight' },
              },
            },
            style: {
              description: 'Appearance of GObject',
              properties: { color: { description: '"(black)', type: 'Color' } },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection_export.json',
        },
        constrain: function() {
          var e = this.getParent('line0'),
            t = this.getParent('line1');
          (this.geom.loc = o.Geom.LineLineIntersection(e, t)),
            (this.state.exists = this.geom.loc.isDefined());
        },
      })),
      (o.gConstraints.Line = o.makeClass(o.gConstraints.Straight, {
        doc: {
          description: 'A straight line that extends to infinity.',
          inherits: 'Straight',
          refspec: {
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Straight'] },
          existenceRule:
            'Exists iff the parent points exist and are not coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: {
                  description: 'First reference point defining the line',
                  kind: 'Point',
                },
                p1: {
                  description: 'Second reference point defining the line',
                  kind: 'Point',
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Line_export.json',
        },
        overbarType: 4,
        getPointOnPath: function(e, t) {
          return this.getPointOnLine(e, t);
        },
        constrain: function() {
          var e, t, n, i, r, s, a;
          (e = this.getStraightP0()),
            (this.geom.p0 = e),
            (t = this.getStraightP1()),
            (this.geom.p1 = t),
            (n = t.subtract(e)),
            n.isZeroLength()
              ? ((this.geom.xp0 = o.GeometricPoint(0, 0)),
                (this.geom.xp1 = o.GeometricPoint(0, 0)))
              : ((i = n.vLength()),
                (r = 1e4 / i),
                (s = e.add(n.multiply(-r))),
                (a = e.add(n.multiply(r))),
                (this.geom.xp0 = s),
                (this.geom.xp1 = a)),
            (this.state.exists = !n.isZeroLength());
        },
      })),
      (o.gConstraints.MeasurementAngle = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description: 'The measurement of an angle defined by three points.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'Angle3PointsMeasure_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Angle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parent points exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: { description: '', kind: 'Point' },
                  p1: { description: '', kind: 'Point' },
                  p2: { description: '', kind: 'Point' },
                },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementAngle_export.json',
          },
          unitPowers: { angle: 1 },
          constrain: function() {
            var e,
              t = this.getParent('p0').geom.loc,
              n = this.getParent('p1').geom.loc,
              i = this.getParent('p2').geom.loc,
              r = this.sQuery().prefs().units.angle;
            (e = o.GeometricPoint.threePointFlippedAngle(t, n, i)),
              'deg' === r &&
                (0 > e && (e += 2 * Math.PI),
                e > Math.PI && (e = 2 * Math.PI - e)),
              (this.value = e),
              (this.uValue = o.units.convert(e, 'radians', r));
          },
          getParentalNameMFS: function(e) {
            var t,
              n,
              i,
              r,
              s,
              a = [],
              c = this.getMathItalicization();
            for (t = this.parentsList, n = 0; n < t.length; n += 1)
              (i = t[n]), (r = i.getNameMFS(e)), a.push(r);
            return (
              (s = o.mfs.makeHorizontalNamesMFS(a)),
              o.mfs.makeHorizontalMFS(
                o.mfs.makeTextMFS('m', c),
                { type: 'symbol', value: 'd0' },
                s
              )
            );
          },
        }
      )),
      (o.gConstraints.MeasurementAngleMarker = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description: 'The value of an angle marker',
            inherits: 'Constraint',
            refspec: { gspRef: 'AngleMarkerMeasure_C' },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parent marker exists.',
            properties: {
              parents: {
                properties: {
                  marker: {
                    description: 'The AngleMarker to be measured',
                    kind: 'AngleMarker',
                  },
                },
              },
            },
          },
          unitPowers: { angle: 1 },
          genus: 'AngleMeasure',
          constrain: function() {
            var e,
              t = this.getParent('marker'),
              n = this.sQuery().prefs().units.angle;
            (e = -t.value),
              (this.value = e),
              'deg' === n && 0 > e && (e = -e),
              (this.uValue = o.units.convert(e, 'radians', n));
          },
          getParentalNameMFS: function(e) {
            var t,
              n = this.getParent('marker');
            (t = n.getNameMFS(e)),
              o.mfs.isEmptyTextMFS(t) && (t = o.mfs.makeTextMFS(n.id));
            var i = o.mfs.makeItalicMFS(t),
              r = [
                o.mfs.makeTextMFS('m', !0),
                { type: 'symbol', value: 'd0' },
                i,
              ];
            return o.mfs.makeHorizontalMFS.apply(this, r);
          },
        }
      )),
      (o.gConstraints.MeasurementArea = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'The measurement of the area of a <span class="kind">Polygon</span>, <span class="kind">Circle</span>, or <span class="kind">CircleInterior</span>.',
          inherits: 'Constraint',
          refspec: {
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, TBD, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Measure'] },
          existenceRule:
            'Exists iff the parent points exist and are not all coincident.',
          properties: {
            parents: {
              description: '',
              properties: {
                shape: { description: '', kind: 'Arc|Circle|Polygon' },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementArea_export.json',
        },
        unitPowers: { length: 2 },
        constrain: function() {
          var e, t;
          (t = this.getParent('shape')),
            (e = t.area()),
            (this.value = e),
            (this.uValue = o.units.convertFromBaseToUnitObject(
              e,
              this.unitsObject
            ));
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('shape'),
            n = [o.mfs.makeTextMFS('Area ')];
          return (
            ('Circle' === t.kind || 'CircleInterior' === t.kind) &&
              n.push({ type: 'symbol', value: '100' }),
            n.push(
              o.mfs.makeItalicMFS(o.mfs.makeHorizontalMFS(t.getNameMFS(e)))
            ),
            o.mfs.makeHorizontalMFS.apply(this, n)
          );
        },
      })),
      (o.gConstraints.MeasurementCircumference = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the circumference of a <span class="kind">Circle</span>.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'CircumferenceM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, CircumferenceM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parent circle exists.',
            properties: {
              parents: {
                description: '',
                properties: {
                  shape: {
                    description:
                      'The circle whose circumference is to be measured',
                    kind: 'Circle',
                  },
                },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementCircumference_export.json',
          },
          unitPowers: { length: 1 },
          constrain: function() {
            var e,
              t,
              n = this.sQuery().prefs().units.length;
            (t = this.getParent('shape')),
              (e = t.circumference()),
              (this.value = e),
              (this.uValue = o.units.convert(e, 'pixels', n));
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('shape'),
              n = t.getNameMFS(e);
            return o.mfs.makeHorizontalMFS(
              o.mfs.makeTextMFS('Circumference '),
              { type: 'symbol', value: '100' },
              o.mfs.makeItalicMFS(n)
            );
          },
        }
      )),
      (o.gConstraints.MeasurementCoordinateBased = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The parent class for all coordinate-system based constraints.',
            inherits: 'Constraint',
            usage: { abstract: !0, kinds: ['Measure'] },
            properties: {
              parents: {
                description: '',
                properties: {
                  coordSys: {
                    description:
                      'The coordinate system used for the measurements',
                    kind: 'CoordSys',
                  },
                },
              },
            },
          },
          unitPowers: { scalar: 1 },
          getCoordinates: function(e) {
            var t = this.getParent('coordSys');
            return t.locatePoint(e.geom.loc);
          },
        }
      )),
      (o.gConstraints.MeasurementDistance = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the distance between two <span class="kind">Point</span>s.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'DistanceM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, DistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parent points exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: {
                    description:
                      'The point from which distance is to be measured',
                    kind: 'Point',
                  },
                  obj0: {
                    description:
                      'The point or line to which distance is to be measured',
                    kind: 'Point|Straight',
                  },
                },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementDistance_export.json',
          },
          unitPowers: { length: 1 },
          constrain: function() {
            var e,
              t,
              n,
              i,
              r,
              s = this.sQuery().prefs().units.length;
            (t = this.getParent('p0')),
              (i = t.geom.loc),
              (n = this.getParent('obj0')),
              'Point' === n.kind
                ? ((r = n.geom.loc), (e = r.subtract(i).vLength()))
                : n.isOfKind('Straight')
                ? ((r = n.getClosestPointOnLine(
                    { p0: n.getZeroPoint(), p1: n.getUnitPoint() },
                    i
                  )),
                  (e = r.subtract(i).vLength()))
                : o.log(
                    this.id +
                      ': Cannot compute distance from point to object: ' +
                      n.id +
                      '(' +
                      n.kind +
                      ')'
                  ),
              (this.value = e),
              (this.uValue = o.units.convert(e, 'pixels', s));
          },
          getParentalNameMFS: function(e) {
            var t, n, i, r;
            return (
              (t = this.getParent('p0')),
              (n = this.getParent('obj0')),
              t.label || t.getLabel(e),
              n.label || n.getLabel(e),
              (i = t.getNameMFS()),
              (r = n.getNameMFS()),
              'Straight' === n.kind
                ? o.mfs.makeHorizontalMFS(
                    o.mfs.makeTextMFS('Distance '),
                    o.mfs.makeItalicMFS(o.mfs.makeHorizontalMFS(i)),
                    o.mfs.makeTextMFS(' to '),
                    o.mfs.makeItalicMFS(o.mfs.makeHorizontalMFS(r))
                  )
                : o.mfs.makeItalicMFS(o.mfs.makeHorizontalNamesMFS([i, r]))
            );
          },
        }
      )),
      (o.gConstraints.MeasurementLength = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the length of a <span class="constraint">Segment</span>s.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'LengthM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, LengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule:
              'Exists if the parent segment exists. Also exists if the parent segment is an original segment and end-points are coincident. Then, the length is zero.',
            properties: {
              parents: {
                description: '',
                properties: { path: { description: '', genus: 'Path' } },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementLength_export.json',
          },
          unitPowers: { length: 1 },
          checkParentsExist: function() {
            return !0;
          },
          checkExists: function() {
            var e = this.getParent('path');
            return e.state.exists
              ? !0
              : 'Segment' === e.constraint &&
                e.getParent('p0').state.exists &&
                e.getParent('p1').state.exists
              ? !0
              : !1;
          },
          constrain: function() {
            var e,
              t = this.getParent('path'),
              n = this.sQuery().prefs().units.length;
            (this.state.exists = this.checkExists()),
              this.state.exists &&
                ((e = t.state.exists ? t.pathLength() : 0),
                (this.value = e),
                (this.uValue = o.units.convert(e, 'pixels', n)));
          },
          getParentalNameMFS: function(e) {
            var t,
              n = this.getParent('path'),
              i = this.getMathItalicization(),
              r =
                n.label || n.isTransformationConstraint
                  ? []
                  : [o.mfs.makeTextMFS('m ', i)];
            return (
              (t = n.getNameMFS(e)),
              o.mfs.isEmptyTextMFS(t) && (t = o.mfs.makeTextMFS(n.id, i)),
              r.push(t),
              o.mfs.makeHorizontalMFS.apply(this, r)
            );
          },
        }
      )),
      (o.gConstraints.MeasurementPerimeter = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the perimeter of a <span class="kind">Polygon</span>s.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'PerimeterM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PerimeterM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule:
              'Exists iff the parent points all exist and are not coincident.',
            properties: {
              parents: {
                description: '',
                properties: { shape: { description: '', kind: 'Arc|Polygon' } },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementPerimeter_export.json',
          },
          unitPowers: { length: 1 },
          constrain: function() {
            var e, t, n;
            (t = this.getParent('shape')),
              (e = t.perimeter()),
              (n = this.sQuery().prefs().units.length),
              (this.value = e),
              (this.uValue = o.units.convert(e, 'pixels', n));
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('shape');
            return o.mfs.makeHorizontalMFS(
              o.mfs.makeTextMFS('Perimeter '),
              o.mfs.makeItalicMFS(t.getNameMFS(e))
            );
          },
        }
      )),
      (o.gConstraints.MeasurementRadius = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the radius of a <span class="kind">Circle</span>.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'RadiusM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, RadiusM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parent circle exist.',
            properties: {
              parents: {
                description: '',
                properties: { shape: { description: '', kind: 'Arc|Circle' } },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementRadius_export.json',
          },
          unitPowers: { length: 1 },
          constrain: function() {
            var e,
              t,
              n = this.sQuery().prefs().units.length;
            (t = this.getParent('shape')),
              (e = t.radius()),
              isFinite(e) || (e = Number.POSITIVE_INFINITY),
              (this.value = e),
              (this.uValue = o.units.convert(e, 'pixels', n));
          },
          getParentalNameMFS: function(e) {
            var t = [o.mfs.makeTextMFS('Radius ')],
              n = this.getParent('shape').kind;
            return (
              ('Circle' === n || 'CircleInterior' === n) &&
                t.push({ type: 'symbol', value: '100' }),
              t.push(
                o.mfs.makeItalicMFS(this.getParent('shape').getNameMFS(e))
              ),
              o.mfs.makeHorizontalMFS.apply(this, t)
            );
          },
        }
      )),
      (o.gConstraints.MeasurementRatio = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the ratio of two segments or three points.',
            inherits: 'Constraint',
            refspec: { gspRef: 'RatioM_C' },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule:
              'Exists iff the parent points all exist and are not coincident.',
            properties: {
              parents: {
                description: '',
                properties: {
                  obj0: {
                    description: 'First segment or point',
                    kind: 'Straight|Point',
                  },
                  obj1: {
                    description: 'Second segment or point',
                    kind: 'Straight|Point',
                  },
                  obj2: {
                    description: 'Third point',
                    kind: 'Point',
                    required: !1,
                  },
                },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementRatio_export.json',
          },
          unitPowers: { scalar: 1 },
          ratioFromTwoSegments: function() {
            var e,
              t = this.getParent('obj0'),
              n = this.getParent('obj1');
            return (
              (this.state.exists = t.state.exists && n.state.exists),
              this.state.exists ? (e = t.pathLength() / n.pathLength()) : void 0
            );
          },
          ratioFromThreePoints: function() {
            var e,
              t = this.getParent('obj0'),
              n = this.getParent('obj1'),
              i = this.getParent('obj2');
            return (
              (this.state.exists =
                t.state.exists && n.state.exists && i.state.exists),
              this.state.exists
                ? ((e = o.GeometricPoint.mapPointToLine(
                    t.geom.loc,
                    n.geom.loc,
                    i.geom.loc
                  ).param),
                  isNaN(e) &&
                    t.geom.loc.equals(n.geom.loc) &&
                    !n.geom.loc.equals(i.geom.loc) &&
                    (e = Number.POSITIVE_INFINITY),
                  e)
                : void 0
            );
          },
          constrain: function() {
            var e,
              t = this.getParent('obj0');
            (e =
              'Straight' === t.kind
                ? this.ratioFromTwoSegments()
                : this.ratioFromThreePoints()),
              (this.value = e),
              (this.uValue = e);
          },
          nameFromTwoSegments: function(e) {
            var t = this.getParent('obj0'),
              n = this.getParent('obj1');
            return (
              t.label || t.getLabel(e),
              n.label || n.getLabel(e),
              {
                type: 'fraction',
                value: [
                  o.mfs.makeHorizontalMFS(
                    o.mfs.makeTextMFS('m ', !0),
                    t.getNameMFS()
                  ),
                  o.mfs.makeHorizontalMFS(
                    o.mfs.makeTextMFS('m ', !0),
                    n.getNameMFS()
                  ),
                ],
              }
            );
          },
          nameFromThreePoints: function(e) {
            var t = this.getParent('obj0'),
              n = this.getParent('obj1'),
              i = this.getParent('obj2');
            return (
              t.label || t.getLabel(e),
              n.label || n.getLabel(e),
              i.label || i.getLabel(e),
              {
                type: 'fraction',
                value: [
                  o.mfs.makeHorizontalNamesMFS([
                    t.getNameMFS(),
                    i.getNameMFS(),
                  ]),
                  o.mfs.makeHorizontalNamesMFS([
                    t.getNameMFS(),
                    n.getNameMFS(),
                  ]),
                ],
              }
            );
          },
          getParentalNameMFS: function(e) {
            var t,
              n = this.getParent('obj0');
            return (t =
              'Straight' === n.kind
                ? this.nameFromTwoSegments(e)
                : this.nameFromThreePoints(e));
          },
        }
      )),
      (o.gConstraints.MeasurementValueOfPointOnPath = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description: 'The measurement of the value of a point on path',
            inherits: 'Constraint',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TBD, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule:
              'Exists iff the parent points exist and are not all coincident.',
            properties: {
              parents: {
                properties: {
                  point: { description: 'The point', kind: 'Point' },
                  path: {
                    description: 'The path that the point lives on.',
                    genus: 'Path',
                  },
                },
              },
            },
          },
          unitPowers: { scalar: 1 },
          constrain: function(e) {
            var t, n;
            (t = this.getParent('point')),
              (n = this.getParent('path')),
              (this.value = n.mapPositionToPathValue(t.geom.loc)),
              (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('point'),
              n = this.getParent('path');
            return (
              t.label || t.getLabel(e),
              t.label || t.getLabel(e),
              o.mfs.makeHorizontalMFS(
                t.getNameMFS(),
                o.mfs.makeTextMFS(' on '),
                n.getNameMFS()
              )
            );
          },
        }
      )),
      (o.gConstraints.MultimeasureBase = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description: 'Abstract class for multimeasure constraints .',
            inherits: 'Constraint',
            usage: { abstract: !0, kinds: ['Text'] },
            existenceRule: 'Exists iff the parents exist.',
          },
          isMultimeasure: !0,
          values: {},
          valuesMFS: null,
          precisions: {},
          units: {},
          initTextMFS: function() {
            o.signalErrorWithMessage(
              'Multimeasures must implement initTextMFS'
            );
          },
          initUnits: function() {
            o.signalErrorWithMessage('Multimeasures must implement initUnits');
          },
          initPrecision: function() {
            o.signalErrorWithMessage(
              'Multimeasures must implement initPrecision'
            );
          },
          initConstraint: function() {
            this.initUnits(), this.initPrecision();
          },
          updateLabelForConstraint: function e() {
            (e.base || e.callee.base).call(this), this.initTextMFS();
          },
          getValuesAsMFS: function() {
            var e = this,
              n = {};
            return (
              e.formatNumberAsMFS ||
                o.signalErrorWithMessage(
                  'multimeasures are required to be Text kind'
                ),
              t.each(e.values, function(t, i) {
                n[t] = e.formatNumberAsMFS(i, e.precisions[t], e.units[t], !1);
              }),
              n
            );
          },
          getMultiMeasureParentLabelMFS: function() {
            var e = this.getParent('point');
            return e.label || e.getLabel({ create: !0 }), e.getNameMFS();
          },
          getColorableComponent: function() {
            return 'TextGObject_BackgroundContrast';
          },
          verificationString: function(e, t) {
            return '';
          },
          getMFSAppearanceForVariant: function() {
            var e = t.extend(!0, {}, this.valuesMFS);
            return o.mfs.realizeParamNodes(e, this.getValuesAsMFS()), e;
          },
          getMFSListSeparator: function() {
            return o.mfs.makeTextMFS(', ');
          },
        }
      )),
      (o.gConstraints.MeasurementRectCoordinates = o.makeClass(
        o.gConstraints.MultimeasureBase,
        {
          doc: {
            description:
              'The (x, y) coordinates of a point relative to a coordinate system.',
            inherits: 'MultiMeasureBase',
            refspec: {
              gspRef: 'RectCoordinateM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, RectCoordinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Text'] },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          initTextMFS: function() {
            var e = { type: 'parameter', value: 'xValue' },
              t = { type: 'parameter', value: 'yValue' },
              n = o.mfs.makeHorizontalMFS(e, this.getMFSListSeparator(), t);
            (this.valuesMFS = { type: 'paren', value: [n] }),
              (this.parsedMFS = o.mfs.makeHorizontalMFS(
                this.getMultiMeasureParentLabelMFS(),
                o.mfs.makeTextMFS(': '),
                this.valuesMFS
              ));
          },
          initUnits: function() {
            this.units = { xValue: 'scalar', yValue: 'scalar' };
          },
          initPrecision: function() {
            var e = this.sQuery().prefs(),
              t = e.precision.scalar;
            this.precisions = { xValue: t, yValue: t };
          },
          constrain: function() {
            var e = this.getParent('coordSys'),
              t = this.getParent('point'),
              n = e.locatePoint(t.geom.loc);
            this.values = { xValue: n.x, yValue: n.y };
          },
        }
      )),
      (o.gConstraints.MeasurementPolarCoordinates = o.makeClass(
        o.gConstraints.MultimeasureBase,
        {
          doc: {
            description:
              'The (r, theta) coordinates of a point relative to a coordinate system.',
            inherits: 'MultiMeasureBase',
            refspec: {
              gspRef: 'PolarCoordinateM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PolarCoordinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Text'] },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          initTextMFS: function() {
            var e = { type: 'parameter', value: 'rValue' },
              t = { type: 'parameter', value: 'thetaValue' },
              n = o.units.makeUnitObjectFromUnitsAndPowers(
                { angle: this.units.thetaValue },
                { angle: 1 }
              ),
              i = o.units.getMFSForUnitObject(n),
              r = o.mfs.makeHorizontalMFS(e, this.getMFSListSeparator(), t, i);
            (this.valuesMFS = { type: 'paren', value: [r] }),
              (this.parsedMFS = o.mfs.makeHorizontalMFS(
                this.getMultiMeasureParentLabelMFS(),
                o.mfs.makeTextMFS(': '),
                this.valuesMFS
              ));
          },
          initUnits: function() {
            var e = this.sQuery().prefs().units;
            this.units = { rValue: 'scalar', thetaValue: e.angle };
          },
          initPrecision: function() {
            var e = this.sQuery().prefs();
            this.precisions = {
              rValue: e.precision.scalar,
              thetaValue: e.precision.angle,
            };
          },
          constrain: function() {
            var e = this.getParent('coordSys'),
              t = this.getParent('point'),
              n = e.locatePoint(t.geom.loc),
              i = n.vLength(),
              r = Math.atan2(n.y, n.x);
            this.values = {
              rValue: i,
              thetaValue: o.units.convert(r, 'radians', this.units.thetaValue),
            };
          },
        }
      )),
      (o.gConstraints.LinearEquation = o.makeClass(
        o.gConstraints.MultimeasureBase,
        {
          doc: {
            description: 'Constraint for linear equation measurements',
            inherits: 'MultimeasureBase',
            usage: { abstract: !1, kinds: ['Text'] },
            properties: {
              parents: {
                description: '',
                properties: {
                  coordSys: {
                    description:
                      'The coordinate system used for the measurements',
                    kind: 'CoordSys',
                  },
                  straight: {
                    description: 'The straight we are measuring.',
                    kind: 'Straight',
                  },
                },
              },
            },
          },
          initTextMFS: function() {},
          initUnits: function() {
            this.units = {
              xValue: 'scalar',
              yValue: 'scalar',
              slope: 'scalar',
              yIntercept: 'scalar',
            };
          },
          initPrecision: function() {
            var e = this.sQuery().prefs(),
              t = e.precision.scalar;
            this.precisions = { xValue: t, yValue: t, slope: t, yIntercept: t };
          },
          getMultiMeasureParentLabelMFS: function() {
            return this.getParent('straight').getNameMFS();
          },
          constrain: function() {
            function e(e, t) {
              return (d.values[e] = t), { type: 'parameter', value: e };
            }
            function t() {
              var t,
                n = u / l,
                i = c.y - n * c.x,
                r = ' + ';
              0 > i && ((r = ' − '), (i = -i)),
                (t = [
                  o.mfs.makeTextMFS('y', !0),
                  o.mfs.makeTextMFS(' = '),
                  e('slope', n),
                  o.mfs.makeTextMFS('x', !0),
                ]),
                0 !== i &&
                  (t.push(o.mfs.makeTextMFS(r)), t.push(e('yIntercept', i))),
                (d.valuesMFS = o.mfs.makeHorizontalMFS.apply(this, t));
            }
            function n() {
              d.valuesMFS = o.mfs.makeHorizontalMFS(
                o.mfs.makeTextMFS('x', !0),
                o.mfs.makeTextMFS(' = '),
                e('xValue', c.x)
              );
            }
            function i() {
              d.valuesMFS = o.mfs.makeHorizontalMFS(
                o.mfs.makeTextMFS('y', !0),
                o.mfs.makeTextMFS(' = '),
                e('yValue', c.y)
              );
            }
            var r = this.getParent('coordSys'),
              s = this.getParent('straight'),
              a = r.locatePoint(s.getStraightP0()),
              c = r.locatePoint(s.getStraightP1()),
              l = c.x - a.x,
              u = c.y - a.y,
              d = this;
            (d.values = {}),
              0 === l ? n() : 0 === u ? i() : t(),
              (d.parsedMFS = o.mfs.makeHorizontalMFS(
                s.getNameMFS(),
                o.mfs.makeTextMFS(': '),
                d.valuesMFS
              ));
          },
        }
      )),
      (o.gConstraints.QuadraticEquation = o.makeClass(
        o.gConstraints.MultimeasureBase,
        {
          doc: {
            description: 'Constraint for quadratic equation multimeasures.',
            inherits: 'MultimeasureBase',
            usage: { abstract: !1, kinds: ['Text'] },
            properties: {
              parents: {
                description: '',
                properties: {
                  coordSys: {
                    description:
                      'The coordinate system used for the measurements',
                    kind: 'CoordSys',
                  },
                  circle: {
                    description: 'The circle we are measuring',
                    kind: 'Circle',
                  },
                },
              },
            },
          },
          initTextMFS: function() {},
          initUnits: function() {
            this.units = {
              cX: 'scalar',
              cY: 'scalar',
              rX: 'scalar',
              rY: 'scalar',
            };
          },
          initPrecision: function() {
            var e = this.sQuery().prefs(),
              t = e.precision.scalar;
            this.precisions = { cX: t, cY: t, rX: t, rY: t };
          },
          getMultiMeasureParentLabelMFS: function() {
            return o.mfs.makeHorizontalMFS(
              { type: 'symbol', value: '100' },
              o.mfs.makeItalicMFS(this.getParent('circle').getNameMFS())
            );
          },
          constrain: function() {
            function e(e, t) {
              return (p.values[e] = t), { type: 'parameter', value: e };
            }
            function t(t, n, i) {
              function r(e) {
                return { type: 'super', value: [e, o.mfs.makeTextMFS('2')] };
              }
              var s;
              return 0 === n
                ? r(t)
                : ((s = ' + '),
                  0 > n && ((s = ' − '), (n = -n)),
                  r(
                    o.mfs.makeParenthesisMFS(
                      o.mfs.makeHorizontalMFS(t, o.mfs.makeTextMFS(s), e(i, n))
                    )
                  ));
            }
            function n() {
              p.valuesMFS = o.mfs.makeHorizontalMFS(
                t(o.mfs.makeTextMFS('x', !0), a.x, 'cX'),
                o.mfs.makeTextMFS(' + '),
                t(o.mfs.makeTextMFS('y', !0), a.y, 'cY'),
                o.mfs.makeTextMFS(' = '),
                t(e('rX', u), 0)
              );
            }
            function i() {
              p.valuesMFS = o.mfs.makeHorizontalMFS(
                o.mfs.makeFractionMFS(
                  t(o.mfs.makeTextMFS('x', !0), a.x, 'cX'),
                  t(e('rX', u), 0)
                ),
                o.mfs.makeTextMFS(' + '),
                o.mfs.makeFractionMFS(
                  t(o.mfs.makeTextMFS('y', !0), a.y, 'cY'),
                  t(e('rY', d), 0)
                ),
                o.mfs.makeTextMFS(' = '),
                o.mfs.makeTextMFS('1')
              );
            }
            var r = this.getParent('coordSys'),
              s = this.getParent('circle'),
              a = r.locatePoint(s.geom.c),
              c = r.geom.unit0.x - r.geom.origin.x,
              l = -(r.geom.unit1.y - r.geom.origin.y),
              u = s.geom.r / c,
              d = s.geom.r / l,
              h = 1e-13,
              p = this;
            (a.x = -a.x),
              (a.y = -a.y),
              (p.values = {}),
              Math.abs(c - l) >= h ? i() : n(),
              (p.parsedMFS = o.mfs.makeHorizontalMFS(
                { type: 'symbol', value: '100' },
                o.mfs.makeItalicMFS(s.getNameMFS()),
                o.mfs.makeTextMFS(': '),
                p.valuesMFS
              ));
          },
        }
      )),
      (o.gConstraints.Midpoint = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'The midpoint of a <span class="constraint">Segment</span>.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'Midpoint_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Midpoint_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Point'] },
          existenceRule: 'Exists iff the parent segment exists.',
          properties: {
            parents: {
              description: '',
              properties: { path: { description: '', kind: 'Straight' } },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Midpoint_export.json',
        },
        state: {},
        constrain: function() {
          var e, t;
          (e = this.getParent('path')),
            (t = e.mapPathValueToPosition(0.5)),
            (this.state.exists = e.state.exists),
            (this.geom.loc = t);
        },
        canMergeTo: function(e) {
          var t = this.getParent('path'),
            n = e.getParent('path'),
            i = !1;
          return (
            t && n
              ? (i = t === n)
              : o.signalErrorWithMessage(
                  'Midpoint canMergeTo() missing parents!'
                ),
            i
          );
        },
      })),
      (o.gConstraints.Pegged = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'A translation of a <span class="kind">Text</span> message to a <span class="kind">Point</span>.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'PeggedText_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, PeggedText_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Text'] },
          existenceRule: 'Exists iff the parent text and point exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: {
                  description: 'The point to which the pegged text is bound.',
                  kind: 'Point',
                },
                text: {
                  description: 'The original text replicated by this object.',
                  kind: 'Text',
                },
              },
            },
            geom: { suppressed: !0 },
          },
          example:
            '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Text/Pegged_export.json',
        },
        style: { 'text-align': 'center', 'vertical-align': 'middle' },
        supportsAutoplacement: function() {
          return !1;
        },
        constrain: function() {
          var e = this.getParent('p0'),
            t = this.getParent('text');
          (this.parsedMFS = t.getStrippedMFSAppearanceForVariant('default')),
            (this.text = null),
            (this.state.exists = null !== this.parsedMFS && e.state.exists),
            this.state.exists
              ? (this.geom.loc = e.geom.loc)
              : (this.geom.loc = o.GeometricPoint.INFINITY);
        },
      })),
      (o.gConstraints.PointOnPath = o.makeClass(
        o.gConstraints.PointOnPathBase,
        {
          doc: {
            description: 'A point on a <span class="genus">Path</span>.',
            inherits: 'Constraint',
            refspec: { gspRef: 'OnPath_C' },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule: 'Exists iff the parent path exists.',
            properties: {
              value: { description: '', type: 'Number' },
              parents: {
                description: '',
                properties: { path: { description: '', genus: 'Path' } },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-PointOnPath_export.json',
          },
          updateValue: function(e) {
            this.value = e;
          },
          transform: function(e, t) {
            var n, i;
            (i = t.geom.loc.copy()),
              t.affine.transform(i),
              (n = this.getParent('path')),
              this.updateValue(n.mapPositionToPathValue(i));
          },
          constraintVerificationString: function(e) {
            return this.testConsistency('value', this.value, e.value);
          },
        }
      )),
      (o.gConstraints.PlotFixedValueOnPath = o.makeClass(
        o.gConstraints.PointOnPathBase,
        {
          doc: {
            description:
              'Defines a point on a <span class="genus">Path</span> that has a fixed value.',
            inherits: 'Constraint',
            refspec: { gspRef: 'PlotFixedValueOnPath_C' },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule: 'Exists iff the parent path exists.',
            properties: {
              value: {
                description: '',
                type: 'Number',
              },
              parents: {
                description: '',
                properties: {
                  path: {
                    description:
                      'Identifies the path on which the point is plotted',
                    genus: 'Path',
                  },
                },
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Point-PlotFixedValueOnPath_export.json',
          },
          isFreePointOnPath: !1,
        }
      )),
      (o.gConstraints.PlotValueOnPath = o.makeClass(
        o.gConstraints.PointOnPathBase,
        {
          doc: {
            description:
              'Defines a point on a <span class="genus">Path</span> that has a value defined by a <span class="kind">Param</span>.',
            inherits: 'Constraint',
            refspec: { gspRef: 'PlotMarkedValueOnPath_C' },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule: 'Exists iff the parent param and path exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  param: {
                    description:
                      'Identifies a measure whose value determines the position on the path as a normalized path coordinate',
                    kind: 'Measure',
                  },
                  path: {
                    description:
                      'Identifies the path on which the point is plotted',
                    genus: 'Path',
                  },
                },
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Point/PlottedPoint_export.json',
          },
          isFreePointOnPath: !1,
          constrain: function e() {
            var t = this.getParent('param');
            (this.value = t.uValue),
              (e.base || arguments.callee.base).call(this);
          },
        }
      )),
      (o.gConstraints.Reflect = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Defines a <span class="kind">GObject</span> that is the reflection of another GObject with respect to a <span class="kind">Straight</span> object.',
          inherits: 'Transform',
          refspec: {
            gspRef: 'Reflect_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Reflect_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule: 'Exists iff the parent object and mirror exist.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Reflection_export.json',
          properties: {
            parents: {
              description: '',
              properties: { mirror: { description: '', kind: 'Straight' } },
            },
          },
        },
        determineExists: function() {
          return !0;
        },
        getTransform: function() {
          var e = this.getParent('mirror');
          return function(t) {
            var n = e.geom.xp0,
              i = e.geom.xp1,
              r = n.x,
              s = n.y,
              a = i.x - r,
              c = i.y - s,
              l = a * a + c * c,
              u = ((t.x - r) * a + (t.y - s) * c) / l;
            return o.GeometricPoint(
              2 * (u * a + r) - t.x,
              2 * (u * c + s) - t.y
            );
          };
        },
        makeFnLabelPrefix: function(e, t) {
          var n,
            i,
            r = '',
            s = this.getParent('mirror');
          switch (((t = t || {}), e)) {
            case 'namedByFullFn':
              (r = s.label),
                r ||
                  ((n = s.getParentLabel('p0', t)),
                  (i = s.getParentLabel('p1', t)),
                  n && i && (r = n + i)),
                r || (r = s.getLabel(t)),
                (r = 'r[' + (r ? r : '') + ']');
              break;
            case 'namedByShortFn':
              r = 'r';
          }
          return r;
        },
      })),
      (o.gConstraints.GlideReflect = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Defines a <span class="kind">GObject</span> that is the glide reflection of another GObject with respect to a <span class="kind">Straight</span> object that defines the vector/mirror.',
          inherits: 'Transform',
          refspec: {
            gspRef: 'GlideReflect_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, GlideReflect_C, in a future published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the preimage and segment (vector/mirror) exist.',
          example: '',
          properties: {
            parents: {
              description: '',
              properties: { vector: { description: '', kind: 'Straight' } },
            },
          },
        },
        determineExists: function() {
          var e = this.getParent('vector'),
            t = e.geom.p0,
            n = e.geom.p1,
            i = n.subtract(t);
          return !i.isZeroLength();
        },
        getTransform: function() {
          var e = this.getParent('vector');
          return function(t) {
            var n = e.geom.p0,
              i = e.geom.p1,
              r = n.x,
              s = n.y,
              a = i.x - r,
              c = i.y - s,
              l = a * a + c * c,
              u = ((t.x - r) * a + (t.y - s) * c) / l;
            return o.GeometricPoint(
              2 * (u * a + r) - t.x + a,
              2 * (u * c + s) - t.y + c
            );
          };
        },
        makeFnLabelPrefix: function(e, t) {
          var n = this.getParent('vector'),
            i = 'v',
            r = n.getParent('p0'),
            s = n.getParent('p1'),
            o = 'G';
          return (
            (t = t || {}),
            'namedByFullFn' === e &&
              ((i =
                r && r.label && s && s.label
                  ? n.getParentLabel('p0') + n.getParentLabel('p1')
                  : n.label
                  ? this.getParentLabel('vector')
                  : r && s
                  ? n.getParentLabel('p0', t) + n.getParentLabel('p1', t)
                  : this.getParentLabel('vector', t)),
              (o = 'G[' + i + ']')),
            o
          );
        },
      })),
      (o.gConstraints.Rotate = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Defines a new GObject as a rotation of a GObject by a fixed angle about a pivot point p0.',
          inherits: 'Transform',
          refspec: {
            gspRef: 'RotatefA_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, RotatefA_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule: 'Exists iff the parent object exists.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Rotation_export.json',
          properties: {
            parents: {
              description: '',
              properties: {
                center: {
                  description: 'The center of the rotation',
                  kind: 'Point',
                },
              },
            },
            angle: { description: '', type: 'Number', required: !0 },
          },
        },
        angle: 0,
        determineExists: function() {
          var e = this.getAngle();
          return 'undefined' != typeof e && isFinite(e);
        },
        getPivot: function() {
          var e = this.getParent('center');
          return e.geom.loc;
        },
        getAngle: function() {
          return this.angle;
        },
        getTransform: function() {
          var e = this;
          return function(t) {
            return t.rotate(e.getPivot(), e.getAngle());
          };
        },
        getAngleText: function() {
          return this.getFixedAngleText(this.angle);
        },
        makeFnLabelPrefix: function(e, t) {
          var n = this.getParentLabel('center', t),
            i = 'R';
          return (
            'namedByFullFn' === e &&
              (i += '[' + n + ',' + this.getAngleText(t) + ']'),
            i
          );
        },
      })),
      (o.gConstraints.Segment = o.makeClass(o.gConstraints.Straight, {
        doc: {
          description: 'Defines a line segment from two points.',
          inherits: 'Straight',
          refspec: {
            gspRef: 'Segment_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Segment_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Straight'] },
          existenceRule: 'Exists iff the parent points exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: {
                  description: 'First reference point defining the segment',
                  kind: 'Point',
                },
                p1: {
                  description: 'Second reference point defining the segment',
                  kind: 'Point',
                },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Segment_export.json',
        },
        overbarType: 2,
        getPointOnPath: function(e, t) {
          return this.getPointOnSegment(e, t);
        },
        constrain: function() {
          var e;
          (this.geom.xp0 = this.geom.p0 = this.getStraightP0()),
            (this.geom.xp1 = this.geom.p1 = this.getStraightP1()),
            (e = this.geom.p1.subtract(this.geom.p0)),
            (this.state.exists = !e.isZeroLength());
        },
      })),
      (o.gConstraints.ColorizeTrivariate = o.makeClass(
        o.gConstraints.Colorize,
        {
          doc: {
            description:
              'Defines a new GObject that is coincident to another GObject, but colored differently.',
            inherits: 'Colorize',
            refspec: {
              gspRef: 'Colorization_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the parent measures exist and are finite.',
            properties: {
              parents: {
                description: '',
                properties: {
                  red: {
                    description:
                      'For a trivariate parameterization, the red value.',
                    kind: 'Measure',
                  },
                  green: {
                    description:
                      'For a trivariate parameterization, the green value.',
                    kind: 'Measure',
                  },
                  blue: {
                    description:
                      'For a trivariate parameterization, the blue value.',
                    kind: 'Measure',
                  },
                },
              },
            },
          },
          determineExists: function() {
            var e = this.getParent('red'),
              t = this.getParent('green'),
              n = this.getParent('blue');
            return !!(
              e &&
              o.math.isFiniteScalar(e.uValue) &&
              t &&
              o.math.isFiniteScalar(t.uValue) &&
              n &&
              o.math.isFiniteScalar(n.uValue)
            );
          },
          convertToColor: function() {
            var e = this.getParent('red'),
              t = this.getParent('green'),
              n = this.getParent('blue'),
              i = e && e.uValue,
              r = t && t.uValue,
              s = n && n.uValue;
            if (
              !o.math.isFiniteScalar(i) ||
              !o.math.isFiniteScalar(r) ||
              !o.math.isFiniteScalar(s)
            )
              return null;
            if (
              ((i = this.normalizeColorParameter(i)),
              (r = this.normalizeColorParameter(r)),
              (s = this.normalizeColorParameter(s)),
              'TrivariateHSV' === this.colorModel)
            ) {
              var a,
                c,
                l,
                u,
                d,
                h = i,
                p = r,
                f = s;
              if (0 === p) i = r = s = f;
              else
                switch (
                  ((h /= 60 / 360),
                  (a = Math.floor(h)),
                  (c = h - a),
                  (l = f * (1 - p)),
                  (u = f * (1 - p * c)),
                  (d = f * (1 - p * (1 - c))),
                  a)
                ) {
                  case 0:
                    (i = f), (r = d), (s = l);
                    break;
                  case 1:
                    (i = u), (r = f), (s = l);
                    break;
                  case 2:
                    (i = l), (r = f), (s = d);
                    break;
                  case 3:
                    (i = l), (r = u), (s = f);
                    break;
                  case 4:
                    (i = d), (r = l), (s = f);
                    break;
                  default:
                    (i = f), (r = l), (s = u);
                }
            }
            return { red: i, green: r, blue: s };
          },
        }
      )),
      (o.gConstraints.UnitPoint = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Base class for all unit point constraints',
          inherits: 'Constraint',
          usage: { abstract: !0, kinds: ['Point'] },
        },
        state: {},
        kMinUnitPointDistanceFromOrigin: 0.1,
        unitPointDeltaX: function() {
          return 0;
        },
        unitPointDeltaY: function() {
          return 0;
        },
        unitPointOrigin: function() {
          return this.parents.origin;
        },
        constrain: function() {
          var e = this.unitPointOrigin();
          this.geom.loc = o.GeometricPoint(
            e.geom.loc.getX() + this.unitPointDeltaX(),
            e.geom.loc.getY() + this.unitPointDeltaY()
          );
        },
      })),
      (o.gConstraints.ColorizeUnivariate = o.makeClass(
        o.gConstraints.Colorize,
        {
          doc: {
            description:
              'Defines a new GObject that is coincident to another GObject, but colored differently.',
            inherits: 'Colorize',
            refspec: {
              gspRef: 'Colorization_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the parent measures exist and are finite.',
            properties: {
              parents: {
                description: '',
                properties: {
                  color: {
                    description:
                      'For a univariate parameterization, the color value.',
                    kind: 'Measure',
                  },
                },
              },
            },
          },
          determineExists: function() {
            var e = this.getParent('color');
            return !(!e || !o.math.isFiniteScalar(e.uValue));
          },
          convertToColor: function() {
            var e = this.getParent('color'),
              t = e && e.uValue;
            if (!o.math.isFiniteScalar(t)) return null;
            var n,
              i,
              r,
              s,
              a = 3800,
              c = 5100,
              l = 6450,
              u = 4400,
              d = 7800,
              h = 3850,
              p = 6750,
              f = 0,
              m = 0,
              g = 0;
            return (
              (r = this.normalizeColorParameter(t)),
              'UnivariateHue' === this.colorModel
                ? ((i = h + r * (p - h)),
                  u > i && i > a
                    ? ((g = 1), (f = (u - i) / (u - a)))
                    : c > i
                    ? ((s = (c - i) / (c - u)),
                      (m = 1 - s * s),
                      (s = (i - u) / (c - u)),
                      (g = 1 - s * s))
                    : l > i
                    ? ((s = (i - c) / (l - c)),
                      (m = 1 - s * s),
                      (s = (l - i) / (l - c)),
                      (f = 1 - s * s))
                    : d > i
                    ? (f = 1)
                    : ((f = 1), (m = 1), (g = 1)),
                  (n = i > 7e3 ? 0.3 + (0.7 * (d - i)) / 800 : 1))
                : ((f = 1), (m = 1), (g = 1), (n = r)),
              { red: f * n, green: m * n, blue: g * n }
            );
          },
        }
      )),
      (o.gConstraints.AxisDist = o.makeClass(o.gConstraints.Line, {
        doc: {
          description: 'An axis determined by origin and unitPoint.',
          inherits: 'Line',
          refspec: { gspRef: 'DistAxis_C' },
          usage: { abstract: !0, kinds: ['Axis'] },
          existenceRule:
            'Exists iff the parent origin point and unitPoint exists.',
          properties: {
            parents: {
              description: '',
              properties: {
                origin: {
                  description: 'The origin of the axis',
                  kind: 'Point',
                },
                unitPoint: {
                  description: 'The unit point defines one unit along the axis',
                  kind: 'Point',
                },
                p0: { suppressed: !0 },
                p1: { suppressed: !0 },
              },
            },
          },
        },
        getStraightP0: function() {
          return this.geom.p0;
        },
        getStraightP1: function() {
          return this.geom.p1;
        },
        constrain: function e() {
          var t = 100,
            n = this.geom.unit.subtract(this.geom.origin),
            i = n.multiply(t / n.vLength());
          (i.y = -i.getY()),
            (this.geom.p0 = this.geom.origin.subtract(i)),
            (this.geom.p1 = this.geom.origin.add(i)),
            (e.base || arguments.callee.base).call(this);
        },
        getParentalNameMFS: function(e) {
          var t = this.getParent('origin');
          return o.mfs.makeHorizontalMFS(
            o.mfs.makeTextMFS('axis '),
            t.getNameMFS(e)
          );
        },
        canMergeTo: function(e) {
          function t(e) {
            return 'CoordSys' === e.kind;
          }
          var n,
            i,
            r = this.getParent('origin'),
            s = e.getParent('unitPoint'),
            o = this.getParent('origin'),
            a = e.getParent('unitPoint');
          return e.constraint !== this.constraint ||
            r !== s ||
            o !== a ||
            this.orientation !== e.orientation
            ? !1
            : ((n = this.children.filter(t)),
              (i = e.children.filter(t)),
              1 === n.length && 1 === i.length && n[0] === i[0]);
        },
      })),
      (o.gConstraints.ArcSector = o.makeClass(o.gConstraints.ArcInterior, {
        doc: {
          description:
            'Defines an arc sector, bounded by the arc and by the radii to the two endpoints of the arc',
          inherits: 'ArcInterior',
          usage: { abstract: !1 },
        },
      })),
      (o.gConstraints.ArcSegment = o.makeClass(o.gConstraints.ArcInterior, {
        doc: {
          description:
            'Defines a arc segment, bounded by the arc and by the chord connecting the two endpoints of the arc.',
          inherits: 'ArcInterior',
          usage: { abstract: !1 },
        },
      })),
      (o.gConstraints.DilateFixFactor = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Defines a new GObject as a dilation about a point of a GObject by a fixed factor.',
          inherits: 'Transform',
          refspec: { gspRef: 'DilatefR_C' },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the source object and the center point exists. For dilations of non-points, existence also requires that the dilation factor be non-zero.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-DilateFixFactor_export.json',
          properties: {
            parents: {
              description: '',
              properties: {
                center: {
                  description: 'The center of the dilation',
                  kind: 'Point',
                },
              },
            },
            scaleFactor: {
              description: 'A scale factor.',
              type: 'Number',
              required: !1,
            },
          },
        },
        scaleFactor: 0,
        determineExists: function() {
          var e = this.getScaleFactor();
          return o.math.isFiniteScalar(e) && ('Point' === this.kind || 0 !== e);
        },
        getScaleFactor: function() {
          return this.scaleFactor;
        },
        getPivot: function() {
          return this.getParent('center').geom.loc;
        },
        getTransform: function() {
          var e = this;
          return function(t) {
            return t.scale(e.getPivot(), e.getScaleFactor());
          };
        },
        getScalarTransform: function() {
          var e = this;
          return function(t) {
            return Math.abs(t * e.getScaleFactor());
          };
        },
        getScaleText: function() {
          var e = this.sQuery.sketch.preferences,
            t = o.units.findUnit(e.units.scalar),
            n = Math.pow(10, e.precision.scalar),
            i = Math.round(this.scaleFactor * t.conversionFromBase * n) / n;
          return (0 > i ? '–' : '') + Math.abs(i) + t.symbol;
        },
        makeFnLabelPrefix: function(e, t) {
          var n = this.getParentLabel('center', t),
            i = 'D';
          return (
            'namedByFullFn' === e &&
              (i += '[' + n + ',' + this.getScaleText(t) + ']'),
            i
          );
        },
      })),
      (o.gConstraints.AxisExternalDist = o.makeClass(o.gConstraints.AxisDist, {
        doc: {
          description:
            'An axis determined by origin and parental unit distance.',
          inherits: 'AxisDist',
          refspec: {
            gspRef: 'ExternalDistAxis_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, ExternalDistAxis_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Axis'] },
          existenceRule:
            'Exists iff the parent origin point exists and distance parent exists and is positive.',
          properties: {
            parents: {
              description: '',
              properties: {
                unitDistance: {
                  description: 'A measure or segment',
                  kind: 'Measure|Straight',
                },
                unitPoint: { suppressed: !0 },
              },
            },
          },
        },
        constrain: function e() {
          var t = this.getParent('unitDistance'),
            n = this.getParent('origin').geom.loc,
            i = t.pathLength ? t.pathLength() : t.value,
            r = 0,
            s = 0;
          return isNaN(i) || 0 >= i
            ? void (this.state.exists = !1)
            : ('horizontal' === this.orientation && (r = i),
              'vertical' === this.orientation && (s = -i),
              (this.geom.origin = o.GeometricPoint(n.getX(), n.getY())),
              (this.geom.unit = o.GeometricPoint(n.getX() + r, n.getY() + s)),
              void (e.base || arguments.callee.base).call(this));
        },
      })),
      (o.gConstraints.UnitPointExternalRectangle = o.makeClass(
        o.gConstraints.UnitPoint,
        {
          doc: {
            description:
              'A unit point displaced perpendicularly from the origin of an axis by a given distance.',
            inherits: 'UnitPoint',
            refspec: {
              gspRef: 'ExternalRectangleUnitPoint_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ExternalRectangleUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent axis exists.',
            properties: {
              parents: {
                description: '',
                properties: {
                  axis: {
                    description:
                      'The Axis for which this point is the unit point',
                    kind: 'Axis',
                  },
                },
              },
              unitDistance: {
                description:
                  'unit distance from grand-parental origin in pixels',
                type: 'Number',
              },
            },
          },
          constrain: function() {
            var e = this.getParent('axis'),
              t = e.geom.origin.getX(),
              n = e.geom.origin.getY(),
              i = e.geom.unit.getX() - t,
              r = e.geom.unit.getY() - n,
              s = this.unitDistance;
            (i = i > 0 ? 1 : 0 === i ? 0 : -1),
              (r = r > 0 ? 1 : 0 === r ? 0 : -1),
              (i *= s),
              (r *= s),
              (this.geom.loc = o.GeometricPoint(t + r, n - i));
          },
        }
      )),
      (o.gConstraints.UnitPointExternalSquare = o.makeClass(
        o.gConstraints.UnitPoint,
        {
          doc: {
            description:
              'A unit point displaced perpendicularly from the origin of an axis by the unit distance of that axis.',
            inherits: 'UnitPoint',
            refspec: { gspRef: 'ExternalSquareUnitPoint_C' },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the parent origin point exists and distance parent exists and is positive.',
            properties: {
              parents: {
                description: '',
                properties: {
                  axis: {
                    description:
                      'The Axis for which this point is the unit point',
                    kind: 'Axis',
                  },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('axis'),
              t = e.geom.origin.getX(),
              n = e.geom.origin.getY(),
              i = e.geom.unit.getX() - t,
              r = e.geom.unit.getY() - n;
            this.geom.loc = o.GeometricPoint(t + r, n - i);
          },
        }
      )),
      (o.gConstraints.HorizontalUnitPoint = o.makeClass(
        o.gConstraints.UnitPoint,
        {
          doc: {
            description:
              'A unit point of a horizontal <span class="kind">Axis</span>.',
            inherits: 'UnitPoint',
            refspec: {
              gspRef: 'HorizontalUnitPoint_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, HorizontalUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent origin point exists.',
            properties: {
              value: {
                description:
                  'horizontal displacement from parental origin in pixels.',
                type: 'Number',
              },
              parents: {
                description: '',
                properties: {
                  origin: {
                    description: 'origin point of related axis.',
                    kind: 'Point',
                  },
                },
              },
            },
          },
          value: 20,
          unitPointDeltaX: function() {
            return this.value;
          },
          transform: function(e, t) {
            var n = this.unitPointOrigin(),
              i = t.geom.loc.copy();
            t.affine.transform(i),
              (this.value = Math.max(
                this.kMinUnitPointDistanceFromOrigin,
                i.getX() - n.geom.loc.getX()
              ));
          },
        }
      )),
      (o.gConstraints.AxisInternalDist = o.makeClass(o.gConstraints.AxisDist, {
        doc: {
          description: 'An axis determined by origin and unitPoint.',
          inherits: 'AxisDist',
          refspec: { gspRef: 'InternalDistAxis_C' },
          usage: { abstract: !1, kinds: ['Axis'] },
          existenceRule:
            'Exists iff the parent origin point and unitPoint exists.',
          properties: {
            parents: {
              description: '',
              properties: {
                origin: { description: '', genus: 'Point' },
                unitPoint: { description: '', genus: 'Point' },
              },
            },
          },
        },
        constrain: function e() {
          var t = this.getParent('origin').geom.loc,
            n = this.getParent('unitPoint').geom.loc;
          (this.geom.origin = o.GeometricPoint(t.getX(), t.getY())),
            (this.geom.unit = o.GeometricPoint(n.getX(), n.getY())),
            (e.base || arguments.callee.base).call(this);
        },
      })),
      (o.gConstraints.UnitPointInternalRectangle = o.makeClass(
        o.gConstraints.UnitPoint,
        {
          doc: {
            description:
              'A unit point displaced perpendicularly from the origin of a parental axis of a unit point by a given distance.',
            inherits: 'UnitPoint',
            refspec: {
              gspRef: 'InternalRectangleUnitPoint_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, InternalRectangleUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent unitPoint exists.',
            properties: {
              parents: {
                description: '',
                properties: { unitPoint: { description: '', kind: 'Point' } },
              },
              unitDistance: {
                description:
                  'unit distance from grand-parental origin in pixels',
                type: 'Number',
              },
            },
          },
          transform: function(e, t) {
            var n = this.getParent('unitPoint'),
              i = n.getParent('origin'),
              r = t.geom.loc.copy();
            t.affine.transform(r),
              (this.unitDistance = Math.max(
                this.kMinUnitPointDistanceFromOrigin,
                i.geom.loc.getY() - r.getY()
              ));
          },
          constrain: function() {
            var e = this.getParent('unitPoint'),
              t = e.getParent('origin'),
              n = t.geom.loc.getX(),
              i = t.geom.loc.getY(),
              r = this.unitDistance,
              s = e.geom.loc.getX() - n,
              a = e.geom.loc.getY() - i;
            (s = s > 0 ? 1 : 0 === s ? 0 : -1),
              (a = a > 0 ? 1 : 0 === a ? 0 : -1),
              (s *= r),
              (a *= r),
              (this.geom.loc = o.GeometricPoint(n + a, i - s));
          },
        }
      )),
      (o.gConstraints.UnitPointInternalSquare = o.makeClass(
        [o.gConstraints.UnitPoint, o.mixins.transformable],
        {
          doc: {
            description:
              'A unit point displaced perpendicularly from the origin of a parental axis of a unit point by the unit distance of that axis.',
            inherits: 'UnitPoint',
            refspec: {
              gspRef: 'InternalSquareUnitPoint_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, InternalSquareUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent unitPoint exists.',
            properties: {
              parents: {
                description: '',
                properties: { unitPoint: { description: '', kind: 'Point' } },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('unitPoint'),
              t = e.getParent('origin'),
              n = t.geom.loc.getX(),
              i = t.geom.loc.getY(),
              r = e.geom.loc.getX() - n,
              s = e.geom.loc.getY() - i;
            this.geom.loc = o.GeometricPoint(n + s, i - r);
          },
          getParentalNameMFS: function() {
            return o.mfs.makeTextMFS('Unit point ' + this.id);
          },
        }
      )),
      (o.gConstraints.MeasurementAbscissa = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The abscissa (x coordinate) of a point relative to a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'AbscissaM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, AbscissaM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getCoordinates(this.getParent('point'));
            (this.value = e.x), (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('point');
            return (
              t.label || t.getLabel(e),
              {
                type: 'sub',
                value: [o.mfs.makeTextMFS('x', !0), t.getNameMFS()],
              }
            );
          },
        }
      )),
      (o.gConstraints.MeasurementAnalyticSlope = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The slope of a straight relative to a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'AnalyticSlopeM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, AnalyticSlopeM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Measure'] },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  seg: { description: '', kind: 'Straight' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getParent('seg'),
              t = this.getParent('coordSys'),
              n = t.locatePoint(e.geom.p0),
              i = t.locatePoint(e.geom.p1),
              r = i.subtract(n);
            (this.value = 0 === r.getX() ? NaN : r.getY() / r.getX()),
              (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            return o.mfs.makeHorizontalMFS(
              o.mfs.makeTextMFS('Slope '),
              this.getParent('seg').getNameMFS(e)
            );
          },
        }
      )),
      (o.gConstraints.GeometricSlope = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'The slope of a straight.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'GeometricSlopeM_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, GeometricSlopeM_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Measure'] },
          existenceRule: 'Exists iff the parents exist.',
          properties: {
            parents: {
              description: '',
              properties: { straight: { description: '', kind: 'Straight' } },
            },
          },
        },
        constrain: function() {
          var e = this.getParent('straight'),
            t = e.getP0(),
            n = e.getP1(),
            i = n.subtract(t);
          (this.value = 0 === i.getX() ? NaN : -(i.getY() / i.getX())),
            (this.uValue = this.value);
        },
        getParentalNameMFS: function(e) {
          return o.mfs.makeHorizontalMFS(
            o.mfs.makeTextMFS('Slope '),
            this.getParent('straight').getNameMFS(e)
          );
        },
      })),
      (o.gConstraints.MeasurementArcBase = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'The measurement of the angle of an arc. The arc is either an arc object, or a circle and points on the circle which define an arc.',
            inherits: 'Constraint',
            usage: { abstract: !0, kinds: ['Measure'] },
            existenceRule:
              'Exists iff the parents and are non-coincident exist.',
          },
          getParentalArc: function() {
            throw o.createError(
              'MeasurementArcBase.getParentalArc: Derived class must override!'
            );
          },
          getArcNameMFS: function(e) {
            throw o.createError(
              'MeasurementArcBase.getParentalArc: Derived class must override!'
            );
          },
          measureArcAngle: function() {
            var e = this.getParentalArc(),
              t = e.arcAngle,
              n = this.sQuery().prefs().units.angle;
            (this.value = t), (this.uValue = o.units.convert(t, 'radians', n));
          },
          measureArcLength: function() {
            var e = this.getParentalArc(),
              t = e.getCache(e.genus).arcLength || e.arcLength,
              n = this.sQuery().prefs().units.length;
            (this.value = t), (this.uValue = o.units.convert(t, 'pixels', n));
          },
          getAngleNameMFS: function(e) {
            return o.mfs.makeHorizontalMFS(
              o.mfs.makeTextMFS('m ', !0),
              this.getArcNameMFS(e)
            );
          },
          getLengthNameMFS: function(e) {
            return o.mfs.makeHorizontalMFS(
              o.mfs.makeTextMFS(o.Strings.loc('GSP.Measure.arcLength') + ' '),
              this.getArcNameMFS(e)
            );
          },
        }
      )),
      (o.gConstraints.MeasurementArc = o.makeClass(
        o.gConstraints.MeasurementArcBase,
        {
          doc: {
            description: 'The measurement of the angle of an arc.',
            inherits: 'MeasurementArcBase',
            existenceRule:
              'Exists iff the parents and are non-coincident exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  arc: { description: 'The arc to be measured', kind: 'Arc' },
                },
              },
            },
          },
          getParentalArc: function() {
            var e = this.getParent('arc');
            return e && e.geom.arc;
          },
          getArcNameMFS: function(e) {
            var t = this.getParent('arc');
            return t && t.getParentalNameMFS(e);
          },
        }
      )),
      (o.gConstraints.MeasurementArcAngle = o.makeClass(
        o.gConstraints.MeasurementArc,
        {
          doc: {
            description: 'The measurement of an angle defined by three points.',
            inherits: 'MeasurementArc',
            refspec: {
              gspRef: 'ArcAngle3PointsMeasure_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ArcAngle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          unitPowers: { angle: 1 },
          constrain: function() {
            this.measureArcAngle();
          },
          getParentalNameMFS: function(e) {
            return this.getAngleNameMFS(e);
          },
        }
      )),
      (o.gConstraints.MeasurementArcLength = o.makeClass(
        o.gConstraints.MeasurementArc,
        {
          doc: {
            description:
              'The measurement of the length of a <span class="kind">Arc</span>s.',
            inherits: 'MeasurementArc',
            refspec: {
              gspRef: 'ArcLengthM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ArcLengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          unitPowers: { length: 1 },
          constrain: function() {
            this.measureArcLength();
          },
          getParentalNameMFS: function(e) {
            return this.getLengthNameMFS(e);
          },
        }
      )),
      (o.gConstraints.MeasurementArcOnCircle = o.makeClass(
        o.gConstraints.MeasurementArcBase,
        {
          doc: {
            description:
              'The measurement of the angle of an arc. The arc is defined by a circle and points on the circle which define an arc.',
            inherits: 'MeasurementArcBase',
            existenceRule:
              'Exists iff the parents and are non-coincident exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  circle: {
                    description: 'Circle containing arc',
                    kind: 'Circle',
                  },
                  p0: { description: 'Initial point', kind: 'Point' },
                  p1: {
                    description: 'Final point (or if p2 is set, middle point)',
                    kind: 'Point',
                  },
                  p2: {
                    description: 'Final point',
                    kind: 'Point',
                    required: !1,
                  },
                },
              },
            },
          },
          getParentalArc: function() {
            var e, t, n, i, r, s;
            return (
              (s = this.getParent('circle')),
              (t = this.getParent('p0').geom.loc),
              (n = this.getParent('p1').geom.loc),
              (i = this.getParent('p2')),
              i
                ? ((r = o.Geom.ThreePointCollinear(t, i.geom.loc, n)),
                  (e = o.GeometricArc.FromCenterAndEndpoints(
                    s.geom.c,
                    t,
                    i.geom.loc,
                    r.orientation
                  )))
                : ((r = o.Geom.ThreePointCollinear(t, s.geom.c, n)),
                  (e = o.GeometricArc.FromCenterAndEndpoints(
                    s.geom.c,
                    t,
                    n,
                    r.orientation
                  ))),
              e
            );
          },
          measureArcAngle: function() {
            var e = this.getParentalArc(),
              t = e.arcAngle,
              n = this.sQuery().prefs().units.angle;
            'deg' !== n && (t *= -e.orientation),
              (this.value = t),
              (this.uValue = o.units.convert(t, 'radians', n));
          },
          getArcNameMFS: function(e) {
            var t,
              n = this.getParent('circle'),
              i = this,
              r = { type: 'style', value: [{ code: 'fontStyle', value: '2' }] },
              s = [];
            ['p0', 'p1', 'p2'].forEach(function(n) {
              (t = i.getParent(n)), t && s.push(t.getNameMFS(e));
            }),
              r.value.push(o.mfs.makeHorizontalNamesMFS(s)),
              (r = { type: 'overbar', variant: 5, value: r });
            var a = o.mfs.makeHorizontalMFS(
              { type: 'symbol', value: '100' },
              n.getParentalNameMFS(e)
            );
            return o.mfs.makeHorizontalMFS(r, o.mfs.makeTextMFS(' on '), a);
          },
        }
      )),
      (o.gConstraints.MeasurementArcOnCircleAngle = o.makeClass(
        o.gConstraints.MeasurementArcOnCircle,
        {
          doc: {
            description:
              'The measurement of the length of a <span class="kind">Arc</span>s.',
            inherits: 'MeasurementArcOnCircle',
            refspec: {
              gspRef: 'ArcAngle3PointsMeasure_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ArcAngle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          unitPowers: { angle: 1 },
          constrain: function() {
            this.measureArcAngle();
          },
          getParentalNameMFS: function(e) {
            return this.getAngleNameMFS(e);
          },
        }
      )),
      (o.gConstraints.MeasurementArcOnCircleLength = o.makeClass(
        o.gConstraints.MeasurementArcOnCircle,
        {
          doc: {
            description:
              'The measurement of the length of a <span class="kind">Arc</span>s.',
            inherits: 'MeasurementArcOnCircle',
            refspec: {
              gspRef: 'ArcLengthM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, ArcLengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          unitPowers: { length: 1 },
          constrain: function() {
            this.measureArcLength();
          },
          getParentalNameMFS: function(e) {
            return this.getLengthNameMFS(e);
          },
        }
      )),
      (o.gConstraints.MeasurementCoordinateDistance = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The distance between two points relative to a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'CoordinateDistanceM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, CoordinateDistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: {
                    description:
                      'The point from which distance is to be measured',
                    kind: 'Point',
                  },
                  p1: {
                    description:
                      'The point to which distance is to be measured',
                    kind: 'Point',
                  },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getCoordinates(this.getParent('p0')),
              t = this.getCoordinates(this.getParent('p1'));
            (this.value = t.subtract(e).vLength()), (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            var t, n, i, r;
            return (
              (t = this.getParent('p0')),
              (n = this.getParent('p1')),
              t.label || t.getLabel(e),
              n.label || n.getLabel(e),
              (i = t.getNameMFS()),
              (r = n.getNameMFS()),
              o.mfs.makeHorizontalNamesMFS([i, r])
            );
          },
        }
      )),
      (o.gConstraints.MeasurementOrdinate = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The ordinate (y coordinate) of a point relative to a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'OrdinateM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, OrdinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getCoordinates(this.getParent('point'));
            (this.value = e.y), (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            var t = this.getParent('point');
            return (
              t.label || t.getLabel(e),
              {
                type: 'sub',
                value: [o.mfs.makeTextMFS('y', !0), t.getNameMFS()],
              }
            );
          },
        }
      )),
      (o.gConstraints.MeasurementPolarDirection = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The angle (theta-value of the polar coordinates) of a point relative to the x-axis of a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'PolarDirectionM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PolarDirectionM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          unitPowers: { angle: 1 },
          constrain: function(e) {
            var t,
              n = this.getCoordinates(this.getParent('point')),
              i = e.preferences.units.angle;
            (t = Math.atan2(n.getY(), n.getX())),
              (this.value = t),
              (this.uValue = o.units.convert(t, 'radians', i));
          },
          getParentalNameMFS: function(e) {
            return {
              type: 'sub',
              value: [
                o.mfs.makeItalicMFS({ type: 'symbol', value: '71' }),
                this.getParent('point').getNameMFS(e),
              ],
            };
          },
        }
      )),
      (o.gConstraints.MeasurementPolarDistance = o.makeClass(
        o.gConstraints.MeasurementCoordinateBased,
        {
          doc: {
            description:
              'The distance from the origin (r-value of the polar coordinates) of a point relative to a coordinate system.',
            inherits: 'MeasurementCoordinateBased',
            refspec: {
              gspRef: 'PolarDistanceM_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PolarDistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parents exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  point: { description: '', kind: 'Point' },
                  coordSys: { description: '', kind: 'CoordSys' },
                },
              },
            },
          },
          constrain: function() {
            var e = this.getCoordinates(this.getParent('point'));
            (this.value = e.vLength()), (this.uValue = this.value);
          },
          getParentalNameMFS: function(e) {
            return {
              type: 'sub',
              value: [
                o.mfs.makeTextMFS('r', !0),
                this.getParent('point').getNameMFS(e),
              ],
            };
          },
        }
      )),
      (o.gConstraints.PointOnPolygonEdge = o.makeClass(
        o.gConstraints.PointOnPathBase,
        {
          doc: {
            description: 'A point on a <span class="kind">Polygon</span>.',
            inherits: 'Constraint',
            refspec: {
              gspRef: 'OnPath_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, OnPath_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule: 'Exists iff the parent param and path exist.',
            properties: {
              baseVertex: {
                description: 'index of initial vertex of edge containing point',
                type: 'Number',
              },
              baseValue: {
                description:
                  'parameterized location on edge starting at baseVertex',
                type: 'Number',
              },
              parents: {
                description: '',
                properties: { path: { description: '', kind: 'Polygon' } },
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-PointOnPath_export.json',
          },
          value: 0.5,
          isPathValuePrimary: !1,
          updateValue: function(e) {
            (this.value = e - Math.floor(e)), (this.isPathValuePrimary = !0);
            var t = this.getParent('path'),
              n = t.mapPathValueToCharacteristic(this.value);
            (this.baseVertex = n.baseVertex), (this.baseValue = n.baseValue);
          },
          transform: function(e, t) {
            var n = this.getParent('path'),
              i = t.geom.loc.copy();
            t.affine.transform(i),
              this.updateValue(n.mapPositionToPathValue(i));
          },
          constrain: function() {
            var e = this.getParent('path'),
              t = e.geom.points,
              n = t[this.baseVertex],
              i = t[(this.baseVertex + 1) % t.length];
            (this.geom.loc = n.add(i.subtract(n).multiply(this.baseValue))),
              this.isPathValuePrimary ||
                (this.value = e.mapPositionToPathValue(this.geom.loc));
          },
        }
      )),
      (o.gConstraints.RotateAngleMarker = o.makeClass(o.gConstraints.Rotate, {
        doc: {
          description:
            'Defines a new GObject as a rotation of a GObject by the measure of a marked angle about a pivot point.',
          inherits: 'Rotate',
          refspec: {
            gspRef: 'RotateByMarkedAngleMarker_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, RotateByMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the parent object and the three angle points exist.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-RotateAngleMarker_export.json',
          properties: {
            parents: {
              description: '',
              properties: { angle: { description: '', kind: 'AngleMarker' } },
            },
            angle: { suppressed: !0 },
          },
        },
        getAngle: function() {
          var e;
          return (e = this.getParent('angle')), e.value;
        },
        getAngleText: function(e) {
          return this.getAngleMarkerText('angle', e);
        },
      })),
      (o.gConstraints.RotateMeasureAngle = o.makeClass(o.gConstraints.Rotate, {
        doc: {
          description:
            'Defines a new GObject as a rotation of a GObject by a measure about a pivot point, p0.',
          inherits: 'Rotate',
          refspec: {
            gspRef: 'RotateByMarkedAngleMeasure_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, RotateByMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the parent object and the three angle points exist.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-RotateMeasureAngle_export.json',
          properties: {
            parents: {
              description: '',
              properties: { angle: { description: '', kind: 'Measure' } },
            },
            angle: { suppressed: !0 },
          },
        },
        getAngle: function() {
          var e;
          return (e = this.getParent('angle')), -e.value;
        },
        getAngleText: function(e) {
          return this.getParentLabel('angle', e);
        },
      })),
      (o.gConstraints.Rotate3 = o.makeClass(o.gConstraints.Rotate, {
        doc: {
          description:
            'Defines a new GObject as a rotation of a GObject about a pivot point, p0, by an angle from three points.',
          inherits: 'Rotate',
          refspec: {
            gspRef: 'Rotate3A_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Rotate3A_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the parent object and the three angle points exist.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Rotation3_export.json',
          properties: {
            parents: {
              description: '',
              properties: {
                A: { description: '', kind: 'Point' },
                B: { description: '', kind: 'Point' },
                C: { description: '', kind: 'Point' },
              },
            },
            angle: { suppressed: !0 },
          },
        },
        getAngle: function() {
          var e, t, n;
          return (
            (e = this.getParent('A').geom.loc),
            (t = this.getParent('B').geom.loc),
            (n = this.getParent('C').geom.loc),
            o.GeometricPoint.threePointAngle(e, t, n)
          );
        },
        getAngleText: function(e) {
          return this.get3PtAngleText('A', 'B', 'C', e);
        },
      })),
      (o.gConstraints.AxisUnitCircle = o.makeClass(o.gConstraints.AxisDist, {
        doc: {
          description: 'An axis determined a unit circle.',
          inherits: 'AxisDist',
          refspec: {
            gspRef: 'UnitCircleAxis_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, UnitCircleAxis_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Axis'] },
          existenceRule:
            'Exists iff the parent circle exists and has positive radius.',
          properties: {
            parents: {
              description: '',
              properties: {
                circle: { description: '', kind: 'Circle' },
                origin: { suppressed: !0 },
                unitPoint: { suppressed: !0 },
              },
            },
          },
        },
        constrain: function e() {
          var t = this.getParent('circle'),
            n = t.geom.r,
            i = 0,
            r = 0;
          return (
            (this.geom.origin = t.geom.c),
            isNaN(n) || 0 >= n
              ? void (this.state.exists = !1)
              : ('horizontal' === this.orientation && (i = n),
                'vertical' === this.orientation && (r = -n),
                (this.geom.unit = o.GeometricPoint(
                  this.geom.origin.getX() + i,
                  this.geom.origin.getY() + r
                )),
                void (e.base || arguments.callee.base).call(this))
          );
        },
      })),
      (o.gConstraints.AngleMarker = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'Marks the angle between two lines.',
          inherits: 'Constraint',
          refspec: {},
          usage: { abstract: !0, kinds: ['AngleMarker'] },
          existenceRule:
            'Exists iff parents exist, and define a non-zero angle.',
          properties: {
            parents: {
              properties: {
                p0: { description: 'A point on an angle edge', kind: 'Point' },
                p1: {
                  description: 'The focal point of an angle',
                  kind: 'Point',
                },
                p2: {
                  description: 'A point on the other angle edge',
                  kind: 'Point',
                },
              },
            },
          },
        },
        makeArcs: function(e, t, i, r, s) {
          var a,
            c,
            l = e.subtract(t);
          return Math.abs(this.value) < 4e-4
            ? ((this.geom.arc = n), void (this.state.exists = !0))
            : void (l.isZeroLength()
                ? (this.state.exists = !1)
                : ((a = l.multiply(this.style['inner-radius'] / l.vLength())),
                  (l = i.subtract(t)),
                  l.isZeroLength()
                    ? (this.state.exists = !1)
                    : ((c = l.multiply(
                        this.style['inner-radius'] / l.vLength()
                      )),
                      (this.geom.arc = o.GeometricArc.FromCenterAndEndpoints(
                        t,
                        t.add(a),
                        t.add(c),
                        s
                      )),
                      (this.state.exists = this.geom.arc.exists))));
        },
        getParentalNameMFS: function(e) {
          return this.getAngleMarkerMFS(e, !1);
        },
        constrainedAngle: function(e, t) {
          return e;
        },
        constrain: function() {
          var e,
            t = this.getParent('p0').geom.loc,
            n = this.getParent('p1').geom.loc,
            i = this.getParent('p2').geom.loc,
            r = o.GeometricPoint.threePointAngle(t, n, i),
            s = o.Geom.ThreePointCollinear(t, n, i);
          s.isStraight ||
            (r + Math.PI < o.math.SIMPLE_PI_THRESHOLD && (r += 2 * Math.PI)),
            (this.value = this.constrainedAngle(r, s)),
            (e = s.orientation),
            this.makeArcs(t, n, i, r, e);
        },
      })),
      (o.gConstraints.ActionButtonAnimate = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description: 'A button that moves a point on a path.',
            inherits: 'ActionButton',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            properties: {
              parents: {
                description: 'Animating objects',
                type: 'Object',
                properties: {
                  0: {
                    description:
                      'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                    kind: 'kind',
                  },
                },
                regex: /^[0-9]+$/,
              },
              animationStates: {
                description:
                  'Array of objects containing state information (rate, repeat, motionType, etc.) for each animation controlled by this button.  State information depends on the kind of animation',
                type: 'Array',
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-Animation_export.json',
          },
          animationStates: [],
          smoothInSpace: !0,
          press: function(e, t) {
            function i() {
              this.animateFunction(e) ||
                (e.MotionManager.EndMotion(this.motionID),
                e.event('EndAnimate', { button: f, id: f.id }),
                t || (f.state.pressedUp = !0));
            }
            function r() {
              var t;
              for (
                this.motionID = n,
                  f.state.isActive = f.state.motions.length > 1,
                  t = 0;
                t < f.state.motions.length;
                t++
              )
                if (this === f.state.motions[t]) {
                  f.state.motions.splice(t, 1);
                  break;
                }
              f.state.isActive || e.invalidateGeom(f);
            }
            function s(e) {
              function t(e, t, n, i, r) {
                var s,
                  o,
                  a = 0.2,
                  c = 0.3,
                  l = i - n,
                  u = t;
                return (
                  l &&
                    ((s = (e - n) / l),
                    a > s
                      ? ((o = a - s), (u += o >= c ? r : (r * o) / c))
                      : s > 1 - a &&
                        ((o = s - (1 - a)), (u -= o >= c ? r : (r * o) / c))),
                  u
                );
              }
              var n,
                i,
                r,
                s = Math.PI / 2,
                a = Date.now(),
                c = this.gobj,
                l = e.sketchRect();
              return (
                this.animContext ||
                  (this.animContext = {
                    currentAngle: 2 * Math.random() * Math.PI,
                    lastSampleTime: Date.now() - 16,
                  }),
                (r = this.animContext),
                (r.currentAngle += s * Math.random() - 0.5 * s),
                (n = this.rate * o.kWebSpeedMultiplier),
                (i = {
                  x: Math.cos(r.currentAngle) * n,
                  y: Math.sin(r.currentAngle) * n,
                }),
                (i.x = t(c.geom.loc.getX(), i.x, l.left, l.right, n)),
                (i.y = t(c.geom.loc.getY(), i.y, l.top, l.bottom, n)),
                c.transform(e, {
                  geom: c.geom,
                  affine: o.AffineTransform({
                    m00: 1,
                    m11: 1,
                    m20: i.x,
                    m21: i.y,
                  }),
                }),
                e.invalidateGeom(c),
                (r.lastSampleTime = a),
                !0
              );
            }
            function a(e, t, n) {
              function i(e, t) {
                var n,
                  i,
                  r,
                  s = e.maxValue - e.minValue,
                  a = t - e.minValue;
                return a >= 0 && s >= a
                  ? void o.signalErrorWithMessage(
                      'calculateWrappedPosition() should only be called when we need wrapping'
                    )
                  : ((r = a % s),
                    e.oscillate &&
                      ((n = a > 0 ? a - s : a),
                      (i = 1 + Math.floor(Math.abs(n / s))),
                      i % 2 === 1 && (r *= -1)),
                    r > 0
                      ? { value: e.minValue + r, direction: 1 }
                      : { value: e.maxValue + r, direction: -1 });
              }
              function r() {
                var e = c.maxValue - c.minValue;
                if (null !== c.finalValue) {
                  if (d >= e) return !0;
                  if (n.firstTime) return !1;
                  if (f) {
                    if (
                      (s >= c.finalValue && h >= c.finalValue) ||
                      (s <= c.finalValue && h <= c.finalValue)
                    )
                      return !0;
                  } else if (
                    (s >= c.finalValue && c.finalValue >= h) ||
                    (h >= c.finalValue && c.finalValue >= s)
                  )
                    return !0;
                }
                return !1;
              }
              var s,
                a,
                c = t.animContext,
                l = t.gobj,
                u = n.curSampleTime - c.lastSampleTime,
                d = t.smoothInSpace
                  ? c.stepSize
                  : c.stepSize * ((u * o.kIdealFrameRate) / 1e3),
                h = l.value,
                p = !0,
                f = !1;
              return (
                h < c.minValue && (h = c.minValue),
                h > c.maxValue && (h = c.maxValue),
                (s = h + d * c.direction),
                (s < c.minValue || s > c.maxValue) &&
                  ((a = i(c, s)),
                  (s = a.value),
                  (c.direction = a.direction),
                  (f = !0)),
                r() && ((s = c.finalValue), (p = !1)),
                l.updateValue
                  ? l.updateValue(s)
                  : o.signalErrorWithMessage(
                      'animateOneStep encountered unexpected object type'
                    ),
                e.invalidateGeom(l),
                p
              );
            }
            function c(e, t, n) {
              var i = t.animContext,
                r = !0;
              return (
                n.curSampleTime >= i.nextRandomEventTime &&
                  (t.gobj.updateValue(
                    i.minValue + Math.random() * (i.maxValue - i.minValue)
                  ),
                  e.invalidateGeom(t.gobj),
                  (i.nextRandomEventTime = n.curSampleTime + i.randomPeriod),
                  (r = i.repeat)),
                r
              );
            }
            function l(e) {
              var t,
                n = this.path,
                i = { curSampleTime: Date.now(), firstTime: !1 },
                r = n.pathLength(),
                s = n.getAnimationRange(),
                l = !0;
              if (
                (this.animContext ||
                  ((i.firstTime = !0),
                  (this.animContext = {
                    lastPathLength: 0,
                    lastSampleTime: i.curSampleTime - 1e3 / o.kIdealFrameRate,
                    stepSize: null,
                    minValue: null,
                    maxValue: null,
                    direction: 'backward' === this.motionType ? -1 : 1,
                    oscillate: 'both' === this.motionType,
                    random: 'random' === this.motionType,
                    repeat: this.repeat,
                    finalValue: null,
                    perFrameAdvanceFn: a,
                  }),
                  this.repeat ||
                    (this.animContext.finalValue = this.gobj.value),
                  this.animContext.random &&
                    ((this.animContext.randomPeriod =
                      (o.kNormalSpeedRate / this.rate) * 1e3),
                    (this.animContext.nextRandomEventTime = i.curSampleTime),
                    (this.animContext.perFrameAdvanceFn = c))),
                (t = this.animContext),
                n.state.exists &&
                  (s.min !== t.minValue ||
                    s.max !== t.maxValue ||
                    r !== t.lastPathLength))
              ) {
                var u = n.unitLength();
                t.random ||
                  (t.stepSize = Math.abs(
                    (this.rate / u) * o.kWebSpeedMultiplier
                  )),
                  (t.minValue = s.min),
                  (t.maxValue = s.max),
                  (t.lastPathLength = r);
              }
              return (
                (l = t.perFrameAdvanceFn(e, this, i)),
                (t.lastSampleTime = i.curSampleTime),
                l
              );
            }
            function u(e) {
              function t(e, t, n) {
                var i = !0,
                  r = t.animContext;
                return (
                  n.curSampleTime >= r.nextDiscreteEventTime &&
                    ((i = a(e, t, n)),
                    (r.nextDiscreteEventTime =
                      n.curSampleTime + r.discretePeriod)),
                  i
                );
              }
              var n = { curSampleTime: Date.now(), firstTime: !1 },
                i = !0;
              return (
                this.animContext ||
                  ((n.firstTime = !0),
                  (this.animContext = {
                    lastSampleTime: n.curSampleTime - 1e3 / o.kIdealFrameRate,
                    stepSize: null,
                    minValue: this.paramMinValue,
                    maxValue: this.paramMaxValue,
                    direction: 'backward' === this.motionType ? -1 : 1,
                    oscillate: 'both' === this.motionType,
                    random: 'random' === this.motionType,
                    repeat: this.repeat,
                    finalValue: null,
                    perFrameAdvanceFn: a,
                  }),
                  this.repeat ||
                    (this.animContext.finalValue = this.gobj.value),
                  this.animContext.random
                    ? ((this.animContext.randomPeriod =
                        1e3 * this.timeInterval),
                      (this.animContext.nextRandomEventTime = n.curSampleTime),
                      (this.animContext.perFrameAdvanceFn = c))
                    : this.discrete
                    ? ((this.animContext.discretePeriod =
                        1e3 * this.timeInterval),
                      (this.animContext.nextDiscreteEventTime =
                        n.curSampleTime),
                      (this.animContext.stepSize = Math.abs(this.rate)),
                      (this.animContext.perFrameAdvanceFn = t))
                    : (0 === this.timeInterval &&
                        o.signalErrorWithMessage('invalid time interval'),
                      (this.animContext.stepSize = Math.abs(
                        this.rate / (o.kIdealFrameRate * this.timeInterval)
                      )))),
                (i = this.animContext.perFrameAdvanceFn(e, this, n)),
                (this.animContext.lastSampleTime = n.curSampleTime),
                i
              );
            }
            var d,
              h,
              p,
              f = this;
            if (this.state.isActive) {
              for (
                o.log('Canceling animation ' + this.id), d = 0;
                d < this.state.motions.length;
                d++
              )
                e.MotionManager.EndMotion(this.state.motions[d].motionID);
              e.event('EndAnimate', { button: f, id: f.id }),
                t || (f.state.pressedUp = !0);
            } else {
              for (
                o.log('Started animation ' + this.id),
                  this.state.motions = [],
                  this.state.isActive = !0,
                  d = 0;
                d < this.numParents();
                d++
              )
                (p = this.parentsList[d]),
                  (h = {
                    applyMotion: i,
                    completeMotion: r,
                    animateFunction: n,
                    controlList: e.Bap.createControlList([p]),
                    gobj: p,
                    rate: this.animationStates[d].rate,
                    repeat: this.animationStates[d].repeat,
                    motionType: this.animationStates[d].motionType,
                    smoothInSpace: this.smoothInSpace,
                  }),
                  p.isFreePointOnPath
                    ? ((h.path = p.parents.path), (h.animateFunction = l))
                    : 'Point' === h.gobj.kind
                    ? (h.animateFunction = s)
                    : 'Expression' === h.gobj.kind &&
                      ((h.animateFunction = u),
                      (h.isValueChangingMotion = !0),
                      (h.timeInterval = this.animationStates[d].timeInterval),
                      (h.paramMinValue = this.animationStates[
                        d
                      ].lowerParamBound),
                      (h.paramMaxValue = this.animationStates[
                        d
                      ].upperParamBound),
                      (h.discrete = this.animationStates[d].discrete)),
                  e.event('StartAnimate', { button: f, id: f.id }),
                  (h.motionID = e.MotionManager.StartMotion(h)),
                  this.state.motions.push(h),
                  t || (f.state.pressedDown = !0);
              e.invalidateGeom(this);
            }
          },
        }
      )),
      (o.gConstraints.CoordSys = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'An coordinate system determined by two axes.',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'CoordSys_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, CoordSys_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['CoordSys'] },
          existenceRule: 'Exists iff the parent axes exists.',
          properties: {
            parents: {
              description: '',
              properties: {
                axisX: { description: 'The horizontal axis', kind: 'Axis' },
                axisY: { description: 'The vertical axis', kind: 'Axis' },
              },
            },
          },
        },
        isVisible: function() {
          return (
            !this.style.hidden ||
            (!this.getParent('axisX').style.hidden &&
              !this.getParent('axisY').style.hidden)
          );
        },
        constrain: function() {
          var e,
            t = this.getParent('axisX'),
            n = this.getParent('axisY');
          (this.geom.origin = t.geom.origin),
            (this.geom.unit0 = t.geom.unit),
            (this.geom.unit1 = n.geom.unit),
            (e = {
              x: this.geom.unit0.x - this.geom.origin.x,
              y: -(this.geom.unit1.y - this.geom.origin.y),
            }),
            (this.geom.gridSpacing =
              'polar' === this.shape
                ? t.getPolarSpacing(e).pixelsBetweenTicks
                : {
                    x: t.getLineSpacing().pixelsBetweenTicks,
                    y: n.getLineSpacing().pixelsBetweenTicks,
                  });
        },
      })),
      (o.gConstraints.Dilate2SegRatio = o.makeClass(
        o.gConstraints.DilateFixFactor,
        {
          doc: {
            description:
              'Defines a new GObject as a dilation about a point of a GObject by the ratio of the lengths of two segments.',
            inherits: 'DilateFixFactor',
            refspec: {
              gspRef: 'Dilate2R_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Dilate2R_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object, the center, and the two segments all exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Dilate2SegRatio_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  seg0: {
                    description:
                      'Segment defining the numerator of the scale ratio',
                    kind: 'Straight',
                  },
                  seg1: {
                    description:
                      'Segment defining the denominator of the scale ratio',
                    kind: 'Straight',
                  },
                },
              },
              scaleFactor: { suppressed: !0 },
            },
          },
          getScaleFactor: function() {
            var e = this.getParent('seg0'),
              t = this.getParent('seg1'),
              n = e.pathLength() / t.pathLength();
            return n;
          },
          getScaleText: function(e) {
            var t = this.getParent('seg0'),
              n = this.getParent('seg1');
            return (!t.label || !n.label) &&
              t.getParentLabel('p0') &&
              t.getParentLabel('p1') &&
              n.getParentLabel('p0') &&
              n.getParentLabel('p1')
              ? t.getVisibleParentLabel('p0', e) +
                  t.getVisibleParentLabel('p1', e) +
                  '/' +
                  n.getVisibleParentLabel('p0', e) +
                  n.getVisibleParentLabel('p1', e)
              : this.getVisibleParentLabel('seg0', e) +
                  '/' +
                  this.getVisibleParentLabel('seg1', e);
          },
        }
      )),
      (o.gConstraints.Dilate3PtRatio = o.makeClass(
        o.gConstraints.DilateFixFactor,
        {
          doc: {
            description:
              'Defines a new GObject as a dilation about a point of a GObject by a ratio of three points, A, B, C. The ratio is |AB|/|AC|.',
            inherits: 'DilateFixFactor',
            refspec: {
              gspRef: 'Dilate3R_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, Dilate3R_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the parent object, the three angle points exist and the |AB| evaluates to a non-zero length.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Dilate3PtRatio_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  A: {
                    description: 'First control point of the line',
                    kind: 'Point',
                  },
                  B: {
                    description: 'Second control point of the line',
                    kind: 'Point',
                  },
                  C: {
                    description: 'The point that is mapped to the line',
                    kind: 'Point',
                  },
                },
              },
              scaleFactor: { suppressed: !0 },
            },
          },
          getScaleFactor: function() {
            var e = this.getParent('A').geom.loc,
              t = this.getParent('B').geom.loc,
              n = this.getParent('C').geom.loc;
            return o.GeometricPoint.mapPointToLine(e, t, n).param;
          },
          getScaleText: function(e) {
            var t = this.getVisibleParentLabel('A', e),
              n = this.getVisibleParentLabel('B', e),
              i = this.getVisibleParentLabel('C', e);
            return t + i + '/' + t + n;
          },
        }
      )),
      (o.gConstraints.DilateMeasureFactor = o.makeClass(
        o.gConstraints.DilateFixFactor,
        {
          doc: {
            description:
              'Defines a new GObject as a dilation about a point of a GObject by a measurement.',
            inherits: 'DilateFixFactor',
            refspec: {
              gspRef: 'DilatemR_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, DilatemR_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object, the center point and the measurement exist and the measurement evaluates to a finite, non-zero number.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-DilateMeasureFactor_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  measure: {
                    description: 'A measurement or calculation',
                    kind: 'Measure',
                  },
                },
              },
              scaleFactor: { suppressed: !0 },
            },
          },
          getScaleFactor: function() {
            return this.getParent('measure').value;
          },
          getScaleText: function(e) {
            return this.getParentLabel('measure', e);
          },
        }
      )),
      (o.gConstraints.Intersection1 = o.makeClass(o.gConstraints.Intersection, {
        doc: {
          description:
            'One of two points of intersection of an <span class="kind">Arc</span> or <span class="kind">Circle</span> with another Arc, Circle, or <span class="kind">Straight</span> object.',
          inherits: 'Intersection',
          refspec: {
            gspRef: 'InterLCA',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraints, InterLCA and InterCCA, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Point'] },
          existenceRule:
            'Exists iff the parent objects exist and have at least one point of intersection.',
          properties: {
            parents: {
              description: '',
              properties: {
                circle: {
                  description:
                    'The first of two GObjects for which intersection(s) are to be determined',
                  kind: 'Arc|Circle',
                },
                obj: {
                  description:
                    'The second of two GObjects for which intersection(s) are to be determined',
                  kind: 'Arc|Circle|Straight',
                  type: 'GObject',
                },
                line0: { suppressed: !0 },
                line1: { suppressed: !0 },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection12_export.json',
        },
        getIntersectionPoints: function() {
          return o.getIntersectionPoints(
            this.getParent('circle').getGeometricArc(),
            this.getParent('obj')
          );
        },
        constrain: function() {
          var e = this.getIntersectionPoints();
          e[0]
            ? ((this.geom.loc = e[0]), (this.state.exists = !0))
            : ((this.geom.loc = o.GeometricPoint(n, n)),
              (this.state.exists = !1));
        },
      })),
      (o.getIntersectionPoints = function(e, n) {
        var i,
          r = [],
          s = 'Straight' === n.kind || 'Axis' === n.kind,
          a = s ? n : n.getGeometricArc(),
          c = 0,
          l = 0 === e.orientation ? 'Straight' : 'Arc',
          u =
            'Straight' === a.kind || 'Axis' === a.kind || 0 === a.orientation
              ? 'Straight'
              : 'Arc',
          d = l + u;
        switch (d) {
          case 'StraightStraight':
            (i = o.Geom.LineLineIntersection(e, a)),
              i.isDefined() && r.push(i, i);
            break;
          case 'ArcStraight':
            r = o.Geom.CircleStraightIntersection(e, a);
            break;
          case 'StraightArc':
            (c = -a.orientation), (r = o.Geom.CircleStraightIntersection(a, e));
            break;
          case 'ArcArc':
            r = o.Geom.CircleCircleIntersection(e, a);
        }
        return (
          (r = t.grep(r, function(t) {
            return e.pointIsInBounds(t) && (s || a.pointIsInBounds(t));
          })),
          -1 === c && r.reverse(),
          r
        );
      }),
      (function() {
        var e = {
            init: function() {
              (this.isAtTarget = !1),
                (this.controlList = this.sketch.Bap.createControlList([
                  this.moverGObj,
                ])),
                (this.motionID = null),
                (this.lastSample = Date.now());
            },
            isInstant: function() {
              return 0 === this.button.rate;
            },
            reconfigureFromConstraints: function() {
              this.canKeepMoving() && this.getStep().isAlreadyThere
                ? this.wasAtTarget
                  ? (this.isAtTarget = !0)
                  : (this.wasAtTarget = !0)
                : ((this.wasAtTarget = !1), (this.isAtTarget = !1));
            },
            canKeepMoving: function() {
              return (
                this.moverGObj.state.exists && !1 !== this.getDestination()
              );
            },
            applyMotion: function() {
              var e,
                t,
                n = Date.now(),
                i = Math.max(n - this.lastSample, 1),
                r = 'PointOnPath' === this.moverGObj.genus;
              this.isInstant() || this.reconfigureFromConstraints(),
                this.isAtTarget
                  ? (this.sketch.MotionManager.EndMotion(this.motionID),
                    this.sketch.event('EndMove', {
                      button: this.button,
                      id: this.button.id,
                    }),
                    this.pressSource || (this.button.state.pressedUp = !0))
                  : (this.canKeepMoving() &&
                      ((t =
                        this.rate *
                        o.kWebSpeedMultiplier *
                        (i / 1e3) *
                        o.kIdealFrameRate),
                      r && (e = this.moverGObj.value),
                      (this.isAtTarget = this.getStep().move(t)),
                      (r && e === this.moverGObj.value) ||
                        this.sketch.invalidateGeom(this.moverGObj)),
                    (this.lastSample = n));
            },
            completeMotion: function() {
              var e;
              for (
                this.motionID = n,
                  this.button.state.isActive =
                    this.button.state.motions.length > 1,
                  e = 0;
                e < this.button.state.motions.length;
                e++
              )
                if (this === this.button.state.motions[e]) {
                  this.button.state.motions.splice(e, 1);
                  break;
                }
              this.button.state.isActive ||
                this.sketch.invalidateGeom(this.button);
            },
          },
          i = o.makeClass(e, {
            initializeDistance: function() {
              var e = this.moverGObj,
                t = this.getDestination();
              this.getDestination()
                ? (this.distance = t.subtract(e.geom.loc).vLength())
                : (this.distance = 10);
            },
            getDestination: function() {
              var e = this.targetGObj.geom.loc;
              return e.isDefined() && e;
            },
          }),
          r = o.makeClass(e, {
            init: function e() {
              (e.base || arguments.callee.base).call(this),
                (this.isValueChangingMotion = !0);
            },
            getDestination: function() {
              return this.targetGObj.blank
                ? this.isInstant()
                  ? 'blank'
                  : !1
                : this.moverGObj.blank && !this.isInstant()
                ? !1
                : !isNaN(this.targetGObj.value) && this.targetGObj.value;
            },
            initializeDistance: function() {
              var e = this.moverGObj;
              e.value === this.targetGObj.value
                ? (this.distance = 0)
                : (this.distance = -1);
            },
            getStep: function() {
              var e = this.moverGObj,
                t = this.getDestination(),
                n = t - e.value,
                i = 0 > n ? -1 : 1,
                r = 0 === n,
                s = {
                  isAlreadyThere: r,
                  move: function(s) {
                    return 'blank' === t
                      ? (e.setParameterValue(''), (e.blank = !0), !0)
                      : (r ||
                          (0 === s || Math.abs(n) <= Math.abs(s)
                            ? (e.updateValue(t), e.blank && (e.blank = !1))
                            : e.updateValue(e.value + i * Math.abs(s))),
                        0 === s || r);
                  },
                };
              return s;
            },
          }),
          s = o.makeClass(i, {
            getStep: function() {
              var e = 1e-12,
                t = this.moverGObj.geom.loc,
                n = this.getDestination().subtract(t),
                i = n.vLength(),
                r = this,
                s = {
                  isAlreadyThere: e >= i,
                  move: function(e) {
                    var t,
                      s = !1;
                    return (
                      0 === e || Math.abs(e) >= i
                        ? ((t = n), (s = !0))
                        : (t = n.multiply(e / i)),
                      r.sketch.MotionManager.ApplyTransformToControlList(
                        r.sketch,
                        new o.AffineTransform({
                          m00: 1,
                          m11: 1,
                          m20: t.x,
                          m21: t.y,
                        }),
                        r.controlList,
                        { snapPoints: !1, onPathTracksIdealLoc: !1 }
                      ),
                      s
                    );
                  },
                };
              return s;
            },
          }),
          a = o.makeClass(i, {
            getStep: function() {
              function e(e) {
                var t = l.mapPathValueToPosition(e),
                  n = o;
                return (
                  a ||
                    (n = l.mapPathValueToPosition(l.mapPositionToPathValue(o))),
                  t.equals(n, c)
                );
              }
              var t,
                n,
                i,
                r = this.moverGObj,
                s = this.targetGObj,
                o = this.getDestination(),
                a = this.button.towardInitialDestination,
                c = 0.05,
                l = r.getParent('path'),
                u = r.value,
                d = l.mapPositionToPathValue(o),
                h = l.makeMotionPath(u, d);
              return (
                (i = e(u)),
                (n = {
                  isAlreadyThere: i,
                  move: function(n) {
                    return (
                      i ||
                        ((t = 0 === n ? h.end : h.advance(n)),
                        r.updateValue(
                          e(t) &&
                            'PointOnPath' === s.constraint &&
                            s.getParent('path') === r.getParent('path')
                            ? s.value
                            : t
                        )),
                      0 === n || i
                    );
                  },
                })
              );
            },
          });
        o.gConstraints.ActionButtonMove = o.makeClass(
          o.gConstraints.ActionButton,
          {
            doc: {
              description:
                'A button that moves a set of points towards other points.',
              inherits: 'ActionButton',
              refspec: {
                msg:
                  "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
              },
              usage: { abstract: !1, kinds: ['Button'] },
              properties: {
                parents: {
                  description: 'Set of objects to be moved',
                  type: 'Object',
                  properties: {
                    0: {
                      description:
                        'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                      kind: 'Point|Expression',
                    },
                  },
                  regex: /^[0-9]+$/,
                },
                rate: {
                  description:
                    'For point animation, the number of pixels to advance per frame cycle.',
                  type: 'Number',
                },
                towardInitialDestination: {
                  description:
                    'Rather than follow a moving destination, move to the position the destination was when the movement started ',
                  default: !1,
                  type: 'Boolean',
                },
              },
              example:
                '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Move_export.json',
            },
            rate: 1,
            towardInitialDestination: !1,
            updateConstraintAncestry: function e() {
              (e.base || arguments.callee.base).call(this),
                (this.state.motions = []);
            },
            updateLabelForConstraint: function() {
              var e, t;
              2 === this.numParents() &&
                this.shouldAutogenerateLabel &&
                ((e = this.parentsList[0]),
                (t = this.parentsList[1]),
                e.labelExists() &&
                  t.labelExists() &&
                  ((this.messages = [
                    o.Strings.loc('GSP.Label.MoveButton', t.label, e.label),
                  ]),
                  (this.label = this.messages[0])));
            },
            press: function(e, n) {
              function i(i, c) {
                var l,
                  u,
                  h,
                  p,
                  f = i.isFreePointOnPath;
                switch (i.kind) {
                  case 'Point':
                    h = f ? a : s;
                    break;
                  case 'Expression':
                    h = r;
                    break;
                  default:
                    throw o.createError(
                      'Move button encountered unexpected object type'
                    );
                }
                if (
                  ((p = o.makeInstance(h)),
                  t.extend(p, {
                    moverGObj: i,
                    targetGObj: c,
                    sketch: e,
                    button: d,
                    pressSource: n,
                  }),
                  p.init(),
                  d.towardInitialDestination)
                ) {
                  if (!p.targetGObj.state.exists) return;
                  (l = p.getDestination()),
                    f
                      ? ((u = i.parents.path),
                        (p.getDestination = function() {
                          return u.mapPathValueToPosition(
                            u.mapPositionToPathValue(l)
                          );
                        }))
                      : (p.getDestination = function() {
                          return l;
                        });
                }
                return p.moverGObj.state.exists &&
                  (p.initializeDistance(), 0 !== this.distance)
                  ? p
                  : void 0;
              }
              var c,
                l,
                u,
                d = this,
                h = -1;
              if (this.state.isActive) {
                for (
                  o.log('Canceling move ' + d.id), c = 0;
                  c < this.state.motions.length;
                  c++
                )
                  e.MotionManager.EndMotion(this.state.motions[c].motionID);
                e.event('EndMove', { button: d, id: d.id }),
                  n || (d.state.pressedUp = !0);
              } else {
                for (
                  this.state.isActive = !0,
                    o.log('Starting move ' + d.id),
                    c = 0;
                  c < this.numParents();
                  c += 2
                )
                  (l = i(this.parentsList[c + 1], this.parentsList[c])),
                    l &&
                      ((h = Math.max(h, l.distance)),
                      this.state.motions.push(l));
                if (0 === this.state.motions.length)
                  return (
                    (this.state.isActive = !1), void e.invalidateGeom(this)
                  );
                0 !== this.rate &&
                  ((h = -1 === h ? 400 : h),
                  (u = h / this.rate),
                  0 === u && (u = 1)),
                  t.each(this.state.motions, function(t, i) {
                    var r, s, a;
                    0 === d.rate
                      ? (i.rate = 0)
                      : 'Point' === i.targetGObj.kind
                      ? (i.rate = i.distance / u)
                      : ((r = i.moverGObj.value),
                        (s = i.getDestination()),
                        s !== !1
                          ? ((a = s - r), (i.rate = a / u))
                          : (i.rate = 100 / u)),
                      isNaN(i.rate) &&
                        (o.signalErrorWithMessage(
                          'This Move Button calculated a Nan rate of speed!'
                        ),
                        (i.rate = d.rate)),
                      e.event('StartMove', { button: d, id: d.id }),
                      (i.motionID = e.MotionManager.StartMotion(i)),
                      n || (d.state.pressedDown = !0);
                  });
              }
            },
          }
        );
      })(),
      (o.gConstraints.UserTabulation = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: '',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'UserTabulation_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, UserTabulation_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Table'] },
          properties: {
            parents: {
              description: 'An associative array of objects used in the table.',
              type: 'Array',
            },
          },
        },
        snapshotParentsAsRowMFS: function() {
          var e = [];
          return (
            this.eachParent(function(t, n) {
              e.push(n.getMFSAppearanceForVariant());
            }),
            e
          );
        },
        constrain: function() {
          var e = this.snapshotParentsAsRowMFS(),
            t = JSONcanonical.stringify(e);
          t !== this.cachedFinalRowString &&
            ((this.finalRowMFS = e), (this.cachedFinalRowString = t));
        },
        doubleClicked: function() {
          var e = this.snapshotParentsAsRowMFS();
          (this.rowsMFS = this.rowsMFS ? this.rowsMFS.slice() : []),
            this.rowsMFS.push(e);
        },
        updateConstraintAncestry: function() {
          var e = this;
          (e.headersMFS = []),
            e.eachParent(function(t, n) {
              e.headersMFS.push(e.getColumnLabelMFS(n));
            });
        },
      })),
      (function() {
        function e(e, t) {
          var i = Object.create(n);
          return (i.table = e), (i.parent = t), i;
        }
        var t = 19,
          n = {
            hasCurrentIterationRow: function() {
              return null !== this.table.currentIterationRow;
            },
            finishRow: function() {
              var e = this.table;
              this.hasCurrentIterationRow() &&
                e.rowsMFS.push(e.currentIterationRow),
                (e.currentIterationRow = null),
                e.rowCount++;
            },
            pushColumnMFSFor: function(e) {
              var t = this.table;
              this.hasCurrentIterationRow() &&
                t.currentIterationRow.push(e.getMFSAppearanceForVariant());
            },
            startRow: function(e) {
              var t =
                e && e.hasOwnProperty('firstColumnText')
                  ? e.firstColumnText
                  : this.table.rowCount;
              this.table.currentIterationRow = [o.mfs.makeTextMFS(t)];
            },
            createFirstRow: function() {
              var e = this.table,
                t = this;
              t.startRow(),
                e.eachParent(function(e, n) {
                  e > 0 && t.pushColumnMFSFor(n);
                }),
                t.finishRow();
            },
            collectSample: function() {
              var e = this.table,
                n = this;
              n.hasCurrentIterationRow() ||
                (0 === e.rowCount && n.createFirstRow(),
                e.rowCount < t && n.startRow()),
                n.pushColumnMFSFor(n.clonedGObj),
                n.isLastColumn && n.finishRow();
            },
            getParent: function() {
              return this.parent;
            },
            clearSamples: function() {
              (this.table.rowsMFS = []),
                (this.table.rowCount = 0),
                (this.table.currentIterationRow = null);
            },
            sampleCountChanged: function() {},
            stampTerminalSample: function() {
              function e() {
                (n.currentIterationRow = []),
                  n.eachParent(function(e, t) {
                    n.currentIterationRow.push(o.mfs.makeTextMFS('...'));
                  }),
                  i.finishRow();
              }
              var n = this.table,
                i = this;
              (n.rowCount > 0 && n.rowCount <= t) ||
                (i.hasCurrentIterationRow() ||
                  (n.rowCount > t + 1
                    ? (e(),
                      i.startRow({ firstColumnText: i.table.rowCount - 2 }))
                    : 0 === n.rowCount
                    ? i.createFirstRow()
                    : i.startRow({ firstColumnText: i.table.rowCount - 1 })),
                i.pushColumnMFSFor(i.clonedGObj),
                i.isLastColumn && i.finishRow());
            },
          };
        o.gConstraints.IteratedValuesTable = o.makeClass(
          o.gConstraints.Constraint,
          {
            doc: {
              description: '',
              inherits: 'Constraint',
              refspec: {
                gspRef: 'IteratedValuesTable_C',
                msg:
                  "This constraint is intended to behave in the same way as the corresponding constraint, IteratedValuesTable_C, in the currently published version of desktop Geometer's Sketchpad.",
              },
              usage: { abstract: !1, kinds: ['Table'] },
              properties: {
                parents: {
                  description:
                    'An associative array of objects used in the table.',
                  type: 'Array',
                },
              },
            },
            updateConstraintAncestry: function() {
              var t,
                n = this.getParent('0'),
                i = this;
              (i.headersMFS = []),
                i.eachParent(function(r, s) {
                  0 === r
                    ? i.headersMFS.push(o.mfs.makeTextMFS('n', !0))
                    : ((t = e(i, s)),
                      (t.clonedGObj = n.registerImageAndGetClone(t)),
                      i.headersMFS.push(i.getColumnLabelMFS(s)));
                }),
                (t.isLastColumn = !0);
            },
            constrain: function() {},
          }
        );
      })(),
      (o.gConstraints.ActionButtonScroll = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description:
              'A button that scrolls the sketch to the position of a point.',
            inherits: 'ActionButton',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Button'] },
            properties: {
              parents: {
                description:
                  'First object can be scrolled to particular location',
                type: 'Array',
              },
              scrollDest: {
                description:
                  'scrolls the page so that the parental point is at specified destination of the window (possible values: center | topLeft).',
                type: 'String',
              },
            },
            example: '',
          },
          scrollDest: 'topLeft',
          press: function(e, t) {
            function n() {
              e.Scroll.translate(s.x / d, s.y / d),
                u++,
                d > u
                  ? e.addDeferredCall(h, n)
                  : e.setGobjPositionInDocumentBound();
            }
            var i,
              r,
              s,
              a = this.parentsList[0],
              c = a.geom.loc.copy(),
              l = e.sketchRect();
            'center' === this.scrollDest
              ? ((r = o.GeometricPoint(
                  l.left + (l.right - l.left) / 2,
                  l.top + (l.bottom - l.top) / 2
                )),
                (s = c.subtract(r)))
              : ((i = o.GeometricPoint(l.left, l.top)), (s = c.subtract(i))),
              t ||
                ((this.state.pressedDown = !0),
                this.updateButtonSpeakableText());
            var u = 0,
              d = 8,
              h = this;
            e.addDeferredCall(h, n);
          },
        }
      )),
      (o.gConstraints.ActionButtonLinkPage = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description:
              'A button that switches to another page in the sketch.',
            inherits: 'ActionButton',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Button'] },
            properties: {
              pageId: {
                description: 'Id of the page being linked to.',
                type: 'String',
              },
              buttonId: {
                description:
                  '(Optional) Id of button to activate on the on the linked page.',
                type: 'String',
                required: !1,
              },
            },
            example: '',
          },
          pageId: '1',
          press: function(e, t) {
            t
              ? e.setSpeakabletext('Switching page.')
              : ((this.state.pressedDown = !0),
                this.updateButtonSpeakableText());
            var n = e.document;
            n.switchPage(this.pageId);
            var i = n.focusPage,
              r = this.buttonId && i.sQuery().get(this.buttonId);
            r && r.press(i, 'linkButton');
          },
        }
      )),
      (o.gConstraints.ActionButtonLinkURL = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description: 'A button that opens a url.',
            inherits: 'ActionButton',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Button'] },
            properties: {
              url: { description: 'Url to link to.', type: 'String' },
            },
            example: '',
          },
          url: '',
          init: function e() {
            (e.base || arguments.callee.base).call(this);
          },
          constrain: function(e) {},
          press: function(t, n) {
            n ||
              ((this.state.pressedDown = !0), this.updateButtonSpeakableText()),
              e && e.open(this.url);
          },
        }
      )),
      (o.gConstraints.Parallel = o.makeClass(o.gConstraints.Line, {
        doc: {
          description:
            'Defines a line through a <span class="kind">Point</span> parallel with another <span class="kind">Straight</span>.',
          inherits: 'Line',
          refspec: {
            gspRef: 'Parallel_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Parallel_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Straight'] },
          existenceRule: 'Exists iff the parent point and line exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: { description: '', kind: 'Point' },
                line: { description: '', kind: 'Straight' },
                p1: { suppressed: !0 },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Parallel_export.json',
        },
        constrain: function() {
          var e = this.getParent('line'),
            t = e.geom.p0,
            n = e.geom.p1,
            i = this.getParent('p0').geom.loc,
            r = n.subtract(t).multiply(0.5);
          (this.geom.p0 = i.subtract(r)), (this.geom.p1 = i.add(r));
          var s = r.vLength(),
            o = 1e4 / s,
            a = i.add(r.multiply(-o)),
            c = i.add(r.multiply(o));
          (this.geom.xp0 = a), (this.geom.xp1 = c);
        },
        getParentalNameMFS: function() {
          return o.mfs.makeTextMFS('Parallel line ' + this.id);
        },
        canMergeTo: function(e) {
          var t = this.getParent('p0'),
            n = e.getParent('p0'),
            i = this.getParent('line'),
            r = e.getParent('line'),
            s = !1;
          return (
            t && n && i && r
              ? (s = t === n && i === r)
              : o.signalErrorWithMessage(
                  'Parallel canMergeTo() missing parents!'
                ),
            s
          );
        },
      })),
      (o.gConstraints.Perpendicular = o.makeClass(o.gConstraints.Line, {
        doc: {
          description:
            'Defines a line through a <span class="kind">Point</span> perpendicular with another <span class="kind">Straight</span>.',
          inherits: 'Line',
          refspec: {
            gspRef: 'Perpend_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, Perpend_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1, kinds: ['Straight'] },
          existenceRule: 'Exists iff the parent point and line exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                p0: { description: '', kind: 'Point' },
                line: { description: '', kind: 'Straight' },
                p1: { suppressed: !0 },
              },
            },
          },
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Perpendicular_export.json',
        },
        constrain: function() {
          var e = this.getParent('line'),
            t = e.getP1().subtract(e.getP0()),
            n = o.GeometricPoint(-t.y, t.x),
            i = this.getParent('p0').geom.loc,
            r = 1e4;
          (this.geom.p0 = i.add(n.multiply(-0.5))),
            (this.geom.p1 = i.add(n.multiply(0.5))),
            (this.geom.xp0 = i.add(n.multiply(-r))),
            (this.geom.xp1 = i.add(n.multiply(r)));
        },
        getParentalNameMFS: function() {
          return (
            o.signalErrorWithMessage(
              "Perpendicular.getParentalNameMFS() shouldn't be called."
            ),
            null
          );
        },
        canMergeTo: function(e) {
          var t = this.getParent('p0'),
            n = e.getParent('p0'),
            i = this.getParent('line'),
            r = e.getParent('line'),
            s = !1;
          return (
            t && n && i && r
              ? (s = t === n && i === r)
              : o.signalErrorWithMessage(
                  'Perpendicular canMergeTo() missing parents!'
                ),
            s
          );
        },
      })),
      (o.gConstraints.PolygonFromPoints = o.makeClass(
        o.gConstraints.Constraint,
        {
          doc: {
            description:
              'Defines a polygon from a sequence of <span class="kind">Point</span>s.',
            inherits: 'Free',
            refspec: { gspRef: 'Polygon_C' },
            usage: { kinds: ['Polygon'], abstract: !1 },
            existenceRule:
              'Exists iff the parent points exist and are not all coincident.',
            properties: {
              parents: {
                description:
                  'An associative array of points that define the polygon. Key values are ignored in processing.',
                properties: {
                  0: {
                    description: 'Vertices labeled "0", ..., "n"',
                    kind: 'Point',
                  },
                },
                regex: /^[0-9]+$/,
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Polygon-Polygon_export.json',
          },
          updateConstraintAncestry: function e() {
            (e.base || arguments.callee.base).call(this),
              (this.geom.points = []);
          },
          constrain: function() {
            var e,
              t,
              n = !1;
            this.geom.points = [];
            for (e in this.parents)
              this.parents.hasOwnProperty(e) &&
                ((t = this.getParent(e).geom.loc), this.geom.points.push(t)),
                !n &&
                  this.geom.points.length &&
                  (n = !t.equals(this.geom.points[0]));
            this.state.exists = n;
          },
          getParentalNameMFS: function(e) {
            var t = this,
              n = [];
            return (
              this.eachParent(function(i, r) {
                r.label || t.getParentLabel(i, e), n.push(r.getNameMFS());
              }),
              o.mfs.makeHorizontalNamesMFS(
                n,
                'Triangle' === this.genus
                  ? { type: 'symbol', value: '102' }
                  : null
              )
            );
          },
          canMergeTo: function(e) {
            var t,
              n,
              i = !0,
              r = this.parentsList.length,
              s = e.parentsList.indexOf(this.parentsList[0]);
            if (e.constraint !== this.constraint) return !1;
            if (e.parentsList.length !== r || 0 > s) return !1;
            for (
              t = 0, n = s;
              t < this.parentsList.length;
              t++, n = (n + 1) % r
            )
              if (this.parentsList[t] !== e.parentsList[n]) {
                i = !1;
                break;
              }
            if (!i)
              for (
                i = !0, t = 0, n = s;
                t < this.parentsList.length;
                t++, n = (n + r - 1) % r
              )
                if (this.parentsList[t] !== e.parentsList[n]) {
                  i = !1;
                  break;
                }
            return i;
          },
          collapseDoubledParent: function(e) {
            function t(t) {
              var n = e.children.indexOf(s);
              if (
                (a.splice(t, 1),
                e.children.splice(n, 1),
                e.children.indexOf(s) < 0)
              )
                throw o.createError(
                  "removeDuplicateVertex removed a child that wasn't duplicated"
                );
            }
            for (
              var n,
                i,
                r = this.sQuery.sketch,
                s = this,
                a = s.parentsList,
                c = !0,
                l = 0;
              c;

            )
              (n = a.indexOf(e, l)),
                (i = n + 1),
                i >= a.length && (i = 0),
                i !== n && a[i] === e
                  ? ((c = !1), t(i))
                  : ((l = Math.max(l + 1, i + 1)), (c = l < a.length));
            for (s.parents = {}, n = 0; n < a.length; n++) s.parents[n] = a[n];
            if (a.length < 3) r.gobjList.removeGObjAndDescendants(this);
            else
              switch (a.length) {
                case 3:
                  s.genus = 'Triangle';
                  break;
                case 4:
                  s.genus = 'Quadrilateral';
                  break;
                case 5:
                  s.genus = 'Pentagon';
                  break;
                case 6:
                  s.genus = 'Hexagon';
                  break;
                default:
                  s.genus = 'Polygon';
              }
          },
        }
      )),
      (o.gConstraints.ActionButtonPresent = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description: 'Defines an action that executes a set of actions.',
            inherits: 'ActionButton',
            refspec: { msg: 'Internal class not intended for instantiation.' },
            usage: { abstract: !0 },
            properties: {
              parents: {
                description: 'Set of objects to be triggered',
                type: 'Object',
                properties: {
                  0: {
                    description:
                      'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                    kind: 'Button',
                  },
                },
                regex: /^[0-9]+$/,
              },
              stopAnyMotions: {
                description:
                  'Stop any previously started animations before commencing the presentation.',
                default: !1,
                type: 'Boolean',
              },
              eraseAnyTraces: {
                description:
                  'Erase any previously displayed traces before commencing the presentation.',
                default: !1,
                type: 'Boolean',
              },
            },
          },
          stopAnyMotions: !1,
          eraseAnyTraces: !1,
          press: function(e, t) {
            this.state.isActive ||
              (this.eraseAnyTraces && e.clearTraces(),
              this.stopAnyMotions && e.MotionManager.StopAllMotions());
          },
        }
      )),
      (o.gConstraints.ActionButtonPresentSequentially = o.makeClass(
        o.gConstraints.ActionButtonPresent,
        {
          doc: {
            description:
              'Defines an action from an ordered sequence of action buttons.',
            inherits: 'ActionButtonPresent',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            properties: {
              waitTime: {
                description: 'Pause between sequential actions in seconds.',
                type: 'Number',
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Sequence_export.json',
          },
          waitTime: 0,
          pressSource: '',
          constrain: function e(t) {
            (e.base || arguments.callee.base).call(this, t);
            var n, i;
            this.state.isActive &&
              (this.state.inInterval ||
                ((n = this.state.buttonList[this.state.current]),
                n.state.isActive ||
                  ((this.state.current += 1),
                  this.state.current >= this.state.buttonList.length &&
                    ((this.state.isActive = !1),
                    t.event('EndSequence', { button: this, id: this.id }),
                    this.pressSource || (this.state.pressedUp = !0)),
                  this.state.isActive &&
                    ((this.state.inInterval = !0),
                    (i = 1e3 * this.waitTime + Date.now()),
                    o.log('Begin interval: now=' + Date.now() + ' start=' + i),
                    t.addDeferredCall(this, function e(t) {
                      var n, r;
                      this.state.inInterval &&
                        ((n = Date.now()),
                        n >= i
                          ? ((this.state.inInterval = !1),
                            o.log('Activating button: ' + this.state.current),
                            (r = this.state.buttonList[this.state.current]),
                            r.state.isActive || r.press(t, 'sequenceButton'))
                          : t.addDeferredCall(this, e));
                    })))));
          },
          press: function e(t, n) {
            var i, r, s;
            if (
              ((this.pressSource = n),
              (e.base || arguments.callee.base).call(this, t),
              (i = this.state.isActive))
            )
              (this.state.isActive = !1),
                (s = this.state.buttonList[this.state.current]),
                s.state.isActive && s.press(t, 'sequenceButton'),
                this.state.inInterval && t.cancelDeferredCall(this),
                t.event('EndSequence', { button: this, id: this.id }),
                n || (this.state.pressedUp = !0);
            else {
              (this.state.isActive = !0),
                t.event('StartSequence', { button: this, id: this.id }),
                (this.state.buttonList = []);
              for (r in this.parents)
                this.parents.hasOwnProperty(r) &&
                  ((s = this.getParent(r)), this.state.buttonList.push(s));
              (this.state.current = 0),
                (this.state.inInterval = !1),
                (s = this.state.buttonList[this.state.current]),
                s.state.isActive || s.press(t, 'sequenceButton'),
                n || (this.state.pressedDown = !0);
            }
          },
        }
      )),
      (o.gConstraints.ActionButtonPresentSimultaneously = o.makeClass(
        o.gConstraints.ActionButtonPresent,
        {
          doc: {
            description:
              'Defines an action that executes a collection of actions simultaneously.',
            inherits: 'ActionButtonPresent',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            properties: {
              stopAfter: {
                description:
                  'Stop the presentation after the last action stops, first action stops, or an elapsed number of seconds',
                default: 'lastActionStops',
                type: 'StopCondition',
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Simultaneous_export.json',
          },
          activeButtons: [],
          stopAfter: 'lastActionStops',
          pressSource: '',
          activateButtons: function(e) {
            var t = this;
            this.eachParent(function(n, i) {
              i.state.isActive || i.press(e, 'simultaneousButton'),
                i.state.isActive && t.activeButtons.push(i);
            });
          },
          deactivateRemainingButtons: function(e) {
            for (var t; this.activeButtons.length; )
              (t = this.activeButtons.pop()), t.state.isActive && t.press(e);
          },
          constrain: function e(t) {
            var n,
              i = !1,
              r = !1,
              s = [];
            if (
              ((e.base || arguments.callee.base).call(this, t),
              this.state.isActive)
            ) {
              for (n = 0; n < this.activeButtons.length; n++) {
                var o = this.activeButtons[n].state.isActive;
                (i = i || !o), (r = r || o), o && s.push(this.activeButtons[n]);
              }
              (this.activeButtons = s),
                'firstActionStops' === this.stopAfter
                  ? ((this.state.isActive = !i),
                    !this.state.isActive &&
                      r &&
                      this.deactivateRemainingButtons(t))
                  : ((this.state.isActive = r),
                    this.pressSource || (this.state.pressedUp = !0));
            }
            this.state.timerSet &&
              !this.state.isActive &&
              t.cancelDeferredCall(this);
          },
          press: function e(t, n) {
            var i,
              r = !this.state.isActive;
            (this.pressSource = n),
              o.log(
                'SimultaneousButton: state: ' +
                  this.state.isActive +
                  ' new state: ' +
                  r
              ),
              (e.base || arguments.callee.base).call(this, t),
              r
                ? (this.activateButtons(t), n || (this.state.pressedDown = !0))
                : (this.deactivateRemainingButtons(t),
                  n || (this.state.pressedUp = !0)),
              (this.state.isActive = this.activeButtons.length > 0),
              r &&
                'number' == typeof this.stopAfter &&
                ((i = 1e3 * this.stopAfter + Date.now()),
                (this.state.timerSet = !0),
                t.addDeferredCall(this, function e(t) {
                  var n;
                  this.state.timerSet &&
                    ((n = Date.now()),
                    n >= i
                      ? ((this.state.timerSet = !1),
                        this.deactivateRemainingButtons(t))
                      : t.addDeferredCall(this, e));
                })),
              this.state.timerSet && !r && t.cancelDeferredCall(this);
          },
        }
      )),
      (o.gConstraints.ActionButtonPresentCase = o.makeClass(
        o.gConstraints.ActionButtonPresent,
        {
          doc: {
            description:
              'Defines an action to run one button from an ordered list of action buttons. Operates similarly to a Sequence button, but activates only one of its parents.',
            inherits: 'ActionButtonPresent',
            refspec: {
              msg:
                'This constraint is intended to to allow the activation of just one button from an ordered list of action buttons.',
            },
            usage: { abstract: !1 },
            properties: {
              target: {
                description:
                  'The parent button designated by the index (the value of parentsList[0]).',
                type: 'gObject',
              },
              activeParent: {
                description:
                  'The currently-activated parent button (may not be the target if the index has changed).',
                type: 'gObject',
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Sequence_export.json',
          },
          activeParent: null,
          target: null,
          checkTarget: function() {
            var e = this.parentsList[0].value,
              t = null;
            return (
              e &&
                Number.isInteger(e) &&
                e < this.parentsList.length &&
                (t = this.parentsList[e]),
              (this.target = t),
              t
            );
          },
          constrain: function e(t) {
            var n;
            (e.base || arguments.callee.base).call(this, t),
              this.state.isActive &&
                ((this.activeParent && this.activeParent.state.isActive) ||
                  ((this.state.isActive = !1),
                  t.event('EndCase', {
                    button: this,
                    id: this.id,
                    activeParent: this.activeParent,
                  }),
                  (this.activeParent = null))),
              (n = this.checkTarget()),
              'auto' === this.label && (this.style.autoLabel = !0),
              n &&
                this.style.autoLabel &&
                this.label !== n.label &&
                (this.label = n.label);
          },
          press: function e(t, n) {
            var i, r;
            (e.base || arguments.callee.base).call(this, t),
              (i = this.state.isActive),
              (r = this.checkTarget()),
              i
                ? (this.activeParent &&
                    this.activeParent.state.isActive &&
                    this.activeParent.press(t, 'caseButton'),
                  (this.state.isActive = !1),
                  t.event('EndCase', {
                    button: this,
                    id: this.id,
                    activeParent: this.activeParent,
                  }),
                  (this.activeParent = null))
                : ((this.activeParent = r),
                  t.event('StartCase', {
                    button: this,
                    id: this.id,
                    activeParent: this.activeParent,
                  }),
                  r && !r.state.isActive
                    ? r.press(t, 'caseButton')
                    : this.invalidateGeom(),
                  (this.state.isActive = !0));
          },
        }
      )),
      (o.gConstraints.ActionButtonToggleHideShow = o.makeClass(
        o.gConstraints.ActionButton,
        {
          doc: {
            description:
              'Defines a button that hides visible objects or shows hidden objects, depending on their state.',
            inherits: 'ActionButton',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            properties: {
              messages: {
                description: 'Hide message, Show message',
                type: 'Array',
              },
              parents: {
                description: 'Set of objects to be hidden/shown',
                type: 'Object',
                properties: {
                  0: {
                    description:
                      'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                    kind: 'kind',
                  },
                },
                regex: /^[0-9]+$/,
              },
              fade: {
                description: 'when true, the objects fade in or out',
                type: 'Boolean',
                default: !1,
              },
            },
            example:
              '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/ToggleDisplayButton_export.json',
          },
          fade: !1,
          value: !1,
          updateLabelForConstraint: function() {
            var e;
            1 === this.numParents() &&
              this.shouldAutogenerateLabel &&
              ((e = this.parentsList[0]),
              e.labelExists() &&
                (e.style.hidden
                  ? (this.label = o.Strings.loc(
                      'GSP.Label.HideButton',
                      e.genus,
                      e.label
                    ))
                  : (this.label = o.Strings.loc(
                      'GSP.Label.ShowButton',
                      e.genus,
                      e.label
                    ))));
          },
          setMessagesFromParent: function(e, t) {
            var n = 1,
              i = 0;
            (this.messages[n] = o.Strings.loc('GSP.Label.ShowButton', e, t)),
              (this.messages[i] = o.Strings.loc('GSP.Label.HideButton', e, t));
          },
          updateLabelFromMessage: function() {
            var e,
              t = o.Locale.current['GSP.Label.ShowButtonSwap'],
              n = o.Locale.current['GSP.Label.HideButtonSwap'];
            (e = this.value
              ? this.label.replace(n, t)
              : this.label.replace(t, n)),
              (this.label = e);
          },
          constrain: function(e) {
            (this.value = this.areHidden()), this.updateLabelFromMessage();
          },
          areHidden: function() {
            var e = !0;
            return (
              this.eachParent(function(t, n) {
                n.style.hidden || (e = !1);
              }, !1),
              e
            );
          },
          beginAction: function(e, t, i) {
            function r(e) {
              var i = this.hideShowState,
                s = Date.now(),
                o = (s - i.startTime) / (i.timeToComplete - i.startTime);
              s >= i.timeToComplete
                ? (this.eachParent(function(e, t) {
                    (this.state.fade = n),
                      t.hide(),
                      t.updateKindHTMLStyle && t.updateKindHTMLStyle();
                  }, !1),
                  (this.state.isActive = !1),
                  (this.hideShowState = n),
                  e.invalidateGeom(this),
                  t || (this.state.pressedDown = !0))
                : (this.eachParent(function(t, n) {
                    (this.state.fade = o), e.invalidateAppearance(this);
                  }, !1),
                  e.addDeferredCall(this, r));
            }
            function s(e) {
              var i = this.hideShowState,
                r = Date.now(),
                o = (r - i.startTime) / (i.timeToComplete - i.startTime);
              i.oneTimeShow ||
                (this.eachParent(function(e, t) {
                  t.style.hidden && ((t.state.fade = 1), t.show());
                }),
                (i.oneTimeShow = !0)),
                r >= i.timeToComplete
                  ? (this.eachParent(function(t, i) {
                      (this.state.fade = n), e.invalidateGeom(this);
                    }, !1),
                    (this.state.isActive = !1),
                    (this.hideShowState = n),
                    e.invalidateGeom(this),
                    t || (this.state.pressedUp = !0))
                  : (this.eachParent(function(t, i) {
                      n !== i.state.fade &&
                        ((i.state.fade = 1 - o), e.invalidateAppearance(i));
                    }, !1),
                    e.addDeferredCall(this, s));
            }
            function o(e, t) {
              var n = 500,
                i = Date.now(),
                r = { startTime: i, timeToComplete: i };
              return (
                a.fade &&
                  'simultaneousButton' !== t &&
                  ('sequenceButton' === t
                    ? (r.timeToComplete += n / 2)
                    : (r.timeToComplete += n)),
                r
              );
            }
            var a = this;
            switch (((this.hideShowState = o(e, t)), e)) {
              case 'hide':
                i.addDeferredCall(this, r);
                break;
              case 'show':
                i.addDeferredCall(this, s);
            }
            ('simultaneousButton' === t ||
              ('sequenceButton' === t && !this.fade)) &&
              (this.state.isActive = !1);
          },
          press: function(e, t) {
            this.state.isActive ||
              ((this.state.isActive = !0),
              e.invalidateGeom(this),
              this.areHidden()
                ? this.beginAction('show', t, e)
                : this.beginAction('hide', t, e));
          },
        }
      )),
      (o.gConstraints.TranslateBase = o.makeClass(o.gConstraints.Transform, {
        doc: {
          description:
            'Abstract class that defines a new GObject that is identical to another GObject, but translated by some amount.',
          inherits: 'Transform',
          usage: { abstract: !0 },
          existenceRule: 'Exists iff the parent point exists.',
          example:
            '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Translation_export.json',
        },
        determineExists: function() {
          var e = this.getOffset();
          return 'undefined' != typeof e && e.isFinite();
        },
        getParentPixelValue: function(e) {
          var t,
            n = this.getParent(e);
          return this.unit
            ? n.value
            : ((t = this.sQuery().prefs().units),
              o.units.convert(n.uValue, t.length, 'pixels'));
        },
        getOffset: function() {
          throw o.createError(
            'Translation subclasses required to implement getOffset()'
          );
        },
        getTransform: function() {
          var e = this;
          return function(t) {
            return t.add(e.getOffset());
          };
        },
        getFixedDistanceText: function(e) {
          var t = this.sQuery.sketch.preferences,
            n = o.units.findUnit(t.units.length),
            i = Math.pow(10, t.precision.length),
            r = Math.round(e * n.conversionFromBase * i) / i;
          return (0 > r ? '–' : '') + Math.abs(r) + n.digraph;
        },
        getFixedAngleText: function(e) {
          var t = this.sQuery.sketch.preferences,
            n = o.units.findUnit(t.units.angle),
            i = Math.pow(10, t.precision.angle),
            r = Math.round(e * n.conversionFromBase * i) / i;
          return (0 > r ? '–' : '') + Math.abs(r) + n.symbol;
        },
        getTranslateText: function(e) {
          return '?';
        },
        makeFnLabelPrefix: function(e, t) {
          var n;
          switch (e) {
            case 'namedByFullFn':
              n = 'T[' + this.getTranslateText(t) + ']';
              break;
            case 'namedByShortFn':
              n = 'T';
          }
          return n;
        },
      })),
      (o.gConstraints.TranslateFixXFixY = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed x,y coordinate.',
            inherits: 'TranslateBase',
            refspec: {
              gspRef: 'TranslatefXfY_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefXfY_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            properties: {
              offset: {
                description:
                  'Offset in pixel coordinates from the source object',
                type: 'GeometricPoint',
                required: !1,
                properties: {
                  x: {
                    description: 'Horizontal coordinate in pixels',
                    type: 'Number',
                  },
                  y: {
                    description: 'Vertical coordinate in pixels',
                    type: 'Number',
                  },
                },
              },
            },
          },
          offset: { x: 0, y: 0 },
          getOffset: function() {
            return (
              this.offset.transformClass ||
                (this.offset = o.GeometricPoint(this.offset.x, this.offset.y)),
              this.offset
            );
          },
          getTranslateText: function() {
            return (
              this.getFixedDistanceText(this.offset.x) +
              ',' +
              this.getFixedDistanceText(-this.offset.y)
            );
          },
        }
      )),
      (o.gConstraints.TranslateFixDist3PtAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction of an angle delineated by three points.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatefD3A_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefD3A_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the three points exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDist3PtAngle_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  A: { description: '', kind: 'Point' },
                  B: { description: '', kind: 'Point' },
                  C: { description: '', kind: 'Point' },
                },
              },
              distance: {
                description: 'A distance in pixels.',
                default: '0',
                type: 'Number',
              },
            },
          },
          distance: 0,
          getOffset: function() {
            var e = this.getParent('A'),
              t = this.getParent('B'),
              n = this.getParent('C'),
              i = e.geom.loc,
              r = t.geom.loc,
              s = n.geom.loc,
              a = o.GeometricPoint.threePointAngle(i, r, s),
              c = o
                .GeometricPoint(this.distance, 0)
                .rotate(o.GeometricPoint.ORIGIN, a);
            return c;
          },
          getTranslateText: function(e) {
            return (
              this.getFixedDistanceText(this.distance) +
              ',' +
              this.get3PtAngleText('A', 'B', 'C', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateFixDistAngleMarker = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction specified by an angle marker.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslateFixedDataMarkedAngleMarker_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslateFixedDataMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the angle marker exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistAngleMarker_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  marker: { description: '', kind: 'AngleMarker' },
                },
              },
              distance: { description: 'A distance.', type: 'Number' },
            },
          },
          distance: 0,
          getOffset: function() {
            var e = this.getParent('marker'),
              t = e.value,
              n = o
                .GeometricPoint(this.distance, 0)
                .rotate(o.GeometricPoint.ORIGIN, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getFixedDistanceText(this.distance) +
              ',' +
              this.getAngleMarkerText('marker', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateFixDistFixAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction of a fixed angle.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatefDfA_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefDfA_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the source object exists.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistFixAngle_export.json',
            properties: {
              distance: { description: 'A distance.', type: 'Number' },
              angle: { description: 'An angle, in radians.', type: 'Number' },
            },
          },
          distance: 0,
          angle: 0,
          getOffset: function() {
            var e = o
              .GeometricPoint(this.distance, 0)
              .rotate(o.GeometricPoint.ORIGIN, this.angle);
            return e;
          },
          getTranslateText: function() {
            return (
              this.getFixedDistanceText(this.distance) +
              ',' +
              this.getFixedAngleText(this.angle)
            );
          },
        }
      )),
      (o.gConstraints.TranslateFixDistMeasureAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction defined by an angle measurement.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslateFixedDistanceMarkedAngleMeasure_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslateFixedDistanceMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent object exists.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistMeasureAngle_export.json',
            properties: {
              parents: {
                description: '',
                properties: { measure: { description: '', kind: 'Measure' } },
              },
              distance: {
                description: 'A distance in pixels.',
                type: 'Number',
              },
            },
          },
          distance: 0,
          getOffset: function() {
            var e = this.getParent('measure'),
              t = -e.value,
              n = o
                .GeometricPoint(this.distance, 0)
                .rotate(o.GeometricPoint.ORIGIN, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getFixedDistanceText(this.distance) +
              ',' +
              this.getParentLabel('measure', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateFixXMeasureY = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed x coordinate and a y coordinate defined by a measure.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatefXmY_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefXmY_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the measurement exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixXMeasureY_export.json',
            properties: {
              parents: {
                description: '',
                properties: { measure: { description: '', kind: 'Measure' } },
              },
              offsetX: { description: '', default: '0', type: 'Number' },
            },
          },
          offsetX: 0,
          getOffset: function() {
            var e = this.offsetX,
              t = -this.getParentPixelValue('measure'),
              n = o.GeometricPoint(e, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getFixedDistanceText(this.offsetX) +
              ',' +
              this.getParentLabel('measure', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureDist3PtAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a distance from a measurement and an angle from three points.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatemD3A_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemD3A_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object, the measurement and the three points all exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDist3PtAngle_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  distance: { description: '', kind: 'Measure' },
                  A: { description: '', kind: 'Point' },
                  B: { description: '', kind: 'Point' },
                  C: { description: '', kind: 'Point' },
                },
              },
            },
          },
          getOffset: function() {
            var e = this.getParentPixelValue('distance'),
              t = this.getParent('A'),
              n = this.getParent('B'),
              i = this.getParent('C'),
              r = t.geom.loc,
              s = n.geom.loc,
              a = i.geom.loc,
              c = o.GeometricPoint.threePointAngle(r, s, a),
              l = o.GeometricPoint(e, 0).rotate(o.GeometricPoint.ORIGIN, c);
            return l;
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('distance', e) +
              ',' +
              this.get3PtAngleText('A', 'B', 'C', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureDistAngleMarker = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a distance measurement in the direction defined by a specified angle marker.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslateMarkedDistanceMarkedAngleMarker_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslateMarkedDistanceMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object, distance measure, and angle marker exists.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistAngleMarker_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  distance: { description: '', kind: 'Measure' },
                  marker: { description: '', kind: 'AngleMarker' },
                },
              },
            },
          },
          getOffset: function() {
            var e = this.getParentPixelValue('distance'),
              t = this.getParent('marker'),
              n = t.value,
              i = o.GeometricPoint(e, 0).rotate(o.GeometricPoint.ORIGIN, n);
            return i;
          },
          getTranslateText: function(e) {
            return (
              this.getParent('distance').label +
              ',' +
              this.getAngleMarkerText('marker', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureDistFixAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a distance derived from a measurement in the direction defined by a fixed angle in radians.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatemDfA_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemDfA_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and angle measurement exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistFixAngle_export.json',
            properties: {
              parents: {
                description: '',
                properties: { distance: { description: '', kind: 'Measure' } },
              },
              angle: { description: 'A angle(radians).', type: 'Number' },
            },
          },
          angle: 0,
          getOffset: function() {
            var e = this.getParentPixelValue('distance'),
              t = this.angle,
              n = o.GeometricPoint(e, 0).rotate(o.GeometricPoint.ORIGIN, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('distance', e) +
              ',' +
              this.getFixedAngleText(this.angle)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureDistMeasureAngle = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a distance measurement in the direction defined by an angle measurement.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslateMarkedDistanceMarkedAngleMeasure_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslateMarkedDistanceMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the distance and angle measurements exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistMeasureAngle_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  distance: { description: '', kind: 'Measure' },
                  angle: { description: '', kind: 'Measure' },
                },
              },
            },
          },
          getOffset: function() {
            var e = this.getParentPixelValue('distance'),
              t = this.getParent('angle'),
              n = -t.value,
              i = o.GeometricPoint(e, 0).rotate(o.GeometricPoint.ORIGIN, n);
            return i;
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('distance', e) +
              ',' +
              this.getParentLabel('angle', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureXFixY = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by a fixed y coordinate and an x coordinate defined by a measure.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatemXfY_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemXfY_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the measurement exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureXFixY_export.json',
            properties: {
              parents: {
                description: '',
                properties: { measure: { description: '', kind: 'Measure' } },
              },
              offsetY: { description: '', type: 'Number' },
            },
          },
          offsetY: 0,
          getOffset: function() {
            var e = this.getParentPixelValue('measure'),
              t = -this.offsetY,
              n = o.GeometricPoint(e, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('measure', e) +
              ',' +
              this.getFixedDistanceText(this.offsetY)
            );
          },
        }
      )),
      (o.gConstraints.TranslateMeasureXMeasureY = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a new GObject that is identical to another GObject, but offset by x and y coordinates defined by measures.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslatemXmY_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemXmY_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the source object and the two measurements exists.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureXMeasureY_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  measureX: { description: '', kind: 'Measure' },
                  measureY: { description: '', kind: 'Measure' },
                },
              },
            },
          },
          getOffset: function() {
            var e = this.getParentPixelValue('measureX'),
              t = -this.getParentPixelValue('measureY'),
              n = o.GeometricPoint(e, t);
            return n;
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('measureX', e) +
              ',' +
              this.getParentLabel('measureY', e)
            );
          },
        }
      )),
      (o.gConstraints.TranslateVector = o.makeClass(
        o.gConstraints.TranslateBase,
        {
          doc: {
            description:
              'Defines a translation of a GObject by an offset that matches the vector defined by two points.',
            inherits: 'Translate',
            refspec: {
              gspRef: 'TranslateVector_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, TranslateVector_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule:
              'Exists iff the transformed object and both length defining points exist.',
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-VectorTranslation_export.json',
            properties: {
              parents: {
                description: '',
                properties: {
                  p0: { description: '', kind: 'Point' },
                  p1: { description: '', kind: 'Point' },
                },
              },
            },
          },
          getOffset: function() {
            var e = this.getParent('p0'),
              t = this.getParent('p1'),
              n = e.geom.loc,
              i = t.geom.loc;
            return i.subtract(n);
          },
          getTransform: function() {
            var e = this;
            return function(t) {
              return t.add(e.getOffset());
            };
          },
          getTranslateText: function(e) {
            return (
              this.getParentLabel('p0', e) + '→' + this.getParentLabel('p1', e)
            );
          },
        }
      )),
      (o.gConstraints.AngleMarker_CCW = o.makeClass(
        o.gConstraints.AngleMarker,
        {
          doc: {
            description: 'A counter-clockwise angle marker',
            inherits: 'AngleMarker',
            refspec: {
              gspRef: 'AngleMarker_CCW_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_CCW_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          constrainedAngle: function(e, t) {
            return (
              t.isStraight
                ? (e = 'fullCircle' === t.isStraight ? 0 : -Math.PI)
                : (e -= o.math.TWO_PI),
              (t.orientation = -1),
              e
            );
          },
        }
      )),
      (o.gConstraints.AngleMarker_CW = o.makeClass(o.gConstraints.AngleMarker, {
        doc: {
          description: 'A clockwise angle marker',
          inherits: 'AngleMarker',
          refspec: {
            gspRef: 'AngleMarker_CW_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_CW_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
        },
        constrainedAngle: function(e, t) {
          return (
            t.isStraight && (e = 'fullCircle' === t.isStraight ? 0 : Math.PI),
            (t.orientation = 1),
            e
          );
        },
      })),
      (o.gConstraints.AngleMarker_Reflex = o.makeClass(
        o.gConstraints.AngleMarker,
        {
          doc: {
            description: 'A reflex angle marker',
            inherits: 'AngleMarker',
            refspec: {
              gspRef: 'AngleMarker_Reflex_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_Reflex_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          constrainedAngle: function(e, t) {
            return (
              t.isStraight
                ? (e = 'fullCircle' === t.isStraight ? o.math.TWO_PI : Math.PI)
                : e <= o.math.SIMPLE_PI_THRESHOLD && (e = -(2 * Math.PI - e)),
              (t.orientation = 0 >= e ? -1 : 1),
              e
            );
          },
        }
      )),
      (o.gConstraints.AngleMarker_Simple = o.makeClass(
        o.gConstraints.AngleMarker,
        {
          doc: {
            description: 'A simple angle marker',
            inherits: 'AngleMarker',
            refspec: {
              gspRef: 'AngleMarker_Simple_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_Simple_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
          },
          constrainedAngle: function(e, t) {
            return (
              t.isStraight
                ? ((e = 'fullCircle' === t.isStraight ? 0 : -Math.PI),
                  (t.orientation = -1))
                : (e > o.math.SIMPLE_PI_THRESHOLD && (e = -(2 * Math.PI - e)),
                  (t.orientation = 0 >= e ? -1 : 1)),
              e
            );
          },
        }
      )),
      (o.gConstraints.PathMarker = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description: 'A path marker on a <span class="genus">Path</span>.',
          inherits: 'Constraint',
          refspec: { gspRef: 'PathMarker_C' },
          usage: { abstract: !1, kinds: ['PathMarker'] },
          existenceRule: 'Exists iff the parent path exists.',
          properties: {
            value: { description: '', type: 'Number' },
            parents: {
              description: '',
              properties: { path: { description: '', genus: 'Path' } },
            },
          },
        },
        value: 0.5,
        constrain: function() {
          var e,
            t,
            n = this.getParent('path'),
            i = !1,
            r = {},
            s = o.GeometricPoint.UNDEFINED;
          n.isValueInBounds(this.value) &&
            ((s = n.mapPathValueToPosition(this.value, r)),
            s && s.isDefined() && r.derivative.isDefined()
              ? ((e = r.derivative.vLength()),
                (t = 1),
                'Crossbar' !== this.style['tick-mark-style'] &&
                  'Forward' !== this.style['arrow-direction'] &&
                  (t *= -1),
                (this.geom.normal = o.GeometricPoint(
                  (-t * r.derivative.y) / e,
                  (t * r.derivative.x) / e
                )),
                (i = !0))
              : (s = o.GeometricPoint.UNDEFINED)),
            (this.state.exists = i),
            (this.geom.loc = s),
            i && (this.state.renderMetrics = this.calculateRenderMetrics());
        },
      })),
      (o.gConstraints.PlotRhoTheta = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by two polar coordinates.',
          inherits: 'Constraint',
          usage: { abstract: !0, kinds: ['Point'] },
          existenceRule:
            'Exists iff the parent CoordSys exists and the coordinates are numbers.',
          properties: {
            parents: {
              description: '',
              properties: {
                coordSys: {
                  description: 'The coordinate system for the coordinates.',
                  kind: 'CoordSys',
                },
              },
            },
          },
        },
        getCoordRho: function() {
          return this.getParent('coordRho').uValue;
        },
        getCoordTheta: function() {
          return this.getParent('coordTheta').value;
        },
        constrain: function() {
          var e = this.getParent('coordSys'),
            t = this.getCoordRho(),
            n = this.getCoordTheta(),
            i = t * Math.cos(n),
            r = t * Math.sin(n);
          this.geom.loc = e.locatePlot(i, r);
        },
      })),
      (o.gConstraints.PlotXY = o.makeClass(o.gConstraints.Constraint, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by two coordinates.',
          inherits: 'Constraint',
          usage: { abstract: !0, kinds: ['Point'] },
          existenceRule:
            'Exists iff the parent CoordSys exists and the coordinates are numbers.',
          properties: {
            parents: {
              description: '',
              properties: {
                coordSys: {
                  description: 'The coordinate system for the coordinates.',
                  kind: 'CoordSys',
                },
              },
            },
          },
        },
        getCoordX: function() {
          return this.getParent('coordX').uValue;
        },
        getCoordY: function() {
          return this.getParent('coordY').uValue;
        },
        constrain: function() {
          var e = this.getParent('coordSys'),
            t = this.getCoordX(),
            n = this.getCoordY();
          isFinite(t) && isFinite(n)
            ? ((this.state.exists = !0), (this.geom.loc = e.locatePlot(t, n)))
            : (this.state.exists = !1);
        },
      })),
      (o.gConstraints.ActionButtonHide = o.makeClass(
        o.gConstraints.ActionButtonToggleHideShow,
        {
          doc: {
            description: 'A button that hides its parents.',
            inherits: 'ActionButtonToggleHideShow',
            refspec: {
              msg:
                "This constraint does not have a functional match in the current version of Geometer's Sketchpad. It was implemented to meet requirements from the Dynamic Number project.",
            },
            usage: { abstract: !1 },
            properties: {
              parents: {
                description: 'Set of objects to be hidden',
                type: 'Array',
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-HideShow_export.json',
          },
          updateLabelFromMessage: function() {
            this.label = this.messages[0];
          },
          setMessagesFromParent: function(e, t) {
            this.messages[0] = o.Strings.loc('GSP.Label.HideButton', e, t);
          },
          press: function(e, t) {
            this.state.isActive ||
              ((this.state.isActive = !0),
              e.invalidateGeom(this),
              this.beginAction('hide', t, e));
          },
        }
      )),
      (o.gConstraints.Intersection2 = o.makeClass(
        o.gConstraints.Intersection1,
        {
          doc: {
            description:
              'One of two points of intersection of a <span class="kind">Circle</span> with another Circle or a Circle with a <span class="kind">Straight</span> object.',
            inherits: 'Intersection1',
            refspec: {
              gspRef: 'InterLCB',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraints, InterLCB and InterCCB, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1, kinds: ['Point'] },
            existenceRule:
              'Exists iff the parent objects exist and have at least one point of intersection.',
            properties: {},
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection12_export.json',
          },
          constrain: function() {
            var e = this.getIntersectionPoints(),
              t = e[1] || e[0];
            t
              ? ((this.geom.loc = t), (this.state.exists = !0))
              : ((this.geom.loc = o.GeometricPoint(n, n)),
                (this.state.exists = !1));
          },
        }
      )),
      (o.gConstraints.PlotFixedRhoFixedTheta = o.makeClass(
        o.gConstraints.PlotRhoTheta,
        {
          doc: {
            description:
              'Defines a point on a <span class="kind">CoordSys</span> determined by two fixed polar coordinates.',
            inherits: 'PlotRhoTheta',
            refspec: {
              gspRef: 'PlotFixedRhoFixedTheta',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedRhoFixedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent Param and CoordSys exist.',
            properties: {
              coordRho: { description: '', type: 'Number' },
              coordTheta: { description: '', kind: 'Number' },
            },
          },
          getCoordRho: function() {
            return this.coordRho;
          },
          getCoordTheta: function() {
            return this.coordTheta;
          },
        }
      )),
      (o.gConstraints.PlotFixedRhoMarkedTheta = o.makeClass(
        o.gConstraints.PlotRhoTheta,
        {
          doc: {
            description:
              'Defines a point on a <span class="kind">CoordSys</span> determined by a fixed and a <span class="kind">Param</span> polar coordinate.',
            inherits: 'PlotRhoTheta',
            refspec: {
              gspRef: 'PlotFixedRhoMarkedTheta_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedRhoMarkedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent Param and CoordSys exist.',
            properties: {
              coordRho: { description: '', type: 'Number' },
              parents: {
                description: '',
                properties: {
                  coordTheta: { description: '', kind: 'Measure' },
                },
              },
            },
          },
          getCoordRho: function() {
            return this.coordRho;
          },
        }
      )),
      (o.gConstraints.PlotFixedXFixedY = o.makeClass(o.gConstraints.PlotXY, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by two fixed coordinates.',
          inherits: 'PlotXY',
          refspec: { gspRef: 'PlotFixedXFixedY_C' },
          usage: { abstract: !1 },
          existenceRule:
            'Exists iff the parent CoordSys exists and the coordinates are numbers.',
          properties: {
            coordX: { description: '', type: 'Number' },
            coordY: { description: '', type: 'Number' },
          },
        },
        getCoordX: function() {
          return this.coordX;
        },
        getCoordY: function() {
          return this.coordY;
        },
      })),
      (o.gConstraints.PlotFixedXMarkedY = o.makeClass(o.gConstraints.PlotXY, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by a fixed coordinate and a <span class="kind">Param</span> coordinate.',
          inherits: 'PlotXY',
          refspec: {
            gspRef: 'PlotFixedXMarkedY_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedXMarkedY_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule: 'Exists iff the parent Param and CoordSys exist.',
          properties: {
            coordX: { description: '', type: 'Number' },
            parents: {
              description: '',
              properties: { coordY: { description: '', kind: 'Measure' } },
            },
          },
        },
        getCoordX: function() {
          return this.coordX;
        },
      })),
      (o.gConstraints.PlotMarkedRhoFixedTheta = o.makeClass(
        o.gConstraints.PlotRhoTheta,
        {
          doc: {
            description:
              'Defines a point on a <span class="kind">CoordSys</span> determined by a <span class="kind">Param</span> and a fixed polar coordinate.',
            inherits: 'PlotRhoTheta',
            refspec: {
              gspRef: 'PlotMarkedRhoFixedTheta_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedRhoFixedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent Param and CoordSys exist.',
            properties: {
              coordTheta: { description: '', type: 'Number' },
              parents: {
                description: '',
                properties: { coordRho: { description: '', kind: 'Measure' } },
              },
            },
          },
          getCoordTheta: function() {
            return this.coordTheta;
          },
        }
      )),
      (o.gConstraints.PlotMarkedRhoMarkedTheta = o.makeClass(
        o.gConstraints.PlotRhoTheta,
        {
          doc: {
            description:
              'Defines a point on a <span class="kind">CoordSys</span> determined by two <span class="kind">Param</span> polar coordinates.',
            inherits: 'PlotRhoTheta',
            refspec: {
              gspRef: 'PlotMarkedRhoMarkedTheta_C',
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedRhoMarkedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent Param and CoordSys exist.',
            properties: {
              parents: {
                description: '',
                properties: {
                  coordRho: { description: '', kind: 'Measure' },
                  coordTheta: { description: '', kind: 'Measure' },
                },
              },
            },
          },
        }
      )),
      (o.gConstraints.PlotMarkedXFixedY = o.makeClass(o.gConstraints.PlotXY, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by a <span class="kind">Param</span> coordinate and a fixed coordinate.',
          inherits: 'PlotXY',
          refspec: {
            gspRef: 'PlotMarkedXFixedY_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedXFixedY_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule: 'Exists iff the parent Param and CoordSys exist.',
          properties: {
            coordY: { description: '', type: 'Number' },
            parents: {
              description: '',
              properties: { coordX: { description: '', kind: 'Measure' } },
            },
          },
        },
        getCoordY: function() {
          return this.coordY;
        },
      })),
      (o.gConstraints.PlotMarkedXMarkedY = o.makeClass(o.gConstraints.PlotXY, {
        doc: {
          description:
            'Defines a point on a <span class="kind">CoordSys</span> determined by two <span class="kind">Param</span> coordinates.',
          inherits: 'PlotXY',
          refspec: {
            gspRef: 'PlotMarkedXMarkedY_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedXMarkedY_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: { abstract: !1 },
          existenceRule: 'Exists iff the parent Params and CoordSys exist.',
          properties: {
            parents: {
              description: '',
              properties: {
                coordX: { description: '', kind: 'Measure' },
                coordY: { description: '', kind: 'Measure' },
              },
            },
          },
        },
      })),
      (o.gConstraints.ActionButtonShow = o.makeClass(
        o.gConstraints.ActionButtonToggleHideShow,
        {
          doc: {
            description: 'Defines an action that reveals a hidden GObject.',
            inherits: 'ActionButtonToggleHideShow',
            refspec: {
              msg:
                "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
            },
            usage: { abstract: !1 },
            existenceRule: 'Exists iff the parent objects exist.',
            properties: {
              parents: {
                description: 'Set of objects to be shown',
                type: 'Array',
              },
            },
            example:
              '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-HideShow_export.json',
          },
          updateLabelFromMessage: function() {
            this.label = this.messages[0];
          },
          setMessagesFromParent: function(e, t) {
            this.messages[0] = o.Strings.loc('GSP.Label.ShowButton', e, t);
          },
          press: function(e, t) {
            this.state.isActive ||
              ((this.state.isActive = !0),
              e.invalidateGeom(this),
              this.beginAction('show', t, e));
          },
        }
      )),
      (o.css =
        "/* For now, these are not in less. Just import them raw. */\n/*!\n  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved.\n  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20221217231404\n*/\n\n/*\n * Styles governing drawing contexts. Within the node we are given we\n * construct a relatively positioned base node. It contains an absolutely\n * positioned node that is used for clipping. All drawing context nodes\n * (canvas layers, html layers) are created within the\n * clipping node and are absolutely positioned. They must correspond exactly\n * to the height and width of the clipping node.\n */\n.wsp-version-4-8-0.wsp-base-node {\n    position: relative;\n    display: inline-block;\n    cursor: default;\n    vertical-align: top;\n    font-size: 0px; /* inline-block adds grot heights for whitespace without this */\n    overflow: visible; /* prevents inheritance of overflow: scroll, which can\n                          cause layout issues */\n\n    /* Reset to default in case our containing elt has modified. */\n    white-space: normal;\n}\n\n.wsp-version-4-8-0 .wsp-transform-node {\n  transform-origin: top left;\n  -webkit-transform-origin: top left;\n  -ms-transform-origin: top left;\n  position:absolute;\n  display: inline;\n  border-collapse: collapse;\n  border-spacing: 0px;\n  top: 0px; left: 0px;\n  padding: 0px; margin: 0px;\n}\n\n.wsp-version-4-8-0 .wsp-main-row {\n  display: flex;  /* Need this so tool-container and sketch-container are full height */\n}\n\n.wsp-version-4-8-0 .wsp-sketch-container {\n  display: table-cell;\n  position: relative;\n  vertical-align: top;\n}\n\n.wsp-version-4-8-0 .wsp-text-layer .wsp-responsive-borderwidth {\n  border-width: 1px;\n}\n\n.wsp-version-4-8-0 .wsp-transform-large {\n  display: inline-block;\n}\n.wsp-version-4-8-0  .wsp-transform-medium {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-transform-small {\n  display: none;\n}\n\n\n.wsp-version-4-8-0 .wsp-clip-node {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n.wsp-version-4-8-0 .wsp-clip-node canvas, .wsp-version-4-8-0 .wsp-text-layer, .wsp-version-4-8-0 .wsp-effects {\n    position: absolute;\n    left: 0; top: 0;\n    z-index: 0;\n}\n\n.wsp-version-4-8-0 .sketch_canvas {\n    -webkit-user-select: none;\n    -moz-user-select: -moz-none;\n}\n\n/*\n * Styles governing html-layer sketch objects.\n */\n.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Point,\n.wsp-version-4-8-0 .wsp-Text, .wsp-version-4-8-0 .wsp-Param,\n.wsp-version-4-8-0 .wsp-Button, .wsp-version-4-8-0 .wsp-Expression,\n.wsp-version-4-8-0 .wsp-Label, .wsp-version-4-8-0 .wsp-Table {\n    /*-webkit-touch-callout: none*/\n    /*-moz-touch-callout: none;*/\n    position:absolute;\n}\n\n\n/*\n  Buttons - see comment in wsp-skin.css for details\n*/\n\n.wsp-version-4-8-0 .wsp-Button {\n    display: table;\n    border-collapse: separate;\n    border-spacing: 0px;\n}\n\n.wsp-version-4-8-0 .wsp-Button-row {\n  display: table-row;\n}\n\n.wsp-version-4-8-0 .wsp-Button-drag-handle {\n  display: table-cell;\n  content: \"\";\n  height:100%;\n}\n\n.wsp-version-4-8-0 .wsp-Button-label-frame {\n  display: table-cell;\n}\n\n.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Text, .wsp-version-4-8-0 .wsp-Param, .wsp-version-4-8-0 .wsp-Expression, .wsp-version-4-8-0 .wsp-Label {\n    font-size: 12px;\n    border: none;\n    margin: 0;\n    padding: 0;\n    background-color:transparent;\n    overflow-x: visible;\n    white-space: pre;\n}\n\n.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Text {\n    cursor: default;\n}\n\n.wsp-version-4-8-0 .wsp-Measure {\n    line-height: 1;\n}\n\n.wsp-version-4-8-0 .wsp-Point {\n    cursor: pointer;\n    font-size: 8px;\n}\n\n.wsp-version-4-8-0 .wsp-Expression .mfs-input {\n    cursor: text;\n}\n\n/* styles for MFS to HTML conversion */\n.wsp-version-4-8-0 .mfs {\n    /*\n      border: solid thin red;\n    */\n    display: run-in;\n}\n\n.wsp-version-4-8-0 .mfs-bracket:before {\n    content: '[';\n}\n\n.wsp-version-4-8-0 .mfs-bracket:after {\n    content: ']';\n}\n\n.wsp-version-4-8-0 .mfs-curly:before {\n    content: '{';\n}\n\n.wsp-version-4-8-0 .mfs-curly:after {\n    content: '}';\n}\n\n.wsp-version-4-8-0 .mfs-tightness-normal {\n    letter-spacing: normal;\n}\n.wsp-version-4-8-0 .mfs-tightness-condensed {\n    letter-spacing: -0.1em;\n}\n.wsp-version-4-8-0 .mfs-tightness-expanded {\n    letter-spacing: .2em;\n}\n\n.wsp-version-4-8-0 .mfs-frac {\n    display: inline-block;\n    font-size: 90%;\n    vertical-align: middle;\n    text-align: center;\n}\n\n\n.wsp-version-4-8-0 .mfs-paren + .mfs-exponent,\n.wsp-version-4-8-0 .mfs-abs + .mfs-exponent,\n.wsp-version-4-8-0 .mfs-root + .mfs-exponent {\n    vertical-align: .9em;\n}\n\n.wsp-version-4-8-0 .mfs-exponent{\n    vertical-align: super;\n    font-size: 70%;\n}\n\n.wsp-version-4-8-0 .mfs-frac .mfs-numr, .wsp-version-4-8-0 .mfs-frac .mfs-denm{\n    display: block;\n}\n\n.wsp-version-4-8-0 .mfs-super-group, .wsp-version-4-8-0 .mfs-sub-group, .wsp-version-4-8-0 .mfs-horizontal, .wsp-version-4-8-0 .mfs-root, .wsp-version-4-8-0 .mfs-paren,\n.wsp-version-4-8-0 .mfs-bracket, .wsp-version-4-8-0 .mfs-curly, .wsp-version-4-8-0 .mfs-abs {\n    display: inline-block;\n    text-decoration: inherit;\n}\n.wsp-version-4-8-0 .mfs-horizontal {\n  white-space: pre;\n}\n.wsp-version-4-8-0 .mfs-param {\n    /*\n     * background-color: lightgray;\n     */\n    display: inline-block;\n}\n\n.wsp-version-4-8-0 tbody { vertical-align: baseline; }\n\n.wsp-version-4-8-0 .mfs-paren, .wsp-version-4-8-0 .mfs-root,\n.wsp-version-4-8-0 .mfs-abs {\n    display: inline-table;\n    border-collapse: collapse;\n    border-spacing: 0px;\n}\n\n.wsp-version-4-8-0 .mfs-paren td, .wsp-version-4-8-0 .mfs-root td,\n.wsp-version-4-8-0 .mfs-abs td {\n    padding: 0px;\n}\n\n.wsp-version-4-8-0 .mfs-paren td.mfs-left-paren,\n.wsp-version-4-8-0 .mfs-paren td.mfs-right-paren,\n.wsp-version-4-8-0 .mfs-abs td.mfs-abs-bar\n {\n    background-size: 100% 100%;\n}\n\n.wsp-version-4-8-0 .mfs-root td.mfs-left-root {\n    background-size: 105% 100%;\n}\n\n.wsp-version-4-8-0 .mfs-root td.mfs-right-root {\n    background-size: 100% 100%;\n}\n\n.wsp-version-4-8-0 td.mfs-right-root {\n    padding-top: .15em;\n}\n\n/* Paren TD's have a dummy span under them, which fixes a rendering\nissue with chrome. If you set the width of the TD itself, chrome adds\nan extra two pixels to the adjoing td containing the parenthesized\nexpression! */\n.wsp-version-4-8-0 .mfs-paren td.mfs-left-paren >span,\n.wsp-version-4-8-0 .mfs-paren td.mfs-right-paren >span\n{\n    display: inline-block;\n    width: .35em;\n}\n\n/* See above comment on paren TD's */\n.wsp-version-4-8-0 .mfs-root td.mfs-left-root >span\n{\n    display: inline-block;\n    width: .7em;\n}\n\n/* See above comment on paren TD's */\n.wsp-version-4-8-0 .mfs-abs td.mfs-abs-bar >span\n{\n    display: inline-block;\n    width: .2em;\n}\n\n.wsp-version-4-8-0 .mfs-subscript {\n    font-size: smaller;\n    vertical-align: sub;\n}\n.wsp-version-4-8-0 .mfs-style {\n    display: inline;\n}\n\n.wsp-version-4-8-0 .mfs-overbar-arc, .wsp-version-4-8-0 .mfs-overbar-ray, .wsp-version-4-8-0 .mfs-overbar-line,\n.wsp-version-4-8-0 .mfs-overbar-seg {\n    display: inline-block;\n    line-height: 1.4;\n    background-repeat: no-repeat;\n}\n\n.wsp-version-4-8-0 .mfs-overbar-ray, .wsp-version-4-8-0 .mfs-overbar-line {\n    background-size: 100% .3em;\n    padding-top: .02em;\n}\n\n.wsp-version-4-8-0 .mfs-overbar-arc {\n    background-size: 100% .7em;\n    padding-top: .55em;\n}\n\n.wsp-version-4-8-0 .mfs-overbar-seg {\n    background-size: 100% 100%;\n}\n\n.wsp-version-4-8-0 .mfs-overbar-line > .mfs-horizontal .mfs-text:last-child:after,\n.wsp-version-4-8-0 .mfs-overbar-ray > .mfs-horizontal .mfs-text:last-child:after {\n    content: \"\\200A\\200A\"; /* two hair spaces */\n}\n\n.wsp-version-4-8-0 .mfs-overbar-seg > .mfs-horizontal .mfs-text:last-child:after {\n    content: \"\\200A\"; /* one hair space */\n}\n\n.wsp-version-4-8-0 .mfs-underbar-seg {\n    border-bottom-width: thin;\n    border-bottom-color: black;\n    border-bottom-style: solid;\n    line-height: 0.9;\n    display: inline-block;\n}\n\n.wsp-version-4-8-0 .mfs-text {\n    display: inline;\n}\n\n/* Add some padding to the left of italic text, to workaround\n  WSP-1751 \"In Safari, screen garbage left behind when you drag a parameter\"\n*/\n.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child,\n.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child,\n.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-sub-group:first-child > .mfs-text.mfs-text-italic:first-child,\n.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-sub-group:first-child > .mfs-text.mfs-text-italic:first-child,\n.wsp-version-4-8-0 .wsp-Measure > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child\n {\n    padding-left: 0.2em;\n}\n\n.wsp-version-4-8-0 .mfs-vertical-group {\n    display: inline-block;\n}\n\n/* This allows us to use a negative margin to shrink the size,\naccomodating borders. If we're a child of an mfs-vertical-group, this property\nis overridden by that child selector. */\n.wsp-version-4-8-0  .wsp-mfs-reference {\n    display: inline-block;\n}\n\n.wsp-version-4-8-0 .mfs-vertical-group > * {\n    display: block;\n}\n\n.wsp-version-4-8-0 .wsp-text-layer * {\n    -ms-user-select: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -o-user-select: none;\n    user-select: none;\n}\n\n.wsp-version-4-8-0 .wsp-text-layer {\n    line-height: normal;\n    pointer-events: none;\n    border: none;\n}\n\n/* Add border:none to make sure mfs nodes based on html tables (such as mfs-paren) don't inherit disfiguring borders */\n.wsp-version-4-8-0 .wsp-text-layer table,\n.wsp-version-4-8-0 .wsp-text-layer td,\n.wsp-version-4-8-0 .wsp-text-layer tr {\n    border: none;\n}\n\n.wsp-version-4-8-0 .mfs-input {\n    font-size: inherit;\n    display: inline-block;\n    white-space: nowrap;\n    overflow: visible;\n    color: inherit;\n    font-family: inherit;\n}\n\n.wsp-version-4-8-0 .wsp-numeric {\n     position: absolute;\n   }\n\n.wsp-version-4-8-0 .wsp-numfield-text {\n    white-space: nowrap;\n}\n\n@-webkit-keyframes blinker { from {opacity:1.0;} to {opacity:0.0;} }\n          @keyframes blinker { from {opacity:1.0;} to {opacity:0.0;} }\n.wsp-version-4-8-0 .wsp-blink {\n    font-size: larger;\n    color: black;\n    font-stretch: ultra-condensed;\n    /*text-decoration:blink;*/\n\n    -webkit-animation-name:blinker;\n            animation-name:blinker;\n    -webkit-animation-iteration-count:infinite;\n            animation-iteration-count:infinite;\n    -webkit-animation-timing-function:cubic-bezier(1.0,0,0,1.0);\n            animation-timing-function:cubic-bezier(1.0,0,0,1.0);\n    -webkit-animation-duration:1s;\n            animation-duration:1s;\n}\n\n.wsp-version-4-8-0 .wsp-selected {\n    background-color: yellow;\n}\n.wsp-version-4-8-0 .wsp-Numberpad {\n    position: absolute;\n    pointer-events: auto;\n    -webkit-user-drag: element;\n}\n\n.wsp-version-4-8-0 .wsp-Numberpad:focus {\n    outline: 0;\n    border: 1px solid black;\n}\n\n.wsp-version-4-8-0 .wsp-Numberpad, .wsp-version-4-8-0 .wsp-Numberpad *,\n.wsp-version-4-8-0 .wsp-Numberpad *:before, .wsp-version-4-8-0 .wsp-Numberpad *:after {\n    /** needs to be set to default in case it has been changed by any plugins/frameworks **/\n    /* Bootstrap changes the setting of box-sizing, which is a setting\n       that tells browser whether to take margin, padding into account when imposing the\n       height/width property. */\n    -webkit-box-sizing: content-box;\n    -moz-box-sizing: content-box;\n    box-sizing: content-box;\n}\n\n/* The body of the Numberpad */\n.wsp-version-4-8-0 .wsp-Numberpad-body {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-direction: column;\n    flex-direction: column;\n    -webkit-justify-content: space-around;\n    justify-content: space-around;\n}\n\n/* A row of Buttons */\n.wsp-version-4-8-0 .wsp-Numberpad-row {\n    display: -webkit-flex;\n    display: flex;\n    -webkit-flex-direction: row;\n    flex-direction: row;\n    -webkit-justify-content: space-around;\n    justify-content: space-around;\n}\n\n.wsp-version-4-8-0 .wsp-error-message {\n  text-align: center;\n  margin-top: 25px;\n  margin-bottom: 25px;\n  color: red;\n  font-size: 125%;\n}\n\n.wsp-version-4-8-0 .wsp-tool-container {\n  display: table-cell;\n  position: relative;\n  vertical-align: top;\n}\n\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-draggable-toolButton {\n  position: absolute;\n  /* Set the z-index. The stacking context is the wsp-transform-node. We\n  need our z-index to place us above the wsp-sketch-container, over\n  which we will be dragged. Otherwise, a sketch with a non-transparent\n  background will occlude us. */\n  z-index: 1;\n}\n\n\n.wsp-version-4-8-0 .wsp-tool > img {\n  display: block;\n}\n\n\n.wsp-version-4-8-0 .wsp-text-target-highlight {\n  background-color: rgba(255,0,0,0.5) !important;\n}\n\n/* We could, if desired, move the wsp-Transform section into\n * wsp-skin.css and make the transform skinnable.\n * For that to be worthwhile, we would need to make the scale factors\n * used customizable. The css transform isn't a problem - customizers\n * just change it. But wsp.js needs to know that at init time, and it's\n * a bit tricky to encode something in css readable by js (e.g. hiding some info\n * in a hidden node is stymied by browsers that don't set properties until the node\n * is displayed. You could stash something in content::after but querying that isn't\n * supported on IE). Best I can think of here is to have a wsp-responsize-size-small-factor\n * class (and medium, etc.), with some property like opacity set to [0,1]. Code would then sniff that\n * by inserting a node into the DOM. This would have to match the value used in transform: scale();\n */\n/* Section Start: wsp-Transform */\n\n/* The transform node is the target for css transforms that\n  scale down the content to fit in smaller form factor devices.\n\n  CSS transforms are used for the scaling - but since those\n  do not change the content size of their targets, we need\n  to fix our content size too. The technique used is to take\n  the actual content containing wsp-transform-node out of the flow,\n  and create sibling DOM elements (wsp-transform-large, wsp-transform-medium,\n  wsp-transform-small) of appropriate size, and make sure the right one is displayed\n  while the rest are not.\n*/\n\n/* .wsp-transform-node will be position: absolute, with transform-origin: top left\n  wsp-transform-large by default is display: inline-block,\n  wsp-transform-medium, wsp-transform-small are display: none\n  Turn on large, medium, small using media queries - you'll need to override the\n  default ones.\n*/\n\n/*\n *  For our default sizing, some assumptions and numbers.\n *  For a normal desktop sketch, we'll take a usual width as 800px (Mac window is 780x540 by default)\n *\n *  For a mobile friendly document, we'll take as a baseline iPad landscape width (1024), where our ideal sketch width is 600px.\n *  On iPad portrate width (768px = 75% of 1024px), our ideal sketch width is 400px (75% of 600px)\n *  On Smartphone portrate (480px = 46.875% of 1024px), our ideal sketch width is 300px (50% of 600px)\n *\n *  The media queries are conditionalized by several classes on the root node.\n *  wsp-responsiveSizing: must be present for responsive sizing to be in effect\n *  wsp-responsiveSizing-small-size: support the 50% size;\n *  wsp-responsiveSizing-medium-size: support the 75% size;\n *  wsp-responsiveSizing-medium-break: if present, a break at the medium device width\n *    chooses medium size if available, otherwise small size\n *  wsp-responsiveSizing-small-break: if present, a break at the small device width\n *    chooses small size if available, otherwise medium size\n *\n */\n\n/*\n * First break half way between iPad landscape and iPad Portrate\n * ideal sketch width: 400px;\n * max-width: 892px\n * scale factor: 0.75;\n*/\n@media only screen and (max-width: 892px) {\n\n\n  /* Small size default if .wsp-responsiveSizing-medium-size*/\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-large {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .mfs-responsive-borderwidth {\n    border-width: 2px;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-medium {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-small {\n    display: inline-block;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-node {\n    transform: scale(0.5);\n    -webkit-transform: scale(0.5);\n    -ms-transform: scale(0.5);\n  }\n\n  /* Override with medium size if wsp-responsiveSizing-medium-size */\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-large {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .mfs-responsive-borderwidth {\n    border-width: 2px;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-medium {\n    display: inline-block;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-small {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-node {\n    transform: scale(0.75);\n    -webkit-transform: scale(0.75);\n    -ms-transform: scale(0.75);\n  }\n}\n\n/*\n * Second break half way between iPad portrate and Smartphone portrate\n * ideal sketch width: 300px;\n * max-width: 624px\n * scale factor: 0.5;\n*/\n@media only screen and (max-width: 624px) {\n\n  /* Default to medium size if .wsp-responsiveSizing-medium-size */\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-large {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .mfs-responsive-borderwidth {\n    border-width: 2px;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-medium {\n    display: inline-block;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-small {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-node {\n    transform: scale(0.75);\n    -webkit-transform: scale(0.75);\n    -ms-transform: scale(0.75);\n  }\n\n  /* Override to small size if .wsp-responsiveSizing-small-size */\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-large {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .mfs-responsive-borderwidth {\n    border-width: 2px;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-medium {\n    display: none;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-small {\n    display: inline-block;\n  }\n  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-node {\n    transform: scale(0.5);\n    -webkit-transform: scale(0.5);\n    -ms-transform: scale(0.5);\n  }\n}\n/* Section End: wsp-Transform */\n\n/* Section Start: wsp-Calculator */\n/* On mobile safari, there's an annoying dark background tap effect\n   in our mathquill edit area. Turn if off */\n.wsp-version-4-8-0 .wsp-Calculator-display {\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n/* Section End: wsp-Calculator */\n\n/* CSS Utilities */\n\n/* A version of the clearfix a la https://css-tricks.com/snippets/css/clear-fix/ */\n.wsp-version-4-8-0 .wsp-clearfix-group:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.wsp-sr-only {\n  border: 0;\n  height: 100%;\n  overflow: hidden;\n  top: 0;\n  position: absolute;\n  width: 100%;\n  color: transparent;\n  background-color: transparent;\n  pointer-events: none;\n}\n.wsp-sr-only:focus {\n  outline: none !important;\n}\n.wsp-live-node {\n  width: 0;\n  height: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n.wsp-version-4-8-0 {\n  /*\n  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved.\n  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20221217231404\n*/\n  /* Section Start: wsp-Button */\n  /*\n\n  The outer element of a button will have class .wsp-Button\n  Additional modifiers will be added as classes\n  .wsp-appearance-drag: The button is being dragged / moved;\n  .wsp-appearance-unselect: The button is not arrow selectable\n    and thus not draggable;\n  .wsp-appearance-short: The button is < 28 pixels high;\n  .wsp-appearance-pressed: The button is depressed by user action;\n  .wsp-appearance-active: The button is performing its action, which may\n    continue after it's been clicked;\n\n\n  Within the button we have some substructure to allow\n  for a drag handle, a row of mfs text, and allow for the text\n  top to move down one pixel during a click as part of it's depressed\n  appearance.\n\n  wsp-Button contains a wsp-Button-row\n  wsp-Button-row contains a wsp-Button-drag-handle and a wsp-Button-label-frame\n  wsp-Button-label-frame contains a wsp-Button-label\n\n+-------------------wsp-Button--------------------------+\no--wsp-Button-row-x------wsp-Button-label-frame--------o|\n||                |                                    ||\n||                +------------------------------------||\n|| wsp-Button-    |                                    ||\n|| drag-handle    |                                    ||\n||                |    wsp-Button-label                ||\n||                |                                    ||\n||                |                                    ||\no-----------------x------------------------------------o|\n+-------------------------------------------------------+\n\n*/\n  /* base style for the whole button */\n  /* When it's dragging about, lighten it up */\n  /* Styles for the handle - the dragable bit on the left of the button */\n  /* When the button is short (< 28 px high) */\n  /* Non-arrow selectable buttons don't have a full sided drag handle.\n It just becomes a narrow vertical strip */\n  /* frame the button label (where the text is).\n The frame is the part that's stable when the button is pressed down,\n so it's just responsible for the top border */\n  /* Some padding and border for the interior portion of the label */\n  /* When pressed the frame lets the the label handle the\n border so it can move down a pixel */\n  /* Add the border on the top now that the frame has punted it to us */\n  /* When the button is working, a background */\n  /* When the button is working, it looks pressed */\n  /*\nIf you want to remove the drag handle completely, here is one approach:\n\n.wsp-Button-drag-handle {\n  display: none !important;\n}\n\n.wsp-Button-label-frame {\n  border-left: 2px solid #c2b892 !important;\n  border-bottom-left-radius: 5px !important;\n  border-top-left-radius: 5px !important;\n}\n\n.wsp-Button-label {\n  padding: 0px 3px 0px 3px !important;\n}\n*/\n  /* Section End: wsp-Button */\n  /* Section Start: wsp-HotText */\n  /*\n  Tweak the \"hot\" part of the appearance of a hot-text caption.\n*/\n  /* Section End: wsp-HotText */\n  /* Section Start: wsp-Tool */\n  /*\n\n.wsp-tool-container contains a .wsp-tool-column\n.wsp-tool-column contains a number of individual .wsp-tool's\n\nA .wsp-tool is an instance of a tool.\n\nNote that Numpad and Tools share a png of a \"X\"\n\n\nTo move the tool palette to the right, you will need change the float\nof the .wsp-sketch-container and .wsp-tool-container, and change some padding and\nmargins.\n\n.wsp-sketch-container {\n  float: left!important;\n}\n.wsp-tool-container {\n  float: right!important;\n  padding-right: 0px!important;\n  margin-right: 0px!important;\n  padding-left: 10px!important;\n  margin-left: 5px!important;\n}\n\n*/\n  /* colors */\n  /* default background */\n  /* active tool text color */\n  /* new look tools: border color */\n  /* undo/redo background color */\n  /* Toolplay classic Look: Background to blend in with box-shadow -\n  you see this outside the rounded border */\n  /* Toolplay New Look: Tool text color */\n  /* a common background color */\n  /* Toolplay new look: Background color for undo/redo hover */\n  /* These tool styles are shared between new and classic looks. */\n  /* Section End: wsp-Tool */\n  /* Section Start: wsp-Parameter */\n  /*\n  Styles for the box around editable values in the sketch\n*/\n  /* Section End: wsp-Parameter */\n  /* Section Start: wsp-Numberpad */\n  /*\n  A numeric entry keypad or \"Numberpad\" has a header and a body. The\n  body contains rows of entries, which are either keys or blank\n  spaces.\n\n *\n *  +-wsp-Numberpad------------------------------------------------------------------+\n *  | +-wsp-Numberpad-header-------------------------------------------------------+ |\n *  | |                                                                            | |\n *  | |                                                       wsp-Numberpad-cancel | |\n *  | |                                                           +--------------+ | |\n *  | |                                                           |              | | |\n *  | |                                                           |       X      | | |\n *  | |                                                           +--------------+ | |\n *  | +----------------------------------------------------------------------------+ |\n *  | +-wsp-Numberpad-Body---------------------------------------------------------+ |\n *  | | +wsp-Numberpad-Row-------------------------------------------------------+ | |\n *  | | | +wsp-Numberpad-key/element/key-1-----+           +-----------+         | | |\n *  | | | |          |             |           |           |           |         | | |\n *  | | | |    1     |             |      2    |           |     3     |         | | |\n *  | | | +----------+             +-----------+           +-----------+         | | |\n *  | | +------------------------------------------------------------------------+ | |\n *  | | +------------------------------------------------------------------------+ | |\n *  | | |  +----------+             +----------+           +-----------+         | | |\n *  | | |  |          |             |          |           |           |         | | |\n *  | | |  |    4     |             |     5    |           |     6     |         | | |\n *  | | |  +----------+             +----------+           +-----------+         | | |\n *  | | +------------------------------------------------------------------------+ | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | | +  +----------+             +----------+           +-----------+        |  | |\n *  | | |  |          |             |          |           |           |        |  | |\n *  | | |  |    7     |             |     8    |           |     9     |        |  | |\n *  | | |  +----------+             +----------+           +-----------+        |  | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | | |  +----------+             +-----------+          +-----------+        |  | |\n *  | | |  |          |             |           |          |           |        |  | |\n *  | | |  |    .     |             |     0     |          |    +/-    |        |  | |\n *  | | |  +----------+             +-----------+          +-----------+        |  | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | |                                                                            | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | | |  +---------+                                     +-----------+        |  | |\n *  | | |  |         |                                     |           |        |  | |\n *  | | |  | clear   |                                     |delete-left|        |  | |\n *  | | |  +---------+                                     +-----------+        |  | |\n *  | | +-----------------------------------------------------------------------+  | |\n *  | |                                                                            | |\n *  | |                                                                            | |\n *  | +----------------------------------------------------------------------------+ |\n *  +--------------------------------------------------------------------------------+\n *\n *\n *\n */\n  /* The Numberpad as a whole */\n  /* The Numberpad header bar. Contains the cancel button. */\n  /* The \"cancel\" button in the header, contains an \"x\" */\n  /* The \"erase to left\" button */\n  /* The clear button */\n  /* A pressable key, like a number or a control key */\n  /* A pressable key or empty space between keys */\n  /* Each key contains its button text as an attribute. Remove or\n   override this to change how keys look. */\n  /* You can override the key text for any key. */\n  /* These keys are not present by default, but can be enabled with\njavascript (see section on Javascript customization). */\n  /* Style for a pressed key */\n  /* One of the special control keys: delete left, clear, or \"+-\". These\n   control key elements also have the wsp-Numberpad-key class, but the\n   style rule below will override styles applied only to that class. */\n  /* Section End: wsp-Numberpad */\n  /* Section Start: misc */\n  /*\n  Various misc. styles\n*/\n  /* In sketch text for error messages e.g. when the document has an unsupported version. */\n  /* Section End: misc */\n  /* Tables */\n  /* Calculators */\n  /* override  bootstrap within a calculator */\n  /* Render styles */\n  /* Insert new styles ABOVE this line to keep version scoping */\n}\n.wsp-version-4-8-0 .wsp-Button {\n  cursor: pointer;\n  padding: 0;\n  background-color: transparent;\n  border: none;\n}\n.wsp-version-4-8-0 .wsp-Button.wsp-appearance-drag {\n  opacity: .8;\n}\n.wsp-version-4-8-0 .wsp-Button-drag-handle {\n  width: 10px;\n  min-width: 10px;\n  padding: 0px;\n  margin: 0px;\n  border: 1px solid;\n  border-bottom: 3px solid;\n  border-color: rgba(0, 0, 0, 0.2);\n  border-bottom-left-radius: 5px;\n  border-top-left-radius: 5px;\n}\n.wsp-version-4-8-0 .wsp-appearance-unselectable .wsp-Button-drag-handle {\n  background-image: none;\n  width: 5px;\n  min-width: 5px;\n}\n.wsp-version-4-8-0 .wsp-Button-label-frame {\n  border-top: 1px solid #c2b892;\n  border-bottom-right-radius: 5px;\n  border-top-right-radius: 5px;\n  background-color: #f5f5ed;\n}\n.wsp-version-4-8-0 .wsp-Button-label {\n  padding-left: 2px;\n  padding-right: 2px;\n  border-style: solid;\n  border-color: #c2b892;\n  border-left-width: 0px;\n  border-right-width: 1px;\n  border-top-width: 0px;\n  border-bottom-width: 3px;\n  border-bottom-right-radius: 5px;\n  border-top-right-radius: 5px;\n}\n.wsp-version-4-8-0 .wsp-appearance-pressed .wsp-Button-label-frame {\n  border-top-color: transparent;\n}\n.wsp-version-4-8-0 .wsp-appearance-pressed .wsp-Button-label {\n  padding-top: 1px;\n  border-top-width: 1px;\n  border-bottom-width: 1px;\n}\n.wsp-version-4-8-0 .wsp-appearance-active .wsp-Button-label-frame {\n  border-top-color: transparent;\n  opacity: 1;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAoCAIAAACw1AcgAAAKmWlDQ1BpY2MAAHjalZZ3UJPpFsbP933phZaAgJTQO1KkCyT0AArSwUZIAgRCjCFBBGzI4gqsBRURrOiiiIKrUmQtiAXbItiwb5BFRV1FXWyo3D+4xHvv3Dt39sy8M78588zzvue8/zwAtL08qVSMagDkSOSymNAAVlJyCov4AChAAxKogQ2PnyvlREdHwv+s97cBAQC44cCTSsXw90pTIMzlAyDRAJAmyOXnACDHAJAyvlQmB8DYAGC+WC6VA2ACAGDKkpJTALB8AGBmTHAFADDTJngXADBlcTGBANgxABKNx5NlAFA7AYCVx8+QA1CVAOAkEYgkADQNAPDjZ/IEALRoALDPyVkoAKAVAYB12r/4ZPybZ5rKk8fLUPHELAAAQAoS5UrFvCV/cx3/v3LEisk7jACAlpsdGwEAWgBIPp8XHDvJmUJu5CRL5QExkyySc+NUGkVY/CQrsuM5k5y9MEKll6TNilL55wamTHJBZlziJAuEQcGTLFsYo9Ln5sUGf9cHzprkLF549CTzZACTLBSHxnx/c7TqnRLxLNUs6bIQlUaY+31eeWZcmIplcSpNuiiEq5pXFvbdXxyt8pQpYlR7EEriVZ4CXpBqtxAIIpCAEHKABywIgyAAuTBfDgAQuFC6RCbKyJSzOFKpWGjP4kr4jvYsFydnF0hKTmFNfNe7O4AAAKJD+t4rPAnAKQRAI773EmwBGnoBmAu+98xfAzBbAE4U8xWyvIkeDgAADxRQBybogRGYgTU4gAu4gw+wIRjCIQriIBnmAx8yIQdksBiKYCWUQjmsh81QAzthD+yHQ3AE2uAEnIELcAV64RbcByUMwQsYgfcwhiAIEaEjDEQPMUYsEDvEBfFE/JBgJBKJQZKRVCQDkSAKpAhZhZQjlUgNshtpQH5BjiNnkEtIH3IXGUCGkbfIZxRDaSgTNUQt0WmoJ8pBI9A4dB6agS5CC9ASdC1ajdahB9FW9Ax6Bb2FKtEX6CgGGBXTwUwwB8wTC8SisBQsHZNhy7AyrAqrw5qwDqwbu4EpsZfYJxwBx8CxcA44H1wYLh7Hxy3CLcNV4Gpw+3GtuHO4G7gB3AjuG56ON8Db4b3xXHwSPgO/GF+Kr8LX41vw5/G38EP49wQCQYdgRfAghBGSCVmEQkIFYTuhmdBJ6CMMEkaJRKIe0Y7oS4wi8ohyYilxK/Eg8TTxOnGI+JFEJRmTXEghpBSShFRMqiIdIJ0iXSc9JY2RNcgWZG9yFFlAXkJeR95L7iBfIw+RxyiaFCuKLyWOkkVZSammNFHOUx5Q3lGpVFOqF3U2VURdQa2mHqZepA5QP9G0aLa0QNpcmoK2lraP1km7S3tHp9Mt6Wx6Cl1OX0tvoJ+lP6J/VGOoOapx1QRqy9Vq1VrVrqu9UierW6hz1OerF6hXqR9Vv6b+UoOsYakRqMHTWKZRq3Fco19jVJOh6awZpZmjWaF5QPOS5jMtopalVrCWQKtEa4/WWa1BBsYwYwQy+IxVjL2M84whJoFpxeQys5jlzEPMHuaItpb2dO0E7XztWu2T2kodTMdSh6sj1lmnc0Tnts7nKYZTOFOEU9ZMaZpyfcoH3am6bF2hbplus+4t3c96LL1gvWy9DXpteg/1cfq2+rP1F+vv0D+v/3Iqc6rPVP7UsqlHpt4zQA1sDWIMCg32GFw1GDU0Mgw1lBpuNTxr+NJIx4htlGW0yeiU0bAxw9jPWGS8yfi08XOWNovDErOqWedYIyYGJmEmCpPdJj0mY6ZWpvGmxabNpg/NKGaeZulmm8y6zEbMjc1nmheZN5rfsyBbeFpkWmyx6Lb4YGllmWi52rLN8pmVrhXXqsCq0eqBNd3a33qRdZ31TRuCjadNts12m15b1NbNNtO21vaaHWrnbiey227XZ4+397KX2NfZ9zvQHDgOeQ6NDgOOOo6RjsWObY6vpplPS5m2YVr3tG9Obk5ip71O9521nMOdi507nN+62LrwXWpdbrrSXUNcl7u2u76ZbjddOH3H9DtuDLeZbqvduty+unu4y9yb3Ic9zD1SPbZ59HsyPaM9KzwveuG9AryWe53w+uTt7i33PuL92sfBJ9vngM+zGVYzhDP2zhj0NfXl+e72Vfqx/FL9dvkp/U38ef51/o/ZZmwBu579lGPDyeIc5LwKcAqQBbQEfAj0Dlwa2BmEBYUGlQX1BGsFxwfXBD8KMQ3JCGkMGQl1Cy0M7QzDh0WEbQjr5xpy+dwG7ki4R/jS8HMRtIjYiJqIx5G2kbLIjpnozPCZG2c+mGUxSzKrLQqiuFEbox5GW0Uviv51NmF29Oza2U9inGOKYrpjGbELYg/Evo8LiFsXdz/eOl4R35WgnjA3oSHhQ2JQYmWiMmla0tKkK8n6yaLk9hRiSkJKfcronOA5m+cMzXWbWzr39jyrefnzLs3Xny+ef3KB+gLegqOp+NTE1AOpX3hRvDreaBo3bVvaCD+Qv4X/QsAWbBIMC32FlcKn6b7plenPMnwzNmYMZ/pnVmW+FAWKakRvssKydmZ9yI7K3pc9Lk4UN+eQclJzjku0JNmScwuNFuYv7JPaSUulykXeizYvGpFFyOpzkdx5ue1yplwqv6qwVvygGMjzy6vN+7g4YfHRfM18Sf7VJbZL1ix5WhBS8HMhrpBf2FVkUrSyaGApZ+nuZciytGVdy82WlywfWhG6Yv9Kysrslb8VOxVXFv+1KnFVR4lhyYqSwR9Cf2gsVSuVlfav9lm980fcj6Ife9a4rtm65luZoOxyuVN5VfmXCn7F5Z+cf6r+aXxt+tqede7rdqwnrJesv73Bf8P+Ss3KgsrBjTM3tm5ibSrb9NfmBZsvVU2v2rmFskWxRVkdWd2+1Xzr+q1fajJrbtUG1DZvM9i2ZtuH7YLt13ewdzTtNNxZvvPzLtGuO7tDd7fWWdZV7SHsydvzZG/C3u6fPX9uqNevL6//uk+yT7k/Zv+5Bo+GhgMGB9Y1oo2KxuGDcw/2Hgo61N7k0LS7Wae5/DAcVhx+/kvqL7ePRBzpOup5tOmYxbFtLYyWslakdUnrSFtmm7I9ub3vePjxrg6fjpZfHX/dd8LkRO1J7ZPrTlFOlZwaP11werRT2vnyTMaZwa4FXffPJp29eW72uZ7zEecvXgi5cLab0336ou/FE5e8Lx2/7Hm57Yr7ldarbldbfnP7raXHvaf1mse19l6v3o6+GX2nrvtfP3Mj6MaFm9ybV27NutV3O/72nf65/co7gjvP7orvvrmXd2/s/ooH+AdlDzUeVj0yeFT3u83vzUp35cmBoIGrj2Mf3x/kD774I/ePL0MlT+hPqp4aP2145vLsxHDIcO/zOc+HXkhfjL0s/VPzz22vrF8de81+fXUkaWTojezN+NuKd3rv9v01/a+u0ejRR+9z3o99KPuo93H/J89P3Z8TPz8dW/yF+KX6q83Xjm8R3x6M54yPS3kyHgAAYACApqcDvN0HQE8GYPQCUNQm8i4AACATGR1gIoP8d57IxAAA4A6wpxMgsRMgvBNgBxvAgg3AAIBoNkAcG1BXV9X5Z+Wmu7pMeFHbAPBV4+PvEgGINgBf+8fHx9rGx7/WA2D3ADrfT+RsAACCBkClGbrCpep06/oV/5l3/wHNmfXlY/st0gAAAAlwSFlzAAAASAAAAEgARslrPgAAAAl2cEFnAAAAAQAAACgAg9PABgAAADBJREFUCNdjWPjgPxMjAwMTEyMDEzOUZmJkYGJGphmIE4OJMzMhyRNhJgwzMmCYBQDI9ANK1RWWcgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMi0xMi0xOFQxNjoxNDowOS0wODowMMK1MMQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTItMTItMThUMTY6MTQ6MDktMDg6MDCz6Ih4AAAAAElFTkSuQmCC');\n  background-repeat: no;\n  background-size: 100% 100%;\n}\n.wsp-version-4-8-0 .wsp-appearance-active .wsp-Button-label {\n  padding-top: 1px;\n  border-top-width: 1px;\n  border-bottom-width: 1px;\n}\n.wsp-version-4-8-0 .wsp-mfs-reference-tracking {\n  outline: 1px solid rgba(255, 0, 0, 0.1);\n}\n.wsp-version-4-8-0 .wsp-mfs-reference {\n  background-color: rgba(255, 0, 0, 0.01);\n  border: 1px solid rgba(255, 0, 0, 0.1);\n  border-radius: 5px;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  /* Cancel the bottom border-radii for numerators */\n  /* No top border or radius for denominators */\n  margin: -1px;\n}\n.wsp-version-4-8-0 .wsp-mfs-reference.mfs-numr {\n  border-bottom-right-radius: 0px;\n  border-bottom-left-radius: 0px;\n  -moz-border-bottom-right-radius: 0px;\n  -moz-border-bottom-left-radius: 0px;\n  -webkit-border-bottom-right-radius: 0px;\n  -webkit-border-bottom-left-radius: 0px;\n}\n.wsp-version-4-8-0 .wsp-mfs-reference.mfs-denm {\n  border-top-style: none;\n  border-top-right-radius: 0px;\n  border-top-left-radius: 0px;\n  -moz-border-top-right-radius: 0px;\n  -moz-border-top-left-radius: 0px;\n  -webkit-border-top-right-radius: 0px;\n  -webkit-border-top-left-radius: 0px;\n}\n.wsp-version-4-8-0 .wsp-mfs-reference:hover {\n  background-color: rgba(255, 0, 0, 0.1);\n}\n.wsp-version-4-8-0 .wsp-mfs-reference.wsp-mfs-reference-hot {\n  background-color: rgba(255, 0, 0, 0.5);\n  border-color: #ff0000;\n}\n.wsp-version-4-8-0 .wsp-sketch-container {\n  /* It's ok to float this left; it will still be right of the wsp-tool-container. */\n  /* With \"float: right;\", at least in FireFox, there's an unavoidable gap between tools and sketch */\n  float: left;\n}\n.wsp-version-4-8-0 .wsp-tool-container {\n  float: left;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-redo {\n  background-color: #FFFFFF;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool-overflow-y.wsp-user-tools {\n  overflow-y: auto;\n  overflow-x: hidden;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool-logo {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-button:hover,\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-button:hover {\n  background-color: #FFFFFF;\n  cursor: pointer;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-button:focus,\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-button:focus {\n  outline: 0;\n  /* gets rid of blue box around focusables in chrome */\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-disabled .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-disabled .wsp-redo-button {\n  opacity: .3;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-disabled .wsp-undo-button:hover,\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-disabled .wsp-redo-button:hover {\n  cursor: default;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool {\n  background-color: white;\n  word-wrap: break-word;\n  white-space: normal;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-draggable-toolButton {\n  box-sizing: content-box;\n  /* This simplifies dynamic sizing of the draggable */\n  border: 2px solid #0087FF;\n}\n.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-tool-active {\n  background-color: #ffffc8;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook,\n.wsp-version-4-8-0 .wsp-tools-compactLook {\n  /* The following styles are common to these two looks */\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo-bottom,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo-bottom {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-image,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-image {\n  margin: auto;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool {\n  width: 100%;\n  text-align: center;\n  font-weight: 200;\n  border: 2px solid black;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button {\n  width: 50%;\n  height: 44px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position: center;\n  background-origin: content-box;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button .wsp-inner-text,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button .wsp-inner-text {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button {\n  background-color: #F5F5F5;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook {\n  background-color: #F5F5F5;\n  padding-right: 10px;\n  margin-right: 5px;\n  min-width: 100px;\n  /* Box shadow for classicLook. Some oddities here: when we set overflow\n    to auto/scroll on an element, that seems to kill the box shadow. So\n    when there's overflow, we put the box shadow on the enclosing element\n    which in this case will be the same size as the visible portion of\n    .wsp-tools-inner */\n  /* Leave 1px space to align right edge with right edge of user tools */\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-column {\n  border-radius: 5px;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-column.wsp-no-tool-icons {\n  width: 125px;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-fixed-tool,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tools-inner,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-overflow-y.wsp-user-tools {\n  box-shadow: 2px 2px black;\n  /* Reduced the shadow and removed the blur to avoid intruding into elements below the sketch_canvas */\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-fixed-tool {\n  margin-right: 1px;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tools-inner {\n  background-color: #393838;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool {\n  font-size: 24px;\n  border-radius: 5px;\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook {\n  /*  The compact look is designed for tools that use icons and no text */\n  /*  If a tool is displayed as text, its name needs to be short enough to fit using 20-pt type. */\n  background-color: #DDD;\n  padding-right: 0px;\n  border-right: 2px solid black;\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook,\n.wsp-version-4-8-0 .wsp-tools-compactLook *,\n.wsp-version-4-8-0 .wsp-tools-compactLook *:before,\n.wsp-version-4-8-0 .wsp-tools-compactLook *:after {\n  box-sizing: border-box;\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column {\n  width: 105px;\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column .wsp-undo-redo {\n  background-color: inherit;\n  /* use the same background color for the entire column */\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column .wsp-undo-redo button {\n  border: 2px solid black;\n  border-radius: 9px;\n  vertical-align: top;\n}\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool {\n  font-size: 20px;\n  /* If you must have a tool with no icon, its name needs to be short enough for 20-pt type */\n  padding: 5px 0;\n  border-radius: 9px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook {\n  padding-right: 0px;\n  margin-right: 0px;\n  border-left: 2px solid #cdcdcd;\n  border-bottom: 2px solid #cdcdcd;\n  border-right: 2px solid #cdcdcd;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook,\n.wsp-version-4-8-0 .wsp-tools-newLook *,\n.wsp-version-4-8-0 .wsp-tools-newLook *:before,\n.wsp-version-4-8-0 .wsp-tools-newLook *:after {\n  box-sizing: border-box;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-user-tools {\n  background-color: white;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner > :last-child {\n  border-bottom: 2px solid #cdcdcd;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool {\n  display: table;\n  width: 220px;\n  border-top: 2px solid #cdcdcd;\n  padding-right: 20px;\n  min-height: 58px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool .wsp-tool-media {\n  width: 40px;\n  height: 40px;\n  display: table-cell;\n  vertical-align: middle;\n  padding: 5px 0px 0px 7px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool .wsp-tool-text {\n  display: table-cell;\n  max-width: 109px;\n  word-wrap: break-word;\n  padding: 7px 10px 7px 10px;\n  vertical-align: middle;\n  font-family: 'Proxima Nova', arial, sans-serif;\n  color: #2d2d2d;\n  font-size: 18px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo-top {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button {\n  margin-right: 2px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button {\n  width: 109px;\n  background-color: white;\n  position: relative;\n  border: none;\n  height: 58px;\n  padding: 0px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button:hover,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button:hover {\n  background-color: #f0f0f0;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-text,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-text {\n  position: absolute;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-icon {\n  width: 20px;\n  height: 20px;\n  left: 40px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  position: absolute;\n  top: 12px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-text,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-text {\n  top: 33px;\n  font-size: 14px;\n  left: 33px;\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button {\n  background-color: white;\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-button {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAQAAADbnPi/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBBYQOhiFrU+GAAAEnklEQVRo3u2Z3WsdRRiHn53dU2zqR61gtBQsKi1t1Ua8EUEQ03/AOylU8aONEiGxYi9V8E4Q0ys1qUIEb0Sai1xFChEvFKRKY0UvilA/oB8cJBITmuzMvl7s7DknJ7vJfirC/JYDh2V35jm/eeedd+aAk5OTk5OTk5OTk5OTU0fqvwYoJg9QRDW36K27I/ZTkx7D7+ugHKZPQJA5XoqAoI6ePL5hjrcI0CVbUCiinjFqcRu3MMA2PIQ1VljiL8LM5wsqYIU3WWSiBLJCYWznOxniMAc5wB52soOW9VIIWWaRP/iZn1jgAotEdkRKYs8jCCeBoMBbPr6FfoBTnKONbLiilHttznGKQzZ0klYK6UuE1ULIvo3F3bzGeYxFMYSEaOt51IGOiDBoQsKeZ89zkt3W6YLQ8wgajfBqDmRlmx9imiWLFKJT3ZRU1zWhfXqJaYasBQWS6zyCIcqFHDd8mBlMBzUfaP+VYBtmeKjHiNzAsiVy3OQgU4Q2APK6mu12HCSaKQbz+5wAJ8jjqchx1D5PuxNAdV0ag9DmOeKILgCcjRwAg8zW5GyW07MMkmPi9wInyGM9L3oEwDBXkJ55XgUv7QcbQoQrDAPB5uvheuB+5HiQxojs/XKI2qa8brKLk2CI6cHXRESMdwIwJ3AvcgsfmCjtrUl5z2xwuJvoYp/fA1QWclrEeCgME8BpfD7hGOFWw7RBgkGhUMAiC1zkF37lKsus4XETO9nDXvYzxD5aAGgUCo+Qce7gGRQZNd5Gh7sujzKJsFZiEsWOXeJdhtm1yQ9T3McxzrJovda2v0+zXU4HjuMsXlbLpKlVPueI9a5bXPrWdWWLUb9TPd/JKBetUYY1hClIT3JZwDFyMdx4XEKm2Q94eDlqYEVgwQKeYgHBoFlDeDs9ZLOBi08xjfAVD5MUNfnj3rPFv88IbYSQEOHZNOS6gDXCMqNAwWKmBzqu3O7irM1LKzzChl1nPcAhwo8cgs4Al5Nn89ErtrC6wAB9e8Q6gEOEWW5my1UqlxQB8ARtDMJp+iZfdeAQ4WNyli451QIO8htCxJPrkasCh50UVO8JRwDcz2WEb22RUAtwiPAZmyylFZEf5BrCaK/HVYA1wtdsp6nzowA4gvA7t3c9Lg8cIVznXqgxdvvVAsYQXqeTkcsDG4SnKXY8UFw+MEebHYnHZYE1cYnSnLuxFHAPmpGkr3LAEUKbvfwbp58B8AY/xA6X7S4C5rhMq9aTz3QZ4B0CHkfwywL7CEd5mbDhCAYQfG4wxVHAq5olXqLpSUeMyS5m2F41Ag3vM4JuHFnw+ZPveLQacLz3+4ARdGdv0RwyfMG+qg4nyCcaj+UIWEBVT0ox8oecaNxlxSpXubu6LwkyTFb44yGfLnFrHWk/QT7eqMsCXKNVzzoVI09yvMFYFmCpvoW1i9xkkltlqb5KIEF+scHAEP5W9ks9yB6GKV5oMDBuJA0XQ87aDikEwxngo5r/EE6kA3u6VdeOzMNHOIPPZCPI2zwOMEBUCFgwmyJH+Ci+rx0Wmt8uFFDOUfZQeDVNuvVqvrB3cnJycnJycnJycnJy+p/pHzDs9DpRnhI/AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA0LTIyVDE2OjU4OjI0LTA0OjAwOz+VcAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNC0yMlQxNjo1ODoyNC0wNDowMEpiLcwAAAAASUVORK5CYII=);\n}\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-redo-button,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-redo-button {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAQAAADbnPi/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBBYQOCnmRS0+AAAElElEQVRo3u3YT6gd5R3G8c+8M0fQaBuzMFYESy0t/k20i3ZTECN03Z0IUqw1USLcaKnLIrgrFHVl6y2FFLopYhZZKVKlCxfFQtKWFnUTWsEqF0m5NSR3/rxdzNyTc5Nz7p1zZkYQ5hkOHM6Z8853nnne3/s7L6NGjRo1atSoUaNGjRo16kuqkPQ4WNK8Lis2r95wVd2BE0GCSrXgIgFR1Rk9EXy3C3AQdmBOfNUNrnONRLTlgk3/lS88fzllCs/7wWrAQVA2ju132CF3usOt9ttn0sQiyn3uvI/80z+cdcb5xqd0BexM4YQX/XF52FTaQN/lOW/ZEK86qjmfbXjLc+4WdozSFpdnRdHby8MmuMWz3lM2KKVcrlCqVFPY+n2pkMtnzn3PT93SON0Oehv3kuid9rChGf6wkzYbpFwx18041/VC3py96aTDjQWhBe4zokKxjMP1wPc6pZyitgO98tjGLp1yaMaIvXArZVvgesiD1hVNANq6utjtOiS5dQd38XkWN7YFrlP7mA1RubKv870uRBt+rE70PNwTU9yWwBkOOt2Ts4ucPu1gc63FuC2AExmO+Ficmec7L9j9Fkq56GNHkE2X9gxrO3D3BK4f0gmVaiYIVVPEcuVMASuawrYqfqFSWZsGcB7uHsCJgBdnvJ1XGaqrfC8XPIt2Pr+E1GQubgOcLcBNVH7nUblMolLJZMh94Iz3nfOR8y6KrrHPzW5zu3scsl9QN0KpZZb9IJFbc8BjcmteUjZNVQvV7v5etDWdy9F5r3vU7bsW+gOO+KUPp09k2YhsiV51fI67u0YixbpoS9n88G+Ou8l2x5vKZFKhOdLmk+1bmXjIay5ZpQyWzYJezf1uLnCGF0RbCqXorB82BSedgVo8UTOJBN92Ur7Aq92RywW/mAuc4UeiXC7acEyKMFNw2kRqu0m6z5/E5sa7H3OAA77jQjNnX3ezyx3astruEY77XOxlhbwKOMF1zqgblKfVS0eX/ySpDHf5uyjvHzjFy6LShgfYM7Ht4pHheqd7QL4COMWDKtG/3IlJZ9jLIyf4bWfkHcD1gvhn0TnfdGUj0lVhWiq7IO8ATnFc9Il7esetDQn4QyfkGeAEN/q36KFBcGuXuda7HSrGDHCGn4nW9JndK5XiGz4VV+zqpsAJ9tnwRjPocMrwcHPpDsApjinc1jy4IZWq26pVYrHD4b/6uaHSO6uAr9tYKRal6O0gFX1f5hcoBweuTJzzBqvusdVN8iPWXZTqc2t0vjK5pzwidpkt1zrlAJ26hra4PNmtSgR8z1989gX4mykc80q34AV8y5v63Smfp4nCMb9a5r/aIuDgrJUnQUtlcke74xJ8zX9cGrj+ThSO+nV3XIKv+HBQ2G13e8ElmPjEkAmeKDzRF26d4c0BgTO5J7zaFy7BpksDwdaFrFdcgv8N5u5E4Sf94hJcHAg3k3vcurLZWOmuWA9bDIIbFB73mz3cXenZ3jAILkdX7hl26yXeSaQDNZX3q5TCri4ut6cUBRfandpXCnvQcCBDLPbJF9Cxjxo1atSoUaNGjRo1atSowfR/LRgeDFizcN0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDQtMjJUMTY6NTY6NDEtMDQ6MDCxoYPjAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA0LTIyVDE2OjU2OjQxLTA0OjAwwPw7XwAAAABJRU5ErkJggg==);\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-button .wsp-inner-icon {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAQAAACBf8+OAAAAtUlEQVR4AbXTVwHEIBBF0SthJEQCEpCABKTEARIiYSUgAQmRMBLSt6XXM588OtCxCD3BE4hdBTzCjEhCEHKUiorUxauuimmXPlJSEXF8ua6TYvnhqOjLM2XR/5bAO54QpoQSxUAvUf10mGNQ4rvvOxhwCPNyKlzfs8CTsU5QXhxQUHGAp8Kwm6XCPhZ/L+aJrR46yPc17fN+BP/9DfOy3yf2pihuzwPumZ3f423/5/vt4ta+dg3LzGOPpQRi5AAAAABJRU5ErkJggg==);\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-redo-button .wsp-inner-icon {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAQAAACBf8+OAAAAu0lEQVR4AbXTBxmFIBQF4BPhRjDCjUAEIhDFBkQwwotABCIYgQi+87n39ncxDrgxI3DwCPXiWZa+3SyjBap6CVxiXUrIIVwiWyYMUh206LEc2Fa2Q0dcPZPBEnvapZ9IGS0hWBLEPu7RCowrVvRhLizXLIs51gl7fT9IQD8kFvZlcCigoIqF05Rxh9MM4+az+MWLuXir5x5kr39N5/UfwQn9J5Zt9uagcx+wReJC538PBZ3/+Xr7v7adR/85A2OP4hj58QAAAABJRU5ErkJggg==);\n}\n.wsp-version-4-8-0 .wsp-Numberpad-cancel {\n  cursor: pointer ;\n  display: block ;\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAB4ElEQVQ4y61UvWsUQRx9s1mEIyF6FpYKFxvB2ORSBgu54giYIoWg/0Caa201nVUqMWksgohY2KlXuFttkBR3CSQHFprAFRZinHXvbm/d25t5FnGP2w8ICz4YmHnDvPl9zBsBSyKNzr3LtVsw1oMx6rMzuAoAvoIsmWh+gX532/Y+ZQ7BkpNRpaoEig4vQKDoVKkq02cnkza5wiLQWrbJlYRQlapCrSWLQmsZR2YAgKONXQhRRlEIUXa0sXteWKpa5iZ3KNsejxJcNCLP9KsgJ7AOVQ2K3EmwfT+K8377m12SpBqRn+UTWBLrX/k6LaTIHSMYo54I95JpEmgAwIMW7kDzJVqDZ2KITQC4P4/FdIbBGHVBzT4E5hI7oxGw7zdEhOfT9PZiubtxDdcztSIG+UIA4A8h9kMRLxdulN9/u4nV3KITfcNXyD5tHQFH4dNp6qSLR28kvDwdX8E1SiaaCXYcAc5gM64J785vcRaPAdd7eOhe+djDcVqoZKKZbX9vEMRd2z7717UwJC3ZgCWBDl/kth+WRMZfP/3vH36l3lEYkj/0Vi/Hd1mLFLVJ2iIt2zs9EGKtkE1I90CItZbtnQI4FwKAJdt1lqEXIo29izT+aOwtC1aXbNeZ2O5/fWx/AXUQdBRBFjTDAAAAAElFTkSuQmCC);\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tool-cancel > .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-cancel,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-cancel,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wwcFx4ZWcAjlgAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADyUlEQVRo3t1aT0gUURj/xi7TFkoLKxiMePLPShAiUogFgoKIeOjQRSoPnrzEijcPHRW6JEQX9eDFi4c8dJEIF4KNkBTEDrUHdTUwMWHezu46O29+Hd7kmm26M/Mmt/1gYRnevPn93nzv+37f90YhCQZAI6L7RNRBRFEiaiCiWiIKOUMyRPSdiLaI6DMRfSSiuKIoKbosAxAGEAOQgHdLOHOE/yVwDcA0AAvyzHLm1IIGPyEZeDEiE0EAb/PpKl5cq00W+KGAV/28tzHkF3wMl2+x/xm8NxKO25SbFXUnpdiGdRLNFSov40TUoSjKp9MXq4oMfFmG4MnB9PLsxaqzcZ6I7lD52p2/5gknw14YLq2vX2H09oLv7UlxbL63B6OnB1Yy6Sa8asUITJdyt9HdDaaqSLe2+ibBd3eRbm0FU1UYvb1ubp0uJsxKSlZWMgnW0FAgsbvrHXw0Kua5fRv82ze3SS7sOeZbm5tgN2+Kh0ejrknwVKoAvqMD/ODAX27wonOstTWw2loBoqUFPJUqHXxLi3Cbe/fAj44866XTm9eT5RMJsHC4QGJn53zwOztINzef+DxnzG8M0Hxn3fy7d9BragSJ5ua/kuDb2wXwg4Ows1k52bnU6HOemW/eQL9+vUBie/tP8E1NYKqKzMOHsE1TlryYJgBvZcxkLi5CD4UEiaamExJ8a6sAfngYtiVVmb8lAElZs5nz89BVVZBobEQ+Hke6sRFMVZEdHYVt27IFXpIA6DJnPH71Cswh8euXHR8PSqHqFES1lXv+/AR87tmzQKu2qkAkVy5X+G+agbdJ5LrQixdi9TUN+eVlME1D9unTIPz/xIWkbeLjmRkBPhKBtb4u3vH6OlgkguzICGzOA9nEcsLowgL0q1eh19QgH4//nuxWVqBXVyMzNAQ7n5ceRv0nsqUl6NeuQQ+FYC4tFR/z+jX0UAiZBw9g53JSE5k/KbG8DL26GkxVcTw3d76Lzc4KKdHfD9swpEkJ72Lu/XvoN26IcDk1VVqInZwUJLq7wXXf8UPzLqdXV8EiEZGoxsZc3ZuNxQSJzk7wHz/8yWlPBc3GBlhdndA3jx+7DpG2bSPz6JGQHO3t4Pv7vgua0kvKL1/A6uvFCg4MeFaWtmnCGBgQJG7dclvVWX+cKbgt6o2uLt8bkafTMLq6xHw9Pd6LeldtlWQSRl8f+OGhnLbK4SGMvj7/bZVTBxjlbhMX9UYTZdyd+6Aoyt3Kbu46A56U4eo/OQu+cg84KuKIqSIO+SrimLUiDror5lODcvzYQ/nfP7f5Cce8asR3hlrBAAAAAElFTkSuQmCC);\n}\n.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tool-ok > .wsp-inner-icon,\n.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-ok,\n.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-ok,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wwcFwczGXtDWAAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADqklEQVRo3t2aXYgbVRTHfzuzIKNZkIFkRmTFUKSgMShIwz4HpeC8VCHgILoQYfXNKQgDAYtQykJx8QNcCj4UBH0QhUVRH7b65toHcbEpYgsbZF9mMrgg2ZKH7vT2JZHpNbXJzNxssxcuzD1zz+F/zj3n3Dv3zBw5NN/3a1EULYdhuBQEwWK3213Y29ub7/f7cwCGYQjTNA9KpVLPtu1dy7K2isXixdXV1cscVmu1Wsdc192oVqs9QKTp1Wq157ruRqvVOjY14L7v1xzH2dZ1XaQFLndd14XjONu+79eUgm80Gpt5Ah+lSKPR2MwduOd5bhZXSeNanue5uYBvNpvrKq3+f6vRbDbXM4F3XXdj2sDlPsAwm+BTKzFYOnE/9bHdyfM89zB8fpyYGCuwp5lt0mSne+b5qQE6gWAdwc8I/kDww3h8d90nfN+vTc11XkBwHcFOovvju1Jyx9aGD+12+0Icx+rPIiZwDtATtOvA2njscRzTbrcv/OdgNjXrfyxZ/hqCpycP6OEBUAPodDprU7H+88CLEm0duDKZmDiO6XQ6a9PNPAUEW5L1v0GgZ8xIg4BQ7zr+CNc5nk2m7/s1LYqiZeWu8yjwukT7DPgzm9goipa1MAyXlCvwDvBAYvw38EF2sWEYLmlBECwqBV8FHIl2HuhlFx0EwaLW7XYXlCrgJXcb4Hfgy3xEd7vdBQqFwi1lgfukFLg7CJ7JT36hULilDa8+lLQ3pfEmsJ2f+H6/Pzc/MdfDwGvAc8CNgT/vjJj3GHBSon2Yv43mDcMQ+/v746/C18DjUpC+BITSvDeApHkuAVfzBW8YhtBM0zyYiOsnafwI8ClgJGgPAqekeR8pOBea5oFWKpUmS2hnge8l2lPA+4nxKeAhSekr+StQKpV6mm3buxNxCeBt4BeJfhJ4ZfD8qvTuEzU5wrbtXc2yrK2JOW8CbwF/yRemQAM4nqBdA35Vo4BlWVtasVi8mIr7n0Gg3pB8f1Wa97m6PfJf7JmO0y+P2KyG/SqCBbUf+BpApVL5MbUZvgK+u8u7b/M584xqQ8waQLlcPq3renpp7wJ7I+hfqAGv6zrlcvn0HUTHcbYzLWsdweXBbcNvCN5T93E0wHrnrUSlUlnJtAqXgBrwBPAscEad9SuVysrhX2yl7PcsgMza1aImE+r1ejZXQp3r1Ov1laN/vX4kChxHosSUdKeZLfIlqzYzW2aV94mZLHTLhZCZ/dVArincDz97zOW1Kof1u81tdvvvyyQ7/+AAAAAASUVORK5CYII=);\n}\n.wsp-version-4-8-0 .wsp-ok-cancel-mode > .wsp-undo-button,\n.wsp-version-4-8-0 .wsp-ok-cancel-mode > .wsp-redo-button {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel {\n  cursor: pointer;\n  display: block;\n  top: 0px;\n  right: 0px;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel .wsp-inner-text {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok {\n  cursor: pointer;\n  display: block;\n  top: 0px;\n  right: 38px;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok .wsp-inner-text {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-ok-cancel-button {\n  position: absolute;\n  margin-right: 10px;\n  margin-top: 10px;\n  height: 28px;\n  width: 28px;\n  background-size: 28px, 28px;\n  background-color: #888888;\n  border-radius: 14px;\n  border-color: #888888;\n  border-style: solid;\n  border-width: thin;\n  box-shadow: 3px 3px 7px #888888;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-accessible:focus {\n  outline: none;\n}\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Measure:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Text:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Button:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Expression:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Table:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-Table > div:focus,\n.wsp-version-4-8-0 .wsp-sketch-container table:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .mfs-input:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .mfs-param:focus,\n.wsp-version-4-8-0 .wsp-sketch-container .wsp-parameter-sr-only:focus {\n  outline: none;\n  outline-offset: 2px;\n  z-index: 100000 !important;\n}\n.wsp-version-4-8-0 .wsp-tool-background {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n.wsp-version-4-8-0 .input-element {\n  position: relative;\n  display: inline-block;\n  width: auto;\n}\n.wsp-version-4-8-0 .input-element input {\n  width: 100%;\n  position: absolute;\n  color: transparent;\n  background-color: transparent;\n  margin: 2px 0px;\n}\n.wsp-version-4-8-0 .mfs-input,\n.wsp-version-4-8-0 .mfs-html-input {\n  background-color: white;\n  border: thin solid;\n  padding: 2px;\n  margin: 2px;\n  vertical-align: middle;\n  min-width: .6em;\n  min-height: 1.2em;\n  text-align: start;\n}\n.wsp-version-4-8-0 .wsp-Numberpad {\n  width: 172px;\n  height: 298px;\n  background-color: #00bdec;\n  border-radius: 9px;\n  border: thin gray solid;\n  padding: 0px 8px 8px 8px;\n}\n.wsp-version-4-8-0 .wsp-Numberpad button:focus {\n  outline: none;\n  outline-offset: 2px;\n  z-index: 100000 !important;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-header {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMDAlJyBoZWlnaHQ9JzI1Jz48cmVjdCBmaWxsPSd3aGl0ZScgeD0nNicgeT0nNicgd2lkdGg9JzkwJScgaGVpZ2h0PScyJy8+PHJlY3QgZmlsbD0nd2hpdGUnIHg9JzYnIHk9JzEyJyB3aWR0aD0nOTAlJyBoZWlnaHQ9JzInLz48cmVjdCBmaWxsPSd3aGl0ZScgeD0nNicgeT0nMTknIHdpZHRoPSc5MCUnIGhlaWdodD0nMicvPjwvc3ZnPgo=\");\n  background-repeat: no-repeat;\n  background-color: #00bdec;\n  height: 25px;\n  margin-bottom: 8px;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-cancel {\n  margin-left: auto ;\n  text-align: center ;\n  vertical-align: middle ;\n  font-weight: bold ;\n  font-size: larger ;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: #00bdec;\n  border-color: #00bdec;\n  height: 28px;\n  width: 28px;\n  border-style: solid;\n  border-width: thick;\n  border-radius: 16px;\n  padding: 0px;\n  outline-offset: 0px !important;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-erase-to-left {\n  /* the following is an svg image of the 'erase to left' unicode character,\n       \\u232b, base64 encoded. To see original, cut out the quoted part after\n       base64, then un-base64 encode.  */\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgCnhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgZmlsbC1vcGFjaXR5PSIxIiBjb2xvci1yZW5kZXJpbmc9ImF1dG8iCmNvbG9yLWludGVycG9sYXRpb249ImF1dG8iIHN0cm9rZT0iYmxhY2siIHRleHQtcmVuZGVyaW5nPSJhdXRvIgpzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1vcGFjaXR5PSIxIgpzaGFwZS1yZW5kZXJpbmc9ImF1dG8iIGZpbGw9ImJsYWNrIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBzdHJva2Utd2lkdGg9IjEiCnN0cm9rZS1saW5lam9pbj0ibWl0ZXIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBpbWFnZS1yZW5kZXJpbmc9ImF1dG8iCndpZHRoPSIxMDBweCIgaGVpZ2h0PSIxMDBweCIgdmlld0JveD0iMCAwIDI3NyAyMDAiID4KPHBhdGggZD0iTTI2MiAxODYKTDEwMSAxODYKTDE1ICAxMDAKTDEwMSAgMTMKTDI2MiAgMTMKTDI2MiAxODYKWk0yNDggMTcyIApMMjQ4ICAyNwpMMTA3ICAyNwpMMzUgIDEwMApMMTA3IDE3MgpMMjQ4IDE3MgpaTTIxNyAxMzMKTDIwNyAxNDMKTDE3NCAxMDkKTDE0MCAxNDMKTDEzMSAxMzMKTDE2NCAxMDAKTDEzMSAgNjYKTDE0MCAgNTYgCkwxNzQgIDkwCkwyMDcgIDU2CkwyMTcgIDY2CkwxODMgMTAwCkwyMTcgMTMzIFoiIHN0cm9rZT0ibm9uZSIvPgo8L3N2Zz4K\");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 30px;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-clear {\n  /* the following is an svg image of the 'circled latin capital letter c'\n       unicode character, \\u2428, base64 encoded. To see original, cut out\n       the quoted part after base64, then un-base64 encode.  */\n  background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+Cgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMC8vRU4nICdodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCc+CjxzdmcgZmlsbC1vcGFjaXR5PSIxIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKY29sb3ItcmVuZGVyaW5nPSJhdXRvIiBjb2xvci1pbnRlcnBvbGF0aW9uPSJhdXRvIiBzdHJva2U9ImJsYWNrIgp0ZXh0LXJlbmRlcmluZz0iYXV0byIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIgpzdHJva2Utb3BhY2l0eT0iMSIgc2hhcGUtcmVuZGVyaW5nPSJhdXRvIiBmaWxsPSJibGFjayIgc3Ryb2tlLWRhc2hhcnJheT0ibm9uZSIKc3Ryb2tlLXdpZHRoPSIxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiCnN0cm9rZS1kYXNob2Zmc2V0PSIwIiBpbWFnZS1yZW5kZXJpbmc9ImF1dG8iIHdpZHRoPSIxMDBweCIgaGVpZ2h0PSIxMDBweCIKdmlld0JveD0iMCAxNTMgMjg3IDI4NyI+CjxwYXRoIGQ9Ik0xNDQgMTc2IApRMTc2IDE3NiAyMDQgMTkyIApRMjMyLjMxMjUgMjA4LjY4NzUgMjQ4IDIzNyAKUTI2NC42NTYyIDI2NC42NTYyIDI2NSAyOTcgClEyNjQuNjU2MiAzMjguOTIxOSAyNDggMzU3IApRMjMyLjE3MTkgMzg0Ljg5MDYgMjA0IDQwMSAKUTE3Ni4wNjI1IDQxNy4yMzQ0IDE0NCA0MTcgClExMTEuOTM3NSA0MTcuMjM0NCA4NCA0MDEgClE1NS44MjgxIDM4NC44OTA2IDQwIDM1NyAKUTIzLjM0MzggMzI4LjkyMTkgMjMgMjk3IApRMjMuMzQzOCAyNjQuNjU2MiA0MCAyMzcgClE1NS42ODc1IDIwOC41NDY5IDg0IDE5MiAKUTExMS43OTY5IDE3NiAxNDQgMTc2IApaTTE0NCAzOTkgClExODUuOTA2MiAzOTkgMjE2IDM2OSAKUTI0Ni41MTU2IDMzOC43NjU2IDI0NyAyOTcgClEyNDYuNTE1NiAyNjkuNTc4MSAyMzMgMjQ2IApRMjE4Ljk1MzEgMjIxLjkwNjIgMTk1IDIwOCAKUTE3MS4yODEyIDE5NC4zNDM4IDE0NCAxOTQgClExMDEuODEyNSAxOTQuMzQzOCA3MiAyMjUgClE0MS40ODQ0IDI1NC44MTI1IDQxIDI5NyAKUTQxLjQ4NDQgMzM4Ljc2NTYgNzEgMzY5IApRMTAyIDM5OSAxNDQgMzk5IApaTTIwMyAzMjAKUTE5Ni41OTM4IDM0Mi44NDM4IDE4MiAzNTQgClExNjcuMzQzOCAzNjUuMjAzMSAxNDcgMzY1IApRMTE0LjA0NjkgMzY1LjIwMzEgOTkgMzQ0IApRODQuMDkzOCAzMjMuNTc4MSA4NCAyOTUgClE4NC4wOTM4IDI2Mi44MjgxIDEwMiAyNDUgClExMTkuMzkwNiAyMjYuNTQ2OSAxNDcgMjI3IApRMTY2Ljc4MTIgMjI2LjU0NjkgMTgxIDIzNyAKUTE5NC42MjUgMjQ2LjUxNTYgMjAwIDI2NiAKTDE4MyAyNzAgClExNzguMzEyNSAyNTUuNzk2OSAxNjkgMjQ5IApRMTYwLjQ1MzEgMjQxLjU5MzggMTQ3IDI0MiAKUTEyNS4xNTYyIDI0MS41OTM4IDExNCAyNTYgClExMDIuNTE1NiAyNzAuMjgxMiAxMDMgMjk1IApRMTAyLjUxNTYgMzIzLjE1NjIgMTE0IDMzNyAKUTEyNi40MjE5IDM0OS44NzUgMTQ1IDM0OS44NzUgClExNjEuMDE1NiAzNDkuODc1IDE3MSAzNDEgClExODAuODQzOCAzMzIuODU5NCAxODUgMzE2IApMMjAzIDMyMCBaCiIgc3Ryb2tlPSJub25lIiAvPgo8L3N2Zz4K\");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 30px;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-key {\n  cursor: pointer;\n  background-color: #eee;\n  border: thin black solid;\n  border-radius: 8px;\n  font-family: Lucida Grande, sans-serif;\n  font-size: 20px;\n  color: black;\n  text-align: center;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-element {\n  margin: 1px;\n  width: 44px;\n  height: 44px;\n  display: inline-block;\n  vertical-align: middle;\n  line-height: 48px;\n  padding: 0px;\n}\n.wsp-version-4-8-0 .wsp-Numberpad-key:after {\n  content: attr(data-keyText);\n}\n.wsp-version-4-8-0 .wsp-Numberpad-key:active,\n.wsp-version-4-8-0 .wsp-Numberpad-key-down {\n  background-color: #636568;\n  border-color: transparent;\n  color: white;\n}\n.wsp-version-4-8-0 button.wsp-Numberpad-control-key {\n  background-color: #c5dee5;\n  border-radius: 5px;\n}\n.wsp-version-4-8-0 .wsp-error-message {\n  text-align: center;\n  margin-top: 25px;\n  margin-bottom: 25px;\n  color: red;\n  font-size: 125%;\n}\n.wsp-version-4-8-0 .wsp-Table > div > table {\n  border-collapse: collapse;\n}\n.wsp-version-4-8-0 .wsp-Table {\n  border-right: 1px solid;\n  border-bottom: 1px solid;\n}\n.wsp-version-4-8-0 .wsp-Table > div > table,\n.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > th,\n.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td {\n  border: 1px solid;\n  text-align: center;\n}\n.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td.wsp-final-row-cell {\n  opacity: 0.5;\n}\n.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td {\n  padding: .1em .4em .1em .4em;\n}\n.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > th {\n  font-weight: normal;\n  font-style: italic;\n  padding: .2em .3em;\n}\n.wsp-version-4-8-0 .wsp-Calculator {\n  width: 389px;\n  height: 356px;\n  background-color: #00bdec;\n  border-radius: 9px;\n  border: thin gray solid;\n  padding: 0px 6px 10px 8px;\n  cursor: default;\n}\n.wsp-version-4-8-0 .wsp-Calculator-title {\n  background-color: #ecf8ff;\n  text-align: center;\n  border-radius: 5px;\n  margin-top: 4px;\n  padding: 2px 0;\n}\n.wsp-version-4-8-0 .wsp-Calculator-display {\n  border-radius: 4px;\n  height: 80px;\n  background-color: white;\n  margin: 7px 0;\n  overflow: auto;\n  font-size: 18px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-display-wrapper {\n  position: relative;\n}\n.wsp-version-4-8-0 .wsp-Calculator-body-wrapper {\n  display: inline-block;\n}\n.wsp-version-4-8-0 .wsp-Calculator-body-wrapper > .wsp-Calculator-body {\n  display: inline-block;\n  margin-left: 7px;\n  /* The default vertical-align for display:inline-block is\n     baseline. This leaves room at the bottom for letters like \"j.\"\n     Setting vertical-align to \"top\" eliminates the spacing. */\n  vertical-align: top;\n}\n.wsp-version-4-8-0 .wsp-Calculator-left {\n  display: inline-block;\n  border-radius: 4px;\n  vertical-align: top;\n  width: 140px;\n  height: 186px;\n  background-color: #ecf8ff;\n  margin-top: 3px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-label-insert {\n  width: 50%;\n  text-align: center;\n  margin: 35px auto 10px auto;\n}\n.wsp-version-4-8-0 .wsp-Calculator-textual {\n  font-family: Lucida Grande, sans-serif;\n  font-size: 16px;\n}\n.wsp-version-4-8-0 .wsp-Calculator button.dropdown-toggle {\n  background-color: #f0f0f0;\n  border: 2px outset #f0f0f0;\n}\n.wsp-version-4-8-0 .wsp-Calculator .dropdown-toggle {\n  width: 110px;\n  white-space: nowrap;\n}\n.wsp-version-4-8-0 .wsp-Calculator-left .dropdown-toggle {\n  height: 24px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .dropdown {\n  display: inline-block;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-select-function ul {\n  top: -220px;\n  left: 110px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-select-units ul {\n  top: -70px;\n  left: 110px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-select-equation ul {\n  top: -170px;\n  left: 135px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-topmost-select-for-insert,\n.wsp-version-4-8-0 .wsp-Calculator-select-for-insert {\n  margin-top: 10px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-left .dropdown {\n  margin-left: 15px;\n  margin-right: 15px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-select-for-insert > button,\n.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-topmost-select-for-insert > button {\n  box-sizing: border-box;\n}\n.wsp-version-4-8-0 .wsp-Calculator-bottom {\n  margin-top: 15px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-select-equation {\n  margin-left: 30px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-bottom-button {\n  margin-left: 30px;\n  border-radius: 5px;\n  padding: 2px 10px 3px;\n  background-color: #C0C0C0;\n  border: 2px outset #C0C0C0;\n  height: 19px;\n}\n.wsp-version-4-8-0 .wsp-Calculator-ok-button-inner {\n  padding: 0 10px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .dropdown a {\n  cursor: pointer;\n  margin-left: 3px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .selected a {\n  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxzdmcgd2lkdGg9IjE5LjIxMzE1IiBoZWlnaHQ9IjE4LjI5NDk5NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDxtZXRhZGF0YSBpZD0ibWV0YWRhdGE3Ij5pbWFnZS9zdmcreG1sPC9tZXRhZGF0YT4KCiA8Zz4KICA8dGl0bGU+TGF5ZXIgMTwvdGl0bGU+CiAgPGcgaWQ9ImxheWVyMSI+CiAgIDxwYXRoIGQ9Im00Ljc3NDY5LDE4LjI5NDk3OWMtMC4yNzUwMSwtMC4wMDM1NCAtMS40NjE4MSwtMS43Nzg0MzkgLTIuNjM3MzQsLTMuOTQ0MTQ5bC0yLjEzNzM0LC0zLjkzNzgxbDAuNTU0MDIsLTAuNTUzOTZjMC4zMDQ2OSwtMC4zMDQ3NSAxLjEyMzY3LC0wLjU1NDAyIDEuODE5OTUsLTAuNTU0MDJsMS4yNjU5NSwwbDAuNjM2MzgsMi4wMDUwN2wwLjYzNjM4LDIuMDA1MDdsNS4wNjQ0OCwtNS41NDEzMmMyLjc4NTQ1LC0zLjA0NzczIDYuMDAzMDcsLTYuMDQzNjQgNy4xNTAyNDEsLTYuNjU3NTlsMi4wODU3NDksLTEuMTE2MjdsLTQuMjA5NDM5LDQuNzgyMTdjLTIuMzE1MiwyLjYzMDI1IC01LjQ1MTM1LDYuNzQ4MDUgLTYuOTY5MjQsOS4xNTA3NmMtMS41MTc4OCwyLjQwMjcxIC0yLjk4NDc5LDQuMzY1NjYgLTMuMjU5NzgsNC4zNjIwNjFsLTAuMDAwMDEsLTAuMDAwMDExeiIgaWQ9InBhdGgyMjIzIiBmaWxsPSIjMDAwMDAwIi8+CiAgPC9nPgogPC9nPgo8L3N2Zz4=);\n  background-repeat: no-repeat;\n  background-position: left;\n  background-size: 16px 16px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math sup {\n  margin-top: 0.5em;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math sup {\n  margin-top: 0.5em;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mathquill-editable.hasCursor {\n  box-shadow: none;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-calculator-edited {\n  padding: 5px;\n  min-width: 364px;\n  min-height: 69px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-calculator-edited .mq-blob > .wsp-ref {\n  background-color: rgba(238, 238, 238, 0.8);\n  display: inline-block;\n  margin: 0px 2px;\n  min-width: 0.7em;\n  text-align: center;\n  padding: 0 1px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math .numerator {\n  padding: 0.1em 0.1em;\n}\n.wsp-version-4-8-0 .wsp-Calculator,\n.wsp-version-4-8-0 .wsp-Calculator *,\n.wsp-version-4-8-0 .wsp-Calculator *:before,\n.wsp-version-4-8-0 .wsp-Calculator *:after {\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-independent-variable {\n  font-style: italic;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-syntax-error-notice {\n  display: none;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-syntax-error-notice:after {\n  content: '!';\n}\n.wsp-version-4-8-0 .wsp-Calculator.wsp-syntax-error .wsp-syntax-error-notice {\n  color: red;\n  background-color: #f8f8f8;\n  font-size: 24px;\n  display: inline;\n  padding: 4px;\n  position: absolute;\n  right: 20px;\n  border: 2px solid red;\n  top: 10px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-root-block .mq-hasCursor {\n  -webkit-box-shadow: inset #68b4df 0 0 2px 1px;\n  -moz-box-shadow: inset #68b4df 0 0 2px 1px;\n  box-shadow: inset #68b4df 0 0 2px 1px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-math-mode .mq-editable-field.mq-focused,\n.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field.mq-focused {\n  box-shadow: none;\n  border: none;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-math-mode .mq-sqrt-prefix {\n  top: .18em;\n}\n.wsp-version-4-8-0 .wsp-Calculator .dropdown-menu > li > a {\n  padding: 3px 19px;\n}\n.wsp-version-4-8-0 .wsp-Calculator .wsp-missing {\n  color: red;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field .mq-textarea {\n  /* Mathquill sets position to relative, but we were seeing premature\n   * scrollbars from IE (WSP-1578) as the selection area grew. This\n   * fixes the issue, perhaps because 1) the textarea is filled with\n   * increasingly more text as the selection is expanded, and 2)\n   * relative positioning inserts the element into the flow for a\n   * time, and thus impacts sizing enough to trigger scrolling. */\n  position: absolute;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field .mq-textarea > * {\n  z-index: -999;\n  /* Mathquill uses a tiny (1px x 1px) textarea for cut/paste event handling, and\n  this triggered a bug. Chrome got confused when selecting, then blurring, then\n  focusing this textarea whenever it contained any text. Empirically, setting the\n  textarea to overflow: hidden fixes the bug; so that is what we do. */\n  overflow: hidden;\n}\n.wsp-version-4-8-0 .wsp-Calculator .mq-non-leaf + .mq-sup-only {\n  vertical-align: .9em;\n  font-size: 85%;\n}\n.wsp-version-4-8-0 .wsp-label-edit {\n  border: 1px solid black;\n  padding: 3px;\n  width: 415px;\n  background-color: #fafafa;\n}\n.wsp-version-4-8-0 .wsp-label-edit button {\n  float: right;\n}\n.wsp-version-4-8-0 .wsp-label-edit * {\n  font-size: 15px;\n  margin: 5px;\n  padding: 5px;\n}\n.wsp-version-4-8-0 .wsp-text-target-highlight,\n.wsp-version-4-8-0 .wsp-text-unmatched-given,\n.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n  border-style: solid !important;\n  border-width: 2px !important;\n  border-radius: 5px !important;\n  box-shadow: 3px 3px 7px black !important;\n}\n.wsp-version-4-8-0 .wsp-text-target-highlight,\n.wsp-version-4-8-0 .wsp-text-unmatched-given {\n  border-color: rgba(255, 0, 0, 0.5) !important;\n}\n.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n  border-color: rgba(255, 215, 0, 0.5) !important;\n}\n.wsp-version-4-8-0 .wsp-text-unmatched-given {\n  -webkit-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n  -moz-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n  -o-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n  animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n}\n@keyframes wsp-version-4-8-0FlickerAnimation {\n  0% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 0, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n}\n@-o-keyframes wsp-version-4-8-0FlickerAnimation {\n  0% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 0, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n}\n@-moz-keyframes wsp-version-4-8-0FlickerAnimation {\n  0% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 0, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n}\n@-webkit-keyframes wsp-version-4-8-0FlickerAnimation {\n  0% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 0, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 0, 0, 0);\n  }\n}\n.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n  -webkit-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n  -moz-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n  -o-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n  animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n}\n@keyframes wsp-version-4-8-0FlickerAnimationGold {\n  0% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 215, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n}\n@-o-keyframes wsp-version-4-8-0FlickerAnimationGold {\n  0% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 215, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n}\n@-moz-keyframes wsp-version-4-8-0FlickerAnimationGold {\n  0% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 215, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n}\n@-webkit-keyframes wsp-version-4-8-0FlickerAnimationGold {\n  0% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n  40% {\n    background-color: rgba(255, 215, 0, 0.5);\n  }\n  80% {\n    background-color: rgba(255, 215, 0, 0);\n  }\n}\n.wsp-version-4-8-0 .wsp-effects {\n  border: 4px dashed transparent;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n}\n.wsp-version-4-8-0 .wsp-drop-target .wsp-effects {\n  border-color: blue;\n}\n.wsp-version-4-8-0 .wsp-parameter-sr-only {\n  border: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: absolute;\n  color: transparent;\n  background-color: transparent;\n}\n.wsp-version-4-8-0.keypressed .wsp-Numberpad button:focus {\n  outline: 3px solid red !important;\n}\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Measure:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Text:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Button:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Expression:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Table:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Table > div:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container table:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .mfs-input:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .mfs-param:focus,\n.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-parameter-sr-only:focus {\n  outline: 3px solid red;\n}\n/*\n * MathQuill: http://mathquill.com\n * by Jay and Han (laughinghan@gmail.com)\n *\n * This Source Code Form is subject to the terms of the\n * Mozilla Public License, v. 2.0. If a copy of the MPL\n * was not distributed with this file, You can obtain\n * one at http://mozilla.org/MPL/2.0/.\n */\n@font-face {\n  font-family: Symbola;\n  src: local(\"Symbola Regular\"), local(\"Symbola\");\n}\n.mq-editable-field {\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-editable-field .mq-root-block {\n  display: -moz-inline-box;\n  display: inline-block;\n  width: 100%;\n  padding: 2px;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  white-space: pre;\n  overflow: hidden;\n  vertical-align: middle;\n}\n.mq-editable-field .mq-root-block:after {\n  content: '';\n}\n.mq-editable-field .mq-cursor {\n  border-left: 1px solid black;\n  margin-left: -1px;\n  position: relative;\n  z-index: 1;\n  padding: 0;\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-editable-field .mq-cursor.mq-blink {\n  visibility: hidden;\n}\n.mq-editable-field,\n.mq-math-mode .mq-editable-field {\n  border: 1px solid gray;\n}\n.mq-editable-field.mq-focused,\n.mq-math-mode .mq-editable-field.mq-focused {\n  -webkit-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n  -moz-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n  box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n  border-color: #709AC0;\n  border-radius: 1px;\n}\n.mq-math-mode .mq-editable-field {\n  margin: 1px;\n}\n.mq-editable-field .mq-latex-command-input {\n  color: inherit;\n  font-family: \"Courier New\", monospace;\n  border: 1px solid gray;\n  padding-right: 1px;\n  margin-right: 1px;\n  margin-left: 2px;\n}\n.mq-editable-field .mq-latex-command-input.mq-empty {\n  background: transparent;\n}\n.mq-editable-field .mq-latex-command-input.mq-hasCursor {\n  border-color: ActiveBorder;\n}\n.mq-editable-field.mq-empty:after,\n.mq-editable-field.mq-text-mode:after,\n.mq-math-mode .mq-empty:after {\n  visibility: hidden;\n  content: 'c';\n}\n.mq-editable-field .mq-cursor:only-child:after,\n.mq-editable-field .mq-textarea + .mq-cursor:last-child:after {\n  visibility: hidden;\n  content: 'c';\n}\n.mq-editable-field .mq-text-mode .mq-cursor:only-child:after {\n  content: '';\n}\n.mq-editable-field.mq-text-mode {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.mq-math-mode {\n  font-variant: normal;\n  font-weight: normal;\n  font-style: normal;\n  font-size: 115%;\n  line-height: 1;\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-math-mode .mq-non-leaf,\n.mq-math-mode .mq-scaled {\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-math-mode var,\n.mq-math-mode .mq-text-mode,\n.mq-math-mode .mq-nonSymbola {\n  font-family: \"Times New Roman\", Symbola, serif;\n  line-height: .9;\n}\n.mq-math-mode * {\n  font-size: inherit;\n  line-height: inherit;\n  margin: 0;\n  padding: 0;\n  border-color: black;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n.mq-math-mode .mq-empty {\n  background: #ccc;\n}\n.mq-math-mode .mq-empty.mq-root-block {\n  background: transparent;\n}\n.mq-math-mode.mq-empty {\n  background: transparent;\n}\n.mq-math-mode .mq-text-mode {\n  font-size: 87%;\n}\n.mq-math-mode .mq-font {\n  font: 1em \"Times New Roman\", Symbola, serif;\n}\n.mq-math-mode .mq-font * {\n  font-family: inherit;\n  font-style: inherit;\n}\n.mq-math-mode b,\n.mq-math-mode b.mq-font {\n  font-weight: bolder;\n}\n.mq-math-mode var,\n.mq-math-mode i,\n.mq-math-mode i.mq-font {\n  font-style: italic;\n}\n.mq-math-mode var.mq-florin {\n  display: -moz-inline-box;\n  display: inline-block;\n  width: .3em;\n  position: relative;\n  left: -0.1em;\n}\n.mq-math-mode big {\n  font-size: 125%;\n}\n.mq-math-mode .mq-roman {\n  font-style: normal;\n}\n.mq-math-mode .mq-sans-serif {\n  font-family: sans-serif, Symbola, serif;\n}\n.mq-math-mode .mq-monospace {\n  font-family: monospace, Symbola, serif;\n}\n.mq-math-mode .mq-overline {\n  border-top: 1px solid black;\n  margin-top: 1px;\n}\n.mq-math-mode .mq-underline {\n  border-bottom: 1px solid black;\n  margin-bottom: 1px;\n}\n.mq-math-mode .mq-binary-operator {\n  padding: 0 0.2em;\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-math-mode .mq-supsub {\n  font-size: 90%;\n  vertical-align: -0.5em;\n}\n.mq-math-mode .mq-supsub.mq-limit {\n  font-size: 80%;\n  vertical-align: -0.4em;\n}\n.mq-math-mode .mq-supsub.mq-sup-only {\n  vertical-align: .5em;\n}\n.mq-math-mode .mq-supsub.mq-sup-only .mq-sup {\n  display: inline-block;\n  vertical-align: text-bottom;\n}\n.mq-math-mode .mq-supsub .mq-sup {\n  display: block;\n}\n.mq-math-mode .mq-supsub .mq-sub {\n  display: block;\n  float: left;\n}\n.mq-math-mode .mq-supsub.mq-limit .mq-sub {\n  margin-left: -0.25em;\n}\n.mq-math-mode .mq-supsub .mq-binary-operator {\n  padding: 0 .1em;\n}\n.mq-math-mode .mq-supsub .mq-fraction {\n  font-size: 70%;\n}\n.mq-math-mode sup.mq-nthroot {\n  font-size: 80%;\n  vertical-align: 0.8em;\n  margin-right: -0.6em;\n  margin-left: .2em;\n  min-width: .5em;\n}\n.mq-math-mode .mq-paren {\n  padding: 0 .1em;\n  vertical-align: top;\n  -webkit-transform-origin: center .06em;\n  -moz-transform-origin: center .06em;\n  -ms-transform-origin: center .06em;\n  -o-transform-origin: center .06em;\n  transform-origin: center .06em;\n}\n.mq-math-mode .mq-paren.mq-ghost {\n  color: silver;\n}\n.mq-math-mode .mq-paren + span {\n  margin-top: .1em;\n  margin-bottom: .1em;\n}\n.mq-math-mode .mq-array {\n  vertical-align: middle;\n  text-align: center;\n}\n.mq-math-mode .mq-array > span {\n  display: block;\n}\n.mq-math-mode .mq-operator-name {\n  font-family: Symbola, \"Times New Roman\", serif;\n  line-height: .9;\n  font-style: normal;\n}\n.mq-math-mode var.mq-operator-name.mq-first {\n  padding-left: .2em;\n}\n.mq-math-mode var.mq-operator-name.mq-last {\n  padding-right: .2em;\n}\n.mq-math-mode .mq-fraction {\n  font-size: 90%;\n  text-align: center;\n  vertical-align: -0.4em;\n  padding: 0 .2em;\n}\n.mq-math-mode .mq-fraction,\n.mq-math-mode .mq-large-operator,\n.mq-math-mode x:-moz-any-link {\n  display: -moz-groupbox;\n}\n.mq-math-mode .mq-fraction,\n.mq-math-mode .mq-large-operator,\n.mq-math-mode x:-moz-any-link,\n.mq-math-mode x:default {\n  display: inline-block;\n}\n.mq-math-mode .mq-numerator,\n.mq-math-mode .mq-denominator {\n  display: block;\n}\n.mq-math-mode .mq-numerator {\n  padding: 0 0.1em;\n}\n.mq-math-mode .mq-denominator {\n  border-top: 1px solid;\n  float: right;\n  width: 100%;\n  padding: .15em .1em 0 .1em;\n  margin-right: -0.1em;\n  margin-left: -0.1em;\n}\n.mq-math-mode .mq-sqrt-prefix {\n  padding-top: 0;\n  position: relative;\n  top: .05em;\n  vertical-align: top;\n  -webkit-transform-origin: top;\n  -moz-transform-origin: top;\n  -ms-transform-origin: top;\n  -o-transform-origin: top;\n  transform-origin: top;\n}\n.mq-math-mode .mq-sqrt-stem {\n  border-top: 1px solid;\n  margin-top: 1px;\n  padding-left: .15em;\n  padding-right: .2em;\n  margin-right: .1em;\n  padding-top: 1px;\n}\n.mq-math-mode .mq-vector-prefix {\n  display: block;\n  text-align: center;\n  line-height: .25em;\n  margin-bottom: -0.1em;\n  font-size: 0.75em;\n}\n.mq-math-mode .mq-vector-stem {\n  display: block;\n}\n.mq-math-mode .mq-large-operator {\n  text-align: center;\n}\n.mq-math-mode .mq-large-operator .mq-from,\n.mq-math-mode .mq-large-operator big,\n.mq-math-mode .mq-large-operator .mq-to {\n  display: block;\n}\n.mq-math-mode .mq-large-operator .mq-from,\n.mq-math-mode .mq-large-operator .mq-to {\n  font-size: 80%;\n}\n.mq-math-mode .mq-large-operator .mq-from {\n  float: right;\n  /* take out of normal flow to manipulate baseline */\n  width: 100%;\n}\n.mq-math-mode,\n.mq-math-mode .mq-editable-field {\n  cursor: text;\n  font-family: Symbola, \"Times New Roman\", serif;\n}\n.mq-math-mode .mq-selection,\n.mq-editable-field .mq-selection,\n.mq-math-mode .mq-selection .mq-non-leaf,\n.mq-editable-field .mq-selection .mq-non-leaf,\n.mq-math-mode .mq-selection .mq-scaled,\n.mq-editable-field .mq-selection .mq-scaled {\n  background: #B4D5FE !important;\n  background: Highlight !important;\n  color: HighlightText;\n  border-color: HighlightText;\n}\n.mq-math-mode .mq-selection .mq-matrixed,\n.mq-editable-field .mq-selection .mq-matrixed {\n  background: #39F !important;\n}\n.mq-math-mode .mq-selection .mq-matrixed-container,\n.mq-editable-field .mq-selection .mq-matrixed-container {\n  filter: progid:DXImageTransform.Microsoft.Chroma(color='#3399FF') !important;\n}\n.mq-math-mode .mq-selection.mq-blur,\n.mq-editable-field .mq-selection.mq-blur,\n.mq-math-mode .mq-selection.mq-blur .mq-non-leaf,\n.mq-editable-field .mq-selection.mq-blur .mq-non-leaf,\n.mq-math-mode .mq-selection.mq-blur .mq-scaled,\n.mq-editable-field .mq-selection.mq-blur .mq-scaled,\n.mq-math-mode .mq-selection.mq-blur .mq-matrixed,\n.mq-editable-field .mq-selection.mq-blur .mq-matrixed {\n  background: #D4D4D4 !important;\n  color: black;\n  border-color: black;\n}\n.mq-math-mode .mq-selection.mq-blur .mq-matrixed-container,\n.mq-editable-field .mq-selection.mq-blur .mq-matrixed-container {\n  filter: progid:DXImageTransform.Microsoft.Chroma(color='#D4D4D4') !important;\n}\n.mq-editable-field .mq-textarea,\n.mq-math-mode .mq-textarea {\n  position: relative;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  user-select: text;\n}\n.mq-editable-field .mq-textarea *,\n.mq-math-mode .mq-textarea *,\n.mq-editable-field .mq-selectable,\n.mq-math-mode .mq-selectable {\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  user-select: text;\n  position: absolute;\n  clip: rect(1em 1em 1em 1em);\n  resize: none;\n  width: 1px;\n  height: 1px;\n}\n.mq-math-mode .mq-matrixed {\n  background: white;\n  display: -moz-inline-box;\n  display: inline-block;\n}\n.mq-math-mode .mq-matrixed-container {\n  filter: progid:DXImageTransform.Microsoft.Chroma(color='white');\n  margin-top: -0.1em;\n}\n\n/* Import only the bits of bootstrap needed for our components. Code\nis not generated as css output unless actually referenced. */\n/* Components we adopt from bootstrap. */\n.caret {\n  display: inline-block;\n  width: 0;\n  height: 0;\n  margin-left: 2px;\n  vertical-align: middle;\n  border-top: 4px solid;\n  border-right: 4px solid transparent;\n  border-left: 4px solid transparent;\n}\n.dropdown {\n  position: relative;\n}\n.dropdown-toggle:focus {\n  outline: 0;\n}\n.dropdown-menu {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  z-index: 1000;\n  display: none;\n  float: left;\n  min-width: 160px;\n  padding: 5px 0;\n  margin: 2px 0 0;\n  list-style: none;\n  font-size: 14px;\n  text-align: left;\n  background-color: #fff;\n  border: 1px solid #ccc;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  border-radius: 4px;\n  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n  background-clip: padding-box;\n}\n.dropdown-menu.pull-right {\n  right: 0;\n  left: auto;\n}\n.dropdown-menu .divider {\n  height: 1px;\n  margin: 9px 0;\n  overflow: hidden;\n  background-color: #e5e5e5;\n}\n.dropdown-menu > li > a {\n  display: block;\n  padding: 3px 20px;\n  clear: both;\n  font-weight: normal;\n  line-height: 1.42857143;\n  color: #333333;\n  white-space: nowrap;\n}\n.dropdown-menu > li > a:hover,\n.dropdown-menu > li > a:focus {\n  text-decoration: none;\n  color: #262626;\n  background-color: #f5f5f5;\n}\n.dropdown-menu > .active > a,\n.dropdown-menu > .active > a:hover,\n.dropdown-menu > .active > a:focus {\n  color: #fff;\n  text-decoration: none;\n  outline: 0;\n  background-color: #337ab7;\n}\n.dropdown-menu > .disabled > a,\n.dropdown-menu > .disabled > a:hover,\n.dropdown-menu > .disabled > a:focus {\n  color: #777777;\n}\n.dropdown-menu > .disabled > a:hover,\n.dropdown-menu > .disabled > a:focus {\n  text-decoration: none;\n  background-color: transparent;\n  background-image: none;\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);\n  cursor: not-allowed;\n}\n.open > .dropdown-menu {\n  display: block;\n}\n.open > a {\n  outline: 0;\n}\n.dropdown-menu-right {\n  left: auto;\n  right: 0;\n}\n.dropdown-menu-left {\n  left: 0;\n  right: auto;\n}\n.dropdown-header {\n  display: block;\n  padding: 3px 20px;\n  font-size: 12px;\n  line-height: 1.42857143;\n  color: #777777;\n  white-space: nowrap;\n}\n.dropdown-backdrop {\n  position: fixed;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  top: 0;\n  z-index: 990;\n}\n.pull-right > .dropdown-menu {\n  right: 0;\n  left: auto;\n}\n.dropup .caret,\n.navbar-fixed-bottom .dropdown .caret {\n  border-top: 0;\n  border-bottom: 4px solid;\n  content: \"\";\n}\n.dropup .dropdown-menu,\n.navbar-fixed-bottom .dropdown .dropdown-menu {\n  top: auto;\n  bottom: 100%;\n  margin-bottom: 2px;\n}\n@media (min-width: 768px) {\n  .navbar-right .dropdown-menu {\n    left: auto;\n    right: 0;\n  }\n  .navbar-right .dropdown-menu-left {\n    left: 0;\n    right: auto;\n  }\n}\n"),
      (o.noConflict = function() {
        return e.GSP === o && (e.GSP = s), o;
      }),
      t(function() {
        var e = 'wsp-css-4-8-0';
        0 === t('style#' + e).length &&
          t('head').append(
            t('<style>')
              .attr({ id: e })
              .text(o.css)
          );
      }),
      'undefined' == typeof e.GSPConfig && (e.GSPConfig = {}),
      'undefined' == typeof e.GSPConfig.instances &&
        (e.GSPConfig.instances = []),
      e.GSPConfig.instances.push(o),
      (e.GSP = o);
  })(window, jQuery);
