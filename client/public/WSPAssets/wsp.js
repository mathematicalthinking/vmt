/*!
  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved. 
  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20230306155548

  Web Sketchpad uses the Alphanum Algorithm by Brian Huisman and David Koelle, which is
  available here:
  http://www.davekoelle.com/files/alphanum.js

  Web Sketchpad uses FastClick, By the Financial Times, which includes this license:

  Copyright (c) 2014 The Financial Times Ltd.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation
  files (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use,
  copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

*/

/**
 * @fileOverview Fragment included at the top of the WSP-library - comments only - no code.
 * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
 * @version 0.0
 * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
 *
 *  Put comments below intended to survive minification / compression,
 *  e.g. copyright notice.
 *
 *  Individual files should have:
 *  Copyright © 2012-2013 KCP Technologies, Inc. All rights reserved.
 *  but it's OK to let those be stripped out in the build process.
 *
 */ /**
 * MathQuill: http://mathquill.com
 * by Jay and Han (laughinghan@gmail.com)
 *
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL
 * was not distributed with this file, You can obtain
 * one at http://mozilla.org/MPL/2.0/.
 */

(function() {
  var jQuery = window.jQuery,
    undefined,
    mqCmdId = 'mathquill-command-id',
    mqBlockId = 'mathquill-block-id',
    min = Math.min,
    max = Math.max;

  function noop() {}

  /**
   * A utility higher-order function that makes defining variadic
   * functions more convenient by letting you essentially define functions
   * with the last argument as a splat, i.e. the last argument "gathers up"
   * remaining arguments to the function:
   *   var doStuff = variadic(function(first, rest) { return rest; });
   *   doStuff(1, 2, 3); // => [2, 3]
   */
  var __slice = [].slice;
  function variadic(fn) {
    var numFixedArgs = fn.length - 1;
    return function() {
      var args = __slice.call(arguments, 0, numFixedArgs);
      var varArg = __slice.call(arguments, numFixedArgs);
      return fn.apply(this, args.concat([varArg]));
    };
  }

  /**
   * A utility higher-order function that makes combining object-oriented
   * programming and functional programming techniques more convenient:
   * given a method name and any number of arguments to be bound, returns
   * a function that calls it's first argument's method of that name (if
   * it exists) with the bound arguments and any additional arguments that
   * are passed:
   *   var sendMethod = send('method', 1, 2);
   *   var obj = { method: function() { return Array.apply(this, arguments); } };
   *   sendMethod(obj, 3, 4); // => [1, 2, 3, 4]
   *   // or more specifically,
   *   var obj2 = { method: function(one, two, three) { return one*two + three; } };
   *   sendMethod(obj2, 3); // => 5
   *   sendMethod(obj2, 4); // => 6
   */
  var send = variadic(function(method, args) {
    return variadic(function(obj, moreArgs) {
      if (method in obj) return obj[method].apply(obj, args.concat(moreArgs));
    });
  });

  /**
   * A utility higher-order function that creates "implicit iterators"
   * from "generators": given a function that takes in a sole argument,
   * a "yield_" function, that calls "yield_" repeatedly with an object as
   * a sole argument (presumably objects being iterated over), returns
   * a function that calls it's first argument on each of those objects
   * (if the first argument is a function, it is called repeatedly with
   * each object as the first argument, otherwise it is stringified and
   * the method of that name is called on each object (if such a method
   * exists)), passing along all additional arguments:
   *   var a = [
   *     { method: function(list) { list.push(1); } },
   *     { method: function(list) { list.push(2); } },
   *     { method: function(list) { list.push(3); } }
   *   ];
   *   a.each = iterator(function(yield_) {
   *     for (var i in this) yield_(this[i]);
   *   });
   *   var list = [];
   *   a.each('method', list);
   *   list; // => [1, 2, 3]
   *   // Note that the for-in loop will yield 'each', but 'each' maps to
   *   // the function object created by iterator() which does not have a
   *   // .method() method, so that just fails silently.
   */
  function iterator(generator) {
    return variadic(function(fn, args) {
      if (typeof fn !== 'function') fn = send(fn);
      var yield_ = function(obj) {
        return fn.apply(obj, [obj].concat(args));
      };
      return generator.call(this, yield_);
    });
  }

  /**
   * sugar to make defining lots of commands easier.
   * TODO: rethink this.
   */
  function bind(cons /*, args... */) {
    var args = __slice.call(arguments, 1);
    return function() {
      return cons.apply(this, args);
    };
  }

  /**
   * a development-only debug method.  This definition and all
   * calls to `pray` will be stripped from the minified
   * build of mathquill.
   *
   * This function must be called by name to be removed
   * at compile time.  Do not define another function
   * with the same name, and only call this function by
   * name.
   */
  function pray(message, cond) {
    if (!cond) throw new Error('prayer failed: ' + message);
  }
  var P = (function(prototype, ownProperty, undefined) {
    // helper functions that also help minification
    function isObject(o) {
      return typeof o === 'object';
    }
    function isFunction(f) {
      return typeof f === 'function';
    }

    // used to extend the prototypes of superclasses (which might not
    // have `.Bare`s)
    function SuperclassBare() {}

    return function P(_superclass /* = Object */, definition) {
      // handle the case where no superclass is given
      if (definition === undefined) {
        definition = _superclass;
        _superclass = Object;
      }

      // C is the class to be returned.
      //
      // It delegates to instantiating an instance of `Bare`, so that it
      // will always return a new instance regardless of the calling
      // context.
      //
      //  TODO: the Chrome inspector shows all created objects as `C`
      //        rather than `Object`.  Setting the .name property seems to
      //        have no effect.  Is there a way to override this behavior?
      function C() {
        var self = new Bare();
        if (isFunction(self.init)) self.init.apply(self, arguments);
        return self;
      }

      // C.Bare is a class with a noop constructor.  Its prototype is the
      // same as C, so that instances of C.Bare are also instances of C.
      // New objects can be allocated without initialization by calling
      // `new MyClass.Bare`.
      function Bare() {}
      C.Bare = Bare;

      // Set up the prototype of the new class.
      var _super = (SuperclassBare[prototype] = _superclass[prototype]);
      var proto = (Bare[prototype] = C[prototype] = C.p = new SuperclassBare());

      // other variables, as a minifier optimization
      var extensions;

      // set the constructor property on the prototype, for convenience
      proto.constructor = C;

      C.mixin = function(def) {
        Bare[prototype] = C[prototype] = P(C, def)[prototype];
        return C;
      };

      return (C.open = function(def) {
        extensions = {};

        if (isFunction(def)) {
          // call the defining function with all the arguments you need
          // extensions captures the return value.
          extensions = def.call(C, proto, _super, C, _superclass);
        } else if (isObject(def)) {
          // if you passed an object instead, we'll take it
          extensions = def;
        }

        // ...and extend it
        if (isObject(extensions)) {
          for (var ext in extensions) {
            if (ownProperty.call(extensions, ext)) {
              proto[ext] = extensions[ext];
            }
          }
        }

        // if there's no init, we assume we're inheriting a non-pjs class, so
        // we default to applying the superclass's constructor.
        if (!isFunction(proto.init)) {
          proto.init = _superclass;
        }

        return C;
      })(definition);
    };

    // as a minifier optimization, we've closured in a few helper functions
    // and the string 'prototype' (C[p] is much shorter than C.prototype)
  })('prototype', {}.hasOwnProperty);
  /*************************************************
   * Base classes of edit tree-related objects
   *
   * Only doing tree node manipulation via these
   * adopt/ disown methods guarantees well-formedness
   * of the tree.
   ************************************************/

  // L = 'left'
  // R = 'right'
  //
  // the contract is that they can be used as object properties
  // and (-L) === R, and (-R) === L.
  var L = (MathQuill.L = -1);
  var R = (MathQuill.R = 1);

  function prayDirection(dir) {
    pray('a direction was passed', dir === L || dir === R);
  }

  /**
   * Tiny extension of jQuery adding directionalized DOM manipulation methods.
   *
   * Funny how Pjs v3 almost just works with `jQuery.fn.init`.
   *
   * jQuery features that don't work on $:
   *   - jQuery.*, like jQuery.ajax, obviously (Pjs doesn't and shouldn't
   *                                            copy constructor properties)
   *
   *   - jQuery(function), the shortcut for `jQuery(document).ready(function)`,
   *     because `jQuery.fn.init` is idiosyncratic and Pjs doing, essentially,
   *     `jQuery.fn.init.apply(this, arguments)` isn't quite right, you need:
   *
   *       _.init = function(s, c) { jQuery.fn.init.call(this, s, c, $(document)); };
   *
   *     if you actually give a shit (really, don't bother),
   *     see https://github.com/jquery/jquery/blob/1.7.2/src/core.js#L889
   *
   *   - jQuery(selector), because jQuery translates that to
   *     `jQuery(document).find(selector)`, but Pjs doesn't (should it?) let
   *     you override the result of a constructor call
   *       + note that because of the jQuery(document) shortcut-ness, there's also
   *         the 3rd-argument-needs-to-be-`$(document)` thing above, but the fix
   *         for that (as can be seen above) is really easy. This problem requires
   *         a way more intrusive fix
   *
   * And that's it! Everything else just magically works because jQuery internally
   * uses `this.constructor()` everywhere (hence calling `$`), but never ever does
   * `this.constructor.find` or anything like that, always doing `jQuery.find`.
   */
  var $ = P(jQuery, function(_) {
    _.insDirOf = function(dir, el) {
      return dir === L
        ? this.insertBefore(el.first())
        : this.insertAfter(el.last());
    };
    _.insAtDirEnd = function(dir, el) {
      return dir === L ? this.prependTo(el) : this.appendTo(el);
    };
  });

  var Point = P(function(_) {
    _.parent = 0;
    _[L] = 0;
    _[R] = 0;

    _.init = function(parent, leftward, rightward) {
      this.parent = parent;
      this[L] = leftward;
      this[R] = rightward;
    };

    this.copy = function(pt) {
      return Point(pt.parent, pt[L], pt[R]);
    };
  });

  /**
   * MathQuill virtual-DOM tree-node abstract base class
   */
  var Node = P(function(_) {
    _[L] = 0;
    _[R] = 0;
    _.parent = 0;

    var id = 0;
    function uniqueNodeId() {
      return (id += 1);
    }
    this.byId = {};

    _.init = function() {
      this.id = uniqueNodeId();
      Node.byId[this.id] = this;

      this.ends = {};
      this.ends[L] = 0;
      this.ends[R] = 0;
    };

    _.dispose = function() {
      delete Node.byId[this.id];
    };

    _.toString = function() {
      return '{{ MathQuill Node #' + this.id + ' }}';
    };

    _.jQ = $();
    _.jQadd = function(jQ) {
      return (this.jQ = this.jQ.add(jQ));
    };
    _.jQize = function(jQ) {
      // jQuery-ifies this.html() and links up the .jQ of all corresponding Nodes
      jQ = $(jQ || this.html());

      function jQadd(el) {
        if (el.getAttribute) {
          var cmdId = el.getAttribute('mathquill-command-id');
          var blockId = el.getAttribute('mathquill-block-id');
          if (cmdId) Node.byId[cmdId].jQadd(el);
          if (blockId) Node.byId[blockId].jQadd(el);
        }
        for (el = el.firstChild; el; el = el.nextSibling) {
          jQadd(el);
        }
      }

      for (var i = 0; i < jQ.length; i += 1) jQadd(jQ[i]);
      return jQ;
    };

    _.createDir = function(dir, cursor) {
      prayDirection(dir);
      var node = this;
      node.jQize();
      node.jQ.insDirOf(dir, cursor.jQ);
      cursor[dir] = node.adopt(cursor.parent, cursor[L], cursor[R]);
      return node;
    };
    _.createLeftOf = function(el) {
      return this.createDir(L, el);
    };

    _.selectChildren = function(leftEnd, rightEnd) {
      return Selection(leftEnd, rightEnd);
    };

    _.bubble = iterator(function(yield_) {
      for (var ancestor = this; ancestor; ancestor = ancestor.parent) {
        var result = yield_(ancestor);
        if (result === false) break;
      }

      return this;
    });

    _.postOrder = iterator(function(yield_) {
      (function recurse(descendant) {
        descendant.eachChild(recurse);
        yield_(descendant);
      })(this);

      return this;
    });

    _.isEmpty = function() {
      return this.ends[L] === 0 && this.ends[R] === 0;
    };

    _.children = function() {
      return Fragment(this.ends[L], this.ends[R]);
    };

    _.eachChild = function() {
      var children = this.children();
      children.each.apply(children, arguments);
      return this;
    };

    _.foldChildren = function(fold, fn) {
      return this.children().fold(fold, fn);
    };

    _.withDirAdopt = function(dir, parent, withDir, oppDir) {
      Fragment(this, this).withDirAdopt(dir, parent, withDir, oppDir);
      return this;
    };

    _.adopt = function(parent, leftward, rightward) {
      Fragment(this, this).adopt(parent, leftward, rightward);
      return this;
    };

    _.disown = function() {
      Fragment(this, this).disown();
      return this;
    };

    _.remove = function() {
      this.jQ.remove();
      this.postOrder('dispose');
      return this.disown();
    };
  });

  function prayWellFormed(parent, leftward, rightward) {
    pray('a parent is always present', parent);
    pray(
      'leftward is properly set up',
      (function() {
        // either it's empty and `rightward` is the left end child (possibly empty)
        if (!leftward) return parent.ends[L] === rightward;

        // or it's there and its [R] and .parent are properly set up
        return leftward[R] === rightward && leftward.parent === parent;
      })()
    );

    pray(
      'rightward is properly set up',
      (function() {
        // either it's empty and `leftward` is the right end child (possibly empty)
        if (!rightward) return parent.ends[R] === leftward;

        // or it's there and its [L] and .parent are properly set up
        return rightward[L] === leftward && rightward.parent === parent;
      })()
    );
  }

  /**
   * An entity outside the virtual tree with one-way pointers (so it's only a
   * "view" of part of the tree, not an actual node/entity in the tree) that
   * delimits a doubly-linked list of sibling nodes.
   * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range
   * classes: like DocumentFragment, its contents must be sibling nodes
   * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),
   * but like Range, it has only one-way pointers to its contents, its contents
   * have no reference to it and in fact may still be in the visible tree (unlike
   * DocumentFragment, whose contents must be detached from the visible tree
   * and have their 'parent' pointers set to the DocumentFragment).
   */
  var Fragment = P(function(_) {
    _.init = function(withDir, oppDir, dir) {
      if (dir === undefined) dir = L;
      prayDirection(dir);

      pray('no half-empty fragments', !withDir === !oppDir);

      this.ends = {};

      if (!withDir) return;

      pray('withDir is passed to Fragment', withDir instanceof Node);
      pray('oppDir is passed to Fragment', oppDir instanceof Node);
      pray(
        'withDir and oppDir have the same parent',
        withDir.parent === oppDir.parent
      );

      this.ends[dir] = withDir;
      this.ends[-dir] = oppDir;

      this.jQ = this.fold(this.jQ, function(jQ, el) {
        return jQ.add(el.jQ);
      });
    };
    _.jQ = $();

    // like Cursor::withDirInsertAt(dir, parent, withDir, oppDir)
    _.withDirAdopt = function(dir, parent, withDir, oppDir) {
      return dir === L
        ? this.adopt(parent, withDir, oppDir)
        : this.adopt(parent, oppDir, withDir);
    };
    _.adopt = function(parent, leftward, rightward) {
      prayWellFormed(parent, leftward, rightward);

      var self = this;
      self.disowned = false;

      var leftEnd = self.ends[L];
      if (!leftEnd) return this;

      var rightEnd = self.ends[R];

      if (leftward) {
        // NB: this is handled in the ::each() block
        // leftward[R] = leftEnd
      } else {
        parent.ends[L] = leftEnd;
      }

      if (rightward) {
        rightward[L] = rightEnd;
      } else {
        parent.ends[R] = rightEnd;
      }

      self.ends[R][R] = rightward;

      self.each(function(el) {
        el[L] = leftward;
        el.parent = parent;
        if (leftward) leftward[R] = el;

        leftward = el;
      });

      return self;
    };

    _.disown = function() {
      var self = this;
      var leftEnd = self.ends[L];

      // guard for empty and already-disowned fragments
      if (!leftEnd || self.disowned) return self;

      self.disowned = true;

      var rightEnd = self.ends[R];
      var parent = leftEnd.parent;

      prayWellFormed(parent, leftEnd[L], leftEnd);
      prayWellFormed(parent, rightEnd, rightEnd[R]);

      if (leftEnd[L]) {
        leftEnd[L][R] = rightEnd[R];
      } else {
        parent.ends[L] = rightEnd[R];
      }

      if (rightEnd[R]) {
        rightEnd[R][L] = leftEnd[L];
      } else {
        parent.ends[R] = leftEnd[L];
      }

      return self;
    };

    _.remove = function() {
      this.jQ.remove();
      this.each('postOrder', 'dispose');
      return this.disown();
    };

    _.each = iterator(function(yield_) {
      var self = this;
      var el = self.ends[L];
      if (!el) return self;

      for (; el !== self.ends[R][R]; el = el[R]) {
        var result = yield_(el);
        if (result === false) break;
      }

      return self;
    });

    _.fold = function(fold, fn) {
      this.each(function(el) {
        fold = fn.call(this, fold, el);
      });

      return fold;
    };
  });

  /**
   * Registry of LaTeX commands and commands created when typing
   * a single character.
   *
   * (Commands are all subclasses of Node.)
   */
  var LatexCmds = {},
    CharCmds = {};
  /********************************************
   * Cursor and Selection "singleton" classes
   *******************************************/

  /* The main thing that manipulates the Math DOM. Makes sure to manipulate the
  HTML DOM to match. */

  /* Sort of singletons, since there should only be one per editable math
  textbox, but any one HTML document can contain many such textboxes, so any one
  JS environment could actually contain many instances. */

  //A fake cursor in the fake textbox that the math is rendered in.
  var Cursor = P(Point, function(_) {
    _.init = function(initParent, options) {
      this.parent = initParent;
      this.options = options;

      var jQ = (this.jQ = this._jQ = $(
        '<span class="mq-cursor">&#8203;</span>'
      ));
      //closured for setInterval
      this.blink = function() {
        jQ.toggleClass('mq-blink');
      };

      this.upDownCache = {};
    };

    _.show = function() {
      this.jQ = this._jQ.removeClass('mq-blink');
      if ('intervalId' in this)
        //already was shown, just restart interval
        clearInterval(this.intervalId);
      else {
        //was hidden and detached, insert this.jQ back into HTML DOM
        if (this[R]) {
          if (this.selection && this.selection.ends[L][L] === this[L])
            this.jQ.insertBefore(this.selection.jQ);
          else this.jQ.insertBefore(this[R].jQ.first());
        } else this.jQ.appendTo(this.parent.jQ);
        this.parent.focus();
      }
      this.intervalId = setInterval(this.blink, 500);
      return this;
    };
    _.hide = function() {
      if ('intervalId' in this) clearInterval(this.intervalId);
      delete this.intervalId;
      this.jQ.detach();
      this.jQ = $();
      return this;
    };

    _.withDirInsertAt = function(dir, parent, withDir, oppDir) {
      if (parent !== this.parent && this.parent.blur) this.parent.blur();
      this.parent = parent;
      this[dir] = withDir;
      this[-dir] = oppDir;
    };
    _.insDirOf = function(dir, el) {
      prayDirection(dir);
      this.withDirInsertAt(dir, el.parent, el[dir], el);
      this.parent.jQ.addClass('mq-hasCursor');
      this.jQ.insDirOf(dir, el.jQ);
      return this;
    };
    _.insLeftOf = function(el) {
      return this.insDirOf(L, el);
    };
    _.insRightOf = function(el) {
      return this.insDirOf(R, el);
    };

    _.insAtDirEnd = function(dir, el) {
      prayDirection(dir);
      this.withDirInsertAt(dir, el, 0, el.ends[dir]);
      this.jQ.insAtDirEnd(dir, el.jQ);
      el.focus();
      return this;
    };
    _.insAtLeftEnd = function(el) {
      return this.insAtDirEnd(L, el);
    };
    _.insAtRightEnd = function(el) {
      return this.insAtDirEnd(R, el);
    };

    /**
     * jump up or down from one block Node to another:
     * - cache the current Point in the node we're jumping from
     * - check if there's a Point in it cached for the node we're jumping to
     *   + if so put the cursor there,
     *   + if not seek a position in the node that is horizontally closest to
     *     the cursor's current position
     */
    _.jumpUpDown = function(from, to) {
      var self = this;
      self.upDownCache[from.id] = Point.copy(self);
      var cached = self.upDownCache[to.id];
      if (cached) {
        cached[R]
          ? self.insLeftOf(cached[R])
          : self.insAtRightEnd(cached.parent);
      } else {
        var pageX = self.offset().left;
        to.seek(pageX, self);
      }
    };
    _.offset = function() {
      //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()
      //returns all 0's on inline elements with negative margin-right (like
      //the cursor) at the end of their parent, so temporarily remove the
      //negative margin-right when calling jQuery::offset()
      //Opera bug DSK-360043
      //http://bugs.jquery.com/ticket/11523
      //https://github.com/jquery/jquery/pull/717
      var self = this,
        offset = self.jQ.removeClass('mq-cursor').offset();
      self.jQ.addClass('mq-cursor');
      return offset;
    };
    _.unwrapGramp = function() {
      var gramp = this.parent.parent;
      var greatgramp = gramp.parent;
      var rightward = gramp[R];
      var cursor = this;

      var leftward = gramp[L];
      gramp.disown().eachChild(function(uncle) {
        if (uncle.isEmpty()) return;

        uncle
          .children()
          .adopt(greatgramp, leftward, rightward)
          .each(function(cousin) {
            cousin.jQ.insertBefore(gramp.jQ.first());
          });

        leftward = uncle.ends[R];
      });

      if (!this[R]) {
        //then find something to be rightward to insLeftOf
        if (this[L]) this[R] = this[L][R];
        else {
          while (!this[R]) {
            this.parent = this.parent[R];
            if (this.parent) this[R] = this.parent.ends[L];
            else {
              this[R] = gramp[R];
              this.parent = greatgramp;
              break;
            }
          }
        }
      }
      if (this[R]) this.insLeftOf(this[R]);
      else this.insAtRightEnd(greatgramp);

      gramp.jQ.remove();

      if (gramp[L].siblingDeleted) gramp[L].siblingDeleted(cursor.options, R);
      if (gramp[R].siblingDeleted) gramp[R].siblingDeleted(cursor.options, L);
    };
    _.startSelection = function() {
      var anticursor = (this.anticursor = Point.copy(this));
      var ancestors = (anticursor.ancestors = {}); // a map from each ancestor of
      // the anticursor, to its child that is also an ancestor; in other words,
      // the anticursor's ancestor chain in reverse order
      for (
        var ancestor = anticursor;
        ancestor.parent;
        ancestor = ancestor.parent
      ) {
        ancestors[ancestor.parent.id] = ancestor;
      }
    };
    _.endSelection = function() {
      delete this.anticursor;
    };
    _.select = function() {
      var lca,
        anticursor = this.anticursor;
      if (this[L] === anticursor[L] && this.parent === anticursor.parent)
        return false;

      // Find the lowest common ancestor (`lca`), and the ancestor of the cursor
      // whose parent is the LCA (which'll be an end of the selection fragment).
      for (var ancestor = this; ancestor.parent; ancestor = ancestor.parent) {
        if (ancestor.parent.id in anticursor.ancestors) {
          lca = ancestor.parent;
          break;
        }
      }
      pray('cursor and anticursor in the same tree', lca);
      // The cursor and the anticursor should be in the same tree, because the
      // mousemove handler attached to the document, unlike the one attached to
      // the root HTML DOM element, doesn't try to get the math tree node of the
      // mousemove target, and Cursor::seek() based solely on coordinates stays
      // within the tree of `this` cursor's root.

      // The other end of the selection fragment, the ancestor of the anticursor
      // whose parent is the LCA.
      var antiAncestor = anticursor.ancestors[lca.id];

      // Now we have two either Nodes or Points, guaranteed to have a common
      // parent and guaranteed that if both are Points, they are not the same,
      // and we have to figure out which is the left end and which the right end
      // of the selection.
      var leftEnd,
        rightEnd,
        dir = R;

      // This is an extremely subtle algorithm.
      // As a special case, `ancestor` could be a Point and `antiAncestor` a Node
      // immediately to `ancestor`'s left.
      // In all other cases,
      // - both Nodes
      // - `ancestor` a Point and `antiAncestor` a Node
      // - `ancestor` a Node and `antiAncestor` a Point
      // `antiAncestor[R] === rightward[R]` for some `rightward` that is
      // `ancestor` or to its right, if and only if `antiAncestor` is to
      // the right of `ancestor`.
      if (ancestor[L] !== antiAncestor) {
        for (var rightward = ancestor; rightward; rightward = rightward[R]) {
          if (rightward[R] === antiAncestor[R]) {
            dir = L;
            leftEnd = ancestor;
            rightEnd = antiAncestor;
            break;
          }
        }
      }
      if (dir === R) {
        leftEnd = antiAncestor;
        rightEnd = ancestor;
      }

      // only want to select Nodes up to Points, can't select Points themselves
      if (leftEnd instanceof Point) leftEnd = leftEnd[R];
      if (rightEnd instanceof Point) rightEnd = rightEnd[L];

      this.hide().selection = lca.selectChildren(leftEnd, rightEnd);
      this.insDirOf(dir, this.selection.ends[dir]);
      this.selectionChanged();
      return true;
    };

    _.clearSelection = function() {
      if (this.selection) {
        this.selection.clear();
        delete this.selection;
        this.selectionChanged();
      }
      return this;
    };
    _.deleteSelection = function() {
      if (!this.selection) return;

      this[L] = this.selection.ends[L][L];
      this[R] = this.selection.ends[R][R];
      this.selection.remove();
      this.selectionChanged();
      delete this.selection;
    };
    _.replaceSelection = function() {
      var seln = this.selection;
      if (seln) {
        this[L] = seln.ends[L][L];
        this[R] = seln.ends[R][R];
        delete this.selection;
      }
      return seln;
    };
  });

  var Selection = P(Fragment, function(_, super_) {
    _.init = function() {
      super_.init.apply(this, arguments);
      this.jQ = this.jQ.wrapAll('<span class="mq-selection"></span>').parent();
      //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it
    };
    _.adopt = function() {
      this.jQ.replaceWith((this.jQ = this.jQ.children()));
      return super_.adopt.apply(this, arguments);
    };
    _.clear = function() {
      // using the browser's native .childNodes property so that we
      // don't discard text nodes.
      this.jQ.replaceWith(this.jQ[0].childNodes);
      return this;
    };
    _.join = function(methodName) {
      return this.fold('', function(fold, child) {
        return fold + child[methodName]();
      });
    };
  });
  /*********************************************
   * Controller for a MathQuill instance,
   * on which services are registered with
   *
   *   Controller.open(function(_) { ... });
   *
   ********************************************/

  var Controller = P(function(_) {
    _.init = function(API, root, container) {
      this.API = API;
      this.root = root;
      this.container = container;

      API.__controller = root.controller = this;

      this.cursor = root.cursor = Cursor(root, API.__options);
      // TODO: stop depending on root.cursor, and rm it
    };

    _.handle = function(name, dir) {
      var handlers = this.API.__options.handlers;
      if (handlers && handlers[name]) {
        if (dir === L || dir === R) handlers[name](dir, this.API);
        else handlers[name](this.API);
      }
    };

    var notifyees = [];
    this.onNotify = function(f) {
      notifyees.push(f);
    };
    _.notify = function() {
      for (var i = 0; i < notifyees.length; i += 1) {
        notifyees[i].apply(this.cursor, arguments);
      }
      return this;
    };
  });
  /*********************************************************
   * The publicly exposed MathQuill API.
   ********************************************************/

  /**
   * Global function that takes an HTML element and, if it's the root HTML element
   * of a static math or math or text field, returns its API object (if not, null).
   * Identity of API object guaranteed if called multiple times, i.e.:
   *
   *   var mathfield = MathQuill.MathField(mathFieldSpan);
   *   assert(MathQuill(mathFieldSpan) === mathfield);
   *   assert(MathQuill(mathFieldSpan) === MathQuill(mathFieldSpan));
   *
   */
  function MathQuill(el) {
    if (!el || !el.nodeType) return null; // check that `el` is a HTML element, using the
    // same technique as jQuery: https://github.com/jquery/jquery/blob/679536ee4b7a92ae64a5f58d90e9cc38c001e807/src/core/init.js#L92
    var blockId = $(el)
      .children('.mq-root-block')
      .attr(mqBlockId);
    return blockId ? Node.byId[blockId].controller.API : null;
  }

  MathQuill.noConflict = function() {
    window.MathQuill = origMathQuill;
    return MathQuill;
  };
  var origMathQuill = window.MathQuill;
  window.MathQuill = MathQuill;

  /**
   * Returns function (to be publicly exported) that MathQuill-ifies an HTML
   * element and returns an API object. If the element had already been MathQuill-
   * ified into the same kind, return the original API object (if different kind
   * or not an HTML element, null).
   */
  function APIFnFor(APIClass) {
    function APIFn(el, opts) {
      var mq = MathQuill(el);
      if (mq instanceof APIClass || !el || !el.nodeType) return mq;
      return APIClass($(el), opts);
    }
    APIFn.prototype = APIClass.prototype;
    return APIFn;
  }

  var Options = P(),
    optionProcessors = {};
  MathQuill.__options = Options.p;

  var AbstractMathQuill = P(function(_) {
    _.init = function() {
      throw "wtf don't call me, I'm 'abstract'";
    };
    _.initRoot = function(root, el, opts) {
      this.__options = Options();
      this.config(opts);

      var ctrlr = Controller(this, root, el);
      ctrlr.createTextarea();

      var contents = el.contents().detach();
      root.jQ = $('<span class="mq-root-block"/>')
        .attr(mqBlockId, root.id)
        .appendTo(el);
      this.latex(contents.text());

      this.revert = function() {
        return el
          .empty()
          .unbind('.mathquill')
          .removeClass('mq-editable-field mq-math-mode mq-text-mode')
          .append(contents);
      };
    };
    _.config = MathQuill.config = function(opts) {
      for (var opt in opts)
        if (opts.hasOwnProperty(opt)) {
          var optVal = opts[opt],
            processor = optionProcessors[opt];
          this.__options[opt] = processor ? processor(optVal) : optVal;
        }
      return this;
    };
    _.el = function() {
      return this.__controller.container[0];
    };
    _.text = function() {
      return this.__controller.exportText();
    };
    _.latex = function(latex) {
      if (arguments.length > 0) {
        this.__controller.renderLatexMath(latex);
        if (this.__controller.blurred)
          this.__controller.cursor.hide().parent.blur();
        return this;
      }
      return this.__controller.exportLatex();
    };
    _.html = function() {
      return this.__controller.root.jQ
        .html()
        .replace(/ mathquill-(?:command|block)-id="?\d+"?/g, '')
        .replace(/<span class="?mq-cursor( mq-blink)?"?>.?<\/span>/i, '')
        .replace(/ mq-hasCursor|mq-hasCursor ?/, '')
        .replace(/ class=(""|(?= |>))/g, '');
    };
    _.reflow = function() {
      this.__controller.root.postOrder('reflow');
      return this;
    };
  });
  MathQuill.prototype = AbstractMathQuill.prototype;

  MathQuill.StaticMath = APIFnFor(
    P(AbstractMathQuill, function(_, super_) {
      _.init = function(el) {
        this.initRoot(MathBlock(), el.addClass('mq-math-mode'));
        this.__controller.delegateMouseEvents();
        this.__controller.staticMathTextareaEvents();
      };
      _.latex = function() {
        var returned = super_.latex.apply(this, arguments);
        if (arguments.length > 0) {
          this.__controller.root.postOrder(
            'registerInnerField',
            (this.innerFields = [])
          );
        }
        return returned;
      };
    })
  );

  var EditableField = (MathQuill.EditableField = P(AbstractMathQuill, function(
    _
  ) {
    _.initRootAndEvents = function(root, el, opts) {
      this.initRoot(root, el, opts);
      this.__controller.editable = true;
      this.__controller.delegateMouseEvents();
      this.__controller.editablesTextareaEvents();
    };
    _.focus = function() {
      this.__controller.textarea.focus();
      return this;
    };
    _.blur = function() {
      this.__controller.textarea.blur();
      return this;
    };
    _.write = function(latex) {
      this.__controller.writeLatex(latex);
      if (this.__controller.blurred)
        this.__controller.cursor.hide().parent.blur();
      return this;
    };
    _.cmd = function(cmd) {
      var ctrlr = this.__controller.notify(),
        cursor = ctrlr.cursor.show();
      if (/^\\[a-z]+$/i.test(cmd)) {
        cmd = cmd.slice(1);
        var klass = LatexCmds[cmd];
        if (klass) {
          cmd = klass(cmd);
          if (cursor.selection) cmd.replaces(cursor.replaceSelection());
          cmd.createLeftOf(cursor);
        } /* TODO: API needs better error reporting */ else;
      } else cursor.parent.write(cursor, cmd, cursor.replaceSelection());
      if (ctrlr.blurred) cursor.hide().parent.blur();
      return this;
    };
    _.select = function() {
      var ctrlr = this.__controller;
      ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);
      while (ctrlr.cursor[L]) ctrlr.selectLeft();
      return this;
    };
    _.clearSelection = function() {
      this.__controller.cursor.clearSelection();
      return this;
    };

    _.moveToDirEnd = function(dir) {
      this.__controller
        .notify('move')
        .cursor.insAtDirEnd(dir, this.__controller.root);
      return this;
    };
    _.moveToLeftEnd = function() {
      return this.moveToDirEnd(L);
    };
    _.moveToRightEnd = function() {
      return this.moveToDirEnd(R);
    };

    _.keystroke = function(keys) {
      keys = keys.replace(/^\s+|\s+$/g, '').split(/\s+/);
      for (var i = 0; i < keys.length; i += 1) {
        this.__controller.keystroke(keys[i], { preventDefault: noop });
      }
      return this;
    };
    _.typedText = function(text) {
      for (var i = 0; i < text.length; i += 1)
        this.__controller.typedText(text.charAt(i));
      return this;
    };
  }));

  function RootBlockMixin(_) {
    var names = 'moveOutOf deleteOutOf selectOutOf upOutOf downOutOf reflow'.split(
      ' '
    );
    for (var i = 0; i < names.length; i += 1)
      (function(name) {
        _[name] = function(dir) {
          this.controller.handle(name, dir);
        };
      })(names[i]);
  }
  var Parser = P(function(_, super_, Parser) {
    // The Parser object is a wrapper for a parser function.
    // Externally, you use one to parse a string by calling
    //   var result = SomeParser.parse('Me Me Me! Parse Me!');
    // You should never call the constructor, rather you should
    // construct your Parser from the base parsers and the
    // parser combinator methods.

    function parseError(stream, message) {
      if (stream) {
        stream = "'" + stream + "'";
      } else {
        stream = 'EOF';
      }

      throw 'Parse Error: ' + message + ' at ' + stream;
    }

    _.init = function(body) {
      this._ = body;
    };

    _.parse = function(stream) {
      return this.skip(eof)._(stream, success, parseError);

      function success(stream, result) {
        return result;
      }
    };

    // -*- primitive combinators -*- //
    _.or = function(alternative) {
      pray('or is passed a parser', alternative instanceof Parser);

      var self = this;

      return Parser(function(stream, onSuccess, onFailure) {
        return self._(stream, onSuccess, failure);

        function failure(newStream) {
          return alternative._(stream, onSuccess, onFailure);
        }
      });
    };

    _.then = function(next) {
      var self = this;

      return Parser(function(stream, onSuccess, onFailure) {
        return self._(stream, success, onFailure);

        function success(newStream, result) {
          var nextParser = next instanceof Parser ? next : next(result);
          pray('a parser is returned', nextParser instanceof Parser);
          return nextParser._(newStream, onSuccess, onFailure);
        }
      });
    };

    // -*- optimized iterative combinators -*- //
    _.many = function() {
      var self = this;

      return Parser(function(stream, onSuccess, onFailure) {
        var xs = [];
        while (self._(stream, success, failure));
        return onSuccess(stream, xs);

        function success(newStream, x) {
          stream = newStream;
          xs.push(x);
          return true;
        }

        function failure() {
          return false;
        }
      });
    };

    _.times = function(min, max) {
      if (arguments.length < 2) max = min;
      var self = this;

      return Parser(function(stream, onSuccess, onFailure) {
        var xs = [];
        var result = true;
        var failure;

        for (var i = 0; i < min; i += 1) {
          result = self._(stream, success, firstFailure);
          if (!result) return onFailure(stream, failure);
        }

        for (; i < max && result; i += 1) {
          result = self._(stream, success, secondFailure);
        }

        return onSuccess(stream, xs);

        function success(newStream, x) {
          xs.push(x);
          stream = newStream;
          return true;
        }

        function firstFailure(newStream, msg) {
          failure = msg;
          stream = newStream;
          return false;
        }

        function secondFailure(newStream, msg) {
          return false;
        }
      });
    };

    // -*- higher-level combinators -*- //
    _.result = function(res) {
      return this.then(succeed(res));
    };
    _.atMost = function(n) {
      return this.times(0, n);
    };
    _.atLeast = function(n) {
      var self = this;
      return self.times(n).then(function(start) {
        return self.many().map(function(end) {
          return start.concat(end);
        });
      });
    };

    _.map = function(fn) {
      return this.then(function(result) {
        return succeed(fn(result));
      });
    };

    _.skip = function(two) {
      return this.then(function(result) {
        return two.result(result);
      });
    };

    // -*- primitive parsers -*- //
    var string = (this.string = function(str) {
      var len = str.length;
      var expected = "expected '" + str + "'";

      return Parser(function(stream, onSuccess, onFailure) {
        var head = stream.slice(0, len);

        if (head === str) {
          return onSuccess(stream.slice(len), head);
        } else {
          return onFailure(stream, expected);
        }
      });
    });

    var regex = (this.regex = function(re) {
      pray('regexp parser is anchored', re.toString().charAt(1) === '^');

      var expected = 'expected ' + re;

      return Parser(function(stream, onSuccess, onFailure) {
        var match = re.exec(stream);

        if (match) {
          var result = match[0];
          return onSuccess(stream.slice(result.length), result);
        } else {
          return onFailure(stream, expected);
        }
      });
    });

    var succeed = (Parser.succeed = function(result) {
      return Parser(function(stream, onSuccess) {
        return onSuccess(stream, result);
      });
    });

    var fail = (Parser.fail = function(msg) {
      return Parser(function(stream, _, onFailure) {
        return onFailure(stream, msg);
      });
    });

    var letter = (Parser.letter = regex(/^[a-z]/i));
    var letters = (Parser.letters = regex(/^[a-z]*/i));
    var digit = (Parser.digit = regex(/^[0-9]/));
    var digits = (Parser.digits = regex(/^[0-9]*/));
    var whitespace = (Parser.whitespace = regex(/^\s+/));
    var optWhitespace = (Parser.optWhitespace = regex(/^\s*/));

    var any = (Parser.any = Parser(function(stream, onSuccess, onFailure) {
      if (!stream) return onFailure(stream, 'expected any character');

      return onSuccess(stream.slice(1), stream.charAt(0));
    }));

    var all = (Parser.all = Parser(function(stream, onSuccess, onFailure) {
      return onSuccess('', stream);
    }));

    var eof = (Parser.eof = Parser(function(stream, onSuccess, onFailure) {
      if (stream) return onFailure(stream, 'expected EOF');

      return onSuccess(stream, stream);
    }));
  });
  /*************************************************
   * Sane Keyboard Events Shim
   *
   * An abstraction layer wrapping the textarea in
   * an object with methods to manipulate and listen
   * to events on, that hides all the nasty cross-
   * browser incompatibilities behind a uniform API.
   *
   * Design goal: This is a *HARD* internal
   * abstraction barrier. Cross-browser
   * inconsistencies are not allowed to leak through
   * and be dealt with by event handlers. All future
   * cross-browser issues that arise must be dealt
   * with here, and if necessary, the API updated.
   *
   * Organization:
   * - key values map and stringify()
   * - saneKeyboardEvents()
   *    + defer() and flush()
   *    + event handler logic
   *    + attach event handlers and export methods
   ************************************************/

  var saneKeyboardEvents = (function() {
    // The following [key values][1] map was compiled from the
    // [DOM3 Events appendix section on key codes][2] and
    // [a widely cited report on cross-browser tests of key codes][3],
    // except for 10: 'Enter', which I've empirically observed in Safari on iOS
    // and doesn't appear to conflict with any other known key codes.
    //
    // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues
    // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
    // [3]: http://unixpapa.com/js/key.html
    var KEY_VALUES = {
      8: 'Backspace',
      9: 'Tab',

      10: 'Enter', // for Safari on iOS

      13: 'Enter',

      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      20: 'CapsLock',

      27: 'Esc',

      32: 'Spacebar',

      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',

      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',

      45: 'Insert',

      46: 'Del',

      144: 'NumLock',
    };

    // To the extent possible, create a normalized string representation
    // of the key combo (i.e., key code and modifier keys).
    function stringify(evt) {
      var which = evt.which || evt.keyCode;
      var keyVal = KEY_VALUES[which];
      var key;
      var modifiers = [];

      if (evt.ctrlKey) modifiers.push('Ctrl');
      if (evt.originalEvent && evt.originalEvent.metaKey)
        modifiers.push('Meta');
      if (evt.altKey) modifiers.push('Alt');
      if (evt.shiftKey) modifiers.push('Shift');

      key = keyVal || String.fromCharCode(which);

      if (!modifiers.length && !keyVal) return key;

      modifiers.push(key);
      return modifiers.join('-');
    }

    // create a keyboard events shim that calls callbacks at useful times
    // and exports useful public methods
    return function saneKeyboardEvents(el, handlers) {
      var keydown = null;
      var keypress = null;

      var textarea = jQuery(el);
      var target = jQuery(handlers.container || textarea);

      // checkTextareaFor() is called after keypress or paste events to
      // say "Hey, I think something was just typed" or "pasted" (resp.),
      // so that at all subsequent opportune times (next event or timeout),
      // will check for expected typed or pasted text.
      // Need to check repeatedly because #135: in Safari 5.1 (at least),
      // after selecting something and then typing, the textarea is
      // incorrectly reported as selected during the input event (but not
      // subsequently).
      var checkTextarea = noop,
        timeoutId;
      function checkTextareaFor(checker) {
        checkTextarea = checker;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(checker);
      }
      target.bind('keydown keypress input keyup focusout paste', function() {
        checkTextarea();
      });

      // -*- public methods -*- //
      function select(text) {
        // check textarea at least once/one last time before munging (so
        // no race condition if selection happens after keypress/paste but
        // before checkTextarea), then never again ('cos it's been munged)
        checkTextarea();
        checkTextarea = noop;
        clearTimeout(timeoutId);

        textarea.val(text);
        if (text) textarea[0].select();
        shouldBeSelected = !!text;
      }
      var shouldBeSelected = false;

      // -*- helper subroutines -*- //

      // Determine whether there's a selection in the textarea.
      // This will always return false in IE < 9, which don't support
      // HTMLTextareaElement::selection{Start,End}.
      function hasSelection() {
        var dom = textarea[0];

        if (!('selectionStart' in dom)) return false;
        return dom.selectionStart !== dom.selectionEnd;
      }

      function handleKey() {
        //handlers.keystroke(stringify(keydown), keydown);
      }

      // -*- event handlers -*- //
      function onKeydown(e) {
        keydown = e;
        keypress = null;

        if (shouldBeSelected)
          checkTextareaFor(function() {
            textarea[0].select(); // re-select textarea in case it's an unrecognized
            checkTextarea = noop; // key that clears the selection, then never
            clearTimeout(timeoutId); // again, 'cos next thing might be blur
          });

        handleKey();
      }

      function onKeypress(e) {
        // call the key handler for repeated keypresses.
        // This excludes keypresses that happen directly
        // after keydown.  In that case, there will be
        // no previous keypress, so we skip it here
        if (keydown && keypress) handleKey();

        keypress = e;

        checkTextareaFor(typedText);
      }
      function typedText() {
        // If there is a selection, the contents of the textarea couldn't
        // possibly have just been typed in.
        // This happens in browsers like Firefox and Opera that fire
        // keypress for keystrokes that are not text entry and leave the
        // selection in the textarea alone, such as Ctrl-C.
        // Note: we assume that browsers that don't support hasSelection()
        // also never fire keypress on keystrokes that are not text entry.
        // This seems reasonably safe because:
        // - all modern browsers including IE 9+ support hasSelection(),
        //   making it extremely unlikely any browser besides IE < 9 won't
        // - as far as we know IE < 9 never fires keypress on keystrokes
        //   that aren't text entry, which is only as reliable as our
        //   tests are comprehensive, but the IE < 9 way to do
        //   hasSelection() is poorly documented and is also only as
        //   reliable as our tests are comprehensive
        // If anything like #40 or #71 is reported in IE < 9, see
        // b1318e5349160b665003e36d4eedd64101ceacd8
        if (hasSelection()) return;

        var text = textarea.val();
        if (text.length === 1) {
          textarea.val('');
          handlers.typedText(text);
        } // in Firefox, keys that don't type text, just clear seln, fire keypress
        // https://github.com/mathquill/mathquill/issues/293#issuecomment-40997668
        else if (text) textarea[0].select(); // re-select if that's why we're here
      }

      function onBlur() {
        keydown = keypress = null;
      }

      function onPaste(e) {
        // browsers are dumb.
        //
        // In Linux, middle-click pasting causes onPaste to be called,
        // when the textarea is not necessarily focused.  We focus it
        // here to ensure that the pasted text actually ends up in the
        // textarea.
        //
        // It's pretty nifty that by changing focus in this handler,
        // we can change the target of the default action.  (This works
        // on keydown too, FWIW).
        //
        // And by nifty, we mean dumb (but useful sometimes).
        textarea.focus();

        checkTextareaFor(pastedText);
      }
      function pastedText() {
        var text = textarea.val();
        textarea.val('');
        //if (text) handlers.paste(text);
      }

      // -*- attach event handlers -*- //
      target.bind({
        //      keydown: onKeydown,
        //      keypress: onKeypress,
        focusout: onBlur,
        paste: onPaste,
      });

      // -*- export public methods -*- //
      return {
        select: select,
      };
    };
  })();
  /***********************************************
   * Export math in a human-readable text format
   * As you can see, only half-baked so far.
   **********************************************/

  Controller.open(function(_, super_) {
    _.exportText = function() {
      return this.root.foldChildren('', function(text, child) {
        return text + child.text();
      });
    };
  });
  Controller.open(function(_) {
    _.focusBlurEvents = function() {
      var ctrlr = this,
        root = ctrlr.root,
        cursor = ctrlr.cursor;
      var blurTimeout;
      ctrlr.textarea
        .focus(function() {
          ctrlr.blurred = false;
          clearTimeout(blurTimeout);
          ctrlr.container.addClass('mq-focused');
          if (!cursor.parent) cursor.insAtRightEnd(root);
          if (cursor.selection) {
            cursor.selection.jQ.removeClass('mq-blur');
            ctrlr.selectionChanged(); //re-select textarea contents after tabbing away and back
          } else cursor.show();
        })
        .blur(function() {
          ctrlr.blurred = true;
          blurTimeout = setTimeout(function() {
            // wait for blur on window; if
            root.postOrder('intentionalBlur'); // none, intentional blur: #264
            cursor.clearSelection();
            blur();
          });
          $(window).on('blur', windowBlur);
        });
      function windowBlur() {
        // blur event also fired on window, just switching
        clearTimeout(blurTimeout); // tabs/windows, not intentional blur
        if (cursor.selection) cursor.selection.jQ.addClass('mq-blur');
        blur();
      }
      function blur() {
        // not directly in the textarea blur handler so as to be
        cursor.hide().parent.blur(); // synchronous with/in the same frame as
        ctrlr.container.removeClass('mq-focused'); // clearing/blurring selection
        $(window).off('blur', windowBlur);
      }
      ctrlr.blurred = true;
      cursor.hide().parent.blur();
    };
  });

  /**
   * TODO: I wanted to move MathBlock::focus and blur here, it would clean
   * up lots of stuff like, TextBlock::focus is set to MathBlock::focus
   * and TextBlock::blur calls MathBlock::blur, when instead they could
   * use inheritance and super_.
   *
   * Problem is, there's lots of calls to .focus()/.blur() on nodes
   * outside Controller::focusBlurEvents(), such as .postOrder('blur') on
   * insertion, which if MathBlock::blur becomes Node::blur, would add the
   * 'blur' CSS class to all Symbol's (because .isEmpty() is true for all
   * of them).
   *
   * I'm not even sure there aren't other troublesome calls to .focus() or
   * .blur(), so this is TODO for now.
   */
  /*****************************************
   * Deals with the browser DOM events from
   * interaction with the typist.
   ****************************************/

  Controller.open(function(_) {
    _.keystroke = function(key, evt) {
      this.cursor.parent.keystroke(key, evt, this);
    };
  });

  Node.open(function(_) {
    _.keystroke = function(key, e, ctrlr) {
      var cursor = ctrlr.cursor;

      switch (key) {
        case 'Ctrl-Shift-Backspace':
        case 'Ctrl-Backspace':
          while (cursor[L] || cursor.selection) {
            ctrlr.backspace();
          }
          break;

        case 'Shift-Backspace':
        case 'Backspace':
          ctrlr.backspace();
          break;

        // Tab or Esc -> go one block right if it exists, else escape right.
        case 'Esc':
        case 'Tab':
          ctrlr.escapeDir(R, key, e);
          return;

        // Shift-Tab -> go one block left if it exists, else escape left.
        case 'Shift-Tab':
        case 'Shift-Esc':
          ctrlr.escapeDir(L, key, e);
          return;

        // End -> move to the end of the current block.
        case 'End':
          ctrlr.notify('move').cursor.insAtRightEnd(cursor.parent);
          break;

        // Ctrl-End -> move all the way to the end of the root block.
        case 'Ctrl-End':
          ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);
          break;

        // Shift-End -> select to the end of the current block.
        case 'Shift-End':
          while (cursor[R]) {
            ctrlr.selectRight();
          }
          break;

        // Ctrl-Shift-End -> select to the end of the root block.
        case 'Ctrl-Shift-End':
          while (cursor[R] || cursor.parent !== ctrlr.root) {
            ctrlr.selectRight();
          }
          break;

        // Home -> move to the start of the root block or the current block.
        case 'Home':
          ctrlr.notify('move').cursor.insAtLeftEnd(cursor.parent);
          break;

        // Ctrl-Home -> move to the start of the current block.
        case 'Ctrl-Home':
          ctrlr.notify('move').cursor.insAtLeftEnd(ctrlr.root);
          break;

        // Shift-Home -> select to the start of the current block.
        case 'Shift-Home':
          while (cursor[L]) {
            ctrlr.selectLeft();
          }
          break;

        // Ctrl-Shift-Home -> move to the start of the root block.
        case 'Ctrl-Shift-Home':
          while (cursor[L] || cursor.parent !== ctrlr.root) {
            ctrlr.selectLeft();
          }
          break;

        case 'Left':
          ctrlr.moveLeft();
          break;
        case 'Shift-Left':
          ctrlr.selectLeft();
          break;
        case 'Ctrl-Left':
          break;

        case 'Right':
          ctrlr.moveRight();
          break;
        case 'Shift-Right':
          ctrlr.selectRight();
          break;
        case 'Ctrl-Right':
          break;

        case 'Up':
          ctrlr.moveUp();
          break;
        case 'Down':
          ctrlr.moveDown();
          break;

        case 'Shift-Up':
          if (cursor[L]) {
            while (cursor[L]) ctrlr.selectLeft();
          } else {
            ctrlr.selectLeft();
          }

        case 'Shift-Down':
          if (cursor[R]) {
            while (cursor[R]) ctrlr.selectRight();
          } else {
            ctrlr.selectRight();
          }

        case 'Ctrl-Up':
          break;
        case 'Ctrl-Down':
          break;

        case 'Ctrl-Shift-Del':
        case 'Ctrl-Del':
          while (cursor[R] || cursor.selection) {
            ctrlr.deleteForward();
          }
          break;

        case 'Shift-Del':
        case 'Del':
          ctrlr.deleteForward();
          break;

        case 'Meta-A':
        case 'Ctrl-A':
          ctrlr.notify('move').cursor.insAtRightEnd(ctrlr.root);
          while (cursor[L]) ctrlr.selectLeft();
          break;

        default:
          return;
      }
      e.preventDefault();
      ctrlr.scrollHoriz();
    };

    _.moveOutOf = _.moveTowards = _.deleteOutOf = _.deleteTowards = _.unselectInto = _.selectOutOf = _.selectTowards = function() { // called by Controller::escapeDir, moveDir // called by Controller::moveDir // called by Controller::deleteDir // called by Controller::deleteDir // called by Controller::selectDir // called by Controller::selectDir // called by Controller::selectDir
      pray('overridden or never called on this node');
    };
  });

  Controller.open(function(_) {
    this.onNotify(function(e) {
      if (e === 'move' || e === 'upDown') this.show().clearSelection();
    });
    _.escapeDir = function(dir, key, e) {
      prayDirection(dir);
      var cursor = this.cursor;

      // only prevent default of Tab if not in the root editable
      if (cursor.parent !== this.root) e.preventDefault();

      // want to be a noop if in the root editable (in fact, Tab has an unrelated
      // default browser action if so)
      if (cursor.parent === this.root) return;

      cursor.parent.moveOutOf(dir, cursor);
      return this.notify('move');
    };

    optionProcessors.leftRightIntoCmdGoes = function(updown) {
      if (updown && updown !== 'up' && updown !== 'down') {
        throw '"up" or "down" required for leftRightIntoCmdGoes option, ' +
          'got "' +
          updown +
          '"';
      }
      return updown;
    };
    _.moveDir = function(dir) {
      prayDirection(dir);
      var cursor = this.cursor,
        updown = cursor.options.leftRightIntoCmdGoes;

      if (cursor.selection) {
        cursor.insDirOf(dir, cursor.selection.ends[dir]);
      } else if (cursor[dir]) cursor[dir].moveTowards(dir, cursor, updown);
      else cursor.parent.moveOutOf(dir, cursor, updown);

      return this.notify('move');
    };
    _.moveLeft = function() {
      return this.moveDir(L);
    };
    _.moveRight = function() {
      return this.moveDir(R);
    };

    /**
     * moveUp and moveDown have almost identical algorithms:
     * - first check left and right, if so insAtLeft/RightEnd of them
     * - else check the parent's 'upOutOf'/'downOutOf' property:
     *   + if it's a function, call it with the cursor as the sole argument and
     *     use the return value as if it were the value of the property
     *   + if it's a Node, jump up or down into it:
     *     - if there is a cached Point in the block, insert there
     *     - else, seekHoriz within the block to the current x-coordinate (to be
     *       as close to directly above/below the current position as possible)
     *   + unless it's exactly `true`, stop bubbling
     */
    _.moveUp = function() {
      return moveUpDown(this, 'up');
    };
    _.moveDown = function() {
      return moveUpDown(this, 'down');
    };
    function moveUpDown(self, dir) {
      var cursor = self.notify('upDown').cursor;
      var dirInto = dir + 'Into',
        dirOutOf = dir + 'OutOf';
      if (cursor[R][dirInto]) cursor.insAtLeftEnd(cursor[R][dirInto]);
      else if (cursor[L][dirInto]) cursor.insAtRightEnd(cursor[L][dirInto]);
      else {
        cursor.parent.bubble(function(ancestor) {
          var prop = ancestor[dirOutOf];
          if (prop) {
            if (typeof prop === 'function') prop = ancestor[dirOutOf](cursor);
            if (prop instanceof Node) cursor.jumpUpDown(ancestor, prop);
            if (prop !== true) return false;
          }
        });
      }
      return self;
    }
    this.onNotify(function(e) {
      if (e !== 'upDown') this.upDownCache = {};
    });

    this.onNotify(function(e) {
      if (e === 'edit') this.show().deleteSelection();
    });
    _.deleteDir = function(dir) {
      prayDirection(dir);
      var cursor = this.cursor;

      var hadSelection = cursor.selection;
      this.notify('edit'); // deletes selection if present
      if (!hadSelection) {
        if (cursor[dir]) cursor[dir].deleteTowards(dir, cursor);
        else cursor.parent.deleteOutOf(dir, cursor);
      }

      if (cursor[L].siblingDeleted) cursor[L].siblingDeleted(cursor.options, R);
      if (cursor[R].siblingDeleted) cursor[R].siblingDeleted(cursor.options, L);
      cursor.parent.bubble('reflow');

      return this;
    };
    _.backspace = function() {
      return this.deleteDir(L);
    };
    _.deleteForward = function() {
      return this.deleteDir(R);
    };

    this.onNotify(function(e) {
      if (e !== 'select') this.endSelection();
    });
    _.selectDir = function(dir) {
      var cursor = this.notify('select').cursor,
        seln = cursor.selection;
      prayDirection(dir);

      if (!cursor.anticursor) cursor.startSelection();

      var node = cursor[dir];
      if (node) {
        // "if node we're selecting towards is inside selection (hence retracting)
        // and is on the *far side* of the selection (hence is only node selected)
        // and the anticursor is *inside* that node, not just on the other side"
        if (
          seln &&
          seln.ends[dir] === node &&
          cursor.anticursor[-dir] !== node
        ) {
          node.unselectInto(dir, cursor);
        } else node.selectTowards(dir, cursor);
      } else cursor.parent.selectOutOf(dir, cursor);

      cursor.clearSelection();
      cursor.select() || cursor.show();
    };
    _.selectLeft = function() {
      return this.selectDir(L);
    };
    _.selectRight = function() {
      return this.selectDir(R);
    };
  });
  // Parser MathCommand
  var latexMathParser = (function() {
    function commandToBlock(cmd) {
      var block = MathBlock();
      cmd.adopt(block, 0, 0);
      return block;
    }
    function joinBlocks(blocks) {
      var firstBlock = blocks[0] || MathBlock();

      for (var i = 1; i < blocks.length; i += 1) {
        blocks[i].children().adopt(firstBlock, firstBlock.ends[R], 0);
      }

      return firstBlock;
    }

    var string = Parser.string;
    var regex = Parser.regex;
    var letter = Parser.letter;
    var any = Parser.any;
    var optWhitespace = Parser.optWhitespace;
    var succeed = Parser.succeed;
    var fail = Parser.fail;

    // Parsers yielding MathCommands
    var variable = letter.map(function(c) {
      return Letter(c);
    });
    var symbol = regex(/^[^${}\\_^]/).map(function(c) {
      return VanillaSymbol(c);
    });

    var controlSequence = regex(/^[^\\a-eg-zA-Z]/) // hotfix #164; match MathBlock::write
      .or(
        string('\\').then(
          regex(/^[a-z]+/i)
            .or(regex(/^\s+/).result(' '))
            .or(any)
        )
      )
      .then(function(ctrlSeq) {
        var cmdKlass = LatexCmds[ctrlSeq];

        if (cmdKlass) {
          return cmdKlass(ctrlSeq).parser();
        } else {
          return fail('unknown command: \\' + ctrlSeq);
        }
      });
    var command = controlSequence.or(variable).or(symbol);
    // Parsers yielding MathBlocks
    var mathGroup = string('{')
      .then(function() {
        return mathSequence;
      })
      .skip(string('}'));
    var mathBlock = optWhitespace.then(
      mathGroup.or(command.map(commandToBlock))
    );
    var mathSequence = mathBlock
      .many()
      .map(joinBlocks)
      .skip(optWhitespace);

    var optMathBlock = string('[')
      .then(
        mathBlock
          .then(function(block) {
            return block.join('latex') !== ']' ? succeed(block) : fail();
          })
          .many()
          .map(joinBlocks)
          .skip(optWhitespace)
      )
      .skip(string(']'));
    var latexMath = mathSequence;

    latexMath.block = mathBlock;
    latexMath.optBlock = optMathBlock;
    return latexMath;
  })();

  Controller.open(function(_, super_) {
    _.exportLatex = function() {
      return this.root.latex().replace(/(\\[a-z]+) (?![a-z])/gi, '$1');
    };
    _.writeLatex = function(latex) {
      var cursor = this.notify('edit').cursor;

      var all = Parser.all;
      var eof = Parser.eof;

      var block = latexMathParser
        .skip(eof)
        .or(all.result(false))
        .parse(latex);

      if (block && !block.isEmpty()) {
        block.children().adopt(cursor.parent, cursor[L], cursor[R]);
        var jQ = block.jQize();
        jQ.insertBefore(cursor.jQ);
        cursor[L] = block.ends[R];
        block.finalizeInsert(cursor.options, cursor);
        if (block.ends[R][R].siblingCreated)
          block.ends[R][R].siblingCreated(cursor.options, L);
        if (block.ends[L][L].siblingCreated)
          block.ends[L][L].siblingCreated(cursor.options, R);
        cursor.parent.bubble('reflow');
      }

      return this;
    };
    _.renderLatexMath = function(latex) {
      var root = this.root,
        cursor = this.cursor;

      var all = Parser.all;
      var eof = Parser.eof;

      var block = latexMathParser
        .skip(eof)
        .or(all.result(false))
        .parse(latex);

      root.eachChild('postOrder', 'dispose');
      root.ends[L] = root.ends[R] = 0;

      if (block) {
        block.children().adopt(root, 0, 0);
      }

      var jQ = root.jQ;

      if (block) {
        var html = block.join('html');
        jQ.html(html);
        root.jQize(jQ.children());
        root.finalizeInsert(cursor.options);
      } else {
        jQ.empty();
      }

      delete cursor.selection;
      cursor.insAtRightEnd(root);
    };
    _.renderLatexText = function(latex) {
      var root = this.root,
        cursor = this.cursor;

      root.jQ
        .children()
        .slice(1)
        .remove();
      root.eachChild('postOrder', 'dispose');
      root.ends[L] = root.ends[R] = 0;
      delete cursor.selection;
      cursor.show().insAtRightEnd(root);

      var regex = Parser.regex;
      var string = Parser.string;
      var eof = Parser.eof;
      var all = Parser.all;

      // Parser RootMathCommand
      var mathMode = string('$')
        .then(latexMathParser)
        // because TeX is insane, math mode doesn't necessarily
        // have to end.  So we allow for the case that math mode
        // continues to the end of the stream.
        .skip(string('$').or(eof))
        .map(function(block) {
          // HACK FIXME: this shouldn't have to have access to cursor
          var rootMathCommand = RootMathCommand(cursor);

          rootMathCommand.createBlocks();
          var rootMathBlock = rootMathCommand.ends[L];
          block.children().adopt(rootMathBlock, 0, 0);

          return rootMathCommand;
        });
      var escapedDollar = string('\\$').result('$');
      var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);
      var latexText = mathMode.or(textChar).many();
      var commands = latexText
        .skip(eof)
        .or(all.result(false))
        .parse(latex);

      if (commands) {
        for (var i = 0; i < commands.length; i += 1) {
          commands[i].adopt(root, root.ends[R], 0);
        }

        root.jQize().appendTo(root.jQ);

        root.finalizeInsert(cursor.options);
      }
    };
  });
  /********************************************************
   * Deals with mouse events for clicking, drag-to-select
   *******************************************************/

  Controller.open(function(_) {
    _.delegateMouseEvents = function() {
      var ultimateRootjQ = this.root.jQ;
      //drag-to-select event handling
      this.container.bind('mousedown.mathquill', function(e) {
        var rootjQ = $(e.target).closest('.mq-root-block');
        var root =
          Node.byId[rootjQ.attr(mqBlockId) || ultimateRootjQ.attr(mqBlockId)];
        var ctrlr = root.controller,
          cursor = ctrlr.cursor,
          blink = cursor.blink;
        var textareaSpan = ctrlr.textareaSpan,
          textarea = ctrlr.textarea;

        var target;
        function mousemove(e) {
          target = $(e.target);
        }
        function docmousemove(e) {
          if (!cursor.anticursor) cursor.startSelection();
          ctrlr.seek(target, e.pageX, e.pageY).cursor.select();
          target = undefined;
        }
        // outside rootjQ, the MathQuill node corresponding to the target (if any)
        // won't be inside this root, so don't mislead Controller::seek with it

        function mouseup(e) {
          cursor.blink = blink;
          if (!cursor.selection) {
            if (ctrlr.editable) {
              cursor.show();
            } else {
              textareaSpan.detach();
            }
          }

          // delete the mouse handlers now that we're not dragging anymore
          rootjQ.unbind('mousemove', mousemove);
          $(e.target.ownerDocument)
            .unbind('mousemove', docmousemove)
            .unbind('mouseup', mouseup);
        }

        if (ctrlr.blurred) {
          if (!ctrlr.editable) rootjQ.prepend(textareaSpan);
          textarea.focus();
        }
        e.preventDefault(); // doesn't work in IE\u22648, but it's a one-line fix:
        e.target.unselectable = true; // http://jsbin.com/yagekiji/1

        cursor.blink = noop;
        ctrlr.seek($(e.target), e.pageX, e.pageY).cursor.startSelection();

        rootjQ.mousemove(mousemove);
        $(e.target.ownerDocument)
          .mousemove(docmousemove)
          .mouseup(mouseup);
        // listen on document not just body to not only hear about mousemove and
        // mouseup on page outside field, but even outside page, except iframes: https://github.com/mathquill/mathquill/commit/8c50028afcffcace655d8ae2049f6e02482346c5#commitcomment-6175800
      });
    };
  });

  Controller.open(function(_) {
    _.seek = function(target, pageX, pageY) {
      var nodeId,
        cursor = this.notify('select').cursor;

      if (target) {
        nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);
        if (!nodeId) {
          var targetParent = target.parent();
          nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);
        }
      }
      var node = nodeId ? Node.byId[nodeId] : this.root;
      pray('nodeId is the id of some Node that exists', node);

      // don't clear selection until after getting node from target, in case
      // target was selection span, otherwise target will have no parent and will
      // seek from root, which is less accurate (e.g. fraction)
      cursor.clearSelection().show();

      node.seek(pageX, cursor);
      this.scrollHoriz(); // before .selectFrom when mouse-selecting, so
      // always hits no-selection case in scrollHoriz and scrolls slower
      return this;
    };
  });
  /***********************************************
   * Horizontal panning for editable fields that
   * overflow their width
   **********************************************/

  Controller.open(function(_) {
    _.scrollHoriz = function() {
      var scrollBy,
        cursor = this.cursor,
        seln = cursor.selection;
      var rootRect = this.root.jQ[0].getBoundingClientRect();
      if (!seln) {
        var x = cursor.jQ[0].getBoundingClientRect().left;
        if (x > rootRect.right - 20) scrollBy = x - (rootRect.right - 20);
        else if (x < rootRect.left + 20) scrollBy = x - (rootRect.left + 20);
        else return;
      } else {
        var rect = seln.jQ[0].getBoundingClientRect();
        var overLeft = rect.left - (rootRect.left + 20);
        var overRight = rect.right - (rootRect.right - 20);
        if (seln.ends[L] === cursor[R]) {
          if (overLeft < 0) scrollBy = overLeft;
          else if (overRight > 0) {
            if (rect.left - overRight < rootRect.left + 20) scrollBy = overLeft;
            else scrollBy = overRight;
          } else return;
        } else {
          if (overRight > 0) scrollBy = overRight;
          else if (overLeft < 0) {
            if (rect.right - overLeft > rootRect.right - 20)
              scrollBy = overRight;
            else scrollBy = overLeft;
          } else return;
        }
      }
      this.root.jQ.stop().animate({ scrollLeft: '+=' + scrollBy }, 100);
    };
  });
  /*********************************************
   * Manage the MathQuill instance's textarea
   * (as owned by the Controller)
   ********************************************/

  Controller.open(function(_) {
    Options.p.substituteTextarea = function() {
      return $('<textarea>')[0];
    };
    _.createTextarea = function() {
      var textareaSpan = (this.textareaSpan = $(
          '<span class="mq-textarea"></span>'
        )),
        textarea = this.API.__options.substituteTextarea();
      if (!textarea.nodeType) {
        throw 'substituteTextarea() must return a DOM element, got ' + textarea;
      }
      textarea = this.textarea = $(textarea).appendTo(textareaSpan);

      var ctrlr = this;
      ctrlr.cursor.selectionChanged = function() {
        ctrlr.selectionChanged();
      };
      ctrlr.container.bind('copy', function() {
        ctrlr.setTextareaSelection();
      });
    };
    _.selectionChanged = function() {
      var ctrlr = this;
      forceIERedraw(ctrlr.container[0]);

      // throttle calls to setTextareaSelection(), because setting textarea.value
      // and/or calling textarea.select() can have anomalously bad performance:
      // https://github.com/mathquill/mathquill/issues/43#issuecomment-1399080
      if (ctrlr.textareaSelectionTimeout === undefined) {
        ctrlr.textareaSelectionTimeout = setTimeout(function() {
          ctrlr.setTextareaSelection();
        });
      }
    };
    _.setTextareaSelection = function() {
      this.textareaSelectionTimeout = undefined;
      var latex = '';
      if (this.cursor.selection) {
        latex = this.cursor.selection.join('latex');
        if (this.API.__options.statelessClipboard) {
          // FIXME: like paste, only this works for math fields; should ask parent
          latex = '$' + latex + '$';
        }
      }
      this.selectFn(latex);
    };
    _.staticMathTextareaEvents = function() {
      var ctrlr = this,
        root = ctrlr.root,
        cursor = ctrlr.cursor,
        textarea = ctrlr.textarea,
        textareaSpan = ctrlr.textareaSpan;

      this.container.prepend(
        '<span class="mq-selectable">$' + ctrlr.exportLatex() + '$</span>'
      );
      ctrlr.blurred = true;
      textarea
        .bind('cut paste', false)
        .focus(function() {
          ctrlr.blurred = false;
        })
        .blur(function() {
          if (cursor.selection) cursor.selection.clear();
          setTimeout(detach); //detaching during blur explodes in WebKit
        });
      function detach() {
        textareaSpan.detach();
        ctrlr.blurred = true;
      }

      ctrlr.selectFn = function(text) {
        textarea.val(text);
        if (text) textarea.select();
      };
    };
    _.editablesTextareaEvents = function() {
      var ctrlr = this,
        root = ctrlr.root,
        cursor = ctrlr.cursor,
        textarea = ctrlr.textarea,
        textareaSpan = ctrlr.textareaSpan;

      var keyboardEventsShim = saneKeyboardEvents(textarea, this);
      this.selectFn = function(text) {
        keyboardEventsShim.select(text);
      };

      this.container.prepend(textareaSpan).on('cut', function(e) {
        if (cursor.selection) {
          setTimeout(function() {
            ctrlr.notify('edit'); // deletes selection if present
            ctrlr.notify('cut');
            cursor.parent.bubble('reflow');
          });
        }
      });

      this.focusBlurEvents();
    };
    _.typedText = function(ch) {
      if (ch === '\n') return this.handle('enter');
      var cursor = this.notify().cursor;
      cursor.parent.write(cursor, ch, cursor.show().replaceSelection());
      this.scrollHoriz();
    };
    _.paste = function(text) {
      // TODO: document `statelessClipboard` config option in README, after
      // making it work like it should, that is, in both text and math mode
      // (currently only works in math fields, so worse than pointless, it
      //  only gets in the way by \text{}-ifying pasted stuff and $-ifying
      //  cut/copied LaTeX)
      if (this.API.__options.statelessClipboard) {
        if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
          text = text.slice(1, -1);
        } else {
          text = '\\text{' + text + '}';
        }
      }
      // FIXME: this always inserts math or a TextBlock, even in a RootTextBlock
      this.writeLatex(text).cursor.show();
    };
  });
  /*************************************************
   * Abstract classes of math blocks and commands.
   ************************************************/

  /**
   * Math tree node base class.
   * Some math-tree-specific extensions to Node.
   * Both MathBlock's and MathCommand's descend from it.
   */
  var MathElement = P(Node, function(_, super_) {
    _.finalizeInsert = function(options, cursor) {
      // `cursor` param is only for
      // SupSub::contactWeld, and is deliberately only passed in by writeLatex,
      // see ea7307eb4fac77c149a11ffdf9a831df85247693
      var self = this;
      self.postOrder('finalizeTree', options);
      self.postOrder('contactWeld', cursor);

      // note: this order is important.
      // empty elements need the empty box provided by blur to
      // be present in order for their dimensions to be measured
      // correctly by 'reflow' handlers.
      self.postOrder('blur');

      self.postOrder('reflow');
      if (self[R].siblingCreated) self[R].siblingCreated(options, L);
      if (self[L].siblingCreated) self[L].siblingCreated(options, R);
      self.bubble('reflow');
    };
  });

  /**
   * Commands and operators, like subscripts, exponents, or fractions.
   * Descendant commands are organized into blocks.
   */
  var MathCommand = P(MathElement, function(_, super_) {
    _.init = function(ctrlSeq, htmlTemplate, textTemplate) {
      var cmd = this;
      super_.init.call(cmd);

      if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;
      if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;
      if (textTemplate) cmd.textTemplate = textTemplate;
    };

    // obvious methods
    _.replaces = function(replacedFragment) {
      replacedFragment.disown();
      this.replacedFragment = replacedFragment;
    };
    _.isEmpty = function() {
      return this.foldChildren(true, function(isEmpty, child) {
        return isEmpty && child.isEmpty();
      });
    };

    _.parser = function() {
      var block = latexMathParser.block;
      var self = this;

      return block.times(self.numBlocks()).map(function(blocks) {
        self.blocks = blocks;

        for (var i = 0; i < blocks.length; i += 1) {
          blocks[i].adopt(self, self.ends[R], 0);
        }

        return self;
      });
    };

    // createLeftOf(cursor) and the methods it calls
    _.createLeftOf = function(cursor) {
      var cmd = this;
      var replacedFragment = cmd.replacedFragment;

      cmd.createBlocks();
      super_.createLeftOf.call(cmd, cursor);
      if (replacedFragment) {
        replacedFragment.adopt(cmd.ends[L], 0, 0);
        replacedFragment.jQ.appendTo(cmd.ends[L].jQ);
      }
      cmd.finalizeInsert(cursor.options);
      cmd.placeCursor(cursor);
    };
    _.createBlocks = function() {
      var cmd = this,
        numBlocks = cmd.numBlocks(),
        blocks = (cmd.blocks = Array(numBlocks));

      for (var i = 0; i < numBlocks; i += 1) {
        var newBlock = (blocks[i] = MathBlock());
        newBlock.adopt(cmd, cmd.ends[R], 0);
      }
    };
    _.placeCursor = function(cursor) {
      //insert the cursor at the right end of the first empty child, searching
      //left-to-right, or if none empty, the right end child
      cursor.insAtRightEnd(
        this.foldChildren(this.ends[L], function(leftward, child) {
          return leftward.isEmpty() ? leftward : child;
        })
      );
    };

    // editability methods: called by the cursor for editing, cursor movements,
    // and selection of the MathQuill tree, these all take in a direction and
    // the cursor
    _.moveTowards = function(dir, cursor, updown) {
      var updownInto = updown && this[updown + 'Into'];
      cursor.insAtDirEnd(-dir, updownInto || this.ends[-dir]);
    };
    _.deleteTowards = function(dir, cursor) {
      cursor.startSelection();
      this.selectTowards(dir, cursor);
      cursor.select();
    };
    _.selectTowards = function(dir, cursor) {
      cursor[-dir] = this;
      cursor[dir] = this[dir];
    };
    _.selectChildren = function() {
      return Selection(this, this);
    };
    _.unselectInto = function(dir, cursor) {
      cursor.insAtDirEnd(-dir, cursor.anticursor.ancestors[this.id]);
    };
    _.seek = function(pageX, cursor) {
      function getBounds(node) {
        var bounds = {};
        bounds[L] = node.jQ.offset().left;
        bounds[R] = bounds[L] + node.jQ.outerWidth();
        return bounds;
      }

      var cmd = this;
      var cmdBounds = getBounds(cmd);

      if (pageX < cmdBounds[L]) return cursor.insLeftOf(cmd);
      if (pageX > cmdBounds[R]) return cursor.insRightOf(cmd);

      var leftLeftBound = cmdBounds[L];
      cmd.eachChild(function(block) {
        var blockBounds = getBounds(block);
        if (pageX < blockBounds[L]) {
          // closer to this block's left bound, or the bound left of that?
          if (pageX - leftLeftBound < blockBounds[L] - pageX) {
            if (block[L]) cursor.insAtRightEnd(block[L]);
            else cursor.insLeftOf(cmd);
          } else cursor.insAtLeftEnd(block);
          return false;
        } else if (pageX > blockBounds[R]) {
          if (block[R]) leftLeftBound = blockBounds[R];
          // continue to next block
          else {
            // last (rightmost) block
            // closer to this block's right bound, or the cmd's right bound?
            if (cmdBounds[R] - pageX < pageX - blockBounds[R]) {
              cursor.insRightOf(cmd);
            } else cursor.insAtRightEnd(block);
          }
        } else {
          block.seek(pageX, cursor);
          return false;
        }
      });
    };

    // methods involved in creating and cross-linking with HTML DOM nodes
    /*
      They all expect an .htmlTemplate like
        '<span>&0</span>'
      or
        '<span><span>&0</span><span>&1</span></span>'
  
      See html.test.js for more examples.
  
      Requirements:
      - For each block of the command, there must be exactly one "block content
        marker" of the form '&<number>' where <number> is the 0-based index of the
        block. (Like the LaTeX \newcommand syntax, but with a 0-based rather than
        1-based index, because JavaScript because C because Dijkstra.)
      - The block content marker must be the sole contents of the containing
        element, there can't even be surrounding whitespace, or else we can't
        guarantee sticking to within the bounds of the block content marker when
        mucking with the HTML DOM.
      - The HTML not only must be well-formed HTML (of course), but also must
        conform to the XHTML requirements on tags, specifically all tags must
        either be self-closing (like '<br/>') or come in matching pairs.
        Close tags are never optional.
  
      Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',
      your HTML template would have to have '&amp;123'.
    */
    _.numBlocks = function() {
      var matches = this.htmlTemplate.match(/&\d+/g);
      return matches ? matches.length : 0;
    };
    _.html = function() {
      // Render the entire math subtree rooted at this command, as HTML.
      // Expects .createBlocks() to have been called already, since it uses the
      // .blocks array of child blocks.
      //
      // See html.test.js for example templates and intended outputs.
      //
      // Given an .htmlTemplate as described above,
      // - insert the mathquill-command-id attribute into all top-level tags,
      //   which will be used to set this.jQ in .jQize().
      //   This is straightforward:
      //     * tokenize into tags and non-tags
      //     * loop through top-level tokens:
      //         * add #cmdId attribute macro to top-level self-closing tags
      //         * else add #cmdId attribute macro to top-level open tags
      //             * skip the matching top-level close tag and all tag pairs
      //               in between
      // - for each block content marker,
      //     + replace it with the contents of the corresponding block,
      //       rendered as HTML
      //     + insert the mathquill-block-id attribute into the containing tag
      //   This is even easier, a quick regex replace, since block tags cannot
      //   contain anything besides the block content marker.
      //
      // Two notes:
      // - The outermost loop through top-level tokens should never encounter any
      //   top-level close tags, because we should have first encountered a
      //   matching top-level open tag, all inner tags should have appeared in
      //   matching pairs and been skipped, and then we should have skipped the
      //   close tag in question.
      // - All open tags should have matching close tags, which means our inner
      //   loop should always encounter a close tag and drop nesting to 0. If
      //   a close tag is missing, the loop will continue until i >= tokens.length
      //   and token becomes undefined. This will not infinite loop, even in
      //   production without pray(), because it will then TypeError on .slice().

      var cmd = this;
      var blocks = cmd.blocks;
      var cmdId = ' mathquill-command-id="' + cmd.id + '"';
      var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);

      pray(
        'no unmatched angle brackets',
        tokens.join('') === this.htmlTemplate
      );

      // add cmdId to all top-level tags
      for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {
        // top-level self-closing tags
        if (token.slice(-2) === '/>') {
          tokens[i] = token.slice(0, -2) + cmdId + '/>';
        }
        // top-level open tags
        else if (token.charAt(0) === '<') {
          pray('not an unmatched top-level close tag', token.charAt(1) !== '/');

          tokens[i] = token.slice(0, -1) + cmdId + '>';

          // skip matching top-level close tag and all tag pairs in between
          var nesting = 1;
          do {
            i = i + 1;
            token = tokens[i];
            pray('no missing close tags', token);
            // close tags
            if (token.slice(0, 2) === '</') {
              nesting -= 1;
            }
            // non-self-closing open tags
            else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {
              nesting += 1;
            }
          } while (nesting > 0);
        }
      }
      return tokens.join('').replace(/>&(\d+)/g, function($0, $1) {
        return (
          ' mathquill-block-id="' +
          blocks[$1].id +
          '">' +
          blocks[$1].join('html')
        );
      });
    };

    // methods to export a string representation of the math tree
    _.latex = function() {
      return this.foldChildren(this.ctrlSeq, function(latex, child) {
        return latex + '{' + (child.latex() || ' ') + '}';
      });
    };
    _.textTemplate = [''];
    _.text = function() {
      var cmd = this,
        i = 0;
      return cmd.foldChildren(cmd.textTemplate[i], function(text, child) {
        i += 1;
        var child_text = child.text();
        if (
          text &&
          cmd.textTemplate[i] === '(' &&
          child_text[0] === '(' &&
          child_text.slice(-1) === ')'
        )
          return text + child_text.slice(1, -1) + cmd.textTemplate[i];
        return text + child.text() + (cmd.textTemplate[i] || '');
      });
    };
  });

  /**
   * Lightweight command without blocks or children.
   */
  var Symbol = P(MathCommand, function(_, super_) {
    _.init = function(ctrlSeq, html, text) {
      if (!text)
        text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;

      super_.init.call(this, ctrlSeq, html, [text]);
    };

    _.parser = function() {
      return Parser.succeed(this);
    };
    _.numBlocks = function() {
      return 0;
    };

    _.replaces = function(replacedFragment) {
      replacedFragment.remove();
    };
    _.createBlocks = noop;

    _.moveTowards = function(dir, cursor) {
      cursor.jQ.insDirOf(dir, this.jQ);
      cursor[-dir] = this;
      cursor[dir] = this[dir];
    };
    _.deleteTowards = function(dir, cursor) {
      cursor[dir] = this.remove()[dir];
    };
    _.seek = function(pageX, cursor) {
      // insert at whichever side the click was closer to
      if (pageX - this.jQ.offset().left < this.jQ.outerWidth() / 2)
        cursor.insLeftOf(this);
      else cursor.insRightOf(this);
    };

    _.latex = function() {
      return this.ctrlSeq;
    };
    _.text = function() {
      return this.textTemplate;
    };
    _.placeCursor = noop;
    _.isEmpty = function() {
      return true;
    };
  });
  var VanillaSymbol = P(Symbol, function(_, super_) {
    _.init = function(ch, html) {
      super_.init.call(this, ch, '<span>' + (html || ch) + '</span>');
    };
  });
  var BinaryOperator = P(Symbol, function(_, super_) {
    _.init = function(ctrlSeq, html, text) {
      super_.init.call(
        this,
        ctrlSeq,
        '<span class="mq-binary-operator">' + html + '</span>',
        text
      );
    };
  });

  /**
   * Children and parent of MathCommand's. Basically partitions all the
   * symbols and operators that descend (in the Math DOM tree) from
   * ancestor operators.
   */
  var MathBlock = P(MathElement, function(_, super_) {
    _.join = function(methodName) {
      return this.foldChildren('', function(fold, child) {
        return fold + child[methodName]();
      });
    };
    _.html = function() {
      return this.join('html');
    };
    _.latex = function() {
      return this.join('latex');
    };
    _.text = function() {
      return this.ends[L] === this.ends[R]
        ? this.ends[L].text()
        : '(' + this.join('text') + ')';
    };

    _.keystroke = function(key, e, ctrlr) {
      if (
        ctrlr.API.__options.spaceBehavesLikeTab &&
        (key === 'Spacebar' || key === 'Shift-Spacebar')
      ) {
        e.preventDefault();
        ctrlr.escapeDir(key === 'Shift-Spacebar' ? L : R, key, e);
        return;
      }
      return super_.keystroke.apply(this, arguments);
    };

    // editability methods: called by the cursor for editing, cursor movements,
    // and selection of the MathQuill tree, these all take in a direction and
    // the cursor
    _.moveOutOf = function(dir, cursor, updown) {
      var updownInto = updown && this.parent[updown + 'Into'];
      if (!updownInto && this[dir]) cursor.insAtDirEnd(-dir, this[dir]);
      else cursor.insDirOf(dir, this.parent);
    };
    _.selectOutOf = function(dir, cursor) {
      cursor.insDirOf(dir, this.parent);
    };
    _.deleteOutOf = function(dir, cursor) {
      cursor.unwrapGramp();
    };
    _.seek = function(pageX, cursor) {
      var node = this.ends[R];
      if (!node || node.jQ.offset().left + node.jQ.outerWidth() < pageX) {
        return cursor.insAtRightEnd(this);
      }
      if (pageX < this.ends[L].jQ.offset().left)
        return cursor.insAtLeftEnd(this);
      while (pageX < node.jQ.offset().left) node = node[L];
      return node.seek(pageX, cursor);
    };
    _.write = function(cursor, ch, replacedFragment) {
      var cmd;
      if (ch.match(/^[a-eg-zA-Z]$/))
        //exclude f because want florin
        cmd = Letter(ch);
      else if ((cmd = CharCmds[ch] || LatexCmds[ch])) cmd = cmd(ch);
      else cmd = VanillaSymbol(ch);

      if (replacedFragment) cmd.replaces(replacedFragment);

      cmd.createLeftOf(cursor);
    };

    _.focus = function() {
      this.jQ.addClass('mq-hasCursor');
      this.jQ.removeClass('mq-empty');

      return this;
    };
    _.blur = function() {
      this.jQ.removeClass('mq-hasCursor');
      if (this.isEmpty()) this.jQ.addClass('mq-empty');

      return this;
    };
  });

  var RootMathBlock = P(MathBlock, RootBlockMixin);
  MathQuill.MathField = APIFnFor(
    P(EditableField, function(_, super_) {
      _.init = function(el, opts) {
        el.addClass('mq-editable-field mq-math-mode');
        this.initRootAndEvents(RootMathBlock(), el, opts);
      };
    })
  );
  /*************************************************
   * Abstract classes of text blocks
   ************************************************/

  /**
   * Blocks of plain text, with one or two TextPiece's as children.
   * Represents flat strings of typically serif-font Roman characters, as
   * opposed to hierchical, nested, tree-structured math.
   * Wraps a single HTMLSpanElement.
   */
  var TextBlock = P(Node, function(_, super_) {
    _.ctrlSeq = '\\text';

    _.replaces = function(replacedText) {
      if (replacedText instanceof Fragment)
        this.replacedText = replacedText.remove().jQ.text();
      else if (typeof replacedText === 'string')
        this.replacedText = replacedText;
    };

    _.jQadd = function(jQ) {
      super_.jQadd.call(this, jQ);
      if (this.ends[L]) this.ends[L].jQadd(this.jQ[0].firstChild);
    };

    _.createLeftOf = function(cursor) {
      var textBlock = this;
      super_.createLeftOf.call(this, cursor);

      if (textBlock[R].siblingCreated)
        textBlock[R].siblingCreated(cursor.options, L);
      if (textBlock[L].siblingCreated)
        textBlock[L].siblingCreated(cursor.options, R);
      textBlock.bubble('reflow');

      cursor.insAtRightEnd(textBlock);

      if (textBlock.replacedText)
        for (var i = 0; i < textBlock.replacedText.length; i += 1)
          textBlock.write(cursor, textBlock.replacedText.charAt(i));
    };

    _.parser = function() {
      var textBlock = this;

      // TODO: correctly parse text mode
      var string = Parser.string;
      var regex = Parser.regex;
      var optWhitespace = Parser.optWhitespace;
      return optWhitespace
        .then(string('{'))
        .then(regex(/^[^}]*/))
        .skip(string('}'))
        .map(function(text) {
          // TODO: is this the correct behavior when parsing
          // the latex \text{} ?  This violates the requirement that
          // the text contents are always nonempty.  Should we just
          // disown the parent node instead?
          TextPiece(text).adopt(textBlock, 0, 0);
          return textBlock;
        });
    };

    _.textContents = function() {
      return this.foldChildren('', function(text, child) {
        return text + child.text;
      });
    };
    _.text = function() {
      return '"' + this.textContents() + '"';
    };
    _.latex = function() {
      return '\\text{' + this.textContents() + '}';
    };
    _.html = function() {
      return (
        '<span class="mq-text-mode" mathquill-command-id=' +
        this.id +
        '>' +
        this.textContents() +
        '</span>'
      );
    };

    // editability methods: called by the cursor for editing, cursor movements,
    // and selection of the MathQuill tree, these all take in a direction and
    // the cursor
    _.moveTowards = function(dir, cursor) {
      cursor.insAtDirEnd(-dir, this);
    };
    _.moveOutOf = function(dir, cursor) {
      cursor.insDirOf(dir, this);
    };
    _.unselectInto = _.moveTowards;

    // TODO: make these methods part of a shared mixin or something.
    _.selectTowards = MathCommand.prototype.selectTowards;
    _.deleteTowards = MathCommand.prototype.deleteTowards;

    _.selectOutOf = function(dir, cursor) {
      cursor.insDirOf(dir, this);
    };
    _.deleteOutOf = function(dir, cursor) {
      // backspace and delete at ends of block don't unwrap
      if (this.isEmpty()) cursor.insRightOf(this);
    };
    _.write = function(cursor, ch, replacedFragment) {
      if (replacedFragment) replacedFragment.remove();

      if (ch !== '$') {
        if (!cursor[L]) TextPiece(ch).createLeftOf(cursor);
        else cursor[L].appendText(ch);
      } else if (this.isEmpty()) {
        cursor.insRightOf(this);
        VanillaSymbol('\\$', '$').createLeftOf(cursor);
      } else if (!cursor[R]) cursor.insRightOf(this);
      else if (!cursor[L]) cursor.insLeftOf(this);
      else {
        // split apart
        var leftBlock = TextBlock();
        var leftPc = this.ends[L];
        leftPc.disown();
        leftPc.adopt(leftBlock, 0, 0);

        cursor.insLeftOf(this);
        super_.createLeftOf.call(leftBlock, cursor);
      }
    };

    _.seek = function(pageX, cursor) {
      cursor.hide();
      var textPc = fuseChildren(this),
        newTextPc;

      // insert cursor at approx position in DOMTextNode
      var avgChWidth = this.jQ.width() / this.text.length;
      var approxPosition = Math.round(
        (pageX - this.jQ.offset().left) / avgChWidth
      );
      if (approxPosition <= 0) cursor.insAtLeftEnd(this);
      else if (approxPosition >= textPc.text.length) cursor.insAtRightEnd(this);
      else cursor.insLeftOf(textPc.splitRight(approxPosition));

      // move towards mousedown (pageX)
      var displ = pageX - cursor.show().offset().left; // displacement
      var dir = displ && displ < 0 ? L : R;
      var prevDispl = dir;
      // displ * prevDispl > 0 iff displacement direction === previous direction
      while (cursor[dir] && displ * prevDispl > 0) {
        cursor[dir].moveTowards(dir, cursor);
        prevDispl = displ;
        displ = pageX - cursor.offset().left;
      }
      if (dir * displ < -dir * prevDispl)
        cursor[-dir].moveTowards(-dir, cursor);

      if (!cursor.anticursor) {
        // about to start mouse-selecting, the anticursor is gonna get put here
        this.anticursorPosition = cursor[L] && cursor[L].text.length;
        // ^ get it? 'cos if there's no cursor[L], it's 0... I'm a terrible person.
      } else if (cursor.anticursor.parent === this) {
        // mouse-selecting within this TextBlock, re-insert the anticursor
        var cursorPosition = cursor[L] && cursor[L].text.length;
        if (this.anticursorPosition === cursorPosition) {
          cursor.anticursor = Point.copy(cursor);
        } else {
          if (this.anticursorPosition < cursorPosition) {
            newTextPc = cursor[L].splitRight(this.anticursorPosition);
            cursor[L] = newTextPc;
          } else {
            newTextPc = cursor[R].splitRight(
              this.anticursorPosition - cursorPosition
            );
          }
          cursor.anticursor = Point(this, newTextPc[L], newTextPc);
        }
      }
    };

    _.blur = function() {
      MathBlock.prototype.blur.call(this);
      fuseChildren(this);
    };

    function fuseChildren(self) {
      self.jQ[0].normalize();

      var textPcDom = self.jQ[0].firstChild;
      var textPc = TextPiece(textPcDom.data);
      textPc.jQadd(textPcDom);

      self.children().disown();
      return textPc.adopt(self, 0, 0);
    }

    _.focus = MathBlock.prototype.focus;
  });

  /**
   * Piece of plain text, with a TextBlock as a parent and no children.
   * Wraps a single DOMTextNode.
   * For convenience, has a .text property that's just a JavaScript string
   * mirroring the text contents of the DOMTextNode.
   * Text contents must always be nonempty.
   */
  var TextPiece = P(Node, function(_, super_) {
    _.init = function(text) {
      super_.init.call(this);
      this.text = text;
    };
    _.jQadd = function(dom) {
      this.dom = dom;
      this.jQ = $(dom);
    };
    _.jQize = function() {
      return this.jQadd(document.createTextNode(this.text));
    };
    _.appendText = function(text) {
      this.text += text;
      this.dom.appendData(text);
    };
    _.prependText = function(text) {
      this.text = text + this.text;
      this.dom.insertData(0, text);
    };
    _.insTextAtDirEnd = function(text, dir) {
      prayDirection(dir);
      if (dir === R) this.appendText(text);
      else this.prependText(text);
    };
    _.splitRight = function(i) {
      var newPc = TextPiece(this.text.slice(i)).adopt(
        this.parent,
        this,
        this[R]
      );
      newPc.jQadd(this.dom.splitText(i));
      this.text = this.text.slice(0, i);
      return newPc;
    };

    function endChar(dir, text) {
      return text.charAt(dir === L ? 0 : -1 + text.length);
    }

    _.moveTowards = function(dir, cursor) {
      prayDirection(dir);

      var ch = endChar(-dir, this.text);

      var from = this[-dir];
      if (from) from.insTextAtDirEnd(ch, dir);
      else TextPiece(ch).createDir(-dir, cursor);

      return this.deleteTowards(dir, cursor);
    };

    _.latex = function() {
      return this.text;
    };

    _.deleteTowards = function(dir, cursor) {
      if (this.text.length > 1) {
        if (dir === R) {
          this.dom.deleteData(0, 1);
          this.text = this.text.slice(1);
        } else {
          // note that the order of these 2 lines is annoyingly important
          // (the second line mutates this.text.length)
          this.dom.deleteData(-1 + this.text.length, 1);
          this.text = this.text.slice(0, -1);
        }
      } else {
        this.remove();
        this.jQ.remove();
        cursor[dir] = this[dir];
      }
    };

    _.selectTowards = function(dir, cursor) {
      prayDirection(dir);
      var anticursor = cursor.anticursor,
        newPc;

      var ch = endChar(-dir, this.text);

      if (anticursor[dir] === this) {
        newPc = TextPiece(ch).createDir(dir, cursor);
        anticursor[dir] = newPc;
        cursor.insDirOf(dir, newPc);
      } else {
        var from = this[-dir];
        if (from) from.insTextAtDirEnd(ch, dir);
        else {
          newPc = TextPiece(ch).createDir(-dir, cursor);
          newPc.jQ.insDirOf(-dir, cursor.selection.jQ);
        }

        if (this.text.length === 1 && anticursor[-dir] === this) {
          anticursor[-dir] = this[-dir]; // `this` will be removed in deleteTowards
        }
      }

      return this.deleteTowards(dir, cursor);
    };
  });

  CharCmds.$ = LatexCmds.text = LatexCmds.textnormal = LatexCmds.textrm = LatexCmds.textup = LatexCmds.textmd = TextBlock;

  function makeTextBlock(latex, tagName, attrs) {
    return P(TextBlock, {
      ctrlSeq: latex,
      htmlTemplate: '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>',
    });
  }

  LatexCmds.em = LatexCmds.italic = LatexCmds.italics = LatexCmds.emph = LatexCmds.textit = LatexCmds.textsl = makeTextBlock(
    '\\textit',
    'i',
    'class="mq-text-mode"'
  );
  LatexCmds.strong = LatexCmds.bold = LatexCmds.textbf = makeTextBlock(
    '\\textbf',
    'b',
    'class="mq-text-mode"'
  );
  LatexCmds.sf = LatexCmds.textsf = makeTextBlock(
    '\\textsf',
    'span',
    'class="mq-sans-serif mq-text-mode"'
  );
  LatexCmds.tt = LatexCmds.texttt = makeTextBlock(
    '\\texttt',
    'span',
    'class="mq-monospace mq-text-mode"'
  );
  LatexCmds.textsc = makeTextBlock(
    '\\textsc',
    'span',
    'style="font-variant:small-caps" class="mq-text-mode"'
  );
  LatexCmds.uppercase = makeTextBlock(
    '\\uppercase',
    'span',
    'style="text-transform:uppercase" class="mq-text-mode"'
  );
  LatexCmds.lowercase = makeTextBlock(
    '\\lowercase',
    'span',
    'style="text-transform:lowercase" class="mq-text-mode"'
  );

  var RootMathCommand = P(MathCommand, function(_, super_) {
    _.init = function(cursor) {
      super_.init.call(this, '$');
      this.cursor = cursor;
    };
    _.htmlTemplate = '<span class="mq-math-mode">&0</span>';
    _.createBlocks = function() {
      super_.createBlocks.call(this);

      this.ends[L].cursor = this.cursor;
      this.ends[L].write = function(cursor, ch, replacedFragment) {
        if (ch !== '$')
          MathBlock.prototype.write.call(this, cursor, ch, replacedFragment);
        else if (this.isEmpty()) {
          cursor.insRightOf(this.parent);
          this.parent.deleteTowards(dir, cursor);
          VanillaSymbol('\\$', '$').createLeftOf(cursor.show());
        } else if (!cursor[R]) cursor.insRightOf(this.parent);
        else if (!cursor[L]) cursor.insLeftOf(this.parent);
        else MathBlock.prototype.write.call(this, cursor, ch, replacedFragment);
      };
    };
    _.latex = function() {
      return '$' + this.ends[L].latex() + '$';
    };
  });

  var RootTextBlock = P(RootMathBlock, function(_, super_) {
    _.keystroke = function(key) {
      if (key === 'Spacebar' || key === 'Shift-Spacebar') return;
      return super_.keystroke.apply(this, arguments);
    };
    _.write = function(cursor, ch, replacedFragment) {
      if (replacedFragment) replacedFragment.remove();
      if (ch === '$') RootMathCommand(cursor).createLeftOf(cursor);
      else {
        var html;
        if (ch === '<') html = '&lt;';
        else if (ch === '>') html = '&gt;';
        VanillaSymbol(ch, html).createLeftOf(cursor);
      }
    };
  });
  MathQuill.TextField = APIFnFor(
    P(EditableField, function(_) {
      _.init = function(el) {
        el.addClass('mq-editable-field mq-text-mode');
        this.initRootAndEvents(RootTextBlock(), el);
      };
      _.latex = function(latex) {
        if (arguments.length > 0) {
          this.__controller.renderLatexText(latex);
          if (this.__controller.blurred)
            this.__controller.cursor.hide().parent.blur();
          return this;
        }
        return this.__controller.exportLatex();
      };
    })
  );
  /****************************************
   * Input box to type backslash commands
   ***************************************/

  var LatexCommandInput = (CharCmds['\\'] = P(MathCommand, function(_, super_) {
    _.ctrlSeq = '\\';
    _.replaces = function(replacedFragment) {
      this._replacedFragment = replacedFragment.disown();
      this.isEmpty = function() {
        return false;
      };
    };
    _.htmlTemplate =
      '<span class="mq-latex-command-input mq-non-leaf">\\<span>&0</span></span>';
    _.textTemplate = ['\\'];
    _.createBlocks = function() {
      super_.createBlocks.call(this);
      this.ends[L].focus = function() {
        this.parent.jQ.addClass('mq-hasCursor');
        if (this.isEmpty()) this.parent.jQ.removeClass('mq-empty');

        return this;
      };
      this.ends[L].blur = function() {
        this.parent.jQ.removeClass('mq-hasCursor');
        if (this.isEmpty()) this.parent.jQ.addClass('mq-empty');

        return this;
      };
      this.ends[L].write = function(cursor, ch, replacedFragment) {
        if (replacedFragment) replacedFragment.remove();

        if (ch.match(/[a-z]/i)) VanillaSymbol(ch).createLeftOf(cursor);
        else {
          this.parent.renderCommand(cursor);
          if (ch !== '\\' || !this.isEmpty())
            this.parent.parent.write(cursor, ch);
        }
      };
      this.ends[L].keystroke = function(key, e, ctrlr) {
        if (key === 'Tab' || key === 'Enter' || key === 'Spacebar') {
          this.parent.renderCommand(ctrlr.cursor);
          e.preventDefault();
          return;
        }
        return super_.keystroke.apply(this, arguments);
      };
    };
    _.createLeftOf = function(cursor) {
      super_.createLeftOf.call(this, cursor);

      if (this._replacedFragment) {
        var el = this.jQ[0];
        this.jQ = this._replacedFragment.jQ
          .addClass('mq-blur')
          .bind(
            'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?
            function(e) {
              $((e.target = el)).trigger(e);
              return false;
            }
          )
          .insertBefore(this.jQ)
          .add(this.jQ);
      }
    };
    _.latex = function() {
      return '\\' + this.ends[L].latex() + ' ';
    };
    _.renderCommand = function(cursor) {
      this.jQ = this.jQ.last();
      this.remove();
      if (this[R]) {
        cursor.insLeftOf(this[R]);
      } else {
        cursor.insAtRightEnd(this.parent);
      }

      var latex = this.ends[L].latex();
      if (!latex) latex = ' ';
      var cmd = LatexCmds[latex];
      if (cmd) {
        cmd = cmd(latex);
        if (this._replacedFragment) cmd.replaces(this._replacedFragment);
        cmd.createLeftOf(cursor);
      } else {
        cmd = TextBlock();
        cmd.replaces(latex);
        cmd.createLeftOf(cursor);
        cursor.insRightOf(cmd);
        if (this._replacedFragment) this._replacedFragment.remove();
      }
    };
  }));

  /************************************
   * Symbols for Advanced Mathematics
   ***********************************/

  LatexCmds.notin = LatexCmds.cong = LatexCmds.equiv = LatexCmds.oplus = LatexCmds.otimes = P(
    BinaryOperator,
    function(_, super_) {
      _.init = function(latex) {
        super_.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
      };
    }
  );

  LatexCmds['\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(
    BinaryOperator,
    '\\ne ',
    '&#x2260;'
  );

  LatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast = bind(
    BinaryOperator,
    '\\ast ',
    '&#x2217;'
  );
  //case 'there4 = // a special exception for this one, perhaps?
  LatexCmds.therefor = LatexCmds.therefore = bind(
    BinaryOperator,
    '\\therefore ',
    '&#x2234;'
  );

  LatexCmds.cuz = LatexCmds.because = bind( // l33t
    BinaryOperator,
    '\\because ',
    '&#8757;'
  );

  LatexCmds.prop = LatexCmds.propto = bind(
    BinaryOperator,
    '\\propto ',
    '&#x221D;'
  );

  LatexCmds['\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(
    BinaryOperator,
    '\\approx ',
    '&#x2248;'
  );

  LatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator, '\\in ', '&#x2208;');

  LatexCmds.ni = LatexCmds.contains = bind(BinaryOperator, '\\ni ', '&#x220B;');

  LatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain = bind(
    BinaryOperator,
    '\\not\\ni ',
    '&#8716;'
  );

  LatexCmds.sub = LatexCmds.subset = bind(
    BinaryOperator,
    '\\subset ',
    '&#x2282;'
  );

  LatexCmds.sup = LatexCmds.supset = LatexCmds.superset = bind(
    BinaryOperator,
    '\\supset ',
    '&#x2283;'
  );

  LatexCmds.nsub = LatexCmds.notsub = LatexCmds.nsubset = LatexCmds.notsubset = bind(
    BinaryOperator,
    '\\not\\subset ',
    '&#8836;'
  );

  LatexCmds.nsup = LatexCmds.notsup = LatexCmds.nsupset = LatexCmds.notsupset = LatexCmds.nsuperset = LatexCmds.notsuperset = bind(
    BinaryOperator,
    '\\not\\supset ',
    '&#8837;'
  );

  LatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq = bind(
    BinaryOperator,
    '\\subseteq ',
    '&#x2286;'
  );

  LatexCmds.supe = LatexCmds.supeq = LatexCmds.supsete = LatexCmds.supseteq = LatexCmds.supersete = LatexCmds.superseteq = bind(
    BinaryOperator,
    '\\supseteq ',
    '&#x2287;'
  );

  LatexCmds.nsube = LatexCmds.nsubeq = LatexCmds.notsube = LatexCmds.notsubeq = LatexCmds.nsubsete = LatexCmds.nsubseteq = LatexCmds.notsubsete = LatexCmds.notsubseteq = bind(
    BinaryOperator,
    '\\not\\subseteq ',
    '&#8840;'
  );

  LatexCmds.nsupe = LatexCmds.nsupeq = LatexCmds.notsupe = LatexCmds.notsupeq = LatexCmds.nsupsete = LatexCmds.nsupseteq = LatexCmds.notsupsete = LatexCmds.notsupseteq = LatexCmds.nsupersete = LatexCmds.nsuperseteq = LatexCmds.notsupersete = LatexCmds.notsuperseteq = bind(
    BinaryOperator,
    '\\not\\supseteq ',
    '&#8841;'
  );

  //the canonical sets of numbers
  LatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals = bind(
    VanillaSymbol,
    '\\mathbb{N}',
    '&#8469;'
  );

  LatexCmds.P = LatexCmds.primes = LatexCmds.Primes = LatexCmds.projective = LatexCmds.Projective = LatexCmds.probability = LatexCmds.Probability = bind(
    VanillaSymbol,
    '\\mathbb{P}',
    '&#8473;'
  );

  LatexCmds.Z = LatexCmds.integers = LatexCmds.Integers = bind(
    VanillaSymbol,
    '\\mathbb{Z}',
    '&#8484;'
  );

  LatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals = bind(
    VanillaSymbol,
    '\\mathbb{Q}',
    '&#8474;'
  );

  LatexCmds.R = LatexCmds.reals = LatexCmds.Reals = bind(
    VanillaSymbol,
    '\\mathbb{R}',
    '&#8477;'
  );

  LatexCmds.C = LatexCmds.complex = LatexCmds.Complex = LatexCmds.complexes = LatexCmds.Complexes = LatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane = bind(
    VanillaSymbol,
    '\\mathbb{C}',
    '&#8450;'
  );

  LatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions = bind(
    VanillaSymbol,
    '\\mathbb{H}',
    '&#8461;'
  );

  //spacing
  LatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol, '\\quad ', '    ');
  LatexCmds.qquad = bind(VanillaSymbol, '\\qquad ', '        ');
  /* spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow
  case ',':
    return VanillaSymbol('\\, ',' ');
  case ':':
    return VanillaSymbol('\\: ','  ');
  case ';':
    return VanillaSymbol('\\; ','   ');
  case '!':
    return Symbol('\\! ','<span style="margin-right:-.2em"></span>');
  */

  //binary operators
  LatexCmds.diamond = bind(VanillaSymbol, '\\diamond ', '&#9671;');
  LatexCmds.bigtriangleup = bind(VanillaSymbol, '\\bigtriangleup ', '&#9651;');
  LatexCmds.ominus = bind(VanillaSymbol, '\\ominus ', '&#8854;');
  LatexCmds.uplus = bind(VanillaSymbol, '\\uplus ', '&#8846;');
  LatexCmds.bigtriangledown = bind(
    VanillaSymbol,
    '\\bigtriangledown ',
    '&#9661;'
  );
  LatexCmds.sqcap = bind(VanillaSymbol, '\\sqcap ', '&#8851;');
  LatexCmds.triangleleft = bind(VanillaSymbol, '\\triangleleft ', '&#8882;');
  LatexCmds.sqcup = bind(VanillaSymbol, '\\sqcup ', '&#8852;');
  LatexCmds.triangleright = bind(VanillaSymbol, '\\triangleright ', '&#8883;');
  LatexCmds.odot = bind(VanillaSymbol, '\\odot ', '&#8857;');
  LatexCmds.bigcirc = bind(VanillaSymbol, '\\bigcirc ', '&#9711;');
  LatexCmds.dagger = bind(VanillaSymbol, '\\dagger ', '&#0134;');
  LatexCmds.ddagger = bind(VanillaSymbol, '\\ddagger ', '&#135;');
  LatexCmds.wr = bind(VanillaSymbol, '\\wr ', '&#8768;');
  LatexCmds.amalg = bind(VanillaSymbol, '\\amalg ', '&#8720;');

  //relationship symbols
  LatexCmds.models = bind(VanillaSymbol, '\\models ', '&#8872;');
  LatexCmds.prec = bind(VanillaSymbol, '\\prec ', '&#8826;');
  LatexCmds.succ = bind(VanillaSymbol, '\\succ ', '&#8827;');
  LatexCmds.preceq = bind(VanillaSymbol, '\\preceq ', '&#8828;');
  LatexCmds.succeq = bind(VanillaSymbol, '\\succeq ', '&#8829;');
  LatexCmds.simeq = bind(VanillaSymbol, '\\simeq ', '&#8771;');
  LatexCmds.mid = bind(VanillaSymbol, '\\mid ', '&#8739;');
  LatexCmds.ll = bind(VanillaSymbol, '\\ll ', '&#8810;');
  LatexCmds.gg = bind(VanillaSymbol, '\\gg ', '&#8811;');
  LatexCmds.parallel = bind(VanillaSymbol, '\\parallel ', '&#8741;');
  LatexCmds.bowtie = bind(VanillaSymbol, '\\bowtie ', '&#8904;');
  LatexCmds.sqsubset = bind(VanillaSymbol, '\\sqsubset ', '&#8847;');
  LatexCmds.sqsupset = bind(VanillaSymbol, '\\sqsupset ', '&#8848;');
  LatexCmds.smile = bind(VanillaSymbol, '\\smile ', '&#8995;');
  LatexCmds.sqsubseteq = bind(VanillaSymbol, '\\sqsubseteq ', '&#8849;');
  LatexCmds.sqsupseteq = bind(VanillaSymbol, '\\sqsupseteq ', '&#8850;');
  LatexCmds.doteq = bind(VanillaSymbol, '\\doteq ', '&#8784;');
  LatexCmds.frown = bind(VanillaSymbol, '\\frown ', '&#8994;');
  LatexCmds.vdash = bind(VanillaSymbol, '\\vdash ', '&#8870;');
  LatexCmds.dashv = bind(VanillaSymbol, '\\dashv ', '&#8867;');

  //arrows
  LatexCmds.longleftarrow = bind(VanillaSymbol, '\\longleftarrow ', '&#8592;');
  LatexCmds.longrightarrow = bind(
    VanillaSymbol,
    '\\longrightarrow ',
    '&#8594;'
  );
  LatexCmds.Longleftarrow = bind(VanillaSymbol, '\\Longleftarrow ', '&#8656;');
  LatexCmds.Longrightarrow = bind(
    VanillaSymbol,
    '\\Longrightarrow ',
    '&#8658;'
  );
  LatexCmds.longleftrightarrow = bind(
    VanillaSymbol,
    '\\longleftrightarrow ',
    '&#8596;'
  );
  LatexCmds.updownarrow = bind(VanillaSymbol, '\\updownarrow ', '&#8597;');
  LatexCmds.Longleftrightarrow = bind(
    VanillaSymbol,
    '\\Longleftrightarrow ',
    '&#8660;'
  );
  LatexCmds.Updownarrow = bind(VanillaSymbol, '\\Updownarrow ', '&#8661;');
  LatexCmds.mapsto = bind(VanillaSymbol, '\\mapsto ', '&#8614;');
  LatexCmds.nearrow = bind(VanillaSymbol, '\\nearrow ', '&#8599;');
  LatexCmds.hookleftarrow = bind(VanillaSymbol, '\\hookleftarrow ', '&#8617;');
  LatexCmds.hookrightarrow = bind(
    VanillaSymbol,
    '\\hookrightarrow ',
    '&#8618;'
  );
  LatexCmds.searrow = bind(VanillaSymbol, '\\searrow ', '&#8600;');
  LatexCmds.leftharpoonup = bind(VanillaSymbol, '\\leftharpoonup ', '&#8636;');
  LatexCmds.rightharpoonup = bind(
    VanillaSymbol,
    '\\rightharpoonup ',
    '&#8640;'
  );
  LatexCmds.swarrow = bind(VanillaSymbol, '\\swarrow ', '&#8601;');
  LatexCmds.leftharpoondown = bind(
    VanillaSymbol,
    '\\leftharpoondown ',
    '&#8637;'
  );
  LatexCmds.rightharpoondown = bind(
    VanillaSymbol,
    '\\rightharpoondown ',
    '&#8641;'
  );
  LatexCmds.nwarrow = bind(VanillaSymbol, '\\nwarrow ', '&#8598;');

  //Misc
  LatexCmds.ldots = bind(VanillaSymbol, '\\ldots ', '&#8230;');
  LatexCmds.cdots = bind(VanillaSymbol, '\\cdots ', '&#8943;');
  LatexCmds.vdots = bind(VanillaSymbol, '\\vdots ', '&#8942;');
  LatexCmds.ddots = bind(VanillaSymbol, '\\ddots ', '&#8944;');
  LatexCmds.surd = bind(VanillaSymbol, '\\surd ', '&#8730;');
  LatexCmds.triangle = bind(VanillaSymbol, '\\triangle ', '&#9653;');
  LatexCmds.ell = bind(VanillaSymbol, '\\ell ', '&#8467;');
  LatexCmds.top = bind(VanillaSymbol, '\\top ', '&#8868;');
  LatexCmds.flat = bind(VanillaSymbol, '\\flat ', '&#9837;');
  LatexCmds.natural = bind(VanillaSymbol, '\\natural ', '&#9838;');
  LatexCmds.sharp = bind(VanillaSymbol, '\\sharp ', '&#9839;');
  LatexCmds.wp = bind(VanillaSymbol, '\\wp ', '&#8472;');
  LatexCmds.bot = bind(VanillaSymbol, '\\bot ', '&#8869;');
  LatexCmds.clubsuit = bind(VanillaSymbol, '\\clubsuit ', '&#9827;');
  LatexCmds.diamondsuit = bind(VanillaSymbol, '\\diamondsuit ', '&#9826;');
  LatexCmds.heartsuit = bind(VanillaSymbol, '\\heartsuit ', '&#9825;');
  LatexCmds.spadesuit = bind(VanillaSymbol, '\\spadesuit ', '&#9824;');

  //variable-sized
  LatexCmds.oint = bind(VanillaSymbol, '\\oint ', '&#8750;');
  LatexCmds.bigcap = bind(VanillaSymbol, '\\bigcap ', '&#8745;');
  LatexCmds.bigcup = bind(VanillaSymbol, '\\bigcup ', '&#8746;');
  LatexCmds.bigsqcup = bind(VanillaSymbol, '\\bigsqcup ', '&#8852;');
  LatexCmds.bigvee = bind(VanillaSymbol, '\\bigvee ', '&#8744;');
  LatexCmds.bigwedge = bind(VanillaSymbol, '\\bigwedge ', '&#8743;');
  LatexCmds.bigodot = bind(VanillaSymbol, '\\bigodot ', '&#8857;');
  LatexCmds.bigotimes = bind(VanillaSymbol, '\\bigotimes ', '&#8855;');
  LatexCmds.bigoplus = bind(VanillaSymbol, '\\bigoplus ', '&#8853;');
  LatexCmds.biguplus = bind(VanillaSymbol, '\\biguplus ', '&#8846;');

  //delimiters
  LatexCmds.lfloor = bind(VanillaSymbol, '\\lfloor ', '&#8970;');
  LatexCmds.rfloor = bind(VanillaSymbol, '\\rfloor ', '&#8971;');
  LatexCmds.lceil = bind(VanillaSymbol, '\\lceil ', '&#8968;');
  LatexCmds.rceil = bind(VanillaSymbol, '\\rceil ', '&#8969;');
  LatexCmds.opencurlybrace = LatexCmds.lbrace = bind(
    VanillaSymbol,
    '\\lbrace ',
    '{'
  );
  LatexCmds.closecurlybrace = LatexCmds.rbrace = bind(
    VanillaSymbol,
    '\\rbrace ',
    '}'
  );

  //various symbols

  LatexCmds['\u222b'] = LatexCmds['int'] = LatexCmds.integral = bind(
    Symbol,
    '\\int ',
    '<big>&#x222B;</big>'
  );

  LatexCmds.caret = bind(VanillaSymbol, '\\text{^}', '^');
  LatexCmds.underscore = bind(VanillaSymbol, '\\_', '_');

  LatexCmds.slash = bind(VanillaSymbol, '/');
  LatexCmds.vert = bind(VanillaSymbol, '|');
  LatexCmds.perp = LatexCmds.perpendicular = bind(
    VanillaSymbol,
    '\\perp ',
    '&#x22A5;'
  );
  LatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol, '\\nabla ', '&#x2207;');
  LatexCmds.hbar = bind(VanillaSymbol, '\\hbar ', '&#8463;');

  LatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom = bind(
    VanillaSymbol,
    '\\text\\AA ',
    '&#8491;'
  );

  LatexCmds.ring = LatexCmds.circ = LatexCmds.circle = bind(
    VanillaSymbol,
    '\\circ ',
    '&#8728;'
  );

  LatexCmds.bull = LatexCmds.bullet = bind(
    VanillaSymbol,
    '\\bullet ',
    '&#x2022;'
  );

  LatexCmds.setminus = LatexCmds.smallsetminus = bind(
    VanillaSymbol,
    '\\setminus ',
    '&#8726;'
  );

  LatexCmds.not = LatexCmds['\u00ac'] = LatexCmds.neg = bind( //bind(Symbol,'\\not ','<span class="not">/</span>');
    VanillaSymbol,
    '\\neg ',
    '&#x00AC;'
  );

  LatexCmds[
    '\u2026'
  ] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip = LatexCmds.ellipsis = LatexCmds.hellipsis = bind(
    VanillaSymbol,
    '\\dots ',
    '&#x2026;'
  );

  LatexCmds.converges = LatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow = bind(
    VanillaSymbol,
    '\\downarrow ',
    '&#x2193;'
  );

  LatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow = bind(
    VanillaSymbol,
    '\\Downarrow ',
    '&#x21D3;'
  );

  LatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow = bind(
    VanillaSymbol,
    '\\uparrow ',
    '&#x2191;'
  );

  LatexCmds.uArr = LatexCmds.Uparrow = bind(
    VanillaSymbol,
    '\\Uparrow ',
    '&#x21D1;'
  );

  LatexCmds.to = bind(BinaryOperator, '\\to ', '&#x2192;');

  LatexCmds.rarr = LatexCmds.rightarrow = bind(
    VanillaSymbol,
    '\\rightarrow ',
    '&#x2192;'
  );

  LatexCmds.implies = bind(BinaryOperator, '\\Rightarrow ', '&#x21D2;');

  LatexCmds.rArr = LatexCmds.Rightarrow = bind(
    VanillaSymbol,
    '\\Rightarrow ',
    '&#x21D2;'
  );

  LatexCmds.gets = bind(BinaryOperator, '\\gets ', '&#x2190;');

  LatexCmds.larr = LatexCmds.leftarrow = bind(
    VanillaSymbol,
    '\\leftarrow ',
    '&#x2190;'
  );

  LatexCmds.impliedby = bind(BinaryOperator, '\\Leftarrow ', '&#x21D0;');

  LatexCmds.lArr = LatexCmds.Leftarrow = bind(
    VanillaSymbol,
    '\\Leftarrow ',
    '&#x21D0;'
  );

  LatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow = bind(
    VanillaSymbol,
    '\\leftrightarrow ',
    '&#x2194;'
  );

  LatexCmds.iff = bind(BinaryOperator, '\\Leftrightarrow ', '&#x21D4;');

  LatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow = bind(
    VanillaSymbol,
    '\\Leftrightarrow ',
    '&#x21D4;'
  );

  LatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(
    VanillaSymbol,
    '\\Re ',
    '&#x211C;'
  );

  LatexCmds.Im = LatexCmds.imag = LatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary = bind(
    VanillaSymbol,
    '\\Im ',
    '&#x2111;'
  );

  LatexCmds.part = LatexCmds.partial = bind(
    VanillaSymbol,
    '\\partial ',
    '&#x2202;'
  );

  LatexCmds.infty = LatexCmds.infin = LatexCmds.infinity = bind(
    VanillaSymbol,
    '\\infty ',
    '&#x221E;'
  );

  LatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym = bind(
    VanillaSymbol,
    '\\aleph ',
    '&#x2135;'
  );

  LatexCmds.xist = LatexCmds.xists = LatexCmds.exist = LatexCmds.exists = bind( //LOL
    VanillaSymbol,
    '\\exists ',
    '&#x2203;'
  );

  LatexCmds.and = LatexCmds.land = LatexCmds.wedge = bind(
    VanillaSymbol,
    '\\wedge ',
    '&#x2227;'
  );

  LatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(
    VanillaSymbol,
    '\\vee ',
    '&#x2228;'
  );

  LatexCmds.o = LatexCmds.O = LatexCmds.empty = LatexCmds.emptyset = LatexCmds.oslash = LatexCmds.Oslash = LatexCmds.nothing = LatexCmds.varnothing = bind(
    BinaryOperator,
    '\\varnothing ',
    '&#x8960;'
  );

  LatexCmds.cup = LatexCmds.union = bind(BinaryOperator, '\\cup ', '&#x222A;');

  LatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection = bind(
    BinaryOperator,
    '\\cap ',
    '&#x2229;'
  );

  LatexCmds.deg = LatexCmds.degree = bind(
    VanillaSymbol,
    '^\\circ ',
    '&#x00B0;'
  );

  LatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol, '\\angle ', '&#x2220;');
  /*********************************
   * Symbols for Basic Mathematics
   ********************************/

  var Variable = P(Symbol, function(_, super_) {
    _.init = function(ch, html) {
      super_.init.call(this, ch, '<var>' + (html || ch) + '</var>');
    };
    _.text = function() {
      var text = this.ctrlSeq;
      if (
        this[L] &&
        !(this[L] instanceof Variable) &&
        !(this[L] instanceof BinaryOperator)
      )
        text = '*' + text;
      if (
        this[R] &&
        !(this[R] instanceof BinaryOperator) &&
        !(this[R].ctrlSeq === '^')
      )
        text += '*';
      return text;
    };
  });

  Options.p.autoCommands = { _maxLength: 0 };
  optionProcessors.autoCommands = function(cmds) {
    if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {
      throw '"' + cmds + '" not a space-delimited list of only letters';
    }
    var list = cmds.split(' '),
      dict = {},
      maxLength = 0;
    for (var i = 0; i < list.length; i += 1) {
      var cmd = list[i];
      if (cmd.length < 2) {
        throw 'autocommand "' + cmd + '" not minimum length of 2';
      }
      if (LatexCmds[cmd] === OperatorName) {
        throw '"' + cmd + '" is a built-in operator name';
      }
      dict[cmd] = 1;
      maxLength = max(maxLength, cmd.length);
    }
    dict._maxLength = maxLength;
    return dict;
  };

  var Letter = P(Variable, function(_, super_) {
    _.init = function(ch) {
      return super_.init.call(this, (this.letter = ch));
    };
    _.createLeftOf = function(cursor) {
      var autoCmds = cursor.options.autoCommands,
        maxLength = autoCmds._maxLength;
      if (maxLength > 0) {
        // want longest possible autocommand, so join together longest
        // sequence of letters
        var str = this.letter,
          l = cursor[L],
          i = 1;
        while (l instanceof Letter && i < maxLength) {
          str = l.letter + str;
          l = l[L];
          i = i + 1;
        }
        // check for an autocommand, going thru substrings longest to shortest
        while (str.length) {
          if (autoCmds.hasOwnProperty(str)) {
            for (i = 2, l = cursor[L]; i < str.length; i += 1, l = l[L]);
            Fragment(l, cursor[L]).remove();
            cursor[L] = l[L];
            return LatexCmds[str](str).createLeftOf(cursor);
          }
          str = str.slice(1);
        }
      }
      super_.createLeftOf.apply(this, arguments);
    };
    _.italicize = function(bool) {
      this.jQ.toggleClass('mq-operator-name', !bool);
      return this;
    };
    _.finalizeTree = _.siblingDeleted = _.siblingCreated = function(opts, dir) {
      // don't auto-un-italicize if the sibling to my right changed (dir === R or
      // undefined) and it's now a Letter, it will un-italicize everyone
      if (dir !== L && this[R] instanceof Letter) return;
      this.autoUnItalicize(opts);
    };
    _.autoUnItalicize = function(opts) {
      var autoOps = opts.autoOperatorNames;
      if (autoOps._maxLength === 0) return;
      // want longest possible operator names, so join together entire contiguous
      // sequence of letters
      var str = this.letter;
      for (var l = this[L]; l instanceof Letter; l = l[L]) str = l.letter + str;
      for (var r = this[R]; r instanceof Letter; r = r[R]) str += r.letter;

      // removeClass and delete flags from all letters before figuring out
      // which, if any, are part of an operator name
      Fragment(l[R] || this.parent.ends[L], r[L] || this.parent.ends[R]).each(
        function(el) {
          el.italicize(true).jQ.removeClass('mq-first mq-last');
          el.ctrlSeq = el.letter;
        }
      );

      // check for operator names: at each position from left to right, check
      // substrings from longest to shortest
      outer: for (
        var i = 0, first = l[R] || this.parent.ends[L];
        i < str.length;
        i += 1, first = first[R]
      ) {
        for (
          var len = min(autoOps._maxLength, str.length - i);
          len > 0;
          len -= 1
        ) {
          var word = str.slice(i, i + len),
            last;
          if (autoOps.hasOwnProperty(word)) {
            for (
              var j = 0, letter = first;
              j < len;
              j += 1, letter = letter[R]
            ) {
              letter.italicize(false);
              last = letter;
            }

            var isBuiltIn = BuiltInOpNames.hasOwnProperty(word);
            first.ctrlSeq =
              (isBuiltIn ? '\\' : '\\operatorname{') + first.ctrlSeq;
            last.ctrlSeq += isBuiltIn ? ' ' : '}';
            if (TwoWordOpNames.hasOwnProperty(word))
              last[L][L][L].jQ.addClass('mq-last');
            if (nonOperatorSymbol(first[L])) first.jQ.addClass('mq-first');
            if (nonOperatorSymbol(last[R])) last.jQ.addClass('mq-last');

            i += len - 1;
            first = last;
            continue outer;
          }
        }
      }
    };
    function nonOperatorSymbol(node) {
      return node instanceof Symbol && !(node instanceof BinaryOperator);
    }
  });
  var BuiltInOpNames = {}; // http://latex.wikia.com/wiki/List_of_LaTeX_symbols#Named_operators:_sin.2C_cos.2C_etc.
  // except for over/under line/arrow \lim variants like \varlimsup
  var TwoWordOpNames = { limsup: 1, liminf: 1, projlim: 1, injlim: 1 };
  (function() {
    var i,
      autoOps = (Options.p.autoOperatorNames = { _maxLength: 9 });
    var mostOps = (
      'arg deg det dim exp gcd hom inf ker lg lim ln log max min sup' +
      ' limsup liminf injlim projlim Pr'
    ).split(' ');
    for (i = 0; i < mostOps.length; i += 1) {
      BuiltInOpNames[mostOps[i]] = autoOps[mostOps[i]] = 1;
    }

    var builtInTrigs = 'sin cos tan arcsin arccos arctan sinh cosh tanh sec csc cot coth'.split( // why coth but not sech and csch, LaTeX?
      ' '
    );
    for (i = 0; i < builtInTrigs.length; i += 1) {
      BuiltInOpNames[builtInTrigs[i]] = 1;
    }

    var autoTrigs = 'sin cos tan sec cosec csc cotan cot ctg'.split(' ');
    for (i = 0; i < autoTrigs.length; i += 1) {
      autoOps[autoTrigs[i]] = autoOps['arc' + autoTrigs[i]] = autoOps[
        autoTrigs[i] + 'h'
      ] = autoOps['ar' + autoTrigs[i] + 'h'] = autoOps[
        'arc' + autoTrigs[i] + 'h'
      ] = 1;
    }
  })();
  optionProcessors.autoOperatorNames = function(cmds) {
    if (!/^[a-z]+(?: [a-z]+)*$/i.test(cmds)) {
      throw '"' + cmds + '" not a space-delimited list of only letters';
    }
    var list = cmds.split(' '),
      dict = {},
      maxLength = 0;
    for (var i = 0; i < list.length; i += 1) {
      var cmd = list[i];
      if (cmd.length < 2) {
        throw '"' + cmd + '" not minimum length of 2';
      }
      dict[cmd] = 1;
      maxLength = max(maxLength, cmd.length);
    }
    dict._maxLength = maxLength;
    return dict;
  };
  var OperatorName = P(Symbol, function(_, super_) {
    _.init = function(fn) {
      this.ctrlSeq = fn;
    };
    _.createLeftOf = function(cursor) {
      var fn = this.ctrlSeq;
      for (var i = 0; i < fn.length; i += 1) {
        Letter(fn.charAt(i)).createLeftOf(cursor);
      }
    };
    _.parser = function() {
      var fn = this.ctrlSeq;
      var block = MathBlock();
      for (var i = 0; i < fn.length; i += 1) {
        Letter(fn.charAt(i)).adopt(block, block.ends[R], 0);
      }
      return Parser.succeed(block.children());
    };
  });
  for (var fn in BuiltInOpNames)
    if (BuiltInOpNames.hasOwnProperty(fn)) {
      LatexCmds[fn] = OperatorName;
    }
  LatexCmds.operatorname = P(MathCommand, function(_) {
    _.createLeftOf = noop;
    _.numBlocks = function() {
      return 1;
    };
    _.parser = function() {
      return latexMathParser.block.map(function(b) {
        return b.children();
      });
    };
  });

  LatexCmds.f = P(Letter, function(_, super_) {
    _.init = function() {
      Symbol.p.init.call(
        this,
        (this.letter = 'f'),
        '<var class="mq-florin">&#x0192;</var>'
      );
    };
    _.italicize = function(bool) {
      this.jQ.html(bool ? '&#x0192;' : 'f').toggleClass('mq-florin', bool);
      return super_.italicize.apply(this, arguments);
    };
  });

  // VanillaSymbol's
  LatexCmds[' '] = LatexCmds.space = bind(VanillaSymbol, '\\ ', ' ');

  LatexCmds["'"] = LatexCmds.prime = bind(VanillaSymbol, "'", '&#x2032;');

  LatexCmds.backslash = bind(VanillaSymbol, '\\backslash ', '\\');
  if (!CharCmds['\\']) CharCmds['\\'] = LatexCmds.backslash;

  LatexCmds.$ = bind(VanillaSymbol, '\\$', '$');

  // does not use Symbola font
  var NonSymbolaSymbol = P(Symbol, function(_, super_) {
    _.init = function(ch, html) {
      super_.init.call(
        this,
        ch,
        '<span class="mq-nonSymbola">' + (html || ch) + '</span>'
      );
    };
  });

  LatexCmds['@'] = NonSymbolaSymbol;
  LatexCmds['&'] = bind(NonSymbolaSymbol, '\\&', '&amp;');
  LatexCmds['%'] = bind(NonSymbolaSymbol, '\\%', '%');

  //the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html

  //lowercase Greek letter variables
  LatexCmds.alpha = LatexCmds.beta = LatexCmds.gamma = LatexCmds.delta = LatexCmds.zeta = LatexCmds.eta = LatexCmds.theta = LatexCmds.iota = LatexCmds.kappa = LatexCmds.mu = LatexCmds.nu = LatexCmds.xi = LatexCmds.rho = LatexCmds.sigma = LatexCmds.tau = LatexCmds.chi = LatexCmds.psi = LatexCmds.omega = P(
    Variable,
    function(_, super_) {
      _.init = function(latex) {
        super_.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
      };
    }
  );

  //why can't anybody FUCKING agree on these
  LatexCmds.phi = bind(Variable, '\\phi ', '&#981;'); //W3C or Unicode?

  LatexCmds.phiv = LatexCmds.varphi = bind(Variable, '\\varphi ', '&#x03C6;'); //Elsevier and 9573-13 //AMS and LaTeX

  LatexCmds.epsilon = bind(Variable, '\\epsilon ', '&#1013;'); //W3C or Unicode?

  LatexCmds.epsiv = LatexCmds.varepsilon = bind( //Elsevier and 9573-13 //AMS and LaTeX
    Variable,
    '\\varepsilon ',
    '&#x03B5;'
  );

  LatexCmds.piv = LatexCmds.varpi = bind(Variable, '\\varpi ', '&#x03D6;'); //W3C/Unicode and Elsevier and 9573-13 //AMS and LaTeX

  LatexCmds.sigmaf = LatexCmds.sigmav = LatexCmds.varsigma = bind( //W3C/Unicode //Elsevier //LaTeX
    Variable,
    '\\varsigma ',
    '&#x03C2;'
  );

  LatexCmds.thetav = LatexCmds.vartheta = LatexCmds.thetasym = bind( //Elsevier and 9573-13 //AMS and LaTeX //W3C/Unicode
    Variable,
    '\\vartheta ',
    '&#x03D1;'
  );

  LatexCmds.upsilon = LatexCmds.upsi = bind(Variable, '\\upsilon ', '&#x03C5;'); //AMS and LaTeX and W3C/Unicode //Elsevier and 9573-13

  //these aren't even mentioned in the HTML character entity references
  LatexCmds.gammad = LatexCmds.Gammad = LatexCmds.digamma = bind( //Elsevier //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above) //LaTeX
    Variable,
    '\\digamma ',
    '&#989;'
  );

  LatexCmds.kappav = LatexCmds.varkappa = bind( //Elsevier //AMS and LaTeX
    Variable,
    '\\varkappa ',
    '&#1008;'
  );

  LatexCmds.rhov = LatexCmds.varrho = bind(Variable, '\\varrho ', '&#1009;'); //Elsevier and 9573-13 //AMS and LaTeX

  //Greek constants, look best in non-italicized Times New Roman
  LatexCmds.pi = LatexCmds['\u03c0'] = bind(
    NonSymbolaSymbol,
    '\\pi ',
    '&#x03C0;'
  );
  LatexCmds.lambda = bind(NonSymbolaSymbol, '\\lambda ', '&#x03BB;');

  //uppercase greek letters

  LatexCmds.Upsilon = LatexCmds.Upsi = LatexCmds.upsih = LatexCmds.Upsih = bind( //LaTeX //Elsevier and 9573-13 //W3C/Unicode "upsilon with hook" //'cos it makes sense to me
    Symbol,
    '\\Upsilon ',
    '<var style="font-family: serif">&#x03D2;</var>'
  ); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(

  //other symbols with the same LaTeX command and HTML character entity reference
  LatexCmds.Gamma = LatexCmds.Delta = LatexCmds.Theta = LatexCmds.Lambda = LatexCmds.Xi = LatexCmds.Pi = LatexCmds.Sigma = LatexCmds.Phi = LatexCmds.Psi = LatexCmds.Omega = LatexCmds.forall = P(
    VanillaSymbol,
    function(_, super_) {
      _.init = function(latex) {
        super_.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
      };
    }
  );

  // symbols that aren't a single MathCommand, but are instead a whole
  // Fragment. Creates the Fragment from a LaTeX string
  var LatexFragment = P(MathCommand, function(_) {
    _.init = function(latex) {
      this.latex = latex;
    };
    _.createLeftOf = function(cursor) {
      var block = latexMathParser.parse(this.latex);
      block.children().adopt(cursor.parent, cursor[L], cursor[R]);
      cursor[L] = block.ends[R];
      block.jQize().insertBefore(cursor.jQ);
      block.finalizeInsert(cursor.options, cursor);
      if (block.ends[R][R].siblingCreated)
        block.ends[R][R].siblingCreated(cursor.options, L);
      if (block.ends[L][L].siblingCreated)
        block.ends[L][L].siblingCreated(cursor.options, R);
      cursor.parent.bubble('reflow');
    };
    _.parser = function() {
      var frag = latexMathParser.parse(this.latex).children();
      return Parser.succeed(frag);
    };
  });

  // for what seems to me like [stupid reasons][1], Unicode provides
  // subscripted and superscripted versions of all ten Arabic numerals,
  // as well as [so-called "vulgar fractions"][2].
  // Nobody really cares about most of them, but some of them actually
  // predate Unicode, dating back to [ISO-8859-1][3], apparently also
  // known as "Latin-1", which among other things [Windows-1252][4]
  // largely coincides with, so Microsoft Word sometimes inserts them
  // and they get copy-pasted into MathQuill.
  //
  // (Irrelevant but funny story: Windows-1252 is actually a strict
  // superset of the "closely related but distinct"[3] "ISO 8859-1" --
  // see the lack of a dash after "ISO"? Completely different character
  // set, like elephants vs elephant seals, or "Zombies" vs "Zombie
  // Redneck Torture Family". What kind of idiot would get them confused.
  // People in fact got them confused so much, it was so common to
  // mislabel Windows-1252 text as ISO-8859-1, that most modern web
  // browsers and email clients treat the MIME charset of ISO-8859-1
  // as actually Windows-1252, behavior now standard in the HTML5 spec.)
  //
  // [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_andsuper_scripts
  // [2]: http://en.wikipedia.org/wiki/Number_Forms
  // [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
  // [4]: http://en.wikipedia.org/wiki/Windows-1252
  LatexCmds['\u00b9'] = bind(LatexFragment, '^1');
  LatexCmds['\u00b2'] = bind(LatexFragment, '^2');
  LatexCmds['\u00b3'] = bind(LatexFragment, '^3');
  LatexCmds['\u00bc'] = bind(LatexFragment, '\\frac14');
  LatexCmds['\u00bd'] = bind(LatexFragment, '\\frac12');
  LatexCmds['\u00be'] = bind(LatexFragment, '\\frac34');

  var PlusMinus = P(BinaryOperator, function(_) {
    _.init = VanillaSymbol.prototype.init;

    _.contactWeld = _.siblingCreated = _.siblingDeleted = function(opts, dir) {
      if (dir === R) return; // ignore if sibling only changed on the right
      this.jQ[0].className =
        !this[L] || this[L] instanceof BinaryOperator
          ? ''
          : 'mq-binary-operator';
      return this;
    };
  });

  LatexCmds['+'] = bind(PlusMinus, '+', '+');
  //yes, these are different dashes, I think one is an en dash and the other is a hyphen
  LatexCmds['\u2013'] = LatexCmds['-'] = bind(PlusMinus, '-', '&#x2212;');
  LatexCmds[
    '\u00b1'
  ] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus = bind(
    PlusMinus,
    '\\pm ',
    '&#x00B1;'
  );
  LatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus = bind(
    PlusMinus,
    '\\mp ',
    '&#8723;'
  );

  CharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot = bind(
    BinaryOperator,
    '\\cdot ',
    '&#x00B7;'
  );
  //semantically should be &#x22C5;, but &#x00B7; looks better

  var Inequality = P(BinaryOperator, function(_, super_) {
    _.init = function(data, strict) {
      this.data = data;
      this.strict = strict;
      var strictness = strict ? 'Strict' : '';
      super_.init.call(
        this,
        data['ctrlSeq' + strictness],
        data['html' + strictness],
        data['text' + strictness]
      );
    };
    _.swap = function(strict) {
      this.strict = strict;
      var strictness = strict ? 'Strict' : '';
      this.ctrlSeq = this.data['ctrlSeq' + strictness];
      this.jQ.html(this.data['html' + strictness]);
      this.textTemplate = [this.data['text' + strictness]];
    };
    _.deleteTowards = function(dir, cursor) {
      if (dir === L && !this.strict) {
        this.swap(true);
        return;
      }
      super_.deleteTowards.apply(this, arguments);
    };
  });

  var less = {
    ctrlSeq: '\\le ',
    html: '&#x2264;',
    text: '\u2264',
    ctrlSeqStrict: '<',
    htmlStrict: '&lt;',
    textStrict: '<',
  };
  var greater = {
    ctrlSeq: '\\ge ',
    html: '&#x2265;',
    text: '\u2265',
    ctrlSeqStrict: '>',
    htmlStrict: '&gt;',
    textStrict: '>',
  };

  LatexCmds['<'] = LatexCmds.lt = bind(Inequality, less, true);
  LatexCmds['>'] = LatexCmds.gt = bind(Inequality, greater, true);
  LatexCmds['\u2264'] = LatexCmds.le = LatexCmds.leq = bind(
    Inequality,
    less,
    false
  );
  LatexCmds['\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(
    Inequality,
    greater,
    false
  );

  var Equality = P(BinaryOperator, function(_, super_) {
    _.init = function() {
      super_.init.call(this, '=', '=');
    };
    _.createLeftOf = function(cursor) {
      if (cursor[L] instanceof Inequality && cursor[L].strict) {
        cursor[L].swap(false);
        return;
      }
      super_.createLeftOf.apply(this, arguments);
    };
  });
  LatexCmds['='] = Equality;

  LatexCmds.times = bind(BinaryOperator, '\\times ', '&#x00D7;', '[x]');

  LatexCmds[
    '\u00f7'
  ] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides = bind(
    BinaryOperator,
    '\\div ',
    '&#x00F7;',
    '[/]'
  );

  CharCmds['~'] = LatexCmds.sim = bind(
    BinaryOperator,
    '\\sim ',
    '&#x223C;',
    '~'
  );
  /***************************
   * Commands and Operators.
   **************************/

  var scale, // = function(jQ, x, y) { ... }
    //will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,
    //or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to
    //increasing the fontSize to match the vertical Y scaling factor.

    //ideas from http://github.com/louisremi/jquery.transform.js
    //see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx

    forceIERedraw = noop,
    div = document.createElement('div'),
    div_style = div.style,
    transformPropNames = {
      transform: 1,
      WebkitTransform: 1,
      MozTransform: 1,
      OTransform: 1,
      msTransform: 1,
    },
    transformPropName;

  for (var prop in transformPropNames) {
    if (prop in div_style) {
      transformPropName = prop;
      break;
    }
  }

  if (transformPropName) {
    scale = function(jQ, x, y) {
      jQ.css(transformPropName, 'scale(' + x + ',' + y + ')');
    };
  } else if ('filter' in div_style) {
    //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms
    forceIERedraw = function(el) {
      el.className = el.className;
    };
    scale = function(jQ, x, y) {
      //NOTE: assumes y > x
      x /= 1 + (y - 1) / 2;
      jQ.css('fontSize', y + 'em');
      if (!jQ.hasClass('mq-matrixed-container')) {
        jQ.addClass('mq-matrixed-container').wrapInner(
          '<span class="mq-matrixed"></span>'
        );
      }
      var innerjQ = jQ
        .children()
        .css(
          'filter',
          'progid:DXImageTransform.Microsoft' +
            '.Matrix(M11=' +
            x +
            ",SizingMethod='auto expand')"
        );
      function calculateMarginRight() {
        jQ.css('marginRight', ((innerjQ.width() - 1) * (x - 1)) / x + 'px');
      }
      calculateMarginRight();
      var intervalId = setInterval(calculateMarginRight);
      $(window).load(function() {
        clearTimeout(intervalId);
        calculateMarginRight();
      });
    };
  } else {
    scale = function(jQ, x, y) {
      jQ.css('fontSize', y + 'em');
    };
  }

  var Style = P(MathCommand, function(_, super_) {
    _.init = function(ctrlSeq, tagName, attrs) {
      super_.init.call(
        this,
        ctrlSeq,
        '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>'
      );
    };
  });

  //fonts
  LatexCmds.mathrm = bind(
    Style,
    '\\mathrm',
    'span',
    'class="mq-roman mq-font"'
  );
  LatexCmds.mathit = bind(Style, '\\mathit', 'i', 'class="mq-font"');
  LatexCmds.mathbf = bind(Style, '\\mathbf', 'b', 'class="mq-font"');
  LatexCmds.mathsf = bind(
    Style,
    '\\mathsf',
    'span',
    'class="mq-sans-serif mq-font"'
  );
  LatexCmds.mathtt = bind(
    Style,
    '\\mathtt',
    'span',
    'class="mq-monospace mq-font"'
  );
  //text-decoration
  LatexCmds.underline = bind(
    Style,
    '\\underline',
    'span',
    'class="mq-non-leaf mq-underline"'
  );
  LatexCmds.overline = LatexCmds.bar = bind(
    Style,
    '\\overline',
    'span',
    'class="mq-non-leaf mq-overline"'
  );

  // `\textcolor{color}{math}` will apply a color to the given math content, where
  // `color` is any valid CSS Color Value (see [SitePoint docs][] (recommended),
  // [Mozilla docs][], or [W3C spec][]).
  //
  // [SitePoint docs]: http://reference.sitepoint.com/css/colorvalues
  // [Mozilla docs]: https://developer.mozilla.org/en-US/docs/CSS/color_value#Values
  // [W3C spec]: http://dev.w3.org/csswg/css3-color/#colorunits
  var TextColor = (LatexCmds.textcolor = P(MathCommand, function(_, super_) {
    _.setColor = function(color) {
      this.color = color;
      this.htmlTemplate =
        '<span class="mq-textcolor" style="color:' + color + '">&0</span>';
    };
    _.latex = function() {
      return '\\textcolor{' + this.color + '}{' + this.blocks[0].latex() + '}';
    };
    _.parser = function() {
      var self = this;
      var optWhitespace = Parser.optWhitespace;
      var string = Parser.string;
      var regex = Parser.regex;

      return optWhitespace
        .then(string('{'))
        .then(regex(/^[#\w\s.,()%-]*/))
        .skip(string('}'))
        .then(function(color) {
          self.setColor(color);
          return super_.parser.call(self);
        });
    };
  }));

  // Very similar to the \textcolor command, but will add the given CSS class.
  // Usage: \class{classname}{math}
  // Note regex that whitelists valid CSS classname characters:
  // https://github.com/mathquill/mathquill/pull/191#discussion_r4327442
  var Class = (LatexCmds['class'] = P(MathCommand, function(_, super_) {
    _.parser = function() {
      var self = this,
        string = Parser.string,
        regex = Parser.regex;
      return Parser.optWhitespace
        .then(string('{'))
        .then(regex(/^[-\w\s\\\xA0-\xFF]*/))
        .skip(string('}'))
        .then(function(cls) {
          self.htmlTemplate = '<span class="mq-class ' + cls + '">&0</span>';
          return super_.parser.call(self);
        });
    };
  }));

  var SupSub = P(MathCommand, function(_, super_) {
    _.ctrlSeq = '_{...}^{...}';
    _.createLeftOf = function(cursor) {
      if (!cursor[L] && cursor.options.supSubsRequireOperand) return;
      return super_.createLeftOf.apply(this, arguments);
    };
    _.contactWeld = function(cursor) {
      // Look on either side for a SupSub, if one is found compare my
      // .sub, .sup with its .sub, .sup. If I have one that it doesn't,
      // then call .addBlock() on it with my block; if I have one that
      // it also has, then insert my block's children into its block,
      // unless my block has none, in which case insert the cursor into
      // its block (and not mine, I'm about to remove myself) in the case
      // I was just typed.
      // TODO: simplify

      var dir, pt;
      // equiv. to [L, R].forEach(function(dir) { ... });
      for (dir = L; dir; dir = dir === L ? R : false) {
        if (this[dir] instanceof SupSub) {
          // equiv. to 'sub sup'.split(' ').forEach(function(supsub) { ... });
          for (
            var supsub = 'sub';
            supsub;
            supsub = supsub === 'sub' ? 'sup' : false
          ) {
            var src = this[supsub],
              dest = this[dir][supsub];
            if (!src) continue;
            if (!dest) this[dir].addBlock(src.disown());
            else if (!src.isEmpty()) {
              // ins src children at -dir end of dest
              src.jQ.children().insAtDirEnd(-dir, dest.jQ);
              var children = src.children().disown();
              pt = Point(dest, children.ends[R], dest.ends[L]);
              if (dir === L) children.adopt(dest, dest.ends[R], 0);
              else children.adopt(dest, 0, dest.ends[L]);
            } else pt = Point(dest, 0, dest.ends[L]);
            this.placeCursor = (function(dest, src) {
              // TODO: don't monkey-patch
              return function(cursor) {
                cursor.insAtDirEnd(-dir, dest || src);
              };
            })(dest, src);
          }
          this.remove();
          if (cursor && cursor[L] === this) {
            if (dir === R && pt) {
              pt[L] ? cursor.insRightOf(pt[L]) : cursor.insAtLeftEnd(pt.parent);
            } else cursor.insRightOf(this[dir]);
          }
          break;
        }
      }
      this.respace();
    };
    Options.p.charsThatBreakOutOfSupSub = '';
    _.finalizeTree = function() {
      this.ends[L].write = function(cursor, ch) {
        if (cursor.options.charsThatBreakOutOfSupSub.indexOf(ch) > -1) {
          cursor.insRightOf(this.parent);
        }
        MathBlock.p.write.apply(this, arguments);
      };
    };
    _.latex = function() {
      function latex(prefix, block) {
        var l = block && block.latex();
        return block
          ? prefix + (l.length === 1 ? l : '{' + (l || ' ') + '}')
          : '';
      }
      return latex('_', this.sub) + latex('^', this.sup);
    };
    _.respace = _.siblingCreated = _.siblingDeleted = function(opts, dir) {
      if (dir === R) return; // ignore if sibling only changed on the right
      this.jQ.toggleClass('mq-limit', this[L].ctrlSeq === '\\int ');
    };
    _.addBlock = function(block) {
      if (this.supsub === 'sub') {
        this.sup = this.upInto = this.sub.upOutOf = block;
        block.adopt(this, this.sub, 0).downOutOf = this.sub;
        block.jQ = $('<span class="mq-sup"/>')
          .append(block.jQ.children())
          .attr(mqBlockId, block.id)
          .prependTo(this.jQ);
      } else {
        this.sub = this.downInto = this.sup.downOutOf = block;
        block.adopt(this, 0, this.sup).upOutOf = this.sup;
        block.jQ = $('<span class="mq-sub"></span>')
          .append(block.jQ.children())
          .attr(mqBlockId, block.id)
          .appendTo(this.jQ.removeClass('mq-sup-only'));
        this.jQ.append(
          '<span style="display:inline-block;width:0">&#x00A0;</span>'
        );
      }
      // like 'sub sup'.split(' ').forEach(function(supsub) { ... });
      for (var i = 0; i < 2; i += 1)
        (function(cmd, supsub, oppositeSupsub, updown) {
          cmd[supsub].deleteOutOf = function(dir, cursor) {
            cursor.insDirOf(dir, this.parent);
            if (!this.isEmpty()) {
              cursor[-dir] = this.ends[dir];
              this.children()
                .disown()
                .withDirAdopt(dir, cursor.parent, cursor[dir], this.parent)
                .jQ.insDirOf(dir, this.parent.jQ);
            }
            cmd.supsub = oppositeSupsub;
            delete cmd[supsub];
            delete cmd[updown + 'Into'];
            cmd[oppositeSupsub][updown + 'OutOf'] = insLeftOfMeUnlessAtEnd;
            delete cmd[oppositeSupsub].deleteOutOf;
            if (supsub === 'sub')
              $(cmd.jQ.addClass('mq-sup-only')[0].lastChild).remove();
            this.remove();
          };
        })(
          this,
          'sub sup'.split(' ')[i],
          'sup sub'.split(' ')[i],
          'down up'.split(' ')[i]
        );
    };
  });

  var SummationNotation = P(MathCommand, function(_, super_) {
    _.init = function(ch, html) {
      var htmlTemplate =
        '<span class="mq-large-operator mq-non-leaf">' +
        '<span class="mq-to"><span>&1</span></span>' +
        '<big>' +
        html +
        '</big>' +
        '<span class="mq-from"><span>&0</span></span>' +
        '</span>';
      Symbol.prototype.init.call(this, ch, htmlTemplate);
    };
    _.createLeftOf = function(cursor) {
      super_.createLeftOf.apply(this, arguments);
      if (cursor.options.sumStartsWithNEquals) {
        Letter('n').createLeftOf(cursor);
        Equality().createLeftOf(cursor);
      }
    };
    _.latex = function() {
      function simplify(latex) {
        return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';
      }
      return (
        this.ctrlSeq +
        '_' +
        simplify(this.ends[L].latex()) +
        '^' +
        simplify(this.ends[R].latex())
      );
    };
    _.parser = function() {
      var string = Parser.string;
      var optWhitespace = Parser.optWhitespace;
      var succeed = Parser.succeed;
      var block = latexMathParser.block;

      var self = this;
      var blocks = (self.blocks = [MathBlock(), MathBlock()]);
      for (var i = 0; i < blocks.length; i += 1) {
        blocks[i].adopt(self, self.ends[R], 0);
      }

      return optWhitespace
        .then(string('_').or(string('^')))
        .then(function(supOrSub) {
          var child = blocks[supOrSub === '_' ? 0 : 1];
          return block.then(function(block) {
            block.children().adopt(child, child.ends[R], 0);
            return succeed(self);
          });
        })
        .many()
        .result(self);
    };
    _.finalizeTree = function() {
      this.downInto = this.ends[L];
      this.upInto = this.ends[R];
      this.ends[L].upOutOf = this.ends[R];
      this.ends[R].downOutOf = this.ends[L];
    };
  });

  LatexCmds['\u2211'] = LatexCmds.sum = LatexCmds.summation = bind(
    SummationNotation,
    '\\sum ',
    '&#x2211;'
  );

  LatexCmds['\u220f'] = LatexCmds.prod = LatexCmds.product = bind(
    SummationNotation,
    '\\prod ',
    '&#x220F;'
  );

  LatexCmds.coprod = LatexCmds.coproduct = bind(
    SummationNotation,
    '\\coprod ',
    '&#8720;'
  );

  function insLeftOfMeUnlessAtEnd(cursor) {
    // cursor.insLeftOf(cmd), unless cursor at the end of block, and every
    // ancestor cmd is at the end of every ancestor block
    var cmd = this.parent,
      ancestorCmd = cursor;
    do {
      if (ancestorCmd[R]) return cursor.insLeftOf(cmd);
      ancestorCmd = ancestorCmd.parent.parent;
    } while (ancestorCmd !== cmd);
    cursor.insRightOf(cmd);
  }

  LatexCmds.subscript = LatexCmds._ = P(SupSub, function(_, super_) {
    _.supsub = 'sub';
    _.htmlTemplate =
      '<span class="mq-supsub mq-non-leaf">' +
      '<span class="mq-sub">&0</span>' +
      '<span style="display:inline-block;width:0">&#x00A0;</span>' +
      '</span>';
    _.textTemplate = ['_'];
    _.finalizeTree = function() {
      this.downInto = this.sub = this.ends[L];
      this.sub.upOutOf = insLeftOfMeUnlessAtEnd;
      super_.finalizeTree.call(this);
    };
  });

  LatexCmds.superscript = LatexCmds.supscript = LatexCmds['^'] = P(
    SupSub,
    function(_, super_) {
      _.supsub = 'sup';
      _.htmlTemplate =
        '<span class="mq-supsub mq-non-leaf mq-sup-only">' +
        '<span class="mq-sup">&0</span>' +
        '</span>';
      _.textTemplate = ['**'];
      _.finalizeTree = function() {
        this.upInto = this.sup = this.ends[R];
        this.sup.downOutOf = insLeftOfMeUnlessAtEnd;
        super_.finalizeTree.call(this);
      };
    }
  );

  var Fraction = (LatexCmds.frac = LatexCmds.dfrac = LatexCmds.cfrac = LatexCmds.fraction = P(
    MathCommand,
    function(_, super_) {
      _.ctrlSeq = '\\frac';
      _.htmlTemplate =
        '<span class="mq-fraction mq-non-leaf">' +
        '<span class="mq-numerator">&0</span>' +
        '<span class="mq-denominator">&1</span>' +
        '<span style="display:inline-block;width:0">&#x00A0;</span>' +
        '</span>';
      _.textTemplate = ['(', '/', ')'];
      _.finalizeTree = function() {
        this.upInto = this.ends[R].upOutOf = this.ends[L];
        this.downInto = this.ends[L].downOutOf = this.ends[R];
      };
    }
  ));

  var LiveFraction = (LatexCmds.over = CharCmds['/'] = P(Fraction, function(
    _,
    super_
  ) {
    _.createLeftOf = function(cursor) {
      if (!this.replacedFragment) {
        var leftward = cursor[L];
        while (
          leftward &&
          !(
            leftward instanceof BinaryOperator ||
            leftward instanceof (LatexCmds.text || noop) ||
            leftward instanceof SummationNotation ||
            leftward.ctrlSeq === '\\ ' ||
            /^[,;:]$/.test(leftward.ctrlSeq)
          ) //lookbehind for operator
        )
          leftward = leftward[L];

        if (
          leftward instanceof SummationNotation &&
          leftward[R] instanceof SupSub
        ) {
          leftward = leftward[R];
          if (
            leftward[R] instanceof SupSub &&
            leftward[R].ctrlSeq != leftward.ctrlSeq
          )
            leftward = leftward[R];
        }

        if (leftward !== cursor[L]) {
          this.replaces(
            Fragment(leftward[R] || cursor.parent.ends[L], cursor[L])
          );
          cursor[L] = leftward;
        }
      }
      super_.createLeftOf.call(this, cursor);
    };
  }));

  var SquareRoot = (LatexCmds.sqrt = LatexCmds['\u221a'] = P(
    MathCommand,
    function(_, super_) {
      _.ctrlSeq = '\\sqrt';
      _.htmlTemplate =
        '<span class="mq-non-leaf">' +
        '<span class="mq-scaled mq-sqrt-prefix">&#x221A;</span>' +
        '<span class="mq-non-leaf mq-sqrt-stem">&0</span>' +
        '</span>';
      _.textTemplate = ['sqrt(', ')'];
      _.parser = function() {
        return latexMathParser.optBlock
          .then(function(optBlock) {
            return latexMathParser.block.map(function(block) {
              var nthroot = NthRoot();
              nthroot.blocks = [optBlock, block];
              optBlock.adopt(nthroot, 0, 0);
              block.adopt(nthroot, optBlock, 0);
              return nthroot;
            });
          })
          .or(super_.parser.call(this));
      };
      _.reflow = function() {
        var block = this.ends[R].jQ;
        scale(
          block.prev(),
          1,
          block.innerHeight() / +block.css('fontSize').slice(0, -2) + 0.1
        );
      };
    }
  ));

  var Vec = (LatexCmds.vec = P(MathCommand, function(_, super_) {
    _.ctrlSeq = '\\vec';
    _.htmlTemplate =
      '<span class="mq-non-leaf">' +
      '<span class="mq-vector-prefix">&#x2192;</span>' +
      '<span class="mq-vector-stem">&0</span>' +
      '</span>';
    _.textTemplate = ['vec(', ')'];
  }));

  var NthRoot = (LatexCmds.nthroot = P(SquareRoot, function(_, super_) {
    _.htmlTemplate =
      '<sup class="mq-nthroot mq-non-leaf">&0</sup>' +
      '<span class="mq-scaled">' +
      '<span class="mq-sqrt-prefix mq-scaled">&#x221A;</span>' +
      '<span class="mq-sqrt-stem mq-non-leaf">&1</span>' +
      '</span>';
    _.textTemplate = ['sqrt[', '](', ')'];
    _.latex = function() {
      return (
        '\\sqrt[' + this.ends[L].latex() + ']{' + this.ends[R].latex() + '}'
      );
    };
  }));

  function DelimsMixin(_, super_) {
    _.jQadd = function() {
      super_.jQadd.apply(this, arguments);
      this.delimjQs = this.jQ.children(':first').add(this.jQ.children(':last'));
      this.contentjQ = this.jQ.children(':eq(1)');
    };
    _.reflow = function() {
      var height =
        this.contentjQ.outerHeight() /
        parseFloat(this.contentjQ.css('fontSize'));
      scale(this.delimjQs, min(1 + 0.2 * (height - 1), 1.2), 1.05 * height);
    };
  }

  // Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)
  //   first typed as one-sided bracket with matching "ghost" bracket at
  //   far end of current block, until you type an opposing one
  var Bracket = P(P(MathCommand, DelimsMixin), function(_, super_) {
    _.init = function(side, open, close, ctrlSeq, end) {
      super_.init.call(this, '\\left' + ctrlSeq, undefined, [open, close]);
      this.side = side;
      this.sides = {};
      this.sides[L] = { ch: open, ctrlSeq: ctrlSeq };
      this.sides[R] = { ch: close, ctrlSeq: end };
    };
    _.numBlocks = function() {
      return 1;
    };
    _.html = function() {
      // wait until now so that .side may
      this.htmlTemplate = // be set by createLeftOf or parser
        '<span class="mq-non-leaf">' +
        '<span class="mq-scaled mq-paren' +
        (this.side === R ? ' mq-ghost' : '') +
        '">' +
        this.sides[L].ch +
        '</span>' +
        '<span class="mq-non-leaf">&0</span>' +
        '<span class="mq-scaled mq-paren' +
        (this.side === L ? ' mq-ghost' : '') +
        '">' +
        this.sides[R].ch +
        '</span>' +
        '</span>';
      return super_.html.call(this);
    };
    _.latex = function() {
      return (
        '\\left' +
        this.sides[L].ctrlSeq +
        this.ends[L].latex() +
        '\\right' +
        this.sides[R].ctrlSeq
      );
    };
    _.oppBrack = function(node, expectedSide) {
      // node must be 1-sided bracket of expected side (if any, may be undefined),
      // and unless I'm a pipe, node and I must be opposite-facing sides
      return (
        node instanceof Bracket &&
        node.side &&
        node.side !== -expectedSide &&
        (this.sides[this.side].ch === '|' || node.side === -this.side) &&
        node
      );
    };
    _.closeOpposing = function(brack) {
      brack.side = 0;
      brack.sides[this.side] = this.sides[this.side]; // copy over my info (may be
      brack.delimjQs
        .eq(this.side === L ? 0 : 1) // mis-matched, like [a, b))
        .removeClass('mq-ghost')
        .html(this.sides[this.side].ch);
    };
    _.createLeftOf = function(cursor) {
      var brack, side;
      if (!this.replacedFragment) {
        // unless wrapping seln in brackets,
        // check if next to or inside an opposing one-sided bracket
        brack =
          this.oppBrack(cursor[L], L) ||
          this.oppBrack(cursor[R], R) ||
          this.oppBrack(cursor.parent.parent);
      }
      if (brack) {
        side = this.side = -brack.side; // may be pipe with .side not yet set
        this.closeOpposing(brack);
        if (brack === cursor.parent.parent && cursor[side]) {
          // move the stuff between
          Fragment(cursor[side], cursor.parent.ends[side], -side) // me and ghost outside
            .disown()
            .withDirAdopt(-side, brack.parent, brack, brack[side])
            .jQ.insDirOf(side, brack.jQ);
          brack.bubble('reflow');
        }
      } else {
        (brack = this), (side = brack.side);
        if (brack.replacedFragment) brack.side = 0;
        // wrapping seln, don't be one-sided
        else if (cursor[-side]) {
          // elsewise, auto-expand so ghost is at far end
          brack.replaces(
            Fragment(cursor[-side], cursor.parent.ends[-side], side)
          );
          cursor[-side] = 0;
        }
        super_.createLeftOf.call(brack, cursor);
      }
      if (side === L) cursor.insAtLeftEnd(brack.ends[L]);
      else cursor.insRightOf(brack);
    };
    _.placeCursor = noop;
    _.unwrap = function() {
      this.ends[L].children()
        .disown()
        .adopt(this.parent, this, this[R])
        .jQ.insertAfter(this.jQ);
      this.remove();
    };
    _.deleteSide = function(side, outward, cursor) {
      var origEnd,
        parent = this.parent,
        sib = this[side],
        farEnd = parent.ends[side];

      if (side === this.side) {
        // deleting non-ghost of one-sided bracket, unwrap
        this.unwrap();
        sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);
        return;
      }

      this.side = -side;
      // check if like deleting outer close-brace of [(1+2)+3} where inner open-
      if (this.oppBrack(this.ends[L].ends[this.side], side)) {
        // paren is ghost,
        this.closeOpposing(this.ends[L].ends[this.side]); // if so become [1+2)+3
        origEnd = this.ends[L].ends[side];
        this.unwrap();
        if (origEnd.siblingCreated)
          origEnd.siblingCreated(cursor.options, side);
        sib ? cursor.insDirOf(-side, sib) : cursor.insAtDirEnd(side, parent);
      } else {
        // check if like deleting inner close-brace of ([1+2}+3) where
        if (this.oppBrack(this.parent.parent, side)) {
          // outer open-paren is
          this.parent.parent.closeOpposing(this); // ghost, if so become [1+2+3)
          this.parent.parent.unwrap();
        } else {
          // deleting one of a pair of brackets, become one-sided
          this.sides[side] = {
            ch: OPP_BRACKS[this.sides[this.side].ch],
            ctrlSeq: OPP_BRACKS[this.sides[this.side].ctrlSeq],
          };
          this.delimjQs
            .removeClass('mq-ghost')
            .eq(side === L ? 0 : 1)
            .addClass('mq-ghost')
            .html(this.sides[side].ch);
        }
        if (sib) {
          // auto-expand so ghost is at far end
          origEnd = this.ends[L].ends[side];
          Fragment(sib, farEnd, -side)
            .disown()
            .withDirAdopt(-side, this.ends[L], origEnd, 0)
            .jQ.insAtDirEnd(side, this.ends[L].jQ.removeClass('mq-empty'));
          if (origEnd.siblingCreated)
            origEnd.siblingCreated(cursor.options, side);
          cursor.insDirOf(-side, sib);
        } // didn't auto-expand, cursor goes just outside or just inside parens
        else
          outward
            ? cursor.insDirOf(side, this)
            : cursor.insAtDirEnd(side, this.ends[L]);
      }
    };
    _.deleteTowards = function(dir, cursor) {
      this.deleteSide(-dir, false, cursor);
    };
    _.finalizeTree = function() {
      this.ends[L].deleteOutOf = function(dir, cursor) {
        this.parent.deleteSide(dir, true, cursor);
      };
      // FIXME HACK: after initial creation/insertion, finalizeTree would only be
      // called if the paren is selected and replaced, e.g. by LiveFraction
      this.finalizeTree = this.intentionalBlur = function() {
        this.delimjQs.eq(this.side === L ? 1 : 0).removeClass('mq-ghost');
        this.side = 0;
      };
    };
    _.siblingCreated = function(opts, dir) {
      // if something typed between ghost and far
      if (dir === -this.side) this.finalizeTree(); // end of its block, solidify
    };
  });

  var OPP_BRACKS = {
    '(': ')',
    ')': '(',
    '[': ']',
    ']': '[',
    '{': '}',
    '}': '{',
    '\\{': '\\}',
    '\\}': '\\{',
    '&#x2329;': '&#x232A;',
    '&#x232A;': '&#x2329;',
    '\\langle ': '\\rangle ',
    '\\rangle ': '\\langle ',
    '|': '|',
  };

  function bindCharBracketPair(open, ctrlSeq) {
    ctrlSeq = ctrlSeq || open;
    var close = OPP_BRACKS[open],
      end = OPP_BRACKS[ctrlSeq];
    CharCmds[open] = bind(Bracket, L, open, close, ctrlSeq, end);
    CharCmds[close] = bind(Bracket, R, open, close, ctrlSeq, end);
  }
  bindCharBracketPair('(');
  bindCharBracketPair('[');
  bindCharBracketPair('{', '\\{');
  LatexCmds.langle = bind(
    Bracket,
    L,
    '&#x2329;',
    '&#x232A;',
    '\\langle ',
    '\\rangle '
  );
  LatexCmds.rangle = bind(
    Bracket,
    R,
    '&#x2329;',
    '&#x232A;',
    '\\langle ',
    '\\rangle '
  );
  CharCmds['|'] = bind(Bracket, L, '|', '|', '|', '|');

  LatexCmds.left = P(MathCommand, function(_) {
    _.parser = function() {
      var regex = Parser.regex;
      var string = Parser.string;
      var succeed = Parser.succeed;
      var optWhitespace = Parser.optWhitespace;

      return optWhitespace
        .then(regex(/^(?:[([|]|\\\{)/))
        .then(function(ctrlSeq) {
          // TODO: \langle, \rangle
          var open = ctrlSeq.charAt(0) === '\\' ? ctrlSeq.slice(1) : ctrlSeq;
          return latexMathParser.then(function(block) {
            return string('\\right')
              .skip(optWhitespace)
              .then(regex(/^(?:[\])|]|\\\})/))
              .map(function(end) {
                var close = end.charAt(0) === '\\' ? end.slice(1) : end;
                var cmd = Bracket(0, open, close, ctrlSeq, end);
                cmd.blocks = [block];
                block.adopt(cmd, 0, 0);
                return cmd;
              });
          });
        });
    };
  });

  LatexCmds.right = P(MathCommand, function(_) {
    _.parser = function() {
      return Parser.fail('unmatched \\right');
    };
  });

  var HTMLBlob = (LatexCmds.blob = P(MathCommand, function(_, _super) {
    _.init = function(html) {
      _super.init.call(this, '\\blob');
    };

    _.parser = function() {
      var string = Parser.string;
      var succeed = Parser.succeed;
      var any = Parser.any;
      var fail = Parser.fail;
      var skip = Parser.skip;
      var regex = Parser.regex;

      var joinStr = function(chunks) {
        return chunks.join('');
      };

      var cmd = this;

      return string('\\endBlob')
        .or(string('\\\\'))
        .or(any)
        .then(function(chunk) {
          switch (chunk) {
            case '\\endBlob':
              return fail();
            case '\\\\': // Quoted backslash
              return succeed('\\');
            default:
              return succeed(chunk);
          }
        })
        .many()
        .map(joinStr)
        .skip(string('\\endBlob'))
        .then(function(html) {
          cmd.htmlBlob = html;
          return succeed(cmd);
        });
    };

    _.html = function() {
      return (
        '<span class="mq-blob" ' +
        mqCmdId +
        '= "' +
        this.id +
        '" ' +
        '>' +
        this.htmlBlob +
        '</span>'
      );
    };

    _.latex = function() {
      var quoted = this.htmlBlob.replace(/\\/g, '\\\\');
      return '\\blob' + quoted + '\\endBlob';
    };

    _.replaces = function(replacedFragment) {
      replacedFragment.remove();
    };
    _.createBlocks = noop;

    _.moveTowards = function(dir, cursor) {
      cursor.jQ.insDirOf(dir, this.jQ);
      cursor[-dir] = this;
      cursor[dir] = this[dir];
    };
    _.deleteTowards = function(dir, cursor) {
      cursor[dir] = this.remove()[dir];
    };
    _.seek = function(pageX, cursor) {
      // insert at whichever side the click was closer to
      if (pageX - this.jQ.offset().left < this.jQ.outerWidth() / 2)
        cursor.insLeftOf(this);
      else cursor.insRightOf(this);
    };

    _.placeCursor = noop;
    _.isEmpty = function() {
      return true;
    };
  }));

  var Binomial = (LatexCmds.binom = LatexCmds.binomial = P(
    P(MathCommand, DelimsMixin),
    function(_, super_) {
      _.ctrlSeq = '\\binom';
      _.htmlTemplate =
        '<span class="mq-non-leaf">' +
        '<span class="mq-paren mq-scaled">(</span>' +
        '<span class="mq-non-leaf">' +
        '<span class="mq-array mq-non-leaf">' +
        '<span>&0</span>' +
        '<span>&1</span>' +
        '</span>' +
        '</span>' +
        '<span class="mq-paren mq-scaled">)</span>' +
        '</span>';
      _.textTemplate = ['choose(', ',', ')'];
    }
  ));

  var Choose = (LatexCmds.choose = P(Binomial, function(_) {
    _.createLeftOf = LiveFraction.prototype.createLeftOf;
  }));

  var InnerMathField = P(MathQuill.MathField, function(_) {
    _.init = function(root, container) {
      RootBlockMixin(root);
      this.__options = Options();
      var ctrlr = Controller(this, root, container);
      ctrlr.editable = true;
      ctrlr.createTextarea();
      ctrlr.editablesTextareaEvents();
      ctrlr.cursor.insAtRightEnd(root);
    };
  });
  LatexCmds.MathQuillMathField = P(MathCommand, function(_, super_) {
    _.ctrlSeq = '\\MathQuillMathField';
    _.htmlTemplate =
      '<span class="mq-editable-field">' +
      '<span class="mq-root-block">&0</span>' +
      '</span>';
    _.parser = function() {
      var self = this,
        string = Parser.string,
        regex = Parser.regex,
        succeed = Parser.succeed;
      return string('[')
        .then(regex(/^[a-z][a-z0-9]*/i))
        .skip(string(']'))
        .map(function(name) {
          self.name = name;
        })
        .or(succeed())
        .then(super_.parser.call(self));
    };
    _.finalizeTree = function() {
      InnerMathField(this.ends[L], this.jQ);
    };
    _.registerInnerField = function(innerFields) {
      innerFields.push((innerFields[this.name] = this.ends[L].controller.API));
    };
    _.latex = function() {
      return this.ends[L].latex();
    };
    _.text = function() {
      return this.ends[L].text();
    };
  });
})();
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.1
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+(function($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop';
  var toggle = '[data-toggle="dropdown"]';
  var Dropdown = function(element) {
    $(element).on('click.bs.dropdown', this.toggle);
  };

  Dropdown.VERSION = '3.3.1';

  Dropdown.prototype.toggle = function(e) {
    var $this = $(this);

    if ($this.is('.disabled, :disabled')) return;

    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');

    clearMenus();

    if (!isActive) {
      if (
        'ontouchstart' in document.documentElement &&
        !$parent.closest('.navbar-nav').length
      ) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>')
          .insertAfter($(this))
          .on('click', clearMenus);
      }

      var relatedTarget = { relatedTarget: this };
      $parent.trigger((e = $.Event('show.bs.dropdown', relatedTarget)));

      if (e.isDefaultPrevented()) return;

      $this

        // KLOOGE - We avoid focusing on the dropdown toggle because
        //this would cause Mathquill to clear its selection and prevent
        //using dropdowns to do things like wrapping a square root
        //sign around the selection.

        //  .trigger('focus')
        .attr('aria-expanded', 'true');

      $parent.toggleClass('open').trigger('shown.bs.dropdown', relatedTarget);
    }

    return false;
  };

  Dropdown.prototype.keydown = function(e) {
    if (
      !/(38|40|27|32)/.test(e.which) ||
      /input|textarea/i.test(e.target.tagName)
    )
      return;

    var $this = $(this);

    e.preventDefault();
    e.stopPropagation();

    if ($this.is('.disabled, :disabled')) return;

    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');

    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
      if (e.which == 27) $parent.find(toggle).trigger('focus');
      return $this.trigger('click');
    }

    var desc = ' li:not(.divider):visible a';
    var $items = $parent.find(
      '[role="menu"]' + desc + ', [role="listbox"]' + desc
    );

    if (!$items.length) return;

    var index = $items.index(e.target);

    if (e.which == 38 && index > 0) index--; // up
    if (e.which == 40 && index < $items.length - 1) index++; // down
    if (!~index) index = 0;

    $items.eq(index).trigger('focus');
  };

  function clearMenus(e) {
    if (e && e.which === 3) return;
    $(backdrop).remove();
    $(toggle).each(function() {
      var $this = $(this);
      var $parent = getParent($this);
      var relatedTarget = { relatedTarget: this };

      if (!$parent.hasClass('open')) return;

      $parent.trigger((e = $.Event('hide.bs.dropdown', relatedTarget)));

      if (e.isDefaultPrevented()) return;

      $this.attr('aria-expanded', 'false');
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget);
    });
  }

  function getParent($this) {
    var selector = $this.attr('data-target');

    if (!selector) {
      selector = $this.attr('href');
      selector =
        selector &&
        /#[A-Za-z]/.test(selector) &&
        selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    var $parent = selector && $(selector);

    return $parent && $parent.length ? $parent : $this.parent();
  }

  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this);
      var data = $this.data('bs.dropdown');

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)));
      if (typeof option == 'string') data[option].call($this);
    });
  }

  var old = $.fn.dropdown;

  $.fn.dropdown = Plugin;
  $.fn.dropdown.Constructor = Dropdown;

  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function() {
    $.fn.dropdown = old;
    return this;
  };

  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
      e.stopPropagation();
    })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on(
      'keydown.bs.dropdown.data-api',
      '[role="menu"]',
      Dropdown.prototype.keydown
    )
    .on(
      'keydown.bs.dropdown.data-api',
      '[role="listbox"]',
      Dropdown.prototype.keydown
    );
})(jQuery);
(function() {
  'use strict';

  /**
   * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
   *
   * @codingstandard ftlabs-jsv2
   * @copyright The Financial Times Limited [All Rights Reserved]
   * @license MIT License (see LICENSE.txt)
   */

  /*jslint browser:true, node:true*/
  /*global define, Event, Node*/

  /**
   * Instantiate fast-clicking listeners on the specified layer.
   *
   * @constructor
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
  function FastClick(layer, options) {
    var oldOnClick;

    options = options || {};

    /**
     * Whether a click is currently being tracked.
     *
     * @type boolean
     */
    this.trackingClick = false;

    /**
     * Timestamp for when click tracking started.
     *
     * @type number
     */
    this.trackingClickStart = 0;

    /**
     * The element being tracked for a click.
     *
     * @type EventTarget
     */
    this.targetElement = null;

    /**
     * X-coordinate of touch start event.
     *
     * @type number
     */
    this.touchStartX = 0;

    /**
     * Y-coordinate of touch start event.
     *
     * @type number
     */
    this.touchStartY = 0;

    /**
     * ID of the last touch, retrieved from Touch.identifier.
     *
     * @type number
     */
    this.lastTouchIdentifier = 0;

    /**
     * Touchmove boundary, beyond which a click will be cancelled.
     *
     * @type number
     */
    this.touchBoundary = options.touchBoundary || 10;

    /**
     * The FastClick layer.
     *
     * @type Element
     */
    this.layer = layer;

    /**
     * The minimum time between tap(touchstart and touchend) events
     *
     * @type number
     */
    this.tapDelay = options.tapDelay || 200;

    /**
     * The maximum time for a tap
     *
     * @type number
     */
    this.tapTimeout = options.tapTimeout || 700;

    if (FastClick.notNeeded(layer)) {
      return;
    }

    // Some old versions of Android don't have Function.prototype.bind
    function bind(method, context) {
      return function() {
        return method.apply(context, arguments);
      };
    }

    var methods = [
      'onMouse',
      'onClick',
      'onTouchStart',
      'onTouchMove',
      'onTouchEnd',
      'onTouchCancel',
    ];
    var context = this;
    for (var i = 0, l = methods.length; i < l; i++) {
      context[methods[i]] = bind(context[methods[i]], context);
    }

    // Set up event handlers as required
    if (deviceIsAndroid) {
      layer.addEventListener('mouseover', this.onMouse, true);
      layer.addEventListener('mousedown', this.onMouse, true);
      layer.addEventListener('mouseup', this.onMouse, true);
    }

    layer.addEventListener('click', this.onClick, true);
    layer.addEventListener('touchstart', this.onTouchStart, false);
    layer.addEventListener('touchmove', this.onTouchMove, false);
    layer.addEventListener('touchend', this.onTouchEnd, false);
    layer.addEventListener('touchcancel', this.onTouchCancel, false);

    // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
    // layer when they are cancelled.
    if (!Event.prototype.stopImmediatePropagation) {
      layer.removeEventListener = function(type, callback, capture) {
        var rmv = Node.prototype.removeEventListener;
        if (type === 'click') {
          rmv.call(layer, type, callback.hijacked || callback, capture);
        } else {
          rmv.call(layer, type, callback, capture);
        }
      };

      layer.addEventListener = function(type, callback, capture) {
        var adv = Node.prototype.addEventListener;
        if (type === 'click') {
          adv.call(
            layer,
            type,
            callback.hijacked ||
              (callback.hijacked = function(event) {
                if (!event.propagationStopped) {
                  callback(event);
                }
              }),
            capture
          );
        } else {
          adv.call(layer, type, callback, capture);
        }
      };
    }

    // If a handler is already declared in the element's onclick attribute, it will be fired before
    // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
    // adding it as listener.
    if (typeof layer.onclick === 'function') {
      // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
      // - the old one won't work if passed to addEventListener directly.
      oldOnClick = layer.onclick;
      layer.addEventListener(
        'click',
        function(event) {
          oldOnClick(event);
        },
        false
      );
      layer.onclick = null;
    }
  }

  /**
   * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
   *
   * @type boolean
   */
  var deviceIsWindowsPhone = navigator.userAgent.indexOf('Windows Phone') >= 0;

  /**
   * Android requires exceptions.
   *
   * @type boolean
   */
  var deviceIsAndroid =
    navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;

  /**
   * iOS requires exceptions.
   *
   * @type boolean
   */
  var deviceIsIOS =
    /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;

  /**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */
  var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);

  /**
   * iOS 6.0-7.* requires the target element to be manually derived
   *
   * @type boolean
   */
  var deviceIsIOSWithBadTarget =
    deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);

  /**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */
  var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

  /**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */
  FastClick.prototype.needsClick = function(target) {
    switch (target.nodeName.toLowerCase()) {
      // Don't send a synthetic click to disabled inputs (issue #62)
      case 'button':
      case 'select':
      case 'textarea':
        if (target.disabled) {
          return true;
        }

        break;
      case 'input':
        // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
        if ((deviceIsIOS && target.type === 'file') || target.disabled) {
          return true;
        }

        break;
      case 'label':
      case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
      case 'video':
        return true;
    }

    return /\bneedsclick\b/.test(target.className);
  };

  /**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */
  FastClick.prototype.needsFocus = function(target) {
    switch (target.nodeName.toLowerCase()) {
      case 'textarea':
        return true;
      case 'select':
        return !deviceIsAndroid;
      case 'input':
        switch (target.type) {
          case 'button':
          case 'checkbox':
          case 'file':
          case 'image':
          case 'radio':
          case 'submit':
            return false;
        }

        // No point in attempting to focus disabled inputs
        return !target.disabled && !target.readOnly;
      default:
        return /\bneedsfocus\b/.test(target.className);
    }
  };

  /**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */
  FastClick.prototype.sendClick = function(targetElement, event) {
    var clickEvent, touch;

    // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
    if (document.activeElement && document.activeElement !== targetElement) {
      document.activeElement.blur();
    }

    touch = event.changedTouches[0];

    // Synthesise a click event, with an extra attribute so it can be tracked
    clickEvent = document.createEvent('MouseEvents');
    clickEvent.initMouseEvent(
      this.determineEventType(targetElement),
      true,
      true,
      window,
      1,
      touch.screenX,
      touch.screenY,
      touch.clientX,
      touch.clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
    clickEvent.forwardedTouchEvent = true;
    targetElement.dispatchEvent(clickEvent);
  };

  FastClick.prototype.determineEventType = function(targetElement) {
    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
      return 'mousedown';
    }

    return 'click';
  };

  /**
   * @param {EventTarget|Element} targetElement
   */
  FastClick.prototype.focus = function(targetElement) {
    var length;

    // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
    if (
      deviceIsIOS &&
      targetElement.setSelectionRange &&
      targetElement.type.indexOf('date') !== 0 &&
      targetElement.type !== 'time' &&
      targetElement.type !== 'month'
    ) {
      length = targetElement.value.length;
      targetElement.setSelectionRange(length, length);
    } else {
      targetElement.focus();
    }
  };

  /**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */
  FastClick.prototype.updateScrollParent = function(targetElement) {
    var scrollParent, parentElement;

    scrollParent = targetElement.fastClickScrollParent;

    // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
    // target element was moved to another parent.
    if (!scrollParent || !scrollParent.contains(targetElement)) {
      parentElement = targetElement;
      do {
        if (parentElement.scrollHeight > parentElement.offsetHeight) {
          scrollParent = parentElement;
          targetElement.fastClickScrollParent = parentElement;
          break;
        }

        parentElement = parentElement.parentElement;
      } while (parentElement);
    }

    // Always update the scroll top tracker if possible.
    if (scrollParent) {
      scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
    }
  };

  /**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */
  FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    if (eventTarget.nodeType === Node.TEXT_NODE) {
      return eventTarget.parentNode;
    }

    return eventTarget;
  };

  /**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchStart = function(event) {
    var targetElement, touch, selection;

    // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
    if (event.targetTouches.length > 1) {
      return true;
    }

    targetElement = this.getTargetElementFromEventTarget(event.target);
    touch = event.targetTouches[0];

    if (deviceIsIOS) {
      // Only trusted events will deselect text on iOS (issue #49)
      selection = window.getSelection();
      if (selection.rangeCount && !selection.isCollapsed) {
        return true;
      }

      if (!deviceIsIOS4) {
        // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
        // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
        // with the same identifier as the touch event that previously triggered the click that triggered the alert.
        // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
        // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
        // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
        // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
        // random integers, it's safe to to continue if the identifier is 0 here.
        if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
          event.preventDefault();
          return false;
        }

        this.lastTouchIdentifier = touch.identifier;

        // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
        // 1) the user does a fling scroll on the scrollable layer
        // 2) the user stops the fling scroll with another tap
        // then the event.target of the last 'touchend' event will be the element that was under the user's finger
        // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
        // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
        this.updateScrollParent(targetElement);
      }
    }

    this.trackingClick = true;
    this.trackingClickStart = event.timeStamp;
    this.targetElement = targetElement;

    this.touchStartX = touch.pageX;
    this.touchStartY = touch.pageY;

    // Prevent phantom clicks on fast double-tap (issue #36)
    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      event.preventDefault();
    }

    return true;
  };

  /**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.touchHasMoved = function(event) {
    var touch = event.changedTouches[0],
      boundary = this.touchBoundary;

    if (
      Math.abs(touch.pageX - this.touchStartX) > boundary ||
      Math.abs(touch.pageY - this.touchStartY) > boundary
    ) {
      return true;
    }

    return false;
  };

  /**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchMove = function(event) {
    if (!this.trackingClick) {
      return true;
    }

    // If the touch has moved, cancel the click tracking
    if (
      this.targetElement !==
        this.getTargetElementFromEventTarget(event.target) ||
      this.touchHasMoved(event)
    ) {
      this.trackingClick = false;
      this.targetElement = null;
    }

    return true;
  };

  /**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */
  FastClick.prototype.findControl = function(labelElement) {
    // Fast path for newer browsers supporting the HTML5 control attribute
    if (labelElement.control !== undefined) {
      return labelElement.control;
    }

    // All browsers under test that support touch events also support the HTML5 htmlFor attribute
    if (labelElement.htmlFor) {
      return document.getElementById(labelElement.htmlFor);
    }

    // If no for attribute exists, attempt to retrieve the first labellable descendant element
    // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
    return labelElement.querySelector(
      'button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea'
    );
  };

  /**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onTouchEnd = function(event) {
    var forElement,
      trackingClickStart,
      targetTagName,
      scrollParent,
      touch,
      targetElement = this.targetElement;

    if (!this.trackingClick) {
      return true;
    }

    // Prevent phantom clicks on fast double-tap (issue #36)
    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      this.cancelNextClick = true;
      return true;
    }

    if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
      return true;
    }

    // Reset to prevent wrong click cancel on input (issue #156).
    this.cancelNextClick = false;

    this.lastClickTime = event.timeStamp;

    trackingClickStart = this.trackingClickStart;
    this.trackingClick = false;
    this.trackingClickStart = 0;

    // On some iOS devices, the targetElement supplied with the event is invalid if the layer
    // is performing a transition or scroll, and has to be re-detected manually. Note that
    // for this to function correctly, it must be called *after* the event target is checked!
    // See issue #57; also filed as rdar://13048589 .
    if (deviceIsIOSWithBadTarget) {
      touch = event.changedTouches[0];

      // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
      targetElement =
        document.elementFromPoint(
          touch.pageX - window.pageXOffset,
          touch.pageY - window.pageYOffset
        ) || targetElement;
      targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
    }

    targetTagName = targetElement.tagName.toLowerCase();
    if (targetTagName === 'label') {
      forElement = this.findControl(targetElement);
      if (forElement) {
        this.focus(targetElement);
        if (deviceIsAndroid) {
          return false;
        }

        targetElement = forElement;
      }
    } else if (this.needsFocus(targetElement)) {
      // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
      // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
      if (
        event.timeStamp - trackingClickStart > 100 ||
        (deviceIsIOS && window.top !== window && targetTagName === 'input')
      ) {
        this.targetElement = null;
        return false;
      }

      this.focus(targetElement);
      this.sendClick(targetElement, event);

      // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
      // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
      if (!deviceIsIOS || targetTagName !== 'select') {
        this.targetElement = null;
        event.preventDefault();
      }

      return false;
    }

    if (deviceIsIOS && !deviceIsIOS4) {
      // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
      // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
      scrollParent = targetElement.fastClickScrollParent;
      if (
        scrollParent &&
        scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop
      ) {
        return true;
      }
    }

    // Prevent the actual click from going though - unless the target node is marked as requiring
    // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
    if (!this.needsClick(targetElement)) {
      event.preventDefault();
      this.sendClick(targetElement, event);
    }

    return false;
  };

  /**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */
  FastClick.prototype.onTouchCancel = function() {
    this.trackingClick = false;
    this.targetElement = null;
  };

  /**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onMouse = function(event) {
    // If a target element was never set (because a touch event was never fired) allow the event
    if (!this.targetElement) {
      return true;
    }

    if (event.forwardedTouchEvent) {
      return true;
    }

    // Programmatically generated events targeting a specific element should be permitted
    if (!event.cancelable) {
      return true;
    }

    // Derive and check the target element to see whether the mouse event needs to be permitted;
    // unless explicitly enabled, prevent non-touch click events from triggering actions,
    // to prevent ghost/doubleclicks.
    if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
      // Prevent any user-added listeners declared on FastClick element from being fired.
      if (event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      } else {
        // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        event.propagationStopped = true;
      }

      // Cancel the event
      event.stopPropagation();
      event.preventDefault();

      return false;
    }

    // If the mouse event is permitted, return true for the action to go through.
    return true;
  };

  /**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
  FastClick.prototype.onClick = function(event) {
    var permitted;

    // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
    if (this.trackingClick) {
      this.targetElement = null;
      this.trackingClick = false;
      return true;
    }

    // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
    if (event.target.type === 'submit' && event.detail === 0) {
      return true;
    }

    permitted = this.onMouse(event);

    // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
    if (!permitted) {
      this.targetElement = null;
    }

    // If clicks are permitted, return true for the action to go through.
    return permitted;
  };

  /**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */
  FastClick.prototype.destroy = function() {
    var layer = this.layer;

    if (deviceIsAndroid) {
      layer.removeEventListener('mouseover', this.onMouse, true);
      layer.removeEventListener('mousedown', this.onMouse, true);
      layer.removeEventListener('mouseup', this.onMouse, true);
    }

    layer.removeEventListener('click', this.onClick, true);
    layer.removeEventListener('touchstart', this.onTouchStart, false);
    layer.removeEventListener('touchmove', this.onTouchMove, false);
    layer.removeEventListener('touchend', this.onTouchEnd, false);
    layer.removeEventListener('touchcancel', this.onTouchCancel, false);
  };

  /**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */
  FastClick.notNeeded = function(layer) {
    var metaViewport;
    var chromeVersion;
    var blackberryVersion;
    var firefoxVersion;

    // Devices that don't support touch don't need FastClick
    if (typeof window.ontouchstart === 'undefined') {
      return true;
    }

    // Chrome version - zero for other browsers
    chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

    if (chromeVersion) {
      if (deviceIsAndroid) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          }
          // Chrome 32 and above with width=device-width or less don't need FastClick
          if (
            chromeVersion > 31 &&
            document.documentElement.scrollWidth <= window.outerWidth
          ) {
            return true;
          }
        }

        // Chrome desktop doesn't need FastClick (issue #15)
      } else {
        return true;
      }
    }

    if (deviceIsBlackBerry10) {
      blackberryVersion = navigator.userAgent.match(
        /Version\/([0-9]*)\.([0-9]*)/
      );

      // BlackBerry 10.3+ does not require Fastclick library.
      // https://github.com/ftlabs/fastclick/issues/251
      if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // user-scalable=no eliminates click delay.
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          }
          // width=device-width (or less than device-width) eliminates click delay.
          if (document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        }
      }
    }

    // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
    if (
      layer.style.msTouchAction === 'none' ||
      layer.style.touchAction === 'manipulation'
    ) {
      return true;
    }

    // Firefox version - zero for other browsers
    firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [
      ,
      0,
    ])[1];

    if (firefoxVersion >= 27) {
      // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

      metaViewport = document.querySelector('meta[name=viewport]');
      if (
        metaViewport &&
        (metaViewport.content.indexOf('user-scalable=no') !== -1 ||
          document.documentElement.scrollWidth <= window.outerWidth)
      ) {
        return true;
      }
    }

    // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
    // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
    if (
      layer.style.touchAction === 'none' ||
      layer.style.touchAction === 'manipulation'
    ) {
      return true;
    }

    return false;
  };

  /**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
  FastClick.attach = function(layer, options) {
    return new FastClick(layer, options);
  };

  /* WSP Addition: target the window, add noConflict() support
    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
  
      // AMD. Register as an anonymous module.
      define(function() {
        return FastClick;
      });
    } else if (typeof module !== 'undefined' && module.exports) {
      module.exports = FastClick.attach;
      module.exports.FastClick = FastClick;
    } else {
        var origFastClick = window.FastClick;
        FastClick.noConflict = function() {
          window.FastClick = origFastClick;
          return FastClick;
        };
        */
  var origFastClick = window.FastClick;
  FastClick.noConflict = function() {
    window.FastClick = origFastClick;
    return FastClick;
  };
  window.FastClick = FastClick;
})();
// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4

// ADDED by Sketchpad
(function() {
  var origLZString = window.LZString;

  var LZString = (function() {
    // private property
    var f = String.fromCharCode;
    var keyStrBase64 =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var keyStrUriSafe =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$';
    var baseReverseDic = {};

    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i = 0; i < alphabet.length; i++) {
          baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
      }
      return baseReverseDic[alphabet][character];
    }

    var LZString = {
      compressToBase64: function(input) {
        if (input == null) return '';
        var res = LZString._compress(input, 6, function(a) {
          return keyStrBase64.charAt(a);
        });
        switch (
          res.length % 4 // To produce valid Base64
        ) {
          default: // When could this happen ?
          case 0:
            return res;
          case 1:
            return res + '===';
          case 2:
            return res + '==';
          case 3:
            return res + '=';
        }
      },

      decompressFromBase64: function(input) {
        if (input == null) return '';
        if (input == '') return null;
        return LZString._decompress(input.length, 32, function(index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },

      compressToUTF16: function(input) {
        if (input == null) return '';
        return (
          LZString._compress(input, 15, function(a) {
            return f(a + 32);
          }) + ' '
        );
      },

      decompressFromUTF16: function(compressed) {
        if (compressed == null) return '';
        if (compressed == '') return null;
        return LZString._decompress(compressed.length, 16384, function(index) {
          return compressed.charCodeAt(index) - 32;
        });
      },

      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(uncompressed) {
        var compressed = LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2); // 2 bytes per character

        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
          var current_value = compressed.charCodeAt(i);
          buf[i * 2] = current_value >>> 8;
          buf[i * 2 + 1] = current_value % 256;
        }
        return buf;
      },

      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(compressed) {
        if (compressed === null || compressed === undefined) {
          return LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2); // 2 bytes per character
          for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
          }

          var result = [];
          buf.forEach(function(c) {
            result.push(f(c));
          });
          return LZString.decompress(result.join(''));
        }
      },

      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(input) {
        if (input == null) return '';
        return LZString._compress(input, 6, function(a) {
          return keyStrUriSafe.charAt(a);
        });
      },

      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(input) {
        if (input == null) return '';
        if (input == '') return null;
        input = input.replace(/ /g, '+');
        return LZString._decompress(input.length, 32, function(index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },

      compress: function(uncompressed) {
        return LZString._compress(uncompressed, 16, function(a) {
          return f(a);
        });
      },
      _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null) return '';
        var i,
          value,
          context_dictionary = {},
          context_dictionaryToCreate = {},
          context_c = '',
          context_wc = '',
          context_w = '',
          context_enlargeIn = 2, // Compensate for the first entry which should not count
          context_dictSize = 3,
          context_numBits = 2,
          context_data = [],
          context_data_val = 0,
          context_data_position = 0,
          ii;

        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (
            !Object.prototype.hasOwnProperty.call(context_dictionary, context_c)
          ) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }

          context_wc = context_w + context_c;
          if (
            Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)
          ) {
            context_w = context_wc;
          } else {
            if (
              Object.prototype.hasOwnProperty.call(
                context_dictionaryToCreate,
                context_w
              )
            ) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1) | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            // Add wc to the dictionary.
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }

        // Output the code for w.
        if (context_w !== '') {
          if (
            Object.prototype.hasOwnProperty.call(
              context_dictionaryToCreate,
              context_w
            )
          ) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }

        // Mark the end of the stream
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }

        // Flush the last char
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else context_data_position++;
        }
        return context_data.join('');
      },

      decompress: function(compressed) {
        if (compressed == null) return '';
        if (compressed == '') return null;
        return LZString._decompress(compressed.length, 32768, function(index) {
          return compressed.charCodeAt(index);
        });
      },

      _decompress: function(length, resetValue, getNextValue) {
        var dictionary = [],
          next,
          enlargeIn = 4,
          dictSize = 4,
          numBits = 3,
          entry = '',
          result = [],
          i,
          w,
          bits,
          resb,
          maxpower,
          power,
          c,
          data = { val: getNextValue(0), position: resetValue, index: 1 };

        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }

        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }

        switch ((next = bits)) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 2:
            return '';
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return '';
          }

          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }

          switch ((c = bits)) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }

              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join('');
          }

          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }

          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);

          // Add w+entry[0] to the dictionary.
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;

          w = entry;

          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      },
    };
    return LZString;
  })();

  LZString.noConflict = function() {
    window.LZString = origLZString;
    return LZString;
  };

  window.LZString = LZString;
})(); /*
      json2.js
      
      This is a customized version of Crockford's JSON.stringify() polyfill which
      outputs attributes in canonical order. This allows the output to be hashed
      consistently which can then be used to test whether a JavaScript object has
      changed by testing whether the hash of its canonical JSON representation
      has changed.
      
      This module creates a JSONcanonical object with a single stringify() method
      which has all of the standard behavior of JSON.stringify() but which outputs
      its attributes in canonical order.
  
      json2.js
      2013-05-26
  
      Public Domain.
  
      NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
  
      See http://www.JSON.org/js.html
  
  
      This code should be minified before deployment.
      See http://javascript.crockford.com/jsmin.html
  
      USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
      NOT CONTROL.
  
  
      This file creates a global JSON object containing two methods: stringify
      and parse.
  
          JSON.stringify(value, replacer, space)
              value       any JavaScript value, usually an object or array.
  
              replacer    an optional parameter that determines how object
                          values are stringified for objects. It can be a
                          function or an array of strings.
  
              space       an optional parameter that specifies the indentation
                          of nested structures. If it is omitted, the text will
                          be packed without extra whitespace. If it is a number,
                          it will specify the number of spaces to indent at each
                          level. If it is a string (such as '\t' or '&nbsp;'),
                          it contains the characters used to indent at each level.
  
              This method produces a JSON text from a JavaScript value.
  
              When an object value is found, if the object contains a toJSON
              method, its toJSON method will be called and the result will be
              stringified. A toJSON method does not serialize: it returns the
              value represented by the name/value pair that should be serialized,
              or undefined if nothing should be serialized. The toJSON method
              will be passed the key associated with the value, and this will be
              bound to the value
  
              For example, this would serialize Dates as ISO strings.
  
                  Date.prototype.toJSON = function (key) {
                      function f(n) {
                          // Format integers to have at least two digits.
                          return n < 10 ? '0' + n : n;
                      }
  
                      return this.getUTCFullYear()   + '-' +
                           f(this.getUTCMonth() + 1) + '-' +
                           f(this.getUTCDate())      + 'T' +
                           f(this.getUTCHours())     + ':' +
                           f(this.getUTCMinutes())   + ':' +
                           f(this.getUTCSeconds())   + 'Z';
                  };
  
              You can provide an optional replacer method. It will be passed the
              key and value of each member, with this bound to the containing
              object. The value that is returned from your method will be
              serialized. If your method returns undefined, then the member will
              be excluded from the serialization.
  
              If the replacer parameter is an array of strings, then it will be
              used to select the members to be serialized. It filters the results
              such that only members with keys listed in the replacer array are
              stringified.
  
              Values that do not have JSON representations, such as undefined or
              functions, will not be serialized. Such values in objects will be
              dropped; in arrays they will be replaced with null. You can use
              a replacer function to replace those with JSON values.
              JSON.stringify(undefined) returns undefined.
  
              The optional space parameter produces a stringification of the
              value that is filled with line breaks and indentation to make it
              easier to read.
  
              If the space parameter is a non-empty string, then that string will
              be used for indentation. If the space parameter is a number, then
              the indentation will be that many spaces.
  
              Example:
  
              text = JSON.stringify(['e', {pluribus: 'unum'}]);
              // text is '["e",{"pluribus":"unum"}]'
  
  
              text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
              // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'
  
              text = JSON.stringify([new Date()], function (key, value) {
                  return this[key] instanceof Date ?
                      'Date(' + this[key] + ')' : value;
              });
              // text is '["Date(---current time---)"]'
  
  
      This is a reference implementation. You are free to copy, modify, or
      redistribute.
  */

/* REMOVED by sketchpad 
  if (typeof define === 'function' && define.amd) {
    define(function () { return LZString; });
  } else if( typeof module !== 'undefined' && module != null ) {
    module.exports = LZString
  }
  
  */ /*jshint -W036 */
/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
      call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
      getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
      lastIndex, length, parse, prototype, push, replace, slice, stringify,
      test, toJSON, toString, valueOf
  */

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.
/*global JSONcanonical:true */
if (typeof JSONcanonical !== 'object') {
  JSONcanonical = {};
}

(function() {
  'use strict';

  function f(n) {
    // Format integers to have at least two digits.
    return n < 10 ? '0' + n : n;
  }

  if (typeof Date.prototype.toJSON !== 'function') {
    Date.prototype.toJSON = function() {
      return isFinite(this.valueOf())
        ? this.getUTCFullYear() +
            '-' +
            f(this.getUTCMonth() + 1) +
            '-' +
            f(this.getUTCDate()) +
            'T' +
            f(this.getUTCHours()) +
            ':' +
            f(this.getUTCMinutes()) +
            ':' +
            f(this.getUTCSeconds()) +
            'Z'
        : null;
    };

    String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
      return this.valueOf();
    };
  }

  var //cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {
      // table of character substitutions
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '\\': '\\\\',
    },
    rep;

  function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.

    escapable.lastIndex = 0;
    return escapable.test(string)
      ? '"' +
          string.replace(escapable, function(a) {
            var c = meta[a];
            return typeof c === 'string'
              ? c
              : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          }) +
          '"'
      : '"' + string + '"';
  }

  function str(key, holder) {
    // Produce a string from holder[key].

    var i, // The loop counter.
      k, // The member key.
      v, // The member value.
      length,
      mind = gap,
      partial,
      value = holder[key];

    // If the value has a toJSON method, call it to obtain a replacement value.

    if (
      value &&
      typeof value === 'object' &&
      typeof value.toJSON === 'function'
    ) {
      value = value.toJSON(key);
    }

    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.

    if (typeof rep === 'function') {
      value = rep.call(holder, key, value);
    }

    // What happens next depends on the value's type.

    switch (typeof value) {
      case 'string':
        return quote(value);

      case 'number':
        // JSON numbers must be finite. Encode non-finite numbers as null.
        return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':
        // If the value is a boolean or null, convert it to a string. Note:
        // typeof null does not produce 'null'. The case is included here in
        // the remote chance that this gets fixed someday.

        return String(value);

      // If the type is 'object', we might be dealing with an object or an array or
      // null.

      case 'object':
        // Due to a specification blunder in ECMAScript, typeof null is 'object',
        // so watch out for that case.

        if (!value) {
          return 'null';
        }

        // Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

        // Is the value an array?

        if (Object.prototype.toString.apply(value) === '[object Array]') {
          // The value is an array. Stringify every element. Use null as a placeholder
          // for non-JSON values.

          length = value.length;
          for (i = 0; i < length; i += 1) {
            partial[i] = str(i, value) || 'null';
          }

          // Join all of the elements together, separated with commas, and wrap them in
          // brackets.

          v =
            partial.length === 0
              ? '[]'
              : gap
              ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
              : '[' + partial.join(',') + ']';
          gap = mind;
          return v;
        }

        // If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === 'object') {
          length = rep.length;
          for (i = 0; i < length; i += 1) {
            if (typeof rep[i] === 'string') {
              k = rep[i];
              v = str(k, value);
              if (v) {
                partial.push(quote(k) + (gap ? ': ' : ':') + v);
              }
            }
          }
        } else {
          // Otherwise, iterate through all of the keys in the object.
          // [KCPT] Make an array of keys, sort the array, and then loop over our sorted
          // array so we can guarantee order, which is otherwise not guaranteed.
          var compareKeys = function(iKey1, iKey2) {
            var number1 = Number(iKey1),
              number2 = Number(iKey2),
              isNumber1 = isFinite(number1),
              isNumber2 = isFinite(number2);
            // Both numbers, sort numerically
            if (isNumber1 && isNumber2) {
              return number1 < number2 ? -1 : number1 > number2 ? 1 : 0;
            }
            // Numbers sort before strings
            if (isNumber1) return -1;
            if (isNumber2) return 1;
            // Both strings, sort lexically
            return iKey1 < iKey2 ? -1 : iKey1 > iKey2 ? 1 : 0;
          };

          var keys = [],
            keyCount,
            index;
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              keys.push(k);
            }
          }
          keys.sort(compareKeys);
          keyCount = keys.length;

          for (index = 0; index < keyCount; ++index) {
            k = keys[index];
            v = str(k, value);
            if (v) {
              partial.push(quote(k) + (gap ? ': ' : ':') + v);
            }
          }
        }
        // [/KCPT]

        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v =
          partial.length === 0
            ? '{}'
            : gap
            ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
            : '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
  }

  // If the JSON object does not yet have a stringify method, give it one.

  if (typeof JSONcanonical.stringify !== 'function') {
    JSONcanonical.stringify = function(value, replacer, space) {
      // The stringify method takes a value and an optional replacer, and an optional
      // space parameter, and returns a JSON text. The replacer can be a function
      // that can replace values, or an array of strings that will select the keys.
      // A default replacer method can be provided. Use of the space parameter can
      // produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

      // If the space parameter is a number, make an indent string containing that
      // many spaces.

      if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
          indent += ' ';
        }

        // If the space parameter is a string, it will be used as the indent string.
      } else if (typeof space === 'string') {
        indent = space;
      }

      // If there is a replacer, it must be a function or an array.
      // Otherwise, throw an error.

      rep = replacer;
      if (
        replacer &&
        typeof replacer !== 'function' &&
        (typeof replacer !== 'object' || typeof replacer.length !== 'number')
      ) {
        throw new Error('JSON.stringify');
      }

      // Make a fake root object containing our value under the key of ''.
      // Return the result of stringifying the value.

      return str('', { '': value });
    };
  }
})();

!(function(e) {
  if (
    'object disable exports' == typeof exports &&
    'undefined' != typeof module
  )
    module.exports = e();
  else if ('function disable define' == typeof define && define.amd)
    define([], e);
  else {
    var f;
    'undefined' != typeof window
      ? (f = window)
      : 'undefined' != typeof global
      ? (f = global)
      : 'undefined' != typeof self && (f = self),
      (f.jsondiffpatch = e());
  }
})(function() {
  var define, module, exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw ((f.code = 'MODULE_NOT_FOUND'), f);
        }
        var l = (n[o] = { exports: {} });
        t[o][0].call(
          l.exports,
          function(e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          },
          l,
          l.exports,
          e,
          t,
          n,
          r
        );
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
  })(
    {
      1: [
        function(require, module, exports) {
          (function(e) {
            var r = require('./diffpatcher').DiffPatcher;
            (exports.DiffPatcher = r),
              (exports.create = function(e) {
                return new r(e);
              }),
              (exports.dateReviver = require('./date-reviver'));
            var t;
            if (
              ((exports.diff = function() {
                return t || (t = new r()), t.diff.apply(t, arguments);
              }),
              (exports.patch = function() {
                return t || (t = new r()), t.patch.apply(t, arguments);
              }),
              (exports.unpatch = function() {
                return t || (t = new r()), t.unpatch.apply(t, arguments);
              }),
              (exports.reverse = function() {
                return t || (t = new r()), t.reverse.apply(t, arguments);
              }),
              e.browser)
            )
              (exports.homepage = 'https://github.com/benjamine/jsondiffpatch'),
                (exports.version = '0.1.22');
            else {
              var o = '../package.json',
                a = require(o);
              (exports.homepage = a.homepage), (exports.version = a.version);
              var n = './formatters',
                p = require(n);
              (exports.formatters = p), (exports.console = p.console);
            }
          }.call(this, require('_process')));
        },
        { './date-reviver': 7, './diffpatcher': 8, _process: 2 },
      ],
      2: [
        function(require, module, exports) {
          function noop() {}
          var process = (module.exports = {});
          (process.nextTick = (function() {
            var o = 'undefined' != typeof window && window.setImmediate,
              e =
                'undefined' != typeof window &&
                window.postMessage &&
                window.addEventListener;
            if (o)
              return function(o) {
                return window.setImmediate(o);
              };
            if (e) {
              var s = [];
              return (
                window.addEventListener(
                  'message',
                  function(o) {
                    var e = o.source;
                    if (
                      (e === window || null === e) &&
                      'process-tick' === o.data &&
                      (o.stopPropagation(), s.length > 0)
                    ) {
                      var n = s.shift();
                      n();
                    }
                  },
                  !0
                ),
                function(o) {
                  s.push(o), window.postMessage('process-tick', '*');
                }
              );
            }
            return function(o) {
              setTimeout(o, 0);
            };
          })()),
            (process.title = 'browser'),
            (process.browser = !0),
            (process.env = {}),
            (process.argv = []),
            (process.on = noop),
            (process.addListener = noop),
            (process.once = noop),
            (process.off = noop),
            (process.removeListener = noop),
            (process.removeAllListeners = noop),
            (process.emit = noop),
            (process.binding = function() {
              throw new Error('process.binding is not supported');
            }),
            (process.cwd = function() {
              return '/';
            }),
            (process.chdir = function() {
              throw new Error('process.chdir is not supported');
            });
        },
        {},
      ],
      3: [
        function(require, module, exports) {
          var Pipe = require('../pipe').Pipe,
            Context = function() {};
          (Context.prototype.setResult = function(t) {
            return (this.result = t), (this.hasResult = !0), this;
          }),
            (Context.prototype.exit = function() {
              return (this.exiting = !0), this;
            }),
            (Context.prototype.switchTo = function(t, e) {
              return (
                'string' == typeof t || t instanceof Pipe
                  ? (this.nextPipe = t)
                  : ((this.next = t), e && (this.nextPipe = e)),
                this
              );
            }),
            (Context.prototype.push = function(t, e) {
              return (
                (t.parent = this),
                'undefined' != typeof e && (t.childName = e),
                (t.root = this.root || this),
                (t.options = t.options || this.options),
                this.children
                  ? ((this.children[this.children.length - 1].next = t),
                    this.children.push(t))
                  : ((this.children = [t]),
                    (this.nextAfterChildren = this.next || null),
                    (this.next = t)),
                (t.next = this),
                this
              );
            }),
            (exports.Context = Context);
        },
        { '../pipe': 15 },
      ],
      4: [
        function(require, module, exports) {
          var Context = require('./context').Context,
            DiffContext = function(t, e) {
              (this.left = t), (this.right = e), (this.pipe = 'diff');
            };
          (DiffContext.prototype = new Context()),
            (exports.DiffContext = DiffContext);
        },
        { './context': 3 },
      ],
      5: [
        function(require, module, exports) {
          var Context = require('./context').Context,
            PatchContext = function(t, e) {
              (this.left = t), (this.delta = e), (this.pipe = 'patch');
            };
          (PatchContext.prototype = new Context()),
            (exports.PatchContext = PatchContext);
        },
        { './context': 3 },
      ],
      6: [
        function(require, module, exports) {
          var Context = require('./context').Context,
            ReverseContext = function(e) {
              (this.delta = e), (this.pipe = 'reverse');
            };
          (ReverseContext.prototype = new Context()),
            (exports.ReverseContext = ReverseContext);
        },
        { './context': 3 },
      ],
      7: [
        function(require, module, exports) {
          module.exports = function(d, e) {
            var t;
            return 'string' == typeof e &&
              (t = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+\-])(\d{2}):(\d{2}))$/.exec(
                e
              ))
              ? new Date(
                  Date.UTC(
                    +t[1],
                    +t[2] - 1,
                    +t[3],
                    +t[4],
                    +t[5],
                    +t[6],
                    +(t[7] || 0)
                  )
                )
              : e;
          };
        },
        {},
      ],
      8: [
        function(require, module, exports) {
          var Processor = require('./processor').Processor,
            Pipe = require('./pipe').Pipe,
            DiffContext = require('./contexts/diff').DiffContext,
            PatchContext = require('./contexts/patch').PatchContext,
            ReverseContext = require('./contexts/reverse').ReverseContext,
            trivial = require('./filters/trivial'),
            nested = require('./filters/nested'),
            arrays = require('./filters/arrays'),
            dates = require('./filters/dates'),
            texts = require('./filters/texts'),
            DiffPatcher = function(e) {
              (this.processor = new Processor(e)),
                this.processor.pipe(
                  new Pipe('diff')
                    .append(
                      nested.collectChildrenDiffFilter,
                      trivial.diffFilter,
                      dates.diffFilter,
                      texts.diffFilter,
                      nested.objectsDiffFilter,
                      arrays.diffFilter
                    )
                    .shouldHaveResult()
                ),
                this.processor.pipe(
                  new Pipe('patch')
                    .append(
                      nested.collectChildrenPatchFilter,
                      arrays.collectChildrenPatchFilter,
                      trivial.patchFilter,
                      texts.patchFilter,
                      nested.patchFilter,
                      arrays.patchFilter
                    )
                    .shouldHaveResult()
                ),
                this.processor.pipe(
                  new Pipe('reverse')
                    .append(
                      nested.collectChildrenReverseFilter,
                      arrays.collectChildrenReverseFilter,
                      trivial.reverseFilter,
                      texts.reverseFilter,
                      nested.reverseFilter,
                      arrays.reverseFilter
                    )
                    .shouldHaveResult()
                );
            };
          (DiffPatcher.prototype.options = function() {
            return this.processor.options.apply(this.processor, arguments);
          }),
            (DiffPatcher.prototype.diff = function(e, r) {
              return this.processor.process(new DiffContext(e, r));
            }),
            (DiffPatcher.prototype.patch = function(e, r) {
              return this.processor.process(new PatchContext(e, r));
            }),
            (DiffPatcher.prototype.reverse = function(e) {
              return this.processor.process(new ReverseContext(e));
            }),
            (DiffPatcher.prototype.unpatch = function(e, r) {
              return this.patch(e, this.reverse(r));
            }),
            (exports.DiffPatcher = DiffPatcher);
        },
        {
          './contexts/diff': 4,
          './contexts/patch': 5,
          './contexts/reverse': 6,
          './filters/arrays': 9,
          './filters/dates': 10,
          './filters/nested': 12,
          './filters/texts': 13,
          './filters/trivial': 14,
          './pipe': 15,
          './processor': 16,
        },
      ],
      9: [
        function(require, module, exports) {
          var DiffContext = require('../contexts/diff').DiffContext,
            PatchContext = require('../contexts/patch').PatchContext,
            ReverseContext = require('../contexts/reverse').ReverseContext,
            lcs = require('./lcs'),
            ARRAY_MOVE = 3,
            isArray =
              'function' == typeof Array.isArray
                ? Array.isArray
                : function(e) {
                    return e instanceof Array;
                  },
            arrayIndexOf =
              'function' == typeof Array.prototype.indexOf
                ? function(e, r) {
                    return e.indexOf(r);
                  }
                : function(e, r) {
                    for (var t = e.length, i = 0; t > i; i++)
                      if (e[i] === r) return i;
                    return -1;
                  },
            diffFilter = function(e) {
              if (e.leftIsArray) {
                for (
                  var r,
                    t,
                    i,
                    n,
                    a = e.options && e.options.objectHash,
                    l = function(e, r, t, i, n) {
                      var l = e[t],
                        s = r[i];
                      if (l === s) return !0;
                      if ('object' != typeof l || 'object' != typeof s)
                        return !1;
                      if (!a) return !1;
                      var o, f;
                      return (
                        'number' == typeof t
                          ? ((n.hashCache1 = n.hashCache1 || []),
                            (o = n.hashCache1[t]),
                            'undefined' == typeof o &&
                              (n.hashCache1[t] = o = a(l, t)))
                          : (o = a(l)),
                        'undefined' == typeof o
                          ? !1
                          : ('number' == typeof i
                              ? ((n.hashCache2 = n.hashCache2 || []),
                                (f = n.hashCache2[i]),
                                'undefined' == typeof f &&
                                  (n.hashCache2[i] = f = a(s, i)))
                              : (f = a(s)),
                            'undefined' == typeof f ? !1 : o === f)
                      );
                    },
                    s = {},
                    o = 0,
                    f = 0,
                    c = e.left,
                    h = e.right,
                    d = c.length,
                    u = h.length;
                  d > o && u > o && l(c, h, o, o, s);

                )
                  (r = o),
                    (n = new DiffContext(e.left[r], e.right[r])),
                    e.push(n, r),
                    o++;
                for (
                  ;
                  d > f + o && u > f + o && l(c, h, d - 1 - f, u - 1 - f, s);

                )
                  (t = d - 1 - f),
                    (i = u - 1 - f),
                    (n = new DiffContext(e.left[t], e.right[i])),
                    e.push(n, i),
                    f++;
                var v;
                if (o + f === d) {
                  if (d === u) return void e.setResult(void 0).exit();
                  for (v = v || { _t: 'a' }, r = o; u - f > r; r++)
                    v[r] = [h[r]];
                  return void e.setResult(v).exit();
                }
                if (o + f === u) {
                  for (v = v || { _t: 'a' }, r = o; d - f > r; r++)
                    v['_' + r] = [c[r], 0, 0];
                  return void e.setResult(v).exit();
                }
                s = {};
                var p = c.slice(o, d - f),
                  y = h.slice(o, u - f),
                  x = lcs.get(p, y, l, s),
                  C = [];
                for (v = v || { _t: 'a' }, r = o; d - f > r; r++)
                  arrayIndexOf(x.indices1, r - o) < 0 &&
                    ((v['_' + r] = [c[r], 0, 0]), C.push(r));
                var R = !0;
                e.options &&
                  e.options.arrays &&
                  e.options.arrays.detectMove === !1 &&
                  (R = !1);
                var A = !1;
                e.options &&
                  e.options.arrays &&
                  e.options.arrays.includeValueOnMove &&
                  (A = !0);
                var _ = C.length;
                for (r = o; u - f > r; r++) {
                  var m = arrayIndexOf(x.indices2, r - o);
                  if (0 > m) {
                    var F = !1;
                    if (R && _ > 0)
                      for (var g = 0; _ > g; g++)
                        if (((t = C[g]), l(p, y, t - o, r - o, s))) {
                          v['_' + t].splice(1, 2, r, ARRAY_MOVE),
                            A || (v['_' + t][0] = ''),
                            (i = r),
                            (n = new DiffContext(e.left[t], e.right[i])),
                            e.push(n, i),
                            C.splice(g, 1),
                            (F = !0);
                          break;
                        }
                    F || (v[r] = [h[r]]);
                  } else
                    (t = x.indices1[m] + o),
                      (i = x.indices2[m] + o),
                      (n = new DiffContext(e.left[t], e.right[i])),
                      e.push(n, i);
                }
                e.setResult(v).exit();
              }
            };
          diffFilter.filterName = 'arrays';
          var compare = {
              numerically: function(e, r) {
                return e - r;
              },
              numericallyBy: function(e) {
                return function(r, t) {
                  return r[e] - t[e];
                };
              },
            },
            patchFilter = function(e) {
              if (e.nested && 'a' === e.delta._t) {
                var r,
                  t,
                  i = e.delta,
                  n = e.left,
                  a = [],
                  l = [],
                  s = [];
                for (r in i)
                  if ('_t' !== r)
                    if ('_' === r[0]) {
                      if (0 !== i[r][2] && i[r][2] !== ARRAY_MOVE)
                        throw new Error(
                          'only removal or move can be applied at original array indices, invalid diff type: ' +
                            i[r][2]
                        );
                      a.push(parseInt(r.slice(1), 10));
                    } else
                      1 === i[r].length
                        ? l.push({ index: parseInt(r, 10), value: i[r][0] })
                        : s.push({ index: parseInt(r, 10), delta: i[r] });
                for (
                  a = a.sort(compare.numerically), r = a.length - 1;
                  r >= 0;
                  r--
                ) {
                  t = a[r];
                  var o = i['_' + t],
                    f = n.splice(t, 1)[0];
                  o[2] === ARRAY_MOVE && l.push({ index: o[1], value: f });
                }
                l = l.sort(compare.numericallyBy('index'));
                var c = l.length;
                for (r = 0; c > r; r++) {
                  var h = l[r];
                  n.splice(h.index, 0, h.value);
                }
                var d,
                  u = s.length;
                if (u > 0)
                  for (r = 0; u > r; r++) {
                    var v = s[r];
                    (d = new PatchContext(e.left[v.index], v.delta)),
                      e.push(d, v.index);
                  }
                return e.children
                  ? void e.exit()
                  : void e.setResult(e.left).exit();
              }
            };
          patchFilter.filterName = 'arrays';
          var collectChildrenPatchFilter = function(e) {
            if (e && e.children && 'a' === e.delta._t) {
              for (var r, t = e.children.length, i = 0; t > i; i++)
                (r = e.children[i]), (e.left[r.childName] = r.result);
              e.setResult(e.left).exit();
            }
          };
          collectChildrenPatchFilter.filterName = 'arraysCollectChildren';
          var reverseFilter = function(e) {
            if (!e.nested)
              return void (
                e.delta[2] === ARRAY_MOVE &&
                ((e.newName = '_' + e.delta[1]),
                e
                  .setResult([
                    e.delta[0],
                    parseInt(e.childName.substr(1), 10),
                    ARRAY_MOVE,
                  ])
                  .exit())
              );
            if ('a' === e.delta._t) {
              var r, t;
              for (r in e.delta)
                '_t' !== r &&
                  ((t = new ReverseContext(e.delta[r])), e.push(t, r));
              e.exit();
            }
          };
          reverseFilter.filterName = 'arrays';
          var reverseArrayDeltaIndex = function(e, r, t) {
              var i = r;
              if ('string' == typeof r && '_' === r[0])
                i = parseInt(r.substr(1), 10);
              else {
                var n = '_' + r;
                if (isArray(t) && 0 === t[2]) i = n;
                else
                  for (var a in e) {
                    var l = e[a];
                    isArray(l) &&
                      l[2] === ARRAY_MOVE &&
                      l[1].toString() === r &&
                      (i = a.substr(1));
                  }
              }
              return i;
            },
            collectChildrenReverseFilter = function(e) {
              if (e && e.children && 'a' === e.delta._t) {
                for (
                  var r, t = e.children.length, i = { _t: 'a' }, n = 0;
                  t > n;
                  n++
                ) {
                  r = e.children[n];
                  var a = r.newName;
                  'undefined' == typeof a &&
                    (a = reverseArrayDeltaIndex(
                      e.delta,
                      r.childName,
                      r.result
                    )),
                    i[a] !== r.result && (i[a] = r.result);
                }
                e.setResult(i).exit();
              }
            };
          (collectChildrenReverseFilter.filterName = 'arraysCollectChildren'),
            (exports.diffFilter = diffFilter),
            (exports.patchFilter = patchFilter),
            (exports.collectChildrenPatchFilter = collectChildrenPatchFilter),
            (exports.reverseFilter = reverseFilter),
            (exports.collectChildrenReverseFilter = collectChildrenReverseFilter);
        },
        {
          '../contexts/diff': 4,
          '../contexts/patch': 5,
          '../contexts/reverse': 6,
          './lcs': 11,
        },
      ],
      10: [
        function(require, module, exports) {
          var diffFilter = function(t) {
            t.left instanceof Date
              ? (t.setResult(
                  t.right instanceof Date
                    ? t.left.getTime() !== t.right.getTime()
                      ? [t.left, t.right]
                      : void 0
                    : [t.left, t.right]
                ),
                t.exit())
              : t.right instanceof Date &&
                t.setResult([t.left, t.right]).exit();
          };
          (diffFilter.filterName = 'dates'), (exports.diffFilter = diffFilter);
        },
        {},
      ],
      11: [
        function(require, module, exports) {
          var defaultMatch = function(t, e, n, r) {
              return t[n] === e[r];
            },
            lengthMatrix = function(t, e, n, r) {
              var c,
                a,
                i = t.length,
                u = e.length,
                f = [i + 1];
              for (c = 0; i + 1 > c; c++)
                for (f[c] = [u + 1], a = 0; u + 1 > a; a++) f[c][a] = 0;
              for (f.match = n, c = 1; i + 1 > c; c++)
                for (a = 1; u + 1 > a; a++)
                  f[c][a] = n(t, e, c - 1, a - 1, r)
                    ? f[c - 1][a - 1] + 1
                    : Math.max(f[c - 1][a], f[c][a - 1]);
              return f;
            },
            backtrack = function(t, e, n, r, c, a) {
              if (0 === r || 0 === c)
                return { sequence: [], indices1: [], indices2: [] };
              if (t.match(e, n, r - 1, c - 1, a)) {
                var i = backtrack(t, e, n, r - 1, c - 1, a);
                return (
                  i.sequence.push(e[r - 1]),
                  i.indices1.push(r - 1),
                  i.indices2.push(c - 1),
                  i
                );
              }
              return t[r][c - 1] > t[r - 1][c]
                ? backtrack(t, e, n, r, c - 1, a)
                : backtrack(t, e, n, r - 1, c, a);
            },
            get = function(t, e, n, r) {
              r = r || {};
              var c = lengthMatrix(t, e, n || defaultMatch, r),
                a = backtrack(c, t, e, t.length, e.length, r);
              return (
                'string' == typeof t &&
                  'string' == typeof e &&
                  (a.sequence = a.sequence.join('')),
                a
              );
            };
          exports.get = get;
        },
        {},
      ],
      12: [
        function(require, module, exports) {
          var DiffContext = require('../contexts/diff').DiffContext,
            PatchContext = require('../contexts/patch').PatchContext,
            ReverseContext = require('../contexts/reverse').ReverseContext,
            collectChildrenDiffFilter = function(e) {
              if (e && e.children) {
                for (
                  var t, l = e.children.length, r = e.result, i = 0;
                  l > i;
                  i++
                )
                  (t = e.children[i]),
                    'undefined' != typeof t.result &&
                      ((r = r || {}), (r[t.childName] = t.result));
                r && e.leftIsArray && (r._t = 'a'), e.setResult(r).exit();
              }
            };
          collectChildrenDiffFilter.filterName = 'collectChildren';
          var objectsDiffFilter = function(e) {
            if (!e.leftIsArray && 'object' === e.leftType) {
              var t, l;
              for (t in e.left)
                (l = new DiffContext(e.left[t], e.right[t])), e.push(l, t);
              for (t in e.right)
                'undefined' == typeof e.left[t] &&
                  ((l = new DiffContext(void 0, e.right[t])), e.push(l, t));
              return e.children && 0 !== e.children.length
                ? void e.exit()
                : void e.setResult(void 0).exit();
            }
          };
          objectsDiffFilter.filterName = 'objects';
          var patchFilter = function(e) {
            if (e.nested && !e.delta._t) {
              var t, l;
              for (t in e.delta)
                (l = new PatchContext(e.left[t], e.delta[t])), e.push(l, t);
              e.exit();
            }
          };
          patchFilter.filterName = 'objects';
          var collectChildrenPatchFilter = function(e) {
            if (e && e.children && !e.delta._t) {
              for (var t, l = e.children.length, r = 0; l > r; r++)
                (t = e.children[r]),
                  e.left.hasOwnProperty(t.childName) && void 0 === t.result
                    ? delete e.left[t.childName]
                    : e.left[t.childName] !== t.result &&
                      (e.left[t.childName] = t.result);
              e.setResult(e.left).exit();
            }
          };
          collectChildrenPatchFilter.filterName = 'collectChildren';
          var reverseFilter = function(e) {
            if (e.nested && !e.delta._t) {
              var t, l;
              for (t in e.delta)
                (l = new ReverseContext(e.delta[t])), e.push(l, t);
              e.exit();
            }
          };
          reverseFilter.filterName = 'objects';
          var collectChildrenReverseFilter = function(e) {
            if (e && e.children && !e.delta._t) {
              for (var t, l = e.children.length, r = {}, i = 0; l > i; i++)
                (t = e.children[i]),
                  r[t.childName] !== t.result && (r[t.childName] = t.result);
              e.setResult(r).exit();
            }
          };
          (collectChildrenReverseFilter.filterName = 'collectChildren'),
            (exports.collectChildrenDiffFilter = collectChildrenDiffFilter),
            (exports.objectsDiffFilter = objectsDiffFilter),
            (exports.patchFilter = patchFilter),
            (exports.collectChildrenPatchFilter = collectChildrenPatchFilter),
            (exports.reverseFilter = reverseFilter),
            (exports.collectChildrenReverseFilter = collectChildrenReverseFilter);
        },
        {
          '../contexts/diff': 4,
          '../contexts/patch': 5,
          '../contexts/reverse': 6,
        },
      ],
      13: [
        function(require, module, exports) {
          var TEXT_DIFF = 2,
            DEFAULT_MIN_LENGTH = 60,
            cachedDiffPatch = null,
            getDiffMatchPatch = function() {
              if (!cachedDiffPatch) {
                var t;
                if ('undefined' != typeof diff_match_patch)
                  t =
                    'function' == typeof diff_match_patch
                      ? new diff_match_patch()
                      : new diff_match_patch.diff_match_patch();
                else if ('function' == typeof require)
                  try {
                    var e = 'diff_match_patch_uncompressed',
                      f = require('../../public/external/' + e);
                    t = new f.diff_match_patch();
                  } catch (i) {
                    t = null;
                  }
                if (!t) {
                  var r = new Error('text diff_match_patch library not found');
                  throw ((r.diff_match_patch_not_found = !0), r);
                }
                cachedDiffPatch = {
                  diff: function(e, f) {
                    return t.patch_toText(t.patch_make(e, f));
                  },
                  patch: function(e, f) {
                    for (
                      var i = t.patch_apply(t.patch_fromText(f), e), r = 0;
                      r < i[1].length;
                      r++
                    )
                      if (!i[1][r]) {
                        var a = new Error('text patch failed');
                        a.textPatchFailed = !0;
                      }
                    return i[0];
                  },
                };
              }
              return cachedDiffPatch;
            },
            diffFilter = function(t) {
              if ('string' === t.leftType) {
                var e =
                  (t.options &&
                    t.options.textDiff &&
                    t.options.textDiff.minLength) ||
                  DEFAULT_MIN_LENGTH;
                if (t.left.length < e || t.right.length < e)
                  return void t.setResult([t.left, t.right]).exit();
                var f = getDiffMatchPatch().diff;
                t.setResult([f(t.left, t.right), 0, TEXT_DIFF]).exit();
              }
            };
          diffFilter.filterName = 'texts';
          var patchFilter = function(t) {
            if (!t.nested && t.delta[2] === TEXT_DIFF) {
              var e = getDiffMatchPatch().patch;
              t.setResult(e(t.left, t.delta[0])).exit();
            }
          };
          patchFilter.filterName = 'texts';
          var textDeltaReverse = function(t) {
              var e,
                f,
                i,
                r,
                a,
                c,
                l,
                n,
                h = null,
                d = /^@@ +\-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
              for (i = t.split('\n'), e = 0, f = i.length; f > e; e++) {
                r = i[e];
                var o = r.slice(0, 1);
                '@' === o
                  ? ((h = d.exec(r)),
                    (c = e),
                    (l = null),
                    (n = null),
                    (i[c] =
                      '@@ -' +
                      h[3] +
                      ',' +
                      h[4] +
                      ' +' +
                      h[1] +
                      ',' +
                      h[2] +
                      ' @@'))
                  : '+' === o
                  ? ((l = e),
                    (i[e] = '-' + i[e].slice(1)),
                    '+' === i[e - 1].slice(0, 1) &&
                      ((a = i[e]), (i[e] = i[e - 1]), (i[e - 1] = a)))
                  : '-' === o && ((n = e), (i[e] = '+' + i[e].slice(1)));
              }
              return i.join('\n');
            },
            reverseFilter = function(t) {
              t.nested ||
                (t.delta[2] === TEXT_DIFF &&
                  t
                    .setResult([textDeltaReverse(t.delta[0]), 0, TEXT_DIFF])
                    .exit());
            };
          (reverseFilter.filterName = 'texts'),
            (exports.diffFilter = diffFilter),
            (exports.patchFilter = patchFilter),
            (exports.reverseFilter = reverseFilter);
        },
        {},
      ],
      14: [
        function(require, module, exports) {
          var isArray =
              'function' == typeof Array.isArray
                ? Array.isArray
                : function(e) {
                    return e instanceof Array;
                  },
            diffFilter = function(e) {
              if (e.left === e.right) return void e.setResult(void 0).exit();
              if ('undefined' == typeof e.left) {
                if ('function' == typeof e.right)
                  throw new Error('functions are not supported');
                return void e.setResult([e.right]).exit();
              }
              if ('undefined' == typeof e.right)
                return void e.setResult([e.left, 0, 0]).exit();
              if ('function' == typeof e.left || 'function' == typeof e.right)
                throw new Error('functions are not supported');
              return (
                (e.leftType = null === e.left ? 'null' : typeof e.left),
                (e.rightType = null === e.right ? 'null' : typeof e.right),
                e.leftType !== e.rightType
                  ? void e.setResult([e.left, e.right]).exit()
                  : 'boolean' === e.leftType || 'number' === e.leftType
                  ? void e.setResult([e.left, e.right]).exit()
                  : ('object' === e.leftType &&
                      (e.leftIsArray = isArray(e.left)),
                    'object' === e.rightType &&
                      (e.rightIsArray = isArray(e.right)),
                    e.leftIsArray !== e.rightIsArray
                      ? void e.setResult([e.left, e.right]).exit()
                      : void 0)
              );
            };
          diffFilter.filterName = 'trivial';
          var patchFilter = function(e) {
            return 'undefined' == typeof e.delta
              ? void e.setResult(e.left).exit()
              : ((e.nested = !isArray(e.delta)),
                e.nested
                  ? void 0
                  : 1 === e.delta.length
                  ? void e.setResult(e.delta[0]).exit()
                  : 2 === e.delta.length
                  ? void e.setResult(e.delta[1]).exit()
                  : 3 === e.delta.length && 0 === e.delta[2]
                  ? void e.setResult(void 0).exit()
                  : void 0);
          };
          patchFilter.filterName = 'trivial';
          var reverseFilter = function(e) {
            return 'undefined' == typeof e.delta
              ? void e.setResult(e.delta).exit()
              : ((e.nested = !isArray(e.delta)),
                e.nested
                  ? void 0
                  : 1 === e.delta.length
                  ? void e.setResult([e.delta[0], 0, 0]).exit()
                  : 2 === e.delta.length
                  ? void e.setResult([e.delta[1], e.delta[0]]).exit()
                  : 3 === e.delta.length && 0 === e.delta[2]
                  ? void e.setResult([e.delta[0]]).exit()
                  : void 0);
          };
          (reverseFilter.filterName = 'trivial'),
            (exports.diffFilter = diffFilter),
            (exports.patchFilter = patchFilter),
            (exports.reverseFilter = reverseFilter);
        },
        {},
      ],
      15: [
        function(require, module, exports) {
          var Pipe = function(t) {
            (this.name = t), (this.filters = []);
          };
          (Pipe.prototype.process = function(t) {
            if (!this.processor)
              throw new Error('add this pipe to a processor before using it');
            for (
              var e = this.debug, r = this.filters.length, i = t, s = 0;
              r > s;
              s++
            ) {
              var o = this.filters[s];
              if (
                (e && this.log('filter: ' + o.filterName),
                o(i),
                'object' == typeof i && i.exiting)
              ) {
                i.exiting = !1;
                break;
              }
            }
            !i.next && this.resultCheck && this.resultCheck(i);
          }),
            (Pipe.prototype.log = function(t) {
              console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + t);
            }),
            (Pipe.prototype.append = function() {
              return this.filters.push.apply(this.filters, arguments), this;
            }),
            (Pipe.prototype.prepend = function() {
              return this.filters.unshift.apply(this.filters, arguments), this;
            }),
            (Pipe.prototype.indexOf = function(t) {
              if (!t) throw new Error('a filter name is required');
              for (var e = 0; e < this.filters.length; e++) {
                var r = this.filters[e];
                if (r.filterName === t) return e;
              }
              throw new Error('filter not found: ' + t);
            }),
            (Pipe.prototype.list = function() {
              for (var t = [], e = 0; e < this.filters.length; e++) {
                var r = this.filters[e];
                t.push(r.filterName);
              }
              return t;
            }),
            (Pipe.prototype.after = function(t) {
              var e = this.indexOf(t),
                r = Array.prototype.slice.call(arguments, 1);
              if (!r.length) throw new Error('a filter is required');
              return (
                r.unshift(e + 1, 0),
                Array.prototype.splice.apply(this.filters, r),
                this
              );
            }),
            (Pipe.prototype.before = function(t) {
              var e = this.indexOf(t),
                r = Array.prototype.slice.call(arguments, 1);
              if (!r.length) throw new Error('a filter is required');
              return (
                r.unshift(e, 0),
                Array.prototype.splice.apply(this.filters, r),
                this
              );
            }),
            (Pipe.prototype.clear = function() {
              return (this.filters.length = 0), this;
            }),
            (Pipe.prototype.shouldHaveResult = function(t) {
              if (t === !1) return void (this.resultCheck = null);
              if (!this.resultCheck) {
                var e = this;
                return (
                  (this.resultCheck = function(t) {
                    if (!t.hasResult) {
                      console.log(t);
                      var r = new Error(e.name + ' failed');
                      throw ((r.noResult = !0), r);
                    }
                  }),
                  this
                );
              }
            }),
            (exports.Pipe = Pipe);
        },
        {},
      ],
      16: [
        function(require, module, exports) {
          var Processor = function(e) {
            (this.selfOptions = e), (this.pipes = {});
          };
          (Processor.prototype.options = function(e) {
            return e && (this.selfOptions = e), this.selfOptions;
          }),
            (Processor.prototype.pipe = function(e, t) {
              if ('string' == typeof e) {
                if ('undefined' == typeof t) return this.pipes[e];
                this.pipes[e] = t;
              }
              if (e && e.name) {
                if (((t = e), t.processor === this)) return t;
                this.pipes[t.name] = t;
              }
              return (t.processor = this), t;
            }),
            (Processor.prototype.process = function(e, t) {
              var s = e;
              s.options = this.options();
              for (var r, o, i = t || e.pipe || 'default'; i; )
                'undefined' != typeof s.nextAfterChildren &&
                  ((s.next = s.nextAfterChildren),
                  (s.nextAfterChildren = null)),
                  'string' == typeof i && (i = this.pipe(i)),
                  i.process(s),
                  (o = s),
                  (r = i),
                  (i = null),
                  s &&
                    s.next &&
                    ((s = s.next), (i = o.nextPipe || s.pipe || r));
              return s.hasResult ? s.result : void 0;
            }),
            (exports.Processor = Processor);
        },
        {},
      ],
    },
    {},
    [1]
  )(1);
});

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jshint bitwise:false */
/*jshint -W003 */
/*jshint -W064 */
/*jshint -W098 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad = ''; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s) {
  return rstr2hex(rstr_md5(str2rstr_utf8(s)));
}
function b64_md5(s) {
  return rstr2b64(rstr_md5(str2rstr_utf8(s)));
}
function any_md5(s, e) {
  return rstr2any(rstr_md5(str2rstr_utf8(s)), e);
}
function hex_hmac_md5(k, d) {
  return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function b64_hmac_md5(k, d) {
  return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function any_hmac_md5(k, d, e) {
  return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e);
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test() {
  return hex_md5('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s) {
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data) {
  var bkey = rstr2binl(key);
  if (bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16),
    opad = Array(16);
  for (var i = 0; i < 16; i++) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input) {
  var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef';
  var output = '';
  var x;
  for (var i = 0; i < input.length; i++) {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0f) + hex_tab.charAt(x & 0x0f);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input) {
  b64pad = b64pad || '';
  var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var output = '';
  var len = input.length;
  for (var i = 0; i < len; i += 3) {
    var triplet =
      (input.charCodeAt(i) << 16) |
      (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) |
      (i + 2 < len ? input.charCodeAt(i + 2) : 0);
    for (var j = 0; j < 4; j++) {
      if (i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> (6 * (3 - j))) & 0x3f);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding) {
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for (i = 0; i < dividend.length; i++) {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(
    (input.length * 8) / (Math.log(encoding.length) / Math.log(2))
  );
  var remainders = Array(full_length);
  for (j = 0; j < full_length; j++) {
    quotient = Array();
    x = 0;
    for (i = 0; i < dividend.length; i++) {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = '';
  for (i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input) {
  var output = '';
  var i = -1;
  var x, y;

  while (++i < input.length) {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xd800 <= x && x <= 0xdbff && 0xdc00 <= y && y <= 0xdfff) {
      x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);
      i++;
    }

    /* Encode output as utf-8 */
    if (x <= 0x7f) output += String.fromCharCode(x);
    else if (x <= 0x7ff)
      output += String.fromCharCode(
        0xc0 | ((x >>> 6) & 0x1f),
        0x80 | (x & 0x3f)
      );
    else if (x <= 0xffff)
      output += String.fromCharCode(
        0xe0 | ((x >>> 12) & 0x0f),
        0x80 | ((x >>> 6) & 0x3f),
        0x80 | (x & 0x3f)
      );
    else if (x <= 0x1fffff)
      output += String.fromCharCode(
        0xf0 | ((x >>> 18) & 0x07),
        0x80 | ((x >>> 12) & 0x3f),
        0x80 | ((x >>> 6) & 0x3f),
        0x80 | (x & 0x3f)
      );
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input) {
  var output = '';
  for (var i = 0; i < input.length; i++)
    output += String.fromCharCode(
      input.charCodeAt(i) & 0xff,
      (input.charCodeAt(i) >>> 8) & 0xff
    );
  return output;
}

function str2rstr_utf16be(input) {
  var output = '';
  for (var i = 0; i < input.length; i++)
    output += String.fromCharCode(
      (input.charCodeAt(i) >>> 8) & 0xff,
      input.charCodeAt(i) & 0xff
    );
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input) {
  var output = Array(input.length >> 2);
  var i;
  for (i = 0; i < output.length; i++) output[i] = 0;
  for (i = 0; i < input.length * 8; i += 8)
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input) {
  var output = '';
  for (var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
}
function md5_ff(a, b, c, d, x, s, t) {
  return md5_cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t) {
  return md5_cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xffff);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

/**
 * @fileOverview Sketchpad Web Application prototype main namespace.
 * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
 * @version 0.0
 * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
 */
/*global $:false*/
/**
 * In case Object.create is absent from the browser.
 */
if (typeof Object.create !== 'function') {
  Object.create = function(o) {
    var F = function() {};
    F.prototype = o;
    return new F();
  };
}

//jQuery.noConflict();

(function(window, $, undefined) {
  var // Sandboxed globals
    document = window.document,
    location = window.location,
    navigator = window.navigator,
    // Cache any previous global GSP instance
    _GSP = window.GSP;

  /**
   * @fileOverview Sketchpad Web Application prototype main namespace.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*global GSP:true, $:false */

  /**
   * @namespace GSP    The main Sketchpad namespace.
   */
  // turn off warnings about redefinition and lack of use of GSP global
  /*exported GSP */
  var GSP = (function() {
    // Copy the data src[key] into dest.
    // Data here means non-function, functions
    // will be returned into the (optional) outFunctions {}
    function copyDatum(dest, src, key, outFunctions) {
      var val = src[key],
        type = typeof val;
      if (type === 'object') {
        if (!dest[key]) {
          // vivify dest[key]
          dest[key] = $.isArray(val) ? [] : {};
        }
        $.extend(true, dest[key], val);
      } else if (type === 'function') {
        if (outFunctions) {
          outFunctions[key] = val;
        }
      } else {
        dest[key] = val;
      }
    }

    // Worker function to recursively copy source, omitting functions.
    // those functions are returned (optionally) in outFuctions, which
    // is augmented outFunctions[functionName] = funcion for each such
    // function.
    function copyData(source, outFunctions) {
      var key,
        i,
        src,
        newData = {};

      for (i = 0; i < source.length; i++) {
        src = source[i];
        if (!src) throw GSP.createError('copyData() from undefined source!');
        for (key in src) {
          copyDatum(newData, src, key, outFunctions);
        }
      }

      return newData;
    }

    function unionArrays(iArray1, iArray2) {
      var hash = {},
        union = [];
      iArray1.forEach(function(iValue) {
        hash[iValue] = true;
      });
      iArray2.forEach(function(iValue) {
        hash[iValue] = true;
      });
      GSP.eachKeyValue(hash, function(iKey) {
        union.push(iKey);
      });
      return union;
    }

    function subtractArrays(iArray1, iArray2) {
      var hash = {},
        result = [];
      iArray1.forEach(function(iValue) {
        hash[iValue] = true;
      });
      iArray2.forEach(function(iValue) {
        if (hash[iValue] !== undefined) delete hash[iValue];
      });
      GSP.eachKeyValue(hash, function(iKey) {
        result.push(iKey);
      });
      return result;
    }

    return {
      /*
       * These will be filled in at build time.
       */
      version: {
        number: '4.8.0',
        major: '4',
        minor: '8',
        patch: '0',
        build: '1077',
        release: '2020Q3',
      },

      /* Normal Motion (1.0 user speed) is 3.0*gPlatformSpeedMultiplier pixels per step */
      kNormalSpeedRate: 3.0,

      /* Presumed animation frame rate in frames/sec for Web Sketchpad.
         Used as the basis for frame rate calculations. */
      kIdealFrameRate: 60,

      /* Web Sketchpad speed conversion (frame rate conversion?) */
      kWebSpeedMultiplier: 0.5,

      gOptions: {
        // debug-geom-bounds: Setting to true will display bounding box rectangles.
        'debug-geom-bounds': false,
        // graphics-engine: Setting to 'canvas' will force use of canvas engine.
        'graphics-engine': 'standard',
        // instantiateUnsupportedObjects: setting to true will permit
        // execution of sketches with objects
        // that may not be quite ready for prime time.
        instantiateUnsupportedObjects: false,
        //perfTestMode: Setting to true will force a dirty rect every frame cycle
        perfTestMode: false,
      },

      /**
       * @namespace GSP.gObjects Primitive Geometric types.
       *
       * GObjects are the things themselves. The name derives from the principal
       * object types of Desktop Sketchpad. These object prototypes correspond to
       * "kinds", and are identified by the "kind" property of a JSON object
       * description. These object prototypes encapsulate the data and behavior
       * associated with a mathematical abstraction or, occasionally, a
       * supporting non-mathematical abstraction. A gobject manages its rendering,
       * although it may not understand the underlying rendering technology.
       * A gobject does <em>not</em> know about its relationships with other objects
       * in the sketch. This is the domain of the "constraint". A GObject carries with
       * it style information which affects how the object should be rendered.
       */
      gObjects: {},

      mixins: {},
      /**
       * @namespace GSP.gConstraints Constraints applied to GObjects.
       */
      gConstraints: {},
      /**
       * @namespace GSP.genera
       */
      genera: {},

      /**
       * Triggers a custom "gLog" event to signal the occurrence of some
       * event, which can be handled by the container. The contents of the
       * message object indicate the type, severity, and any additional
       * details of the event being signaled. The preexisting log(), logPerf(),
       * signalError...(), and event() APIs vector through this method to provide
       * a single intercept path for clients.
       * This event is intended as a way to communicate status and debug
       * information to the hosting page.
       *
       * @param {Object} event An event object which contains content properties like:
       *          {String} code - An error code which indicates the error that occurred
       *          {String} message - A message string describing the event
       *          {Boolean} localize - If true, the message is treated as a localizable key
       *          {String} logType - The type of event (e.g. 'debug', 'error', 'api', ...)
       *          {Object} sketch - Some events provide the sketch for client inspection
       *          {Object} stack - Some errors provide the stack for debugging purposes
       *          {Object} error - An error/exception object provided with some events that callers may raise
       *          {Object} args - Some events provide additional arguments for client inspection
       *
       * @return {Object} The event
       */
      signal: function(event) {
        if (event.localize && event.message) {
          event.message = GSP.Strings.loc(event.message);
        } else if (event.code && !event.message) {
          event.message = GSP.Strings.loc(event.code);
        }
        $(document).trigger('gLog', event);

        return event;
      },

      /**
       * Triggers a custom "gLog" event to log debug information.
       * The payload of the event is the passed in message and a logType of
       * "debug".
       * This event is intended as a way to communicate status and debug
       * information to the hosting page.
       *
       * @param {string} message An arbitrary string to be written.
       *
       * @return {Object} The event
       */
      log: function(message) {
        if (message.indexOf('%@') >= 0) {
          var args = Array.prototype.slice.call(arguments, 1);
          message = GSP.Strings.format(message, args);
        }
        return GSP.signal({
          code: 'GSP.Debug.log',
          message: message,
          logType: 'debug',
        });
      },

      /**
       * Triggers a custom "gLog" event to report performance information.
       * The payload of the event is the passed in message and a logType of
       * "perf".
       * This event is intended as a way to communicate performance data
       * to the hosting page.
       *
       * @param {string} message An arbitrary string to be written.
       *
       * @return {Object} The event
       */
      logPerf: function(message) {
        return GSP.signal({
          code: 'GSP.Debug.log',
          message: message,
          logType: 'perf',
        });
      },

      /**
       * Variant of GSP.event (q.v.) for emitting case data - this will
       * tie in to the DataGames project, helping to enable WebGSP to exist
       * as a DG component.
       * @param {string} gobj A JQuery object selector. The referenced
       * element becomes root of the custom event.
       * @param {string} message A message passed as the event payload.
       * @param {object} data    (TBD)
       * @return {Object} The event
       */
      caseData: function(gobj, message, data) {
        return GSP.signal({
          message: message,
          logType: 'data',
          gobj: gobj,
          data: data,
        });
      },

      /**
       * Polyfill substitute for optional chaining. Instead of val = obj?.obj1?.obj2?.obj3.obj4,
       * we can write val = GSP._get(obj, 'obj1.obj2.obj3.obj4'), which will return either
       * the value of obj.obj1.obj2.obj3.obj4 or undefined if any piece of the path is invalid
       */
      _get: function(obj, path) {
        var parts = path.split && path.split('.');
        if (!obj || !parts) return; // undefined
        while (obj && parts.length) {
          obj = obj[parts.shift()];
        }
        return obj && parts.length === 0 ? obj : undefined;
      },

      /**
       * Partner function to _get()
       * If we want to accomplish "obj.obj1.obj2.obj3.obj4 = 'hello';"
       * but we don't know whether obj1, obj2, obj3, and obj4 exist,
       * and we want to create any that don't yet exist,
       * we can write GSP._put(obj, 'obj1,obj2.obj3.obj4', 'hello'),
       * and obj1, obj2, obj3, and obj4 will be created if necessary.
       * The value of obj4 will be 'hello'
       * return value is the last path element (obj4 in this example)
       */
      _put: function(obj, path, value) {
        var parts = path.split && path.split('.'),
          subPath;
        if (!obj || !parts) return;
        while (obj && parts.length) {
          subPath = parts.shift();
          if (!obj[subPath]) {
            obj[subPath] = {};
          }
          if (!parts.length) {
            obj[subPath] = value;
          } else {
            obj = obj[subPath];
          }
        }
        return obj[subPath];
      },

      /**
       * Class construction utility.
       *
       * Data members are instantiated in the new class by merging in the new class
       * non-function properties with those of the base class. Data properties thus
       * become initial/default values once the class is instantiated.
       *
       * Function properties are also merged - but if the new class replaces a
       * base class function, that old function is available as a ".base" member of the new
       * function. You need an unfortunately weird invocation, involving an Named Function Expression
       * (NFE) See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function
       * and an IE<9 NFE non-compliance workaround involving arguments.callee to get at the .base member.
       *
       * Here's a canonical example of how to invoke, including the base class
       * virtual function access.
       * DerivedClass = GSP.makeClass(BaseClass, {
       *  // functions,
       *  fooFunc: function fooFunc(arg1, arg2) {
       *    // do stuff ...
       *    // call base class
       *    (fooFunc.base || arguments.callee.base).call(this, arg1, arg2);
       *  },
       *  // more functions
       *  })
       * };
       *
       * Note that for multiple inheritance where the same function exists in multiple hierarchies,
       * you'll need to use the somewhat brittle syntax:
       *   (fooFunc.base[n] || arguments.callee.base).call(this, arg1, arg2);
       * where n is the index of the derived class in the baseClass list.
       *
       * @see GSP.makeInstance
       *
       * @param {Object} baseClass instance or array thereof (or null)
       * @param {Object} classSpec Associative array of class members.
       *
       * @return {Object} newly created class
       */
      makeClass: function(baseClass, classSpec) {
        var k,
          i,
          fc,
          newClass,
          baseKinds,
          usageKinds,
          baseGenera,
          functions = {};

        if (!baseClass) {
          baseClass = {};
        }

        if (!$.isArray(baseClass)) {
          baseClass = [baseClass];
        }

        function combineBaseKinds(iBaseClasses) {
          var classIndex,
            baseClass,
            kinds = [];
          for (classIndex = 0; classIndex < iBaseClasses.length; ++classIndex) {
            baseClass = iBaseClasses[classIndex];
            if (baseClass.baseKinds)
              kinds = unionArrays(kinds, baseClass.baseKinds);
            if (baseClass.kind) kinds = unionArrays(kinds, [baseClass.kind]);
          }
          return kinds;
        }

        function combineBaseGenera(iBaseClasses) {
          var classIndex,
            baseClass,
            genera = [];
          for (classIndex = 0; classIndex < iBaseClasses.length; ++classIndex) {
            baseClass = iBaseClasses[classIndex];
            if (baseClass.baseGenera)
              genera = unionArrays(genera, baseClass.baseGenera);
            if (baseClass.genus)
              genera = unionArrays(genera, [baseClass.genus]);
          }
          return genera;
        }

        function combineBaseUsageKinds(iBaseClasses) {
          var baseUsageKinds = [],
            classIndex,
            baseClass,
            baseUsage,
            classKinds;
          for (classIndex = 0; classIndex < iBaseClasses.length; ++classIndex) {
            baseClass = iBaseClasses[classIndex];
            baseUsage = baseClass && baseClass.doc && baseClass.doc.usage;
            classKinds = baseUsage && baseUsage.kinds;
            if (classKinds) {
              baseUsageKinds = unionArrays(baseUsageKinds, classKinds);
            }
          }
          return baseUsageKinds;
        }

        function combineUsageKinds(iBaseClasses, iClassSpec) {
          var combinedUsageKinds = [],
            classUsage = iClassSpec && iClassSpec.doc && iClassSpec.doc.usage;

          if (classUsage && classUsage.kinds) {
            return $.merge([], classUsage.kinds);
          }

          combinedUsageKinds = combineBaseUsageKinds(iBaseClasses);

          if (classUsage && classUsage.addKinds) {
            return unionArrays(combinedUsageKinds, classUsage.addKinds);
          }

          if (classUsage && classUsage.subKinds) {
            return subtractArrays(combinedUsageKinds, classUsage.subKinds);
          }
          return combinedUsageKinds;
        }

        baseKinds = combineBaseKinds(baseClass);
        baseGenera = combineBaseGenera(baseClass);
        usageKinds = combineUsageKinds(baseClass, classSpec);

        newClass = copyData(baseClass, functions);
        $.extend(true, newClass, classSpec);

        if (baseKinds && baseKinds.length) {
          newClass.baseKinds = baseKinds;
        }
        if (baseGenera && baseGenera.length) {
          newClass.baseGenera = baseGenera;
        }
        if (newClass.doc && newClass.doc.usage && usageKinds.length) {
          newClass.doc.usage.kinds = usageKinds;
        }

        function funcCount(f) {
          var i,
            c = 0;
          for (i = 0; i < baseClass.length; i++) {
            if (undefined !== baseClass[i][f]) {
              c++;
            }
          }
          return c;
        }

        for (k in functions) {
          fc = funcCount(k);
          if (undefined !== classSpec[k]) {
            newClass[k] = classSpec[k];
            if (1 === fc) {
              newClass[k].base = functions[k];
            } else {
              newClass[k].base = {};
              for (i = 0; i < baseClass.length; i++) {
                newClass[k].base[i] = baseClass[i][k];
              }
            }
          } else {
            if (fc > 1) {
              throw GSP.createError('Ambiguous multiple inheritance for ' + k);
            }
            newClass[k] = functions[k];
          }
        }

        return newClass;
      },

      /**
       * Instance construction utility.
       * Creates and instance of a class object (created with makeClass).
       * @see GSP.makeClass
       *
       * @param {instanceClass} class prototype object
       * @param {Object} classSpec Initial data for new instance.
       * @param {classStaticsMap} classStaticsMap Hash of keys *not* to bring into the new object, but leave in the prototype.
       *
       * @return {Object} newly created instance
       *
       */
      makeInstance: function makeInstance(
        instanceClass,
        instanceSpec,
        classStaticsMap
      ) {
        var instance = Object.create(instanceClass),
          k,
          data = {};

        for (k in instanceClass) {
          if (!classStaticsMap || !classStaticsMap[k]) {
            copyDatum(data, instanceClass, k);
          }
        }
        $.extend(true, data, instanceSpec);
        for (k in data) {
          instance[k] = data[k];
        }

        return instance;
      },
      stringify: function(obj, f) {
        if (window.JSON && window.JSON.stringify) {
          return window.JSON.stringify(obj, f);
        }
        return 'JSON.stringify not supported';
      },
      // Iterate over an object - wrapper for a for(k in obj) loop,
      // with jQuery.each style callback: called with the value as "this",
      // and a callback return === false terminates the iteration.
      eachKeyValue: function(obj, callback) {
        var i, value;
        for (i in obj) {
          value = callback.call(obj[i], i, obj[i]);
          if (value === false) {
            break;
          }
        }
      },

      isParameter: function(gobj) {
        return gobj.isParameter && gobj.isParameter();
      },

      isFunction: function(gobj) {
        return gobj.isFunction && gobj.isFunction();
      },

      isCalculation: function(gobj) {
        return (
          gobj.isOfKind('Expression') &&
          !GSP.isParameter(gobj) &&
          !GSP.isFunction(gobj)
        );
      },

      isAPath: function(gobj) {
        return gobj.isAPath();
      },

      /*
       * Generates a globally unique identifier.
       *
       * Code is from: http://stackoverflow.com/a/105074
       *
       */

      generateUUID: function() {
        function s4() {
          return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
        }
        return (
          s4() +
          s4() +
          '-' +
          s4() +
          '-' +
          s4() +
          '-' +
          s4() +
          '-' +
          s4() +
          s4() +
          s4()
        );
      },

      compare: function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      },

      isString: function(x) {
        return typeof x === 'string';
      },
      isNumber: function(x) {
        return typeof x === 'number';
      },

      // Keep window.FastClick the way we found it
      FastClick: window.FastClick.noConflict(),
      // Keep window.LZString the way we found it
      LZString: window.LZString.noConflict(),
    };
  })();

  (function() {
    // "Natural sort" algorithm -- puts 'a2' before 'a10'
    // LGPL-licensed implementation from: http://www.davekoelle.com/files/alphanum.js

    /* jshint -W009, -W084, -W116 */
    var x;

    // Here is the LGPL'd code, which we have not modified.

    GSP.naturalSortCaseInsensitive = function(a, b) {
      function chunkify(t) {
        var tz = new Array();
        var x = 0,
          y = -1,
          n = 0,
          i,
          j;

        while ((i = (j = t.charAt(x++)).charCodeAt(0))) {
          var m = i == 46 || (i >= 48 && i <= 57);
          if (m !== n) {
            tz[++y] = '';
            n = m;
          }
          tz[y] += j;
        }
        return tz;
      }

      var aa = chunkify(a.toLowerCase());
      var bb = chunkify(b.toLowerCase());

      for (x = 0; aa[x] && bb[x]; x++) {
        if (aa[x] !== bb[x]) {
          var c = Number(aa[x]),
            d = Number(bb[x]);
          if (c == aa[x] && d == bb[x]) {
            return c - d;
          } else return aa[x] > bb[x] ? 1 : -1;
        }
      }
      return aa.length - bb.length;
    };
  })();
  /**
   * @fileOverview Externally overridable plugins. This file contains
   * "delegates" - functions that can be swapped out by integration
   * partners to modify WSP; and "options" - settings that integration
   * partners can modify. Delegates and options are organized in two
   * parallel namespaces: window.GSPConfig, which is never modified by
   * WSP but is read to detect customizations by partners, and
   * GSP.ConfigDefaults, which provides default values for
   * window.GSPConfig.
   * @author <a href="mailto:lyn.headley@mheducation.com">Lyn Headley</a>
   * @version 0.0
   *
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */

  GSP.ConfigDefaults = {
    NumberpadManager: {
      // This determines which number pad manager to use. Integration
      // partners can develop their own plugins that implement this
      // interface.
      delegates: {
        /*
         * registerElement: Sets up a connection between an input element
         * and a number pad. Called when a new input element is
         * created. Should be used to set up a click handler on the input
         * that displays a number pad.
         *
         * @param {elt} A jQuery matched set of input elements.
         */
        registerElement: function(elt) {
          GSP.NumberpadManager.register(elt);
        },

        /* Like registerElement, but for calculators. Receives a div. */
        registerCalculatorElement: function(elt) {
          GSP.NumberpadManager.register(elt);
        },

        /*
         * blurAllNumberpads: Called when the numberpad loses focus. Should
         * hide all currently displayed numberpads in all WSP documents.
         */
        blurAllNumberpads: function() {
          GSP.NumberpadManager.blurNumpads();
        },
      },

      // Configuration options of the NumberpadManager.

      options: {
        /* See customization documentation */

        keyOrder: [
          ['1', '2', '3'],
          ['4', '5', '6'],
          ['7', '8', '9'],
          ['dot', '0', 'opposite'],
          ['', '', 'backspace'],
        ],

        keyOrderCalculator: [
          ['1', '2', '3', 'plus', 'lparen'],
          ['4', '5', '6', 'minus', 'rparen'],
          ['7', '8', '9', 'star', 'exponent'],
          ['dot', '0', 'clear', 'slash', 'backspace'],
        ],
      },
    },

    Fonts: {
      // The Font fallbacks table describes fallback names and settings
      // for font family names. It is keyed by the family name we find
      // in the JSON document. Since these names are platform specific,
      // WSP adds fallback names, separated by commas, to the css
      // font-family it sets on a text element. Sometimes we also need
      // to set other font properties in the text element being rendered
      // such as style and weight in order to get proper cross-platform
      // behavior, and this table permits that too

      /*
        Example entries:
  
         "Report School Rg": {
           fallbackFamilies: ['ReportSchoolRg-Regular']
         }
  
  
        "Proxima Nova Bold": {
          fallbackFamilies: ["Proxima Nova"],
          sets: { "font-weight": "bold" }
  
      */

      fallbacks: {},
    },
    compatibilityVersionPath: function(majorVersion) {
      return 'js/wsp-compat-' + majorVersion + '.js';
    },
  };

  // Look for a configuration value, first in the user config, then in
  // the default config.
  GSP.getConfigValue = function(keys) {
    if (typeof keys === 'string') {
      keys = keys.split('.');
    }
    function checkConfig(config) {
      for (var i = 0; i < keys.length; i++) {
        if (config && typeof config === 'object' && keys[i] in config) {
          config = config[keys[i]];
        } else {
          return { found: false };
        }
      }
      return { found: true, value: config };
    }
    var userPreference = checkConfig(window.GSPConfig);
    if (userPreference.found) {
      return userPreference.value;
    } else {
      return checkConfig(GSP.ConfigDefaults).value;
    }
  };

  /**
   * @fileOverview jQuery plugin normalize touch events (even from the mouse).
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */

  /*
   *
   * The idea is that clients will just look for touch events, and that will
   * still work even when there are just mouse* events.
   */
  (function($) {
    (function() {
      // make sure jQuery events contain touch properties, but don't
      // clutter the jQuery object.
      // Google "jQuery Event Extensions" for more info.
      function pushEventProp(prop) {
        if ($.event.props.indexOf(prop) === -1) {
          $.event.props.push(prop);
        }
      }

      pushEventProp('touches');
      pushEventProp('targetTouches');
      pushEventProp('changedTouches');
    })();

    var mouseTouch = function($elem, options) {
      var config = {};

      return $elem.each(function() {
        var $this = $(this);

        if (options) {
          $.extend(config, options);
        }

        // Set -webkit- only styles directly, to avoid
        // poisoning the jQuery cache of presumed valid styles.
        this.style['-webkit-user-select'] = 'none';
        this.style['-webkit-touch-callout'] = 'none';
        this.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';

        $this.css({
          'touch-action': 'none',
        });

        // Suppress context menu - it can be triggered on touch-and-hold,
        // which can happen on a normal touch if slow.
        $this.on('MSGestureHold contextmenu', false);

        // Translate mousedown events into touch events.
        $this.on('mousedown.mousetouch-mousedown', function(e) {
          if (config.sketch) {
            config.sketch.toggleKeyPressClass(false);
            if (config.sketch.focusedGobj) {
              config.sketch.focusedGobj = '';
            }
          }

          var touchFromMouse = function(e) {
            var touchType = 'touchmove',
              touchEvent;

            /*jshint bitwise:false */
            if (!e.which && e.button) {
              if (e.button & 1) e.which = 1;
              // Left
              else if (e.button & 4) e.which = 2;
              // Middle
              else if (e.button & 2) e.which = 3; // Right
            }
            if (e.which > 1) {
              return false;
            }

            if (e.type === 'mousedown') {
              touchType = 'touchstart';
            } else if (e.type === 'mouseup') {
              touchType = 'touchend';
            }

            touchEvent = $.Event(touchType);

            /* Should have:
                    clientX: X coordinate of touch relative to the viewport (excludes scroll offset)
                    clientY: Y coordinate of touch relative to the viewport (excludes scroll offset)
                    screenX: Relative to the screen
                    screenY: Relative to the screen
                    pageX: Relative to the full page (includes scrolling)
                    pageY: Relative to the full page (includes scrolling)
                    target: Node the touch event originated from
                    identifier: An identifying number, unique to each touch event
                    
                    We'll add a 'mouseEvent' field containing the source mouse event.
  
                */

            var theMouseTouch = [
              {
                identifier: 'mouse0',
                target: e.target,
                clientX: e.clientX,
                clientY: e.clientY,
                screenX: e.screenX,
                screenY: e.screenY,
                pageX: e.pageX,
                pageY: e.pageY,
                mouseEvent: e,
              },
            ];

            touchEvent.touches = touchType === 'touchend' ? [] : theMouseTouch;
            touchEvent.targetTouches = touchEvent.touches;
            touchEvent.changedTouches = theMouseTouch;

            $this.trigger(touchEvent);
            return !touchEvent.isDefaultPrevented();
          };

          $(document).on('mouseup.mousetouch mousemove.mousetouch', function(
            e
          ) {
            if (e.type === 'mouseup') {
              $(document).off('.mousetouch');
            }

            return touchFromMouse(e);
          });
          return touchFromMouse(e);
        });
      });
    };
    GSP.mouseTouch = mouseTouch;
  })(jQuery);

  /**
   * @fileOverview jQuery to implement equivalent of webkitConvertPointFromNodeToPage.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   * See http://developer.apple.com/library/safari/#documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html
   */

  /*global Point */

  /*
      Tricks for the implementation gleaned from: https://gist.github.com/1145197.
      
      See also http://www.w3.org/TR/css3-transforms/ for the definitions of the actual
      transformations involved, and which css properties govern them.
   */

  (function($) {
    var convertPointFromPage, convertPageFromPoint;
    var multiply,
      translate,
      matrixFromCssString,
      boundingClientRect,
      getComputedTransformationCSS,
      getTotalTransformationMatrix,
      getTransformationMatrix;
    var identity;

    // http://www.w3.org/TR/2009/WD-css3-2d-transforms-20090320/
    if (window.convertPointFromPageToNode) {
      convertPointFromPage = function($element, pageX, pageY) {
        var p = window.convertPointFromPageToNode(
          $element.get(0),
          new Point(pageX, pageY)
        );
        return { x: p.x, y: p.y };
      };
    }

    /* Use WebKit's webkitConvertPointFromPageToNode, if available */
    /* webkitConvertPointFromPageToNode (as of Safari 5.1.6 / Chrome 22.0.1229.94)
      has problems with zoom. Sometimes it seems to want to deal in zoomed pixels, sometimes
      in absolute screen pixels. Results are inconsistent, depending on event target.
      Move over a parameter input, and you get a different result than the canvas as a whole.
      This last busts the workaround attempted below. We'll fallback to the generic method.
      C.f. https://bugs.webkit.org/show_bug.cgi?id=101792
    if( window.webkitConvertPointFromPageToNode) {
      convertPointFromPage = function(pageX, pageY, mouseEvent) {
        var p, s;
        
        // On Webkit (as of Safari 5.1.6 / Chrome 22.0.1229.94) webkitConvertPointFromNodeToPage
        // needs coordinates in screen pixels. Under zoom, we've got virtualized pixel coordinates,
        // so we'll dip into the underlying mouse event, and reverse transform the coordinates
        // relative to the target event (i.e. not this), and that'll get us coordinates in the
        // system expected by webkitConvertPointFromPageToNode
        if( mouseEvent) {
          s = window.webkitConvertPointFromNodeToPage(mouseEvent.target,
                new WebKitPoint(mouseEvent.offsetX, mouseEvent.offsetY));
          pageX = s.x;
          pageY = s.y;
        }
        
        p = window.webkitConvertPointFromPageToNode(this.get(0), new WebKitPoint(pageX, pageY));
        return {x : p.x, y: p.y};
      };
    }
    */

    if (!convertPointFromPage) {
      /* OK lets do it the hard way */

      /* Matrix multiplication - inputs are row-major
          a = M x N matrix
          b = N x P matrix
          
          returns c = M x P matrix
      */
      multiply = function(a, b) {
        var M = a.length,
          N = a[0].length,
          P = b[0].length,
          i,
          j,
          k,
          tmp,
          c = [];

        for (i = 0; i < M; i++) {
          c[i] = [];
        }

        for (i = 0; i < M; i++) {
          for (j = 0; j < P; j++) {
            tmp = 0;
            for (k = 0; k < N; k++) {
              tmp += a[i][k] * b[k][j];
            }
            c[i][j] = tmp;
          }
        }

        return c;
      };

      /* Matrix translation
          Return matrix m translated by vector v.
        */
      translate = function(m, v) {
        var i,
          r = [];
        for (i = 0; i < m.length; i++) {
          r[i] = m[i].slice(0);
          r[i][m[i].length - 1] += +v[i] || 0;
        }
        return r;
      };

      /* Create matrix from the 'transform' css property, whose value is like "matrix(...)" or "matrix3d(...)" */
      matrixFromCssString = function(c) {
        c = c.match(/matrix3?d?\(([^\)]+)\)/i)[1].split(',');
        if (c.length === 6) {
          c = [
            c[0],
            c[1],
            0,
            0,
            c[2],
            c[3],
            0,
            0,
            0,
            0,
            1,
            0,
            c[4],
            c[5],
            0,
            1,
          ];
        }
        var i,
          j,
          m = [];
        for (i = 0; i < 4; i++) {
          for (j = 0; j < 4; j++) {
            m[i] = m[i] || [];
            m[i][j] = parseFloat(c[j * 4 + i]);
          }
        }
        return m;
      };

      /* Bounding Rectangle of transformed element */
      boundingClientRect = function(element, transformationMatrix) {
        var width = element.outerWidth(false),
          height = element.outerHeight(false),
          points = multiply(transformationMatrix, [
            [0, width, 0, width],
            [0, 0, height, 0, height],
            [0, 0, 0, 0],
            [1, 1, 1, 1],
          ]);

        return {
          left: Math.min.apply(Math, points[0]),
          top: Math.min.apply(Math, points[1]),
          right: Math.max.apply(Math, points[0]),
          bottom: Math.max.apply(Math, points[1]),
        };
      };

      identity = matrixFromCssString('matrix(1,0,0,1,0,0)');

      /*
          Get current values of the css transformation, with what normalization we can muster.
          we will return null for the identity matrix.
        */
      getComputedTransformationCSS = function(element) {
        var style = window.getComputedStyle
            ? window.getComputedStyle(element, null) || {}
            : {},
          transform,
          origin,
          zoom = 1;

        // Zoom factor from a number, perhaps a percent.
        // Weird things should default to 1.
        function extractZoomFactor(zoom) {
          var zoomFactor = 1,
            zoomInfo;

          // already a number - that's our factor, then.
          if (typeof zoom === 'number') {
            return zoom;
          }

          if (zoom !== undefined && zoom !== '' && zoom !== 'normal') {
            zoomInfo = zoom.match(/(\d+|\d+\.\d*)(%?)$/);
            if (zoomInfo) {
              zoomFactor = parseFloat(zoomInfo[1], 10);
              if (zoomInfo[2] === '%') {
                zoomFactor /= 100;
              }
            }
          }

          return zoomFactor;
        }

        // Extract the non-standard zoom factor if present
        // should be ms only.
        function getZoom(element) {
          var zoomInfo =
            element.currentStyle && element.currentStyle.getAttribute
              ? element.currentStyle.getAttribute('zoom')
              : undefined;

          return extractZoomFactor(zoomInfo);
        }

        transform =
          style.msTransform ||
          style.MozTransform ||
          style.OTransform ||
          style.WebkitTransform ||
          'none';

        zoom = getZoom(element);

        if ('none' === transform) {
          transform = 'matrix(1,0,0,1,0,0)';
        }

        origin =
          style.msTransformOrigin ||
          style.MozTransformOrigin ||
          style.OTransformOrigin ||
          style.WebkitTransformOrigin ||
          '';
        origin = origin.indexOf('%') !== -1 ? '' : origin;
        origin = origin.replace(/px/g, '');

        return {
          origin: origin,
          transform: transform,
          zoom: zoom,
        };
      };

      /* Get the transformation matrix for the element, 
          null means identity */
      getTransformationMatrix = function(element) {
        var transform,
          origin,
          transformationComputedCSS,
          inverseOrigin,
          transformationMatrix;

        transformationComputedCSS = getComputedTransformationCSS(element);
        if (null === transformationComputedCSS) {
          return null;
        }

        transform = matrixFromCssString(transformationComputedCSS.transform);

        origin = transformationComputedCSS.origin;
        origin = matrixFromCssString(
          'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,' +
            ((origin || '0 0') + ' 0').split(' ').slice(0, 3) +
            ',1)'
        );

        // Apply the zoom to the origin, where it will apply before the transform
        origin[0][0] *= transformationComputedCSS.zoom;
        origin[1][1] *= transformationComputedCSS.zoom;

        inverseOrigin = translate(identity, [
          -origin[0][3],
          -origin[1][3],
          -origin[2][3],
        ]);

        // transformationMatrix = origin * transform * origin^-1
        transformationMatrix = multiply(
          multiply(origin, transform),
          inverseOrigin
        );

        return transformationMatrix;
      };

      /* Inverse matrix of the total CSS transform (including parental CSS transforms) */
      getTotalTransformationMatrix = function(element) {
        var t = identity,
          r,
          offset;

        function getJQueryOffset($element) {
          // IE10 Tablet jQuery bug. When msContentZoomFactor is > 1 (happens on pinch zoom)
          // then the jQuery calculation of offset is wrong. In jQuery, we are calculating offset here
          // via getBoundingClientRect(), and adding win.pageYOffset / win.pageXOffset which in this
          // situation are evidently relative to viewport (i.e. upper left of visible region), rather than
          // the "real" upper left. iOS, which also has a pinch zoom, uses the "real" upper left (causes
          // other bugs, but that's a different story). Here we workaround by querying the 'html' DOM element's
          //scroll position, which is untainted by msContentZoomFactor
          var offset = $element.offset(),
            element = $element[0],
            doc = element.ownerDocument,
            win,
            topNode;

          if (
            doc &&
            doc.documentElement.msContentZoomFactor &&
            doc.documentElement.msContentZoomFactor !== 1
          ) {
            win = doc.defaultView;
            offset.left -= win.pageXOffset;
            offset.top -= win.pageYOffset;
            topNode = $('html');
            offset.left += topNode.scrollLeft();
            offset.top += topNode.scrollTop();
          }

          return offset;
        }

        element.parents().each(function() {
          var thisT = getTransformationMatrix(this);
          if (null !== thisT) {
            t = multiply(thisT, t);
          }
        });

        r = boundingClientRect(element, t);
        offset = getJQueryOffset(element);

        t = translate(t, [offset.left - r.left, offset.top - r.top, 0]);

        return t;
      };

      convertPointFromPage = function($element, pageX, pageY) {
        var t = getTotalTransformationMatrix($element);
        /* Solve:
              pageX = t11 t12 t14 | x
              pageY = t21 t22 t24 | y
              1     = 0   0   1   | 1
          */
        return {
          x:
            ((pageX - t[0][3]) * t[1][1] - (pageY - t[1][3]) * t[0][1]) /
            (t[0][0] * t[1][1] - t[0][1] * t[1][0]),
          y:
            (t[0][0] * (pageY - t[1][3]) - t[1][0] * (pageX - t[0][3])) /
            (t[0][0] * t[1][1] - t[0][1] * t[1][0]),
        };
      };

      convertPageFromPoint = function($element, x, y) {
        var t = getTotalTransformationMatrix($element);

        var ret = {
          x: x * t[0][0] + y * t[0][1] + t[0][3],
          y: x * t[1][0] + y * t[1][1] + t[1][3],
        };

        return ret;
      };
    }

    GSP.convertPointFromPage = convertPointFromPage;
    GSP.convertPageFromPoint = convertPageFromPoint;
  })(jQuery);

  GSP.NumberpadManager = (function($) {
    /*
     * NumfieldEditor: this class provides text field editing capabilities.
     * This includes management of a cursor and selection region.
     */
    var NumfieldEditor,
      numfields = [], // Records all numeric fields that are managed by this
      // module.
      numpadCt = 0, // The index of numeric keypads. Keypads are created
      // as needed and assigned a unique index.
      keyMap = {
        // Maps modified keycodes to names. Modified keycodes
        // incorporate which modifier keys are also active
        '8': 'backspace',
        // '9': 'tab', // Remove by magic, it cause problem with screen reader tab key navigation
        // '13': 'submit', // sumbit needs special handling - for accessibility, generally 'enter' means activate current button.
        '27': 'esc',
        '32': 'space',
        '33': 'pageup',
        '34': 'pagedown',
        '35': 'end',
        '36': 'home',
        '37': 'left',
        '37-S': 'selectleft',
        '38': 'up',
        '39': 'right',
        '39-S': 'selectright',
        '40': 'down',
        '45': 'insert',
        '46': 'delete',
        '48': '0',
        '48-S': 'rparen',
        '49': '1',
        '50': '2',
        '51': '3',
        '52': '4',
        '53': '5',
        '54': '6',
        '54-S': 'exponent',
        '55': '7',
        '56': '8',
        '56-S': 'star',
        '57': '9',
        '57-S': 'lparen',
        '61-S': 'plus',
        '80': 'pi',
        '82': 'r',
        '84': 't', // theta
        '88': 'x',
        '89': 'y',
        '96': '0',
        '97': '1',
        '98': '2',
        '99': '3',
        '100': '4',
        '101': '5',
        '102': '6',
        '103': '7',
        '104': '8',
        '105': '9',
        '106': 'star',
        '107': 'plus',
        //'108': 'submit',
        '109': 'minus',
        '110': 'dot',
        '111': 'slash',
        '173': 'minus',
        '187-S': 'plus',
        '188': 'comma',
        '188-S': 'lessthan',
        '189': 'minus',
        '190': 'dot',
        '190-S': 'greaterthan',
        '191': 'slash',
      };

    // Keep window.MathQuill the way we found it
    var MathQuill = window.MathQuill.noConflict();

    /*
     * Composes a modified keycode, incorporating active modifier keys.
     */
    function composeKeyString(ev) {
      var alt = ev.altKey ? '-A' : '',
        ctl = ev.ctrlKey ? '-C' : '',
        meta = ev.metaKey ? '-M' : '',
        shift = ev.shiftKey ? '-S' : '',
        key = String(ev.which);
      return [key, alt, ctl, meta, shift].join('');
    }

    function blurAll(exemptModals) {
      $.each(numfields, function() {
        if (!exemptModals || !this.isModalController) {
          this.vBlur();
        }
      });
    }

    function removeNumpads() {
      blurAll();
      $.each(numfields, function() {
        if (this.numpad) {
          $(this.numpad.numpadEl).remove();
          this.numpad = null;
        }
      });
      numpadCt = 0;
    }

    function getFocusedCtl() {
      var rtn = null;
      $.each(numfields, function() {
        var ctl = this;
        if (ctl.hasVFocus) {
          rtn = ctl;
          return;
        }
      });
      return rtn;
    }

    /*
      function getFocusedEditor() {
          var ctl = getFocusedCtl(),
              ed = ctl && ctl.editor;
          return ed;
      }
  */

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     * Class NumfieldEditor
     *
     * Operations on numeric fields, including insert, delete, clear,
     * cursor management, selection management.
     * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    NumfieldEditor = (function() {
      function lesser(a, b) {
        return a <= b ? a : b;
      }

      function greater(a, b) {
        return a > b ? a : b;
      }

      /*
       * Constructor
       *
       * @param {Element} el - A numeric text field.
       * @param {Object} gobj - a parameter to edit
       */
      function NumfieldEditor(el, gobj) {
        this.textNode = el;
        this.text = $(el).text() || '';
        this.gobj = gobj;
        this.cursor = 0;
        this.rangeEnd = this.cursor;
        this.collapsed = this.cursor === this.rangeEnd;
        this.startWidth = $(el).width();
      }

      NumfieldEditor.prototype.adjustFieldWidth = function(isAuto) {
        if (!isAuto) {
          var textWidth = this.getTextWidth(),
            fieldWidth = $(this.textNode).width(),
            shouldBe = Math.max(textWidth + 1, this.startWidth);
          if (fieldWidth !== shouldBe) {
            $(this.textNode).width(shouldBe);
          }
        } else {
          $(this.textNode).width('auto');
        }
      };

      NumfieldEditor.prototype.setCursor = function(ix) {
        this.cursor = ix;
        this.rangeEnd = ix;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.unsetCursor = function() {
        this.cursor = undefined;
        this.rangeEnd = undefined;
        this.collapsed = undefined;
        this.render();
      };

      NumfieldEditor.prototype.getTextWidth = function() {
        var width = $('.wsp-numfield-text', this.textNode).width();
        return width;
      };
      NumfieldEditor.prototype.toString = function() {
        return (
          'text/cursor/rangeEnd/collapsed = ' +
          [this.text, this.cursor, this.rangeEnd, this.collapsed].join('/')
        );
      };

      NumfieldEditor.prototype.render = function() {
        function renderWithCursor(el) {
          var lix = lesser(this.cursor, this.rangeEnd),
            rix = greater(this.cursor, this.rangeEnd),
            precursor = this.text.substring(0, lix),
            selected = this.text.substring(lix, rix),
            postcursor = this.text.substring(rix),
            cursEl = $('<span>'),
            textSpan = $('<span>').addClass('wsp-numfield-text');

          if (this.collapsed) {
            cursEl.addClass('wsp-blink').html('&#124;');
          } else {
            cursEl.addClass('wsp-selected').text(selected);
          }
          if (precursor) {
            textSpan.append(precursor);
          }
          textSpan.append(cursEl);
          if (postcursor) {
            textSpan.append(postcursor);
          }
          textSpan.appendTo(el);
        }
        var el = $(this.textNode);
        el.empty();
        if (
          this.cursor !== undefined &&
          this.cursor >= 0 &&
          this.cursor <= this.text.length
        ) {
          renderWithCursor.call(this, el);
          this.adjustFieldWidth(false);
        } else {
          $('<span>')
            .addClass('wsp-numfield-text')
            .html(this.text)
            .appendTo(el);
          this.adjustFieldWidth(true);
        }
      };

      NumfieldEditor.prototype.moveLeft = function(n) {
        var num = n || 1;
        if (!this.collapsed) {
          this.collapseToStart();
        } else {
          this.cursor = Math.max(0, this.cursor - num);
          this.rangeEnd = this.cursor;
        }
        this.render();
      };

      NumfieldEditor.prototype.moveRight = function(n) {
        var num = n || 1;
        if (!this.collapsed) {
          this.collapseToEnd();
        } else {
          this.cursor = Math.min(this.text.length, this.cursor + num);
          this.rangeEnd = this.cursor;
        }
        this.render();
      };

      NumfieldEditor.prototype.selectAll = function() {
        this.rangeEnd = 0;
        this.cursor = this.text.length;
        this.collapsed = this.cursor === this.rangeEnd;
        this.render();
      };

      NumfieldEditor.prototype.selectLeft = function(n) {
        var num = n || 1;
        this.rangeEnd = Math.max(0, this.rangeEnd - num);
        this.collapsed = this.cursor === this.rangeEnd;
        this.render();
      };

      NumfieldEditor.prototype.selectRight = function(n) {
        var num = n || 1;
        this.rangeEnd = Math.min(this.text.length, this.rangeEnd + num);
        this.collapsed = this.cursor === this.rangeEnd;
        this.render();
      };

      NumfieldEditor.prototype.collapse = function(n) {
        var num = n || this.text.length;
        this.cursor = num;
        this.rangeEnd = num;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.collapseToStart = function() {
        this.cursor = lesser(this.cursor, this.rangeEnd);
        this.rangeEnd = this.cursor;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.collapseToEnd = function() {
        this.cursor = greater(this.cursor, this.rangeEnd);
        this.rangeEnd = this.cursor;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.deleteAtCursor = function(n) {
        var num = n || 1;
        if (this.collapsed) {
          this.selectLeft(num);
        }
        this.insertAtCursor('');
      };

      NumfieldEditor.prototype.deleteRight = function(n) {
        var num = n || 1;
        if (this.collapsed) {
          this.selectRight(num);
        }
        this.insertAtCursor('');
      };

      NumfieldEditor.prototype.insertAtCursor = function(chars) {
        var text = this.text,
          lix = lesser(this.cursor, this.rangeEnd),
          rix = greater(this.cursor, this.rangeEnd),
          parts = [];
        if (lix > 0) {
          parts.push(text.substring(0, lix));
        }
        parts.push(chars);
        if (rix < text.length) {
          parts.push(text.substring(rix));
        }
        this.text = parts.join('');
        this.cursor = lix + chars.length;
        this.rangeEnd = this.cursor;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.paste = function(text) {
        this.insertAtCursor(text);
      };

      NumfieldEditor.prototype.isValueNegative = function() {
        if (this.text.substring(0, 1) === '-') {
          return true;
        } else {
          return false;
        }
      };

      NumfieldEditor.prototype.makeValueNegative = function() {
        var originCursorPos;
        if (this.text.length === 0) {
          // If the field is empty, we want to insert the character at the cursor like a normal number keypress
          // instead of prepending it to the number
          this.insertAtCursor('-');
        } else if (this.text.substring(0, 1) !== '-') {
          originCursorPos = this.cursor;
          this.setCursor(0);
          this.insertAtCursor('-');
          //we reset to original position + 1 because we've added a minus character to the string, so
          //we have to account for another character.
          this.setCursor(originCursorPos + 1);
          this.render();
        }
      };

      NumfieldEditor.prototype.makeValuePositive = function() {
        var originCursorPos;
        if (this.text.substring(0, 1) === '-') {
          originCursorPos = this.cursor;
          this.setCursor(1);
          this.deleteAtCursor();
          //we reset to original position - 1 because we've removed a minus character to the string, so
          //we have to account for one less character.
          this.setCursor(originCursorPos - 1);
          this.render();
        }
      };

      /* called at the beginning of an edit session */
      NumfieldEditor.prototype.prepare = function() {
        /*
         * Formats an editable expression representing a fraction of pi.
         * @param {object} piFrac An object describing fraction of pi.
         * { numerator: number, denominator: number }
         */
        function formatPiFraction(piFrac) {
          var strVal = '',
            absNum;
          if (piFrac.numerator === 0) {
            strVal = '0';
          } else {
            if (piFrac.numerator < 0) {
              strVal = '-';
            }
            absNum = Math.abs(piFrac.numerator);
            if (absNum !== 1) {
              strVal += absNum;
              strVal += '*';
            }
            strVal += '\u03C0'; // pi
            if (piFrac.denominator !== 1) {
              strVal += '/';
              strVal += piFrac.denominator;
            }
          }
          return strVal;
        }
        /*
         * Truncates a number to a given precision.
         */
        function truncate(val, precision) {
          var mul = Math.pow(10, precision);
          return String(Math.round(val * mul) / mul);
        }
        function getValueString(val, precision) {
          var piFrac = GSP.math.getSimplePiFraction(val),
            strVal;
          if (piFrac) {
            strVal = formatPiFraction(piFrac);
          } else {
            strVal = truncate(val, precision);
          }
          return strVal;
        }

        var gobj = this.gobj,
          precision = Math.max(3, gobj.style.precision),
          txt = gobj.blank ? '' : getValueString(gobj.uValue, precision);

        $(this.textNode).html(txt);
        this.text = txt;
        this.selectAll();

        var numpadRegime = GSP.NumpadEditRegime.createWithGObj(gobj);

        gobj.sQuery.sketch.event(
          'EditExpression',
          { gobj: gobj },
          { action: 'Started', value: gobj.value, expression: this.text }
        );

        this.gobj.sQuery.sketch.pushTouchRegime(numpadRegime);
        this.touchRegime = numpadRegime;
      };

      NumfieldEditor.prototype.reset = function() {
        this.text = '';
        this.cursor = 0;
        this.rangeEnd = 0;
        this.collapsed = true;
        this.render();
      };

      NumfieldEditor.prototype.moveUp = function() {};
      NumfieldEditor.prototype.moveDown = function() {};

      NumfieldEditor.prototype.tab = function() {};

      NumfieldEditor.prototype.positionCursorByOffset = function(pointerPageX) {
        var text = this.text,
          len = text.length,
          width,
          aveCharWidth,
          offset;
        offset = pointerPageX - $(this.textNode).offset().left;
        width = this.getTextWidth();
        aveCharWidth = len ? width / len : 0;

        if (offset > width) {
          this.setCursor(text.length);
        } else {
          this.setCursor(Math.round(offset / aveCharWidth));
        }
      };

      NumfieldEditor.prototype.submit = function() {
        blurAll();
      };

      NumfieldEditor.prototype.cleanupCalculatorState = function() {
        delete this.sessionID;

        if (this.touchRegime) {
          this.gobj.sQuery.sketch.popAllTouchRegimesIncluding(this.touchRegime);
        }

        this.touchRegime = null;
      };

      NumfieldEditor.prototype.finishEditing = function() {
        var gobj = this.gobj,
          oldValue = gobj.value,
          reason = this.closeReason,
          canceled = reason === 'changesNotAccepted';
        // reason is changesAccepted, changesNotAccepted, or undefined.
        // changesNotAccepted indicates user choice to cancel or press escape.
        // changesAccepted indicates user choice is OK or return key.
        // if neither, default is to accept the changes.
        // Note: this.text may be invalid even if reason is changesAccepted.
        // gobj.setEditedValue will set the value only if this.text is valid.

        this.cleanupCalculatorState();

        function gobjIsInSketch() {
          return gobj.sQuery().get(gobj.id) === gobj;
        }

        //Sanity check to make sure gobj is still around
        if (!gobjIsInSketch()) return;
        if (canceled) {
          this.text = oldValue.toString();
        }
        gobj.setEditedValue(this.text);
        gobj.state.selected = false;
        if (gobj.value === oldValue) {
          this.gobj.sQuery.sketch.event(
            'EditExpression',
            { gobj: this.gobj },
            { action: 'Canceled' }
          );
        } else {
          this.gobj.sQuery.sketch.event(
            'EditExpression',
            { gobj: this.gobj },
            {
              action: 'Confirmed',
              oldValue: oldValue,
              expression: this.text,
              newValue: this.gobj.value,
            }
          );
        }
        if (this.calculatorDidClose) this.calculatorDidClose(reason);
        delete this.closeReason; // restore initial editor state
      };

      return NumfieldEditor;
    })($);

    // Mathquill objects use this convention to refer to things on
    // either side of them, and at their "ends."
    var left = -1,
      right = 1;

    function CalculatorEditor(editorEl, gobj) {
      var editor = this;
      this.editorEl = editorEl;
      this.gobj = gobj;

      // Hook into the MathQuill private notification system to react
      // to 'cut' events, and check them for syntax errors.
      this.mq().__controller.constructor.onNotify(function(eventStr) {
        if (eventStr === 'cut') {
          editor.performEdit(function() {}); // do nothing, just check for errors
        }
      });
    }

    CalculatorEditor.prototype = Object.create(NumfieldEditor.prototype);

    /**
     * The main entry point to the MathQuill API
     *
     * @returns {Object} The Mathquill API Object
     */
    CalculatorEditor.prototype.mq = function() {
      var mq = MathQuill; // fool jshint
      return mq(this.editorEl[0]);
    };

    /**
     * Calls a function, passing in the Mathquill cursor
     *
     * @param {Function} func The function to call on the cursor
     * @returns {any} whatever func returns
     */
    CalculatorEditor.prototype.withCursor = function(func) {
      return func(this.mq().__controller.cursor);
    };

    CalculatorEditor.prototype.showCursor = function() {
      this.withCursor(function(c) {
        c.show();
      });
    };

    CalculatorEditor.prototype.moveToFarRight = function() {
      this.mq().moveToRightEnd();
    };

    CalculatorEditor.prototype.tab = function() {
      this.mq().keystroke('Tab');
    };

    CalculatorEditor.prototype.selectLeft = function(n) {
      this.mq().keystroke('Shift-Left');
    };

    /*
     * Paste a math expression into a calculator
     *
     * When Mathquill expressions are copied, they are wrapped in
     * '$'. This therefore unwraps them and calls out to mathquill to
     * parse them.
     *
     * Note: I am not sure they are still wrapped in '$'. We might be
     * able to get rid of the unwrapping.
     *
     * @param {String} text - the expression to paste in.
     */
    CalculatorEditor.prototype.paste = function(text) {
      if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
        text = text.slice(1, -1);
      }

      var editor = this;
      this.performEdit(function() {
        editor.writeLatex(text);
      });
    };

    CalculatorEditor.prototype.selectRight = function(n) {
      this.mq().keystroke('Shift-Right');
    };

    CalculatorEditor.prototype.insertAtCursor = function(chars, hideCursor) {
      this.mq().cmd(chars);
      if (!hideCursor) {
        this.showCursor();
      }
    };

    CalculatorEditor.prototype.writeLatex = function(latex) {
      this.mq().write(latex);
    };

    /*
     * Place the cursor two levels up and one to the right.  Some
     * mathquill objects, like parentheses, place the cursor two levels
     * deep. This is how to exit them.
     *
     */
    CalculatorEditor.prototype.ascendTwo = function() {
      this.withCursor(function(c) {
        c.insRightOf(c.parent.parent);
      });
    };

    CalculatorEditor.prototype.insertFunction = function(insertNameFunc) {
      this.insertAtCursor('(');
      this.moveLeft();
      insertNameFunc();
      this.moveRight();
    };

    CalculatorEditor.prototype.writeLiteral = function(text) {
      var textBlob = GSP.Strings.format('\\blob<span>%@</span>\\endBlob', [
        text,
      ]);
      this.writeLatex(textBlob);
    };

    CalculatorEditor.prototype.insertSimpleFunction = function(funcName) {
      var editor = this;
      this.insertFunction(function() {
        editor.writeLiteral(funcName);
      });
    };

    CalculatorEditor.prototype.insertParentFunction = function(refInfix) {
      var editor = this;
      this.insertFunction(function(/* cursor */) {
        GSP.mfs.renderMathquillFromParsedInfix(
          refInfix,
          editor,
          editor.parents
        );
      });
    };

    CalculatorEditor.prototype.deleteAtCursor = function(chars) {
      this.mq().keystroke('Backspace');
    };

    CalculatorEditor.prototype.deleteRight = function(chars) {
      this.mq().keystroke('Right Backspace');
    };

    CalculatorEditor.prototype.moveLeft = function(chars) {
      this.mq().keystroke('Left');
    };

    CalculatorEditor.prototype.moveRight = function(chars) {
      this.mq().keystroke('Right');
    };

    CalculatorEditor.prototype.moveUp = function(chars) {
      this.mq().keystroke('Up');
    };

    CalculatorEditor.prototype.moveDown = function(chars) {
      this.mq().keystroke('Down');
    };

    /*
     * Create a reference to the given parent and render it, as a tiny,
     * self-contained parsedInfix. We are referencing either a new-to-us
     * parent or a parent that is already in our parents list, so we avoid
     * pushing multiple identical objects onto that list.
     *
     * @param {Object} parent - a parent, either new to us or in our parents list
     *
     */
    CalculatorEditor.prototype.insertParent = function(parent) {
      var editor = this;

      function doInsert() {
        var i = 0,
          ref;

        while (true) {
          if (!editor.parents[i]) {
            // New to us.
            editor.parents[i] = parent;
            if (!parent.label && parent.style.nameOrigin === 'noVisibleName') {
              parent.label = parent.sQuery.sketch.labelPool.generateLabel(
                parent.kind,
                parent.genus,
                parent.id
              );
              // Show a newly-created label; once created the user can hide it.
              parent.style.nameOrigin = 'namedFromLabel';
              parent.updateLabel({ show: true });
              parent.invalidateGeom();
            }
          }
          if (editor.parents[i] === parent) {
            ref = {
              type: 'reference',
              name: String(i),
              kind: 'reference:' + i,
              children: {},
              refCount: 1,
              index: 0,
            };
            // If the parent thinks it can be a function,
            // treat it as a function.
            if (parent.isFunction && parent.isFunction()) {
              editor.insertParentFunction(ref);
            } else {
              GSP.mfs.renderMathquillFromParsedInfix(
                ref,
                editor,
                editor.parents
              );
            }
            return;
          }
          i++;
        }
      }

      editor.performEdit(doInsert);
    };

    /*
     * Renumber and cull parent refs.
     *
     * At the end of an edit session, we may have dangling references from
     * editor.parents, as the nodes they referenced may have been
     * deleted. So we ensure that all references in editor.parents actually
     * point to nodes in the mathquill tree, and that there are no gaps in
     * the index numbers.
     *
     * We also add composite text parents from editor.labelParents. These parents don't affect
     * the value of the calculation, but may specify labels required for its display.
     */
    CalculatorEditor.prototype.coalesceParents = function() {
      var i = 0,
        seen = {},
        editor = this,
        attrName = 'wsp-ref',
        parents = {};

      $('*[wsp-ref]', this.editorEl).each(function() {
        var $node = $(this),
          refNum = $node.attr(attrName);

        if (!seen[refNum]) {
          seen[refNum] = i;
          parents[i] = editor.parents[refNum];
          i++;
        }
        $node.attr(attrName, seen[refNum]);
      });
      // Now add labelParents, making sure that they are still used and are not duplicates
      editor.labelParents.forEach(function(item) {
        var inUse = false,
          duplicate = false,
          j;
        for (j = 0; j < i; j++) {
          if (parents[j] === item.valueGObj) {
            inUse = true;
          }
          if (parents[j] === item.labelGObj) {
            duplicate = true;
            break;
          }
        }
        if (inUse && !duplicate) {
          parents[i] = item.labelGObj;
          i++;
        }
      });
      editor.parents = parents;
    };

    /*
     * The editor is being shown. Reset all state, render an expression,
     * and push a new touch regime for back-clicking.
     */
    CalculatorEditor.prototype.prepare = function() {
      var editor = this,
        gobj = this.gobj,
        sketch = gobj.sQuery.sketch;

      editor.finishEditing = function() {
        console.log('finishEditing called for ', gobj, editor);
        var parentIds = [];
        editor.cleanupCalculatorState();
        if (editor.closeReason === 'changesAccepted') {
          gobj.parentsList.forEach(function(par) {
            parentIds.push(par.id);
          });
          sketch.event(
            'EditExpression',
            { gobj: gobj },
            {
              action: 'Confirmed',
              infix: gobj.parsedInfix,
              expressionType: gobj.expressionType,
              expression: gobj.expression,
              functionExpr: gobj.functionExpr,
              parentIds: parentIds,
              // This may differ for a calculation!!
            }
          );
        } else {
          sketch.event(
            'EditExpression',
            { gobj: gobj },
            { action: 'Canceled' }
          );
        }
        if (editor.calculatorDidClose) {
          editor.calculatorDidClose(editor.closeReason || 'changesNotAccepted');
        }
        editor.closeReason = null;
      };

      editor.reset();

      try {
        GSP.mfs.renderMathquillFromParsedInfix(
          editor.gobj.parsedInfix,
          editor,
          editor.gobj.parentsList
        );
        editor.showCursor();
      } catch (ex) {
        GSP.signalCaughtError(ex);
      }

      var backClickRegime = GSP.BackClickRegime.createWithEditor(editor);

      backClickRegime.delegate = editor;
      editor.gobj.sQuery.sketch.pushTouchRegime(backClickRegime);
      editor.touchRegime = backClickRegime;

      editor.gobj.sQuery().sketch.document.changedUIMode();

      editor.gobj.sQuery.sketch.event(
        'EditExpression',
        { gobj: editor.gobj },
        { action: 'Started' }
      );
    };

    /* Touch regime delegate implementation */
    CalculatorEditor.prototype.regimeDidPop = function(regime) {
      blurAll();
      this.gobj.sQuery().sketch.document.changedUIMode();
    };

    /*
     * Reset the state in order to show the Calculator
     */
    CalculatorEditor.prototype.reset = function() {
      var editor = this,
        gobj = this.gobj,
        i = 0;

      function getValueGObj(composite) {
        // return the first (ONLY) by-value parent
        var retVal;
        $.each(composite.MFSValues, function(key, val) {
          if (key.match(/byValue/)) {
            retVal = editor.gobj.sQuery('#' + val.referenceId);
            return false; // terminate search
          }
        });
        return retVal;
      }

      // Storage for variables that may be set during the edit. On
      // OK, we transfer them to the gobj.

      editor.parents = {};
      editor.labelParents = [];
      $.each(gobj.parents, function(key, parent) {
        // CompositeText parents provide parent labels, not values
        if (parent.constraint === 'CompositeText') {
          editor.labelParents.push({
            labelGObj: parent,
            valueGObj: getValueGObj(parent),
          });
        } else {
          editor.parents[i++] = parent;
        }
      });

      if (gobj.isFunction()) {
        editor.notation = gobj.functionExpr.notation;
        editor.independentVar = gobj.functionExpr.independentVar;
        // Populate equation menu
        editor.generateEquationOptions();
      }

      // Reset UI
      editor.hideErrorNotice();
      editor.mq().latex('');
    };

    /*
     * Set the edited function's independent variable name, and replace
     * every existing instance of an independent variable in the
     * rendered mathquill with the new variable name.
     *
     * @param {String} independentVar - the new independent variable name.
     *
     */
    CalculatorEditor.prototype.setIndependentVar = function(independentVar) {
      this.independentVar = independentVar;
      $('.wsp-independent-variable', this.editorEl).each(function() {
        $(this).text(independentVar);
      });
    };

    CalculatorEditor.prototype.registerIndependentVariable = function() {
      this.withCursor(function(c) {
        var variable = c[left];
        variable.jQ.eq(0).addClass('wsp-independent-variable');
      });
    };

    /*
     * Run a function and select whatever it renders.
     *
     * @param {Function()} func - the function to run. Should render
     * something to the mathquill edited element.
     */
    CalculatorEditor.prototype.renderAndSelect = function(func) {
      var editor = this;
      this.withCursor(function(c) {
        var leftStop = c[left];
        func();
        while (c[left] !== leftStop) {
          editor.selectLeft();
        }
      });
    };

    CalculatorEditor.prototype.renderOnLeft = function(func) {
      var rightStop, parent;

      this.withCursor(function(c) {
        if (c[right]) {
          rightStop = c[right];
          func();
          c.insLeftOf(rightStop);
        } else {
          parent = c.parent;
          func();
          c.insAtRightEnd(parent);
        }
      });
    };

    /*
     * The OK/Enter handler.
     */
    CalculatorEditor.prototype.submit = function() {
      var infix,
        editor = this,
        gobj = this.gobj;

      if (this.errorNoticeIsVisible()) {
        return; // don't submit erroneous input
      }

      function trySave() {
        editor.coalesceParents();

        infix = editor.translateMathQuillToInfix();

        if (gobj.isFunction()) {
          gobj.functionExpr.notation = editor.notation;
          switch (editor.independentVar) {
            case 'x':
              gobj.expressionType = 'YofX_FunctionExprType';
              gobj.functionExpr.dependentVar = 'y';
              break;
            case 'y':
              gobj.expressionType = 'XofY_FunctionExprType';
              gobj.functionExpr.dependentVar = 'x';
              break;
            case 'r':
              gobj.expressionType = 'TofR_FunctionExprType';
              gobj.functionExpr.dependentVar = 'θ';
              break;
            case 'θ':
              gobj.expressionType = 'RofT_FunctionExprType';
              gobj.functionExpr.dependentVar = 'r';
              break;
            case 't':
              gobj.expressionType = 'YofX_FunctionExprType';
              gobj.functionExpr.dependentVar = gobj.functionExpr.dependentVar;
              break;
            default:
              break;
          }
          gobj.functionExpr.independentVar = editor.independentVar;
        }

        try {
          // As with parameters, we do a redundant parse to check
          // for errors.
          GSP.mfs.getParsedInfixAndFunction(infix);
        } catch (ex) {
          return; // syntax error
        }
        // Error checking succeeded -- modify the gobj.
        gobj.parents = editor.parents;
        gobj.expression = infix;
        gobj.expressionAndParentsWereUpdated();
      }
      try {
        trySave();
      } catch (ex) {
        GSP.signalCaughtError(ex);
      }
      this.closeReason = 'changesAccepted';
      blurAll();
    };

    CalculatorEditor.prototype.getCalculatorElement = function() {
      return this.editorEl.closest('.wsp-Calculator');
    };

    CalculatorEditor.prototype.showErrorNotice = function() {
      this.getCalculatorElement().addClass('wsp-syntax-error');
      $('.wsp-Calculator-ok-button', this.getCalculatorElement()).attr(
        'disabled',
        'true'
      );
    };

    CalculatorEditor.prototype.hideErrorNotice = function() {
      this.getCalculatorElement().removeClass('wsp-syntax-error');
      $('.wsp-Calculator-ok-button', this.getCalculatorElement()).removeAttr(
        'disabled'
      );
    };

    CalculatorEditor.prototype.errorNoticeIsVisible = function() {
      return this.getCalculatorElement().hasClass('wsp-syntax-error');
    };

    /*
     * Run a function that changes the edited expression; then check
     * the new expression for syntax errors, and display or clear the
     * error notice.
     *
     * @param {Function} editFunc() - a function that edits the
     * current expression.
     *
     */
    CalculatorEditor.prototype.performEdit = function(editFunc) {
      var infix;

      editFunc();

      try {
        infix = this.translateMathQuillToInfix();

        GSP.mfs.getParsedInfixAndFunction(infix);
        this.hideErrorNotice();
      } catch (ex) {
        this.showErrorNotice();
      }
    };

    /*
     * Return this calculator's current session ID. A new session ID
     * is generated whenever the calculator is shown; this is used for
     * disallowing the act of copy/pasting reference blobs between
     * sessions, since reference indices (i.e. wsp-ref attributes) are
     * only meaningful within the context of a single session.
     */
    CalculatorEditor.prototype.getSessionID = function getSessionID() {
      if (this.sessionID === undefined) {
        this.sessionID = GSP.generateUUID();
      }
      return this.sessionID;
    };

    /*
     * This function is the mirror image of
     * GSP.mfs.renderMathquillFromParsedInfix. That one writes to
     * mathquill, this one reads from mathquill.
     */
    CalculatorEditor.prototype.translateMathQuillToInfix = function() {
      var editor = this;

      function translate($nodes) {
        function translateOne($node) {
          var children;

          function isIndependentVariable(txt) {
            switch (txt) {
              case 'x':
              case 'y':
              case 'r':
              case 'θ':
              case 't':
                return true;
            }
            return false;
          }

          function independentVariableIsValid(variable) {
            return (
              editor.gobj.isFunction() && variable === editor.independentVar
            );
          }

          function child(n, $ofParent) {
            if (!$ofParent) {
              $ofParent = $node;
            }
            return $ofParent.children().eq(n);
          }

          function translateBlob() {
            if (child(0).hasClass('wsp-ref')) {
              // References can only be pasted if they were copied
              // during the same calculator session.
              if (child(0).attr('wsp-sessionID') === editor.getSessionID()) {
                return '@' + child(0).attr('wsp-ref') + ' ';
              } else {
                // The text '??' will trigger a syntax error in the
                // infix parser, and visually indicate an error to the user.
                child(0).html('<span class="wsp-missing">??</span>');
              }
            }
            return child(0).text();
          }

          if ($node.hasClass('mq-non-leaf')) {
            var $first = child(0),
              $second;

            if ($node.hasClass('mq-supsub')) {
              // This looks like:
              // <span.mq-sup-sub><span.mq-sup>EXPONENT</span></span>
              // We only care about extracting EXPONENT from the inner node.
              return translate($node.children());
            }

            if ($first.hasClass('mq-sqrt-prefix')) {
              $second = child(1);
              return 'sqrt(' + translate($second.children()) + ')';
            } else if ($first.hasClass('mq-paren')) {
              // Three children: open delimiter, whatever is
              // parenthesized, close delimter.
              $second = child(1);
              children = translate($second.children());
              switch ($first.text()) {
                case '(':
                  return '(' + children + ')';
                case '|':
                  return 'abs(' + children + ')';
                default:
                  GSP.log('unrecognized delimiter: ' + $first.text());
                  return '(' + children + ')';
              }
            } else if ($first.hasClass('mq-numerator')) {
              $second = child(1);
              // We have to parenthesize not only the numerator and the denominator, but
              // the entire fraction as well.
              return (
                '((' +
                translate($first.children()) +
                ')/(' +
                translate($second.children()) +
                '))'
              );
            } else if (!$first.hasClass('mq-cursor')) {
              GSP.log('unrecognized child of non-leaf: ' + $first[0].outerHTML);
            }
            return '';
          } else if (
            $node.hasClass('mq-root-block') ||
            $node.hasClass('mq-selection') ||
            $node.hasClass('mq-text')
          ) {
            return translate($node.children());
          } else if ($node.hasClass('mq-sup')) {
            return '^(' + translate($node.children()) + ')';
          } else if ($node.hasClass('mq-blob')) {
            return translateBlob();
          } else if ($node.hasClass('mq-cursor')) {
            return '';
          } else if ($node.children().length === 0) {
            var textValue = $node.text() || '';
            if (
              isIndependentVariable(textValue) &&
              !independentVariableIsValid(textValue)
            ) {
              $node.addClass('wsp-missing');
              $node.text('??');
            }
            return $node.text() || '';
          } else {
            GSP.log('unrecognized mathquill node: ' + $node[0].outerHTML);
            return '';
          }
        }
        // mathquill uses fancy symbols, but we need plain ones for
        // the infix parser.
        function fixUp(val) {
          return val
            .replace('\u22C5', '*') // dot operator
            .replace('\u00B7', '*') // middle dot
            .replace('\u2212', '-') // minus sign
            .replace('\u0192', 'f') // small f with hook (function)
            .replace('\xa0', ''); // space
        }
        var ret = [];
        for (var i = 0; i < $nodes.length; i++) {
          ret.push(fixUp(translateOne($nodes.eq(i))));
        }
        return ret.join('');
      }

      function allButFirst($node) {
        return $('> :not(:first-child)', $node);
      }

      return translate(allButFirst(this.editorEl));
    };

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     * Class Numpad
     *
     * This class comprises the view and control elements for a numeric keypad.
     * A number pad exposed a number of keys that, when pressed cause
     * editing of the value in the number field.
     *
     * The numeric keypad is initially positioned immediately below the
     * number field, but it is draggable to any part of the browser viewport.
     *
     * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

    function Numpad() {
      if (!(this instanceof Numpad)) {
        return new Numpad();
      }
    }

    function attachToFastClickTarget(numpadEl, optSubselector) {
      var el = optSubselector ? $(optSubselector, numpadEl[0]) : numpadEl;
      if (el.length > 0) {
        GSP.FastClick.attach(el[0]);
      }
    }

    Numpad.prototype = {
      /*  Attach fastclick to potential elements that might
       *  be used in the numpad or calculator, avoiding
       *  any mathquill areas where fastclick conflicts on iOS
       */
      attachFastClick: function() {
        attachToFastClickTarget(this.numpadEl);
      },
      init: function(editedEl, parentEl, visible, gobj) {
        var ix, jx, bodyEl, rowEl;

        this.decimalSeparator =
          gobj.sQuery.sketch.document.formatOptions.decimalSeparator;
        this.editedEl = editedEl;

        numpadCt += 1;
        this.numpadHome = parentEl;
        this.numpadEl = $('<div>')
          .addClass(this.cssClass)
          .prop({
            /*draggable: true,*/
            tabIndex: -1, // focusable but not in tab order
            id: 'numpad' + numpadCt,
          })
          .css({ position: 'absolute' })
          .attr({ role: 'dialog', 'aria-labelledby': 'numpadLabel' + numpadCt })
          .append(
            $(
              '<h2 style="display: none;" id="numpadLabel' +
                numpadCt +
                '">Number Pad</h2>'
            )
          );

        this.initializeEventHandlers();

        var headerElts = this.addHeader(gobj);
        this.dragHandle = headerElts.dragHandle;
        this.editor = this.createEditor(headerElts.editorElt, gobj);

        bodyEl = this.addBody();

        // construct the keypad keys
        var keyOrder = GSP.getConfigValue(this.getConfigKey());

        for (ix = 0; ix < keyOrder.length; ix += 1) {
          rowEl = $('<div>').addClass('wsp-Numberpad-row');
          for (jx = 0; jx < keyOrder[ix].length; jx += 1) {
            rowEl.append(this.makeKey(keyOrder[ix][jx]));
          }
          bodyEl.append(rowEl);
        }
        this.initializeKeys(this.numpadEl);
        this.addElementForAccessibility();
        this.attachFastClick();

        // hide, if requested
        if (!visible) {
          this.hide();
        }

        this.numpadEl.css('visibility', 'hidden');
        this.numpadHome.append(this.numpadEl);
        this.position();
        this.numpadEl.css('visibility', 'visible');

        function handleMouseDown(ev) {
          function handleMouseMove(ev) {
            var numpad = ev.data,
              x,
              y;
            ev.preventDefault();
            x = ev.pageX - numpad.touch.dx;
            y = ev.pageY - numpad.touch.dy;
            //console.log('Touch x,y: ' + [x,y].join());
            numpad.numpadEl.offset({ left: x, top: y });
          }
          function handleMouseUp(ev) {
            $(document).off('mousemove', handleMouseMove);
            $(document).off('mouseup', handleMouseUp);
          }
          var numpad = ev.data;
          ev.preventDefault();
          numpad.focus();
          numpad.touch = {
            dx: ev.pageX - $(this).offset().left,
            dy: ev.pageY - $(this).offset().top,
          };
          $(document).on('mousemove', numpad, handleMouseMove);
          $(document).on('mouseup', numpad, handleMouseUp);
        }

        function handleTouchStart(ev) {
          function handleTouchMove(ev) {
            var orig = ev.originalEvent,
              numpad = ev.data,
              touchCt = orig.touches.length,
              touch,
              x,
              y;
            if (touchCt >= 1) {
              ev.preventDefault();
              touch = orig.touches[0];
              x = touch.pageX - numpad.touch.dx;
              y = touch.pageY - numpad.touch.dy;
              //console.log('Touch x,y: ' + [x,y].join());
              numpad.numpadEl.offset({ left: x, top: y });
            }
          }
          function handleTouchEnd(ev) {
            $(this).off('touchmove', handleTouchMove);
            $(this).off('touchend', handleTouchEnd);
          }
          var orig = ev.originalEvent,
            numpad = ev.data,
            touchCt = orig.touches.length,
            touch;
          if (touchCt === 1) {
            ev.preventDefault();
            touch = orig.touches[0];
            numpad.touch = {
              dx: touch.pageX - $(this).offset().left,
              dy: touch.pageY - $(this).offset().top,
            };
          }
          $(this).on('touchmove', numpad, handleTouchMove);
          $(this).on('touchend', numpad, handleTouchEnd);
        }

        $(this.dragHandle).on('mousedown', this, handleMouseDown);
        $(this.dragHandle).on('touchstart', this, handleTouchStart);
      },
      createEditor: function(editorEl, gobj) {
        return new NumfieldEditor(editorEl, gobj);
      },
      addHeader: function() {
        var el = $('<div>').addClass('wsp-Numberpad-header');
        var cancelEl = $('<button aria-label="Close"></button>').addClass(
          'wsp-Numberpad-cancel'
        );
        cancelEl.appendTo(el);
        cancelEl
          .on('touchstart mousedown', function() {
            blurAll();
          })
          .on('keydown', function(e) {
            if (e.which === 32 || e.which === 13) {
              blurAll();
            }
          });
        this.numpadEl.append(el);
        // For Numberpads, the edited element is the editor element
        return { dragHandle: el, editorElt: this.editedEl };
      },
      addBody: function() {
        var bodyEl = $('<div></div>').addClass('wsp-Numberpad-body');
        this.numpadEl.append(bodyEl);
        return bodyEl;
      },
      addElementForAccessibility: function() {
        var firstElement = $(
            '<button id="firstElement" aria-label="blank" class="wsp-sr-only" type="button"></button>'
          ),
          lastElement = $(
            '<button id="lastElement" aria-label="blank" class="wsp-sr-only" type="button"></button>'
          );

        firstElement.focusin(function(e) {
          $('.wsp-Numberpad-key-backspace').focus();
        });
        lastElement.focusin(function(e) {
          $('.wsp-Numberpad-cancel').focus();
        });

        this.numpadEl.append(lastElement).prepend(firstElement);
      },
      getConfigKey: function() {
        return 'NumberpadManager.options.keyOrder';
      },
      cssClass: 'wsp-Numberpad',
      keySpecs: {
        '1': { clss: 'wsp-Numberpad-numkey', ent: '1' },
        '2': { clss: 'wsp-Numberpad-numkey', ent: '2' },
        '3': { clss: 'wsp-Numberpad-numkey', ent: '3' },
        '4': { clss: 'wsp-Numberpad-numkey', ent: '4' },
        '5': { clss: 'wsp-Numberpad-numkey', ent: '5' },
        '6': { clss: 'wsp-Numberpad-numkey', ent: '6' },
        '7': { clss: 'wsp-Numberpad-numkey', ent: '7' },
        '8': { clss: 'wsp-Numberpad-numkey', ent: '8' },
        '9': { clss: 'wsp-Numberpad-numkey', ent: '9' },
        '0': { clss: 'wsp-Numberpad-numkey', ent: '0' },
        dot: { clss: 'wsp-Numberpad-numkey', ent: '.' },
        pi: { clss: 'wsp-Numberpad-numkey', ent: '&#x003C0;' },
        plus: { clss: 'wsp-Numberpad-control-key', ent: '+' },
        minus: { clss: 'wsp-Numberpad-control-key', ent: '-' },
        exponent: { clss: 'wsp-Numberpad-control-key', ent: '^' },
        opposite: {
          clss: 'wsp-Numberpad-control-key',
          ent: '&#177;',
          op: 'opposite',
        },
        star: { clss: 'wsp-Numberpad-control-key', ent: '*', op: 'insertStar' },
        slash: { clss: 'wsp-Numberpad-control-key', ent: '/' },
        lparen: { clss: 'wsp-Numberpad-control-key', ent: '(' },
        rparen: { clss: 'wsp-Numberpad-control-key', ent: ')' },
        backspace: {
          clss: 'wsp-Numberpad-control-key wsp-Numberpad-erase-to-left',
          ent: '',
          op: 'backspace',
        },
        clear: {
          clss: 'wsp-Numberpad-control-key wsp-Numberpad-clear',
          ent: '',
          op: 'reset',
        },
        submit: {
          clss: 'wsp-Numberpad-control-key',
          ent: '&#10003;',
          op: 'submit',
        },
        left: { op: 'moveLeft' },
        right: { op: 'moveRight' },
        up: { op: 'moveUp' },
        down: { op: 'moveDown' },
        tab: { op: 'tab' },
        selectleft: { op: 'selectLeft' },
        selectright: { op: 'selectRight' },
        x: { op: 'xPressed' },
        y: { op: 'yPressed' },
        r: { op: 'rPressed' },
        t: { op: 'tPressed' },
        esc: { op: 'doCancel' },
        delete: { op: 'deleteRight' },
      },
      makeKey: function(id) {
        var key = this.keySpecs[id],
          rtn;
        if (key) {
          var ent = key.ent;
          var keyText;
          var keyAriaLabel = id;

          // localize dot
          if (id === 'dot') {
            ent = this.decimalSeparator;
            keyAriaLabel = 'decimal point';
          }

          keyText = $('<div/>')
            .html(ent)
            .text(); // convert HTML entities to text
          rtn = $('<button aria-label="' + keyAriaLabel + '"></button>')
            .addClass('wsp-Numberpad-key wsp-Numberpad-element')
            .addClass(key.clss)
            .addClass('wsp-Numberpad-key-' + id)
            .attr('data-keyText', keyText)
            .data('wsp-key-name', id);
          key.value = keyText;
        } else if (id === '') {
          rtn = $('<div></div>').addClass('wsp-Numberpad-element');
        } else {
          //console.log('id not found: ' + id);
          rtn = $('<div></div>').text('?');
        }
        return rtn;
      },
      getKeyValue: function(keyName) {
        return this.keySpecs[keyName].value;
      },
      initializeKeys: function(el) {
        $('.wsp-Numberpad-key', el).on('click', this, function(ev) {
          ev.data.keyPressed($(this).data('wsp-key-name'));
          return false;
        });
      },

      initializeEventHandlers: function() {},

      hide: function() {
        $(this.numpadEl).hide();
      },
      focus: function() {
        var self = this;
        setTimeout(function() {
          // Why should focusing on the numberpad focus the cancel button?
          // This was changed from $(self.numpadEl).focus(), presumably for accessibility, but why?
          $(self.numpadEl)
            .find('.wsp-Numberpad-cancel')
            .focus();
        }, 100);
      },

      position: function() {
        var numpadWidth = this.numpadEl.outerWidth(),
          numpadHeight = this.numpadEl.outerHeight(),
          editedElHeight = $(this.editedEl).outerHeight(),
          pos = $(this.editedEl).offset(),
          scrollTop = $(document).scrollTop(),
          topAvailable = pos.top - $(document).scrollTop(),
          bottomAvailable =
            scrollTop + $(window).height() - (pos.top + editedElHeight),
          leftAvailable = pos.left,
          shortBottom = bottomAvailable < numpadHeight,
          shortScreen = topAvailable < numpadHeight && shortBottom;

        if (shortScreen) {
          pos.top = scrollTop;
        } else if (shortBottom) {
          pos.top -= numpadHeight;
        } else {
          pos.top += editedElHeight;
        }
        if (leftAvailable < numpadWidth) {
          if (shortScreen) {
            // we're forced to the right of the input
            pos.left += numpadWidth / 2;
          }
        } else {
          pos.left -= numpadWidth;
        }
        this.numpadEl.offset(pos);
      },

      show: function() {
        $(this.numpadEl).show();
        this.position();
      },

      keyPressed: function(keyName) {
        var keyInfo = this.keySpecs[keyName];
        if (keyInfo) {
          if (keyInfo.op) {
            if (this[keyInfo.op]) {
              this[keyInfo.op]();
            } else if (this.editor[keyInfo.op]) {
              this.editor[keyInfo.op]();
            }
          } else {
            if (keyInfo.value !== undefined) {
              this.editor.insertAtCursor(keyInfo.value);
            }
          }
          this.editor.gobj.sQuery.sketch.setSpeakabletext(
            'Display is ' + this.editor.text
          );
        }
      },

      backspace: function() {
        this.editor.deleteAtCursor();
      },

      /*
       * Toggles the negative/positive sign of the value.
       */
      opposite: function() {
        if (!this.editor.isValueNegative()) {
          this.editor.makeValueNegative();
        } else {
          this.editor.makeValuePositive();
        }
      },

      unpressAllKeys: function() {
        $('.wsp-Numberpad-key', this.numpadEl).removeClass(
          'wsp-Numberpad-key-down'
        );
      },

      submit: function() {
        this.editor.closeReason = 'changesAccepted';
        this.editor.submit();
        this.unpressAllKeys();
      },

      insertStar: function() {
        // Check that this key has been enabled. This value is set by makeKey().
        if (this.keySpecs.star.value) {
          this.editor.insertAtCursor('*');
        }
      },

      doCancel: function() {
        this.editor.closeReason = 'changesNotAccepted';
        blurAll();
      },
    };

    function Calculator() {
      Numpad.apply(this, arguments);
    }

    function isInCalculator($elt) {
      return $elt.closest('.wsp-Calculator').length;
    }

    Calculator.prototype = Object.create(Numpad.prototype);
    Calculator.prototype.keySpecs = $.extend(
      true,
      {},
      Numpad.prototype.keySpecs
    );

    Calculator.prototype.attachFastClick = function() {
      attachToFastClickTarget(this.numpadEl, '.wsp-Calculator-body-wrapper');
      attachToFastClickTarget(this.numpadEl, '.wsp-Calculator-bottom');
    };

    Calculator.prototype.createEditor = function(editorEl, gobj) {
      return new CalculatorEditor(editorEl, gobj);
    };

    Calculator.prototype.keyPressed = function(keyName) {
      var calculator = this;

      this.editor.performEdit(function() {
        Numpad.prototype.keyPressed.call(calculator, keyName);
      });
    };

    /**
     * Initialize MathqQuill on an editor element
     *
     * @param {Jquery Object} editorElt - the Editor element containing
     * the mathquill tree
     * @returns {undefined}
     */
    Calculator.prototype.initMathQuill = function(editorElt) {
      // If we're on mobile, don't use a textarea, beacuse focusing it
      // calls up the soft keyboard, which we don't want.

      // This is how mozilla recommends testing for a mobile User Agent
      // https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
      var isMobile = /(Mobi)|(Android)/.test(navigator.userAgent);

      MathQuill.MathField(editorElt[0], {
        substituteTextarea: function() {
          var $focusable = isMobile
            ? $('<span tabindex="0"></span>>')
            : $('<textarea></textarea>');
          return $focusable[0];
        },
      });
    };

    Calculator.prototype.initializeEventHandlers = function(gobj) {
      var calculator = this;
      // Event listener that moves the cursor to the far right.  It
      // only responds to clicks on the editor pane, but outside the
      // mathquill element.
      this.numpadEl.on('click', function(ev) {
        var isInsideMathquill = $(ev.target).closest('.wsp-calculator-edited')
          .length;
        var isInsideDisplay = $(ev.target).closest('.wsp-Calculator-display')
          .length;
        if (isInsideDisplay && !isInsideMathquill) {
          calculator.editor.moveToFarRight();
        }
        calculator.editor.showCursor();
        calculator.focus();
      });

      // This prevents blur of mathquill, and hence keeps the editor
      // selection intact when clicking on the calculator. We've also
      // hacked bootstrap to not set the focus on its dropdown toggle
      // buttons, because mathquill clears the selection on blur, and
      // neither toolkit is extensible in this regard.
      this.numpadEl.on('mousedown', function(ev) {
        if (isInCalculator($(document.activeElement))) {
          ev.preventDefault();
        }
      });
    };

    Calculator.prototype.addHeader = function(gobj) {
      var title,
        display,
        editorElt,
        displayWrapper,
        errorNotice = $('<span>').addClass('wsp-syntax-error-notice');
      title = $('<div/>').addClass('wsp-Calculator-title');
      title.text('Edit ' + (gobj.isFunction() ? 'Function' : 'Calculation'));
      editorElt = $('<span/>').css('border', 'none');
      this.initMathQuill(editorElt);
      editorElt.addClass('wsp-calculator-edited');
      display = $('<div/>')
        .addClass('wsp-Calculator-display')
        .append(editorElt);
      displayWrapper = $('<div>')
        .addClass('wsp-Calculator-display-wrapper')
        .append(display)
        .append(errorNotice);
      this.numpadEl.append(title).append(displayWrapper);
      return { dragHandle: title, editorElt: editorElt };
    };

    Calculator.prototype.insertIndependentVariable = function(variable) {
      if (
        this.editor.gobj.isFunction() &&
        variable === this.editor.independentVar
      ) {
        this.editor.insertAtCursor(variable);
        this.editor.registerIndependentVariable();
      }
    };

    Calculator.prototype.xPressed = function() {
      this.insertIndependentVariable('x');
    };
    Calculator.prototype.yPressed = function() {
      this.insertIndependentVariable('y');
    };
    Calculator.prototype.rPressed = function() {
      this.insertIndependentVariable('r');
    };
    Calculator.prototype.tPressed = function() {
      this.insertIndependentVariable('θ');
    }; // use either t or θ depending on original

    Calculator.prototype.addBody = function() {
      var calculator = this,
        wrapper = $('<div/>').addClass('wsp-Calculator-body-wrapper'),
        left = $('<div/>').addClass('wsp-Calculator-left'),
        labelInsert = $('<p/>')
          .addClass('wsp-Calculator-label-insert')
          .text('Insert:'),
        select = function(name, innerText, options) {
          var dropdownEl = $('<div/>').addClass('dropdown'),
            selectEl = $('<ul/>').addClass('dropdown-menu'),
            titleEl = $('<button/>')
              .addClass('dropdown-toggle')
              .attr('data-toggle', 'dropdown')
              .addClass('wsp-Calculator-textual')
              .text(innerText)
              .append($('<span/>').addClass('caret'));
          dropdownEl.append(titleEl).append(selectEl);
          if (options) {
            for (var i = 0; i < options.length; i++) {
              selectEl.append(options[i]);
            }
          }
          return dropdownEl;
        },
        button = function() {
          return $('<button/>')
            .addClass('wsp-Calculator-textual')
            .addClass('wsp-Calculator-bottom-button');
        },
        forInsert = function($select) {
          return $select.addClass('wsp-Calculator-select-for-insert');
        },
        separator = function() {
          return $('<li/>').addClass('divider');
        },
        mkOption = function(value, text, italicize) {
          var option = $('<a/>')
            .data('value', value)
            .text(text ? text : value);
          if (italicize) option.css('font-style', 'italic');
          return $('<li/>').append(option);
        },
        /* Bootstrap expects dropdown options as li > a, so we set
         * properties on the a element. */
        setOptionData = function(option, key, value) {
          $('a', option).data(key, value);
          return option;
        },
        setOptionText = function(option, text) {
          $('a', option).text(text);
          return option;
        },
        setOptionClass = function(option, clazz) {
          $('a', option).addClass(clazz);
          return option;
        },
        mkIndependentVariableOption = function() {
          // This will vary with the equation menu.
          return setOptionClass(
            mkOption('', '', true),
            'wsp-independent-variable-option'
          );
        },
        selected = function(option) {
          return option.addClass('selected');
        },
        selectValue = select('values', 'Values', [
          separator(),
          mkIndependentVariableOption(),
          separator(),
          mkOption('pi', '\u03C0', true),
          mkOption('e', 'e', true),
        ]).addClass('wsp-Calculator-topmost-select-for-insert'),
        selectFunction = forInsert(
          select('functions', 'Functions', [
            separator(),
            mkOption('function', 'sin'),
            mkOption('function', 'cos'),
            mkOption('function', 'tan'),
            mkOption('function', 'Arcsin'),
            mkOption('function', 'Arccos'),
            mkOption('function', 'Arctan'),
            separator(),
            mkOption('|', 'abs'),
            mkOption('\\sqrt', 'sqrt'),
            mkOption('function', 'ln'),
            mkOption('function', 'log'),
            mkOption('function', 'sgn'),
            mkOption('function', 'round'),
            mkOption('function', 'trunc'),
          ])
        ).addClass('wsp-select-function'),
        selectUnits = forInsert(
          select('units', 'Units', [
            separator(),
            mkOption(' pixels'),
            mkOption(' cm'),
            mkOption(' in.', ' inches'),
            separator(),
            mkOption(' radians'),
            mkOption(' degrees'),
          ])
        ).addClass('wsp-select-units'),
        bodyEl = $('<div/>').addClass('wsp-Calculator-body'),
        bottom = $('<div/>').addClass('wsp-Calculator-bottom'),
        // Equation options are added dynamically, and may change
        selectEquation = select('equation', 'Equation', []).addClass(
          'wsp-Calculator-select-equation'
        ),
        cancelButton = button().text('Cancel'),
        okButton = button()
          .addClass('wsp-Calculator-ok-button')
          .append(
            $('<span/>')
              .addClass('wsp-Calculator-ok-button-inner')
              .text('OK')
          );
      $(cancelButton).on('click', function() {
        calculator.doCancel();
        return false;
      });

      $(okButton).on('click', function() {
        calculator.editor.submit();
        return false;
      });

      left
        .append(labelInsert)
        .append(selectValue)
        .append(selectFunction)
        .append(selectUnits);

      $('a', left).on('click', function(ev) {
        var selected = $(this),
          val = selected.data('value');

        calculator.editor.performEdit(function() {
          if (val === 'function') {
            calculator.editor.insertSimpleFunction(selected.text());
          } else {
            calculator.editor.insertAtCursor(val);
            if (selected.hasClass('wsp-independent-variable-option')) {
              calculator.editor.registerIndependentVariable();
            }
          }
        });
      });

      wrapper.append(left).append(bodyEl);

      // Only functions have an equation menu
      if (!calculator.editor.gobj.isFunction()) {
        selectEquation.css('visibility', 'hidden'); // keep it in the dom for formatting
      }

      function setOptions(dropdown, options) {
        var menu = $('.dropdown-menu', dropdown);
        menu.empty();
        for (var i = 0; i < options.length; i++) {
          menu.append(options[i]);
        }
      }
      function setIndependentVariableOption() {
        var option = $(
          '.wsp-independent-variable-option',
          selectValue
        ).parent();
        setOptionData(option, 'value', calculator.editor.independentVar);
        setOptionText(option, calculator.editor.independentVar);
      }

      /*
       * Generate options for the equation menu.
       *
       * This method will be called when an editor is first created,
       * and also whenever an option is selected from the equation
       * menu.
       *
       */
      calculator.editor.generateEquationOptions = function() {
        var options,
          independentVar = calculator.editor.independentVar;

        function getDependentVar() {
          switch (independentVar) {
            case 'x':
              return 'y';
            case 'y':
              return 'x';
            case 'r':
              return 'θ';
            case 'θ':
              return 'r';
            // allow for functions of time and parametric functions
            case 't':
              return calculator.editor.gobj.functionExpr.dependentVar;
          }
          throw GSP.createError('unrecognized independent variable');
        }
        function generateVariableOption(newIndependentVar, label) {
          var option = mkOption(label);
          setOptionData(option, 'independentVar', newIndependentVar);
          return independentVar === newIndependentVar
            ? selected(option)
            : option;
        }

        function generateNotationOptions() {
          var dependentVarOption = mkOption(getDependentVar() + '= notation'),
            functionOption = mkOption('f(' + independentVar + ') notation');
          setOptionData(dependentVarOption, 'notation', 'dependentVariable');
          setOptionData(functionOption, 'notation', 'function');
          if (calculator.editor.notation === 'function') {
            functionOption = selected(functionOption);
          } else {
            dependentVarOption = selected(dependentVarOption);
          }
          return [separator(), dependentVarOption, functionOption, separator()];
        }

        options = generateNotationOptions().concat([
          generateVariableOption('x', 'y = f(x)'),
          generateVariableOption('y', 'x = f(y)'),
          generateVariableOption('θ', 'r = f(θ)'),
          generateVariableOption('r', 'θ = f(r)'),
          generateVariableOption(
            't',
            calculator.editor.gobj.functionExpr.dependentVar + ' = f(t)'
          ),
        ]);

        setOptions(selectEquation, options);
        setIndependentVariableOption();

        $('a', selectEquation).on('click', function(ev) {
          var selected = $(this),
            independentVar = selected.data('independentVar'),
            notation;

          if (independentVar) {
            calculator.editor.setIndependentVar(independentVar);
          } else {
            notation = selected.data('notation');
            if (notation) {
              calculator.editor.notation = notation;
            }
          }
          calculator.editor.generateEquationOptions();
        });
      };

      bottom
        .append(selectEquation)
        .append(cancelButton)
        .append(okButton);
      this.numpadEl.append(wrapper).append(bottom);
      $('.dropdown-toggle', this.numpadEl).dropdown();

      return bodyEl;
    };

    Calculator.prototype.getConfigKey = function() {
      return 'NumberpadManager.options.keyOrderCalculator';
    };

    /**
     * Gives focus to the mathquill element. We set focus here
     * whenever the calculator is brought up or clicked.
     *
     * Because of strange behavior on chrome, we use .select instead
     * of .focus. The issue was that if you selected text, typed a
     * number key to insert the number, then clicked away from the
     * calculator (losing focus), then clicked the calculator again to
     * regain focus, if the document had been scrolled down at all, it
     * would scroll all the way to the top.
     */
    Calculator.prototype.focus = function() {
      // The final focused element is either an invisible textarea or,
      // on mobile, a span with tabIndex.
      this.editor.editorEl.find('.mq-textarea *').focus();
    };

    Calculator.prototype.cssClass = 'wsp-Calculator';

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     * Class NumfieldCtl
     *
     * Manages a number field. Principally, this is managing focus state.
     * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    function NumfieldCtl(editedEl, parentEl) {
      if (!(this instanceof NumfieldCtl)) {
        return new NumfieldCtl(editedEl);
      }

      $(editedEl).css({
        'user-select': 'none',
      });
      this.editedEl = editedEl;
      this.numpadParent = parentEl;
      this.hasVFocus = false;
      this.numpad = null;
      numfields.push(this);
    }

    NumfieldCtl.prototype = {
      createAndInitNumpad: function(gobj) {
        this.numpad = this.createNumpad();
        this.numpad.init(this.editedEl, this.numpadParent, true, gobj);
        this.numpad.numpadEl.css('z-index', 2); // Keep calculator in front of widgets
      },

      isModalController: false,
      createNumpad: function() {
        return new Numpad();
      },

      /*
       * Set virtual focus to this object this means:
       * (a) remove virtual focus from all other objects within this context,
       * (b) blur browser focus in the enclosing document,
       * (c) generate a vFocus event.
       * (d) create or make visible a number pad immediately below
       *     the number field. If necessary, bind number pad keys to the
       *     number field.
       * (e) position the cursor according to the click location.
       */
      vFocus: function(gobj) {
        var that = this;
        // remove vFocus from others
        blurAll();

        // gen vFocus event.
        // Ensure the Numpad exists before attaching the editor.
        window.setTimeout(function() {
          // create or make visible the numpad
          that.hasVFocus = true;
          if (!that.numpad) {
            that.createAndInitNumpad(gobj);
          } else {
            that.numpad.show();
          }
          that.numpad.editor.prepare();
          that.numpad.focus();
          if (that.futureDidCloseCallback) {
            that.numpad.editor.calculatorDidClose = that.futureDidCloseCallback;
            that.futureDidCloseCallback = null;
          }
        }, 0);
      },
      /*
       * Remove virtual focus.
       * (a) Generate a vBlur event.
       * (b) Hide the number pad.
       */
      vBlur: function() {
        var self = this;
        if (this.hasVFocus) {
          this.numpad.editor.unsetCursor();
          this.hasVFocus = false; // do this before calling finishEditing, which otherwise generates a recursive call to vBlur
          this.numpad.editor.finishEditing();
          // hide the number pad
          setTimeout(function() {
            self.editedEl.focus();
            self.numpad.hide();
          }, 100);
        }
      },
      click: function(touch, gobj) {
        if (!this.hasVFocus) {
          this.vFocus(gobj);
        } else {
          this.numpad.editor.positionCursorByOffset(touch.pageX);
        }
      },
      paste: function(clipboardData) {
        var txt = clipboardData.getData('text/plain');
        this.numpad.editor.paste(txt);
      },
      setListener: function(callback) {
        if (this.numpad && this.numpad.editor) {
          this.numpad.editor.calculatorDidClose = callback;
        } else {
          //Stash the callback here for adding when we have actually created the editor
          this.futureDidCloseCallback = callback;
        }
      },
      clearListener: function() {
        if (this.numpad && this.numpad.editor) {
          this.numpad.editor.calculatorDidClose = null;
        }
        this.futureDidCloseCallback = null;
      },
    };

    function CalculatorCtl() {
      NumfieldCtl.apply(this, arguments);
    }

    CalculatorCtl.prototype = Object.create(NumfieldCtl.prototype);

    CalculatorCtl.prototype.createNumpad = function() {
      return new Calculator();
    };

    CalculatorCtl.prototype.isModalController = true;

    function createNumpadMgr() {
      // handle paste, if within our domain...
      $(document).on('paste', function(ev) {
        var ctl = getFocusedCtl();
        if (ctl) {
          ctl.paste(ev.originalEvent.clipboardData);
          return false;
        }
        return true;
      });

      // if any field in the page gets focus, blur the fields managed herein.
      $(document).on('focus', '*', function(ev) {
        //GSP.log('Blurring numpad: another el wants focus.');

        // IE will focus an element you click on, including
        // the numpad key. Let's ignore anything that's in a numpad
        if (
          (ev.currentTarget && $(ev.currentTarget).is('.wsp-Numberpad')) ||
          $(ev.currentTarget).is('.wsp-Numberpad *')
        ) {
          return false;
        }
        blurAll(true); // exempt modals (calculators)
      });

      $(document).on('StopCurrentPage.WSP', function() {
        removeNumpads();
      });

      // map key up and key down events to numpad actions,
      // when we have a numfield in focus
      $(document).on('keydown keyup', function(ev) {
        var ctl = getFocusedCtl(),
          numpad,
          keyString,
          keyName;

        var inCalc = isInCalculator($(ev.target));
        //console.log('event: ' + ev.type + ' code: ' + code);
        if (!ctl) return;
        if (ctl.isModalController && !inCalc) return;
        numpad = ctl.numpad;
        keyString = composeKeyString(ev);
        keyName = keyMap[keyString];

        // Numpad as part of accessibility doesn't support generic handling of enter = submit,
        // since enter means 'activate current button'. Calculator isn't yet accessibile.
        if (!keyName && inCalc) {
          if (keyString === '13') {
            keyName = 'submit';
          }
        }

        if (keyName) {
          ev.preventDefault();
          if (ev.type === 'keydown') {
            $('.wsp-Numberpad-key-' + keyName, numpad.numpadEl).addClass(
              'wsp-Numberpad-key-down'
            );
            numpad.keyPressed(keyName);
          } else {
            $('.wsp-Numberpad-key-' + keyName, numpad.numpadEl).removeClass(
              'wsp-Numberpad-key-down'
            );
          }
        }
      });

      function getNumberPadParentElement() {
        // Interpolated at build time
        var $existing = $('body > .wsp-Numpads.wsp-version-4-8-0');

        if ($existing.length) {
          return $existing;
        }

        return $('<div/>')
          .addClass('wsp-Numpads wsp-version-4-8-0')
          .appendTo($('body'));
      }

      function NumpadMgr() {}

      NumpadMgr.prototype.register = function($element) {
        var parentEl = getNumberPadParentElement(),
          controller;

        if ($element.hasClass('mfs-input')) {
          controller = new NumfieldCtl($element[0], parentEl);
        } else {
          controller = new CalculatorCtl($element[0], parentEl);
        }

        // attach numfield control
        $element.data('wsp-numfield-ctl', controller);
      };

      NumpadMgr.prototype.blurNumpads = function() {
        blurAll();
      };
      return new NumpadMgr();
    }
    return createNumpadMgr();
  })(jQuery);

  /**
   * @fileOverview Main EventEmitter object that handles Events API implementation.
   * @author <a href="mailto:rcheung@kcptech.com">Raymond Cheung</a>
   * @version 0.0
   *
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * Event emitter that handles the firing off(trigger) of special events, usually generated by
   * user actions(click, drag, scroll, etc.)  This is differentiated from the SketchEvent
   * module generally by being events that are direct results of user actions.
   *
   * @constructor
   * @param {Element} node The jQuery element to attach to.
   * @param {object} spec  The JSON specification of the sketch.
   * @return {GSP.Sketch} a sketch object.
   */
  GSP.EventEmitter = (function() {
    var EventEmitterPrototype = {
      // This is a list of events that will trigger the Event API.  Despite not showing here, all events
      // have the suffix ".WSP" when interacted with outside of this array.  It is not added here for the
      // sake of brevity, e.g. "LoadPage" is actually "LoadPage.WSP".
      events: [
        'StartCurrentPage',
        'StopCurrentPage',
        'LoadDocument',
        'UnloadDocument',
        'DownloadDocument',
        'WillChangeCurrentPage',
        'DidChangeCurrentPage',
        'LoadPage',
        'UnloadPage',
        'WillUndoRedo',
        'UndoRedo',
        'WillPlayTool',
        'ToolPlayBegan', // The user has is matching the first given
        'ToolPlayed',
        'ToolAborted',
        'StartSketchFrame',
        'EndSketchFrame',
        'StartDrag',
        'StartDragConfirmed', // The StartDrag is an actual drag, not a tap
        'MoveDrag',
        'EndDrag',
        'EndLabelDrag', // The drag was on a label, not a gobj
        'MergeGobjs',
        'StartAnimate',
        'EndAnimate',
        'StartMove',
        'EndMove',
        'StartSequence',
        'EndSequence',
        'StartCase',
        'EndCase',
        'Tap',
        'StartScroll',
        'MoveScroll',
        'EndScroll',
        'PressButton', // User has pressed a button
        'ActivateButton', // A button's isActive T/F property has changed
        'EditExpression', // handles all editing of params, calcs, and functions.
        // "ChangeStyle", use "StyleWidget" instead
        'ClearTraces',
        'StyleWidget',
        'TraceWidget',
        'LabelWidget',
        'VisibilityWidget',
        'DeleteWidget',
        'PrefChanged',
        'ToolAdded', // A tool was added to the doc
        'ToolRemoved', // A tool was removed
        'ToolMoved', // A tool was moved to a different index in the tool array
        'ToolPagesChanged', // A tool's active-pages setting was changed
        // When committing event names, make sure changes are documented in documentation/Document/document-event.html
      ],

      /**
       * Notify event listeners that the event has been triggered.
       * @param  {String}  message -- event name, e.g. 'UnloadFocusPage'
       * @param  {Object}  context -- additional arguments to be passed along to handler about the situation in which
       *                   this event fired.Objects (such as a sketch or sketch gobj) are permitted here.
       * @param  {Object}  attributes -- additional arguments to be passed along to handler, either in string form
       *                   or arguments that can be stringified (e.g. a gobj.id rather than the gobj itself).
       * The context is not suitable for external use; data that might be needed by external clients must be
       * in attributes, in a form that can be stringified.
       */
      trigger: function(message, context, attributes) {
        var eventName = message + '.WSP',
          customEvent;

        if (this.events.indexOf(message) < 0) {
          throw GSP.createError('Unregistered event triggered: ' + message);
        }

        // Set a time stamp
        attributes.timeStamp = new Date().toISOString();

        //jQuery event API...
        $(this.canvasNode).trigger(eventName, [context, attributes]);

        // Native Javascript CustomEvent API...
        // We have to fire off the event and define the event in the same scope because the trigger
        // "dispatch" does not take parameters to pass to the listener, only the CustomEvent
        // constructor does.  Therefore, because we do not yet have the data until we are at the moment
        // of triggering the event(i.e. when this.trigger is called) then we have to construct
        // the custom event here.
        try {
          // we have to wrap this in a try catch block in case the browser does not have the CustomEvent
          // feature, most notably phantomjs does not.
          customEvent = new CustomEvent(eventName, {
            detail: {
              context: context,
              attributes: attributes,
            },
          });
          this.canvasNode[0].dispatchEvent(customEvent);
        } catch (error) {}
      },

      /**
       * Get a list of all available WSP events that event listeners can listen for.
       *
       * @returns {Array}
       */
      getAvailableEvents: function() {
        var events = this.events;
        return events.map(function(k) {
          return k + '.WSP';
        });
      },
    };

    /**
     * EventEmitter constructor.  Returns the actual EventEmitter instance that will be used.
     *
     * @param {jQuery Object} documentNode
     * @returns {EventEmitterPrototype}
     * @constructor
     */
    var EventEmitter = function(documentNode) {
      var eventEmitter = Object.create(EventEmitterPrototype);

      eventEmitter.canvasNode = documentNode;

      // Actual object that will be returned when the EventEmitter constructor is executed externally(outside
      // of this class).
      return eventEmitter;
    };

    // Return the constructor which will be executed immediately.
    return EventEmitter;
  })();

  /**
   * @fileOverview General error utilities
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * Utility for creating a GSP Error object.  WSP Code should use this method
   * to create an error for throwing.
   *
   * @param {String} message
   * @param {String} (optional) code
   * @returns {Error}
   */
  GSP.createError = function(message, code) {
    var error = new Error(message);
    error.code = code;

    return error;
  };

  /**
   * signals a preexisting error using the GSP.signal api, allowing clients to
   * respond appropriately to Errors thrown elsewhere in the code.
   *
   * Example usage:
   * try {
   *
   *    if(!doSomeStuff()) {
   *      throw GSP.createError("Couldn't do some stuff");
   *    }
   *
   * } catch(e) {
   *    //optionally append to e.message
   *    e.message = "Caught error: " + e.message;
   *
   *    GSP.signalCaughtError(e);
   * }
   *
   * @param {type} error
   * @returns {Object} the signal object
   */
  GSP.signalCaughtError = function(error) {
    return GSP.signal({
      message: error.message,
      error: error,
      stack: error.stack,
      logType: 'error',
      code: error.code || 'GSP.Error.uncodedError',
    });
  };

  /**
   * Given a code defined by the current local, creates and signals a new error
   * object.
   *
   * Example usage:
   * if (!doSomeStuff()) {
   *   GSP.signalErrorWithCode("GSP.Error.SpecialErrorCodeTakingTwoFormatArgs", [arg1, arg2]);
   * }
   *
   * @param {String} code
   * @param {Array} args array of format arguments used by the error message
   *    defined by the given code.
   * @returns {undefined}
   */
  GSP.signalErrorWithCode = function(code, args) {
    var stringArgs = [code].concat(args),
      msg = GSP.Strings.loc.apply(GSP.Strings, stringArgs),
      error = GSP.createError(msg, code);

    this.signalCaughtError(error);
  };

  /**
   * Given a message and optional code, creates and signals a new error object.
   *
   * Example usage:
   * if (!doSomeStuff()) {
   *   GSP.signalErrorWithMessage("Still can't do some stuff!");
   * }
   *
   * @param {type} message
   * @param {type} code (optional) the Error code to use
   * @returns {undefined}
   */
  GSP.signalErrorWithMessage = function(message, code) {
    var error = GSP.createError(message, code);
    this.signalCaughtError(error);
  };

  /**
   * @fileOverview
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
   */

  /**
  
   */
  GSP.Prefs = (function(/** @lends GSP.Prefs */) {
    var prefs = {
      units: {
        length: 'cm',
        angle: 'deg',
      },
      precision: {
        length: 2,
        angle: 2,
        scalar: 2,
      },
      fadeTraces: false,
      fadeHalfLife: 5,
      fadeSaturationFloor: 0.0625, // (1/16)
      colorableComponents: {
        Points: { color: 'red' },
        Straights: { color: 'navy' },
        Curves: { color: 'green' },
        Interior: { color: 'rgb(138,102,217)' },
        Plot: { color: 'purple' },
        PointLocus: { color: 'maroon' },
        Selection: { color: 'rgb(195,0,195)' },
        Background: {
          color: 'white',
        },
        CoordSys: { color: 'silver' },
        TextGObject_BackgroundContrast: { color: 'black' },
        ActionButton: { color: 'rgb(255,165,0)' },
        LabelText_BackgroundContrast: { color: 'black' },
        Axis: { color: 'rgb(96,96,96)' },
        AngleMarker: { color: 'rgb(64,64,64)' },
        Picture: { color: 'red' },
      },
      text: {
        mathItalicization: true,
        textTypes: {
          Label: {
            'font-family': 'Times',
            'font-size': 24,
            'font-weight': 'bold',
            'font-style': 'normal',
            'text-decoration': 'none',
            'letter-spacing': 'none',
            color: 'black',
          },
          Caption: {
            'font-family': 'Times',
            'font-size': 16,
            'font-weight': 'normal',
            'font-style': 'normal',
            'text-decoration': 'none',
            'letter-spacing': 'none',
            color: 'black',
            padding: '2px 4px',
          },
          Measurement: {
            'font-family': 'Times',
            'font-size': 18,
            'font-weight': 'normal',
            'font-style': 'normal',
            'text-decoration': 'none',
            'letter-spacing': 'none',
            color: 'black',
          },
          Action: {
            label: {
              'font-family': 'Arial',
              'font-size': 16,
              'font-weight': 'normal',
              'font-style': 'normal',
              'text-decoration': 'none',
              'letter-spacing': 'none',
              color: 'black',
            },
          },
          Table: {
            'font-family': 'Arial',
            'font-size': 14,
            'font-weight': 'normal',
            'font-style': 'normal',
            'text-decoration': 'none',
            'letter-spacing': 'none',
            color: 'black',
          },
          AxisTicksAndOptionalLabel: {
            // tick number default
            'font-family': 'Geneva',
            'font-size': 14,
            'font-weight': 'normal',
            'font-style': 'normal',
            'text-decoration': 'none',
            'letter-spacing': 'none',
            color: 'black',
            // label default
            label: {
              'font-family': 'Geneva',
              'font-size': 14,
              'font-weight': 'normal',
              'font-style': 'normal',
              'text-decoration': 'none',
              'letter-spacing': 'none',
              color: 'black',
            },
          },
        },
      },
    };

    return prefs;
  })();

  /**
   * @fileOverview SketchEvent handling facilities.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * This module provides a generic facility for sending events from objects or groups of objects.
   * It is agnostic about the nature of those objects, and indeed the nature of the events that are sent.
   * At this level, objects are specified by id, and events by name (which is basically an id).
   *
   * A client which wants to send sketchevents should:
   *  - Create a GSP.SketchEventHandler
   *  - addHandler() for any handlers
   *  - call raiseEvent() when any emitter signals that it's ready to send an event.
   *  - at some appropriate time in the run loop (e.g. just before the end), call processEvents()
   *    to trigger the appropriate handlers, sending them a GSP.Event().
   *
   *  The GSP.SketchEventHandler() takes a function which will be used to pre-process any GSP.Event that's sent -
   *  that's your chance to mutate the Event based on client only knowledge.
   *
   *  handlers can monitor events on objects, or groups of objects. If they monitor a group, they
   *  will get only one event for any changes in the group. The event will track which elements
   *  have actually changed.
   *
   *  = Terminology =
   *  SketchEvent handling has a wealth of competing terminologies for the various actors. We will use:
   *    - event: A state of interest, specified by type (string). Also a GSP.Event which encapsulates that notion.
   *    - target: A client-space object which is the trigger for events. Client provides target id's.
   *    - handler: The javascript function that is called to handle events. A.k.a. receiver.
   *    - emitter: The object which produces events. A.k.a. notifier. For handlers bound to a single target,
   *               you can think of the emitter as the target. For a handler bound to a group of targets, the
   *               whole group is the emitter. emitter id's are created and maintained by the SketchEventHandler.
   *
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class GSP.SketchEvent
   * Basic event object.
   * At this level, we will add fields for:
   *  type: the name / id of the variety of event.
   *  timeStamp: time of creation - basically to be used for debugging.
   *
   * GSP.SketchEventHandler will add other fields before sending the event:
   *  targetMap: a map { emitter id -> [true|false] }. The keys are all the listened for
   *    emitters, and the values are whether they have in fact signaled the event.
   *  The SketchEventHandler also will apply client specified pre-processing.
   *
   */

  GSP.SketchEvent = function(type, props) {
    if (!(this instanceof GSP.SketchEvent)) {
      return new GSP.SketchEvent(type, props);
    }

    this.type = type;
    if (props) {
      $.extend(this, props);
    }

    this.timeStamp = this.timeStamp || $.now();
  };

  /**
   * @class GSP.SketchEventHandler
   *
   */
  GSP.SketchEventHandler = (function() {
    var sketchEventHandlerPrototype = function() {},
      wspguid = 1,
      eventguid = 1;

    // deep access to object, creating maps along the way if needed.
    function vivify(object, keyarray) {
      var key, i;

      for (i = 0; i < keyarray.length; i++) {
        key = keyarray[i];
        if (!object[key]) {
          object[key] = {};
        }

        object = object[key];
      }

      return object;
    }

    // deep access to object, returning undefined if a key is missing.
    function findValue(object, keyarray) {
      var key, i;

      for (i = 0; i < keyarray.length; i++) {
        key = keyarray[i];

        object = object[key];
        if (object === undefined) {
          break;
        }
      }

      return object;
    }

    // utility method to canonicalize a list of target id's.
    // Will take a singleton id, and wrap it as an array [id]
    // sorts the array list.
    function idListFromTargets(targets) {
      var ids;
      if ($.isArray(targets)) {
        ids = targets.slice();
        ids.sort();
      } else {
        ids = [targets];
      }

      return ids;
    }

    // Set up the sketchEventHandlerPrototype
    $.extend(sketchEventHandlerPrototype, {
      // find / create an id for an emitter.
      // We'll key on the sorted list of target id's, and cache a guid.
      emitterIDFromTargetList: function(targets, eventType) {
        var emitterIDMap = vivify(this.targetsIDMap, [eventType]),
          value = vivify(emitterIDMap, targets);

        if (value.result === undefined) {
          value.result = eventguid++;
        }

        return value.result;
      },
      addHandler: function(targets, eventType, handler) {
        var targetList = idListFromTargets(targets),
          emitterID = this.emitterIDFromTargetList(targetList, eventType),
          handlerMap,
          i;

        if (!handler.wspguid) {
          handler.wspguid = wspguid++;
        }

        // register the new handler by id in our refCounted map of handlers
        handlerMap = vivify(this.handlers, [handler.wspguid]);
        if (handlerMap.refCount) {
          handlerMap.refCount++;
        } else {
          handlerMap.refCount = 1;
          handlerMap.handler = handler;
        }

        // register the emitter, making sure it knows about the handler it's now handling
        if (!this.emitters[emitterID]) {
          this.emitters[emitterID] = {
            type: eventType,
            targets: targetList,
            handlerID: [],
          };
        }
        this.emitters[emitterID].handlerID.push(handler.wspguid);

        // Keep track of which targets will trigger this emitter.
        for (i = 0; i < targetList.length; i++) {
          vivify(this.triggers, [targetList[i], eventType])[emitterID] = true;
        }
      },

      /**
       *  For the specified targets, reemove the eventType emitter linked to the handler callback.
       *  If handler is undefined, remove all emitters for the passed targets and eventType.
       **/
      removeHandler: function(targets, eventType, handler) {
        var emitterID = this.emitterIDFromTargetList(
            idListFromTargets(targets),
            eventType
          ),
          emitter = this.emitters[emitterID],
          self = this;

        function removeOneHandler(id) {
          var i, j;
          // Remove the handler from our refCounted map of handlers.
          if (self.handlers[id].refCount === 1) {
            delete self.handlers[id];
          } else {
            self.handlers[id].refCount--;
          }

          // remove handler for eventType from emitter
          emitter.handlerID.splice(emitter.handlerID.lastIndexOf(id), 1);

          // if there are now no handlers for this emitter, remove the emitter.
          if (0 === emitter.handlerID.length) {
            // dig through triggers
            for (i in self.triggers) {
              for (j in self.triggers[i]) {
                delete self.triggers[i][j][emitterID];
              }
            }
            // remove it from emitters
            delete self.emitters[emitterID];

            // remove it from the live list of events
            delete self.sketchEventList[emitterID];
          }
        }

        function removeMultiple(handlers) {
          var ix,
            IDs = handlers.slice(); // copy the id's, since the passed array may change
          for (ix = 0; ix < IDs.length; ix++) {
            removeOneHandler(IDs[ix]);
          }
        }

        if (!emitter) {
          GSP.signalErrorWithMessage(
            'removeHandler called on unknown target ' + targets
          );
          return;
        }
        if (handler) {
          // remove the matching handler
          removeOneHandler(handler.wspguid);
        } else {
          // handler is undefined, so remove all handlers for this event and target(s)
          removeMultiple(emitter.handlerID);
        }
      },

      raiseSketchEvent: function(targetID, eventType) {
        var emitters = findValue(this.triggers, [targetID, eventType]),
          id;

        if (!emitters) {
          return;
        }

        for (id in emitters) {
          vivify(this.sketchEventList, [id, eventType])[targetID] = true;
        }
      },
      processOneSketchEvent: function(emitterID) {
        var emitter,
          handler,
          sketchEvent,
          i,
          id,
          targetMap = {};

        emitter = this.emitters[emitterID];
        handler = this.handlers[emitter.handlerID];

        for (i = 0; i < emitter.targets.length; i++) {
          id = emitter.targets[i];
          targetMap[id] = findValue(this.sketchEventList, [
            emitterID,
            emitter.type,
            id,
          ])
            ? true
            : false;
        }

        sketchEvent = new GSP.SketchEvent(emitter.type, {
          targetMap: targetMap,
        });

        if (this.sketchEventPreprocessor) {
          this.sketchEventPreprocessor(sketchEvent);
        }

        for (i = 0; i < emitter.handlerID.length; i++) {
          handler = this.handlers[emitter.handlerID[i]].handler;
          handler(sketchEvent);
        }
      },
      processSketchEvents: function() {
        var emitterID;

        for (emitterID in this.sketchEventList) {
          this.processOneSketchEvent(emitterID);
        }
        this.sketchEventList = {};
        this.frameIndex++;
      },
      getFrameIndex: function() {
        return this.frameIndex;
      },
      hasSketchEvents: function() {
        return !$.isEmptyObject(this.sketchEventList);
      },
    });
    function sketchEventHandler(sketchEventPreprocessor) {
      this.sketchEventPreprocessor = sketchEventPreprocessor;
      this.targetsIDMap = {}; // { value: id0, result: id0'} -> ... { value: idn, result: idn'}
      this.triggers = {}; // map targetID -> eventType -> {emitterID -> true}

      this.emitters = {}; // id -> {data}
      this.handlers = {}; // id -> {refcount: n, handler: h}

      this.sketchEventList = {}; // emitterID  -> sketchEventType -> {targetID: true}
      this.frameIndex = 0; // incremented every processSketchEvents
    }
    sketchEventHandler.prototype = sketchEventHandlerPrototype;

    return sketchEventHandler;
  })();

  /**
   * @fileOverview Job Scheduler
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * The JobScheduler module is designed to handle scheduling all timer callbacks,
   * animation frames, deferred actions in a page.  One of the goals of this
   * module is to shield clients from needing to know or worry about the
   * requestAnimationFrame() level of browser communication.  The jobScheduler
   * requests frames when frames are needed, and knows to stop requestion frames
   * if there are none needed.
   *
   * In GSP usage, it is expected that a JobScheduler would have sketch-level scope.
   * Each sketch would have its own jobScheduler that it initializes and tears down
   * when the sketch is left.  The module, as written, though, is not dependent on
   * this.  There is nothing preventing clients from starting up multiple JobSchedulers
   * at once (though there is an efficiency price for this), or having JobSchedulers
   * that outlast sketches.
   *
   *  Defines:
   *  var animFrame
   *  var jobSchedulerProto
   *    addJob: function(callback, options)
   *    _tick: function ()
   *    _animFrameHandle: null,
   *    _requestAnimFrameIfNeeded: function ()
   *    addJob: function(callback, options)
   *    clearJob: function (job)
   *    clearAllJobs: function ()
   *  GSP.JobScheduler  // constructor
   *    create: function ()
   *    isActive: function(job)
   */
  (function(GSP) {
    // requestAnimationFrame implementation as a custom function to allow blacklisting
    // devices with broken implementation. Currently needs timer-based fallbacks for iOS 6.x for
    // code running inside <iframe> elements.
    // Uses polyfills based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    var animFrame = (function() {
      var blacklisted = /iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent),
        lastTime = 0,
        nativeRequest = window.requestAnimationFrame || null,
        nativeCancel = window.cancelAnimationFrame || null,
        retval = {};

      ['webkit', 'moz'].forEach(function(prefix) {
        nativeRequest =
          nativeRequest || window[prefix + 'RequestAnimationFrame'] || null;
        nativeCancel =
          nativeCancel ||
          window[prefix + 'CancelAnimationFrame'] ||
          window[prefix + 'CancelRequestAnimationFrame'] ||
          null;
      });

      function polyfillRequest(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      }

      function polyfillCancel(id) {
        clearTimeout(id);
      }

      retval.nextFrame =
        !blacklisted && nativeRequest != null ? nativeRequest : polyfillRequest;
      retval.cancelFrame =
        !blacklisted && nativeCancel != null ? nativeCancel : polyfillCancel;

      return retval;
    })();
    var requestAnimFrame = animFrame.nextFrame;
    var cancelAnimFrame = animFrame.cancelFrame;

    var jobSchedulerProto = {
      _preprocessJobs: null,
      _modelJobs: null,
      _renderJobs: null,
      _tick: function() {
        var curTime = new Date().getTime(),
          preprocessJobs,
          modelJobs,
          renderJobs;

        function processJob(aJob) {
          if (aJob.scheduledFireTime <= curTime) {
            try {
              //Execute the job, ending it if the callback returns false
              if (aJob.callback() === false) {
                aJob.isActive = false;
              }
            } catch (ex) {
              ex.message = 'Error executing job: ' + ex.message;
              aJob.isActive = false;
              GSP.signalCaughtError(ex);
            }
            if (aJob.repeat) {
              //reschedule repeating job...
              aJob.scheduledFireTime = curTime + aJob.delay;
            } else {
              //else mark for deletion
              aJob.isActive = false;
            }

            if (!aJob.isActive && aJob.doneCallback) {
              aJob.doneCallback('finished');
            }
          }
        }

        preprocessJobs = this._preprocessJobs.slice();
        preprocessJobs.forEach(processJob);

        //re-stamp time, since time will have passed in the processing of the model jobs
        curTime = new Date().getTime();
        modelJobs = this._modelJobs.slice();
        modelJobs.forEach(processJob);

        //restamp again
        curTime = new Date().getTime();
        renderJobs = this._renderJobs.slice();
        renderJobs.forEach(processJob);

        function filterJob(aJob) {
          return aJob.isActive;
        }

        this._preprocessJobs = this._preprocessJobs.filter(filterJob);
        this._modelJobs = this._modelJobs.filter(filterJob);
        this._renderJobs = this._renderJobs.filter(filterJob);

        if (
          this._preprocessJobs.length +
            this._modelJobs.length +
            this._renderJobs >
          0
        ) {
          this._requestAnimFrameIfNeeded();
        }
      },
      _animFrameHandle: null,
      _requestAnimFrameIfNeeded: function() {
        var that = this;

        if (this._animFrameHandle !== null) {
          return;
        }

        this._animFrameHandle = requestAnimFrame(function() {
          that._animFrameHandle = null;
          that._tick();
        });
      },
      /**
       * Schedule a job for execution
       *
       * @param {Function} callback - callback to execute. If the job is a repeating
       *   job and the callback returns false, it will be stopped.
       * @param {Object} options - object containing the following options:
       *  delay: {Number} - optional. Number of milliseconds to delay before firing.
       *    If omitted, 0, or negative, the callback fires on the next animation frame
       *  repeat: {Bool}  - should the callback repeat at the interval specified
       *    by 'delay'
       *  done: {Function}  - callback called when the job completes or is cancelled
       *     The callback is passed the string "finished" if the job finished, and
       *     "cancelled" if the job was cancelled.
       *  priority: {String} - Acceptable values are "preprocess", "model", or "render"
       *     Default is model. The JobScheduler maintains three queues, each with
       *     different requirements of the user.  The "preprocess" queue happens first
       *     and is guaranteed to find a sketch that has been constrained and rendered.
       *     Preprocess jobs are required to leave the sketch in this same state.
       *     The model queue is where the model may be changed (animations, changing
       *     geometry, etc).  During this phase, constrain() need not be called, but
       *     clients can not rely on children to have been constrained.  If a model-priority
       *     queue schedules a render-priority job for immediate execution, it is
       *     guaranteed that the render job will be executed on that same tick.
       *     The render queue is where constraint and render happen.  Normally, any
       *     job scheduled within another job would happen on the next tick, but a job
       *     that schedules a job on a later queue (eg a model job scheduling a render
       *     job, or a preprocess job scheduling either of the others) can guarantee
       *     that the scheduled job will happen during that same animation frame.
       *
       * @returns {Job} - an opaque Job object
       */
      addJob: function(callback, options) {
        options = options || {};
        var delay = options.delay || 0;
        var scheduledFireTime;

        if (delay > 0) {
          scheduledFireTime = new Date().getTime() + delay;
        } else {
          //If no delay, scheduledFireTime is set to 0 to fire at next opportunity
          scheduledFireTime = 0;
        }

        var newJob = {
          callback: callback,
          delay: delay,
          scheduledFireTime: scheduledFireTime,
          repeat: options.repeat,
          doneCallback: options.done,
          queue: options.priority || 'model',
          isActive: true,
        };

        if (newJob.queue === 'preprocess') {
          this._preprocessJobs.push(newJob);
        } else if (newJob.queue === 'render') {
          this._renderJobs.push(newJob);
        } else {
          //default queue
          this._modelJobs.push(newJob);
        }

        this._requestAnimFrameIfNeeded();

        return newJob;
      },
      /**
       * Clear a scheduled job.  This should not be called on jobs that are not
       * scheduled, or that have already executed.
       *
       * @param {type} job
       * @returns {undefined}
       */
      clearJob: function(job) {
        var theQueue;

        if (job.queue === 'preprocess') {
          theQueue = this._preprocessJobs;
        } else if (job.queue === 'render') {
          theQueue = this._renderJobs;
        } else {
          theQueue = this._modelJobs;
        }

        var index = theQueue.indexOf(job);

        if (index === -1) {
          throw GSP.createError(
            'Job Scheduler.clearJob() called on a unscheduled job'
          );
        }

        theQueue.splice(index, 1);

        job.isActive = false;
        if (job.doneCallback) {
          job.doneCallback('cancelled');
        }

        if (
          this._preprocessJobs.length +
            this._renderJobs.length +
            this._modelJobs.length ===
          0
        ) {
          cancelAnimFrame(this._animFrameHandle);
          this._animFrameHandle = null;
        }
      },
      /**
       * Clears all scheduled jobs in the queue.
       *
       * @returns {undefined}
       */
      clearAllJobs: function() {
        function clearTheJob(job) {
          job.isActive = false;
          if (job.doneCallback) {
            job.doneCallback('cancelled');
          }
        }
        this._preprocessJobs.forEach(clearTheJob);
        this._modelJobs.forEach(clearTheJob);
        this._renderJobs.forEach(clearTheJob);

        this._preprocessJobs = [];
        this._modelJobs = [];
        this._renderJobs = [];

        if (this._animFrameHandle !== null) {
          cancelAnimFrame(this._animFrameHandle);
          this._animFrameHandle = null;
        }
      },
    };

    GSP.JobScheduler = {
      /**
       * Designated constructor.
       *
       * @returns {JobScheduler}
       */
      create: function() {
        var ret = Object.create(jobSchedulerProto);
        ret._preprocessJobs = [];
        ret._modelJobs = [];
        ret._renderJobs = [];
        return ret;
      },
      /**
       * Inspects the passed in job to see if it's currently cued in a jobScheduler
       * This method handles null or undefined, so client are free to call this
       * on a not-yet-initialized variable.
       *
       * @param {type} job
       *
       * @returns {Bool}
       */
      isActive: function(job) {
        return !!(job && job.isActive);
      },
    };
  })(GSP);

  (function(GSP) {
    /*
     * An Object Graph is an array with the following properties:
     *  - It is a directed graph of parents followed by children.  The graph is sorted
     *    such that a parent appears before any of its children.
     *  - A parent has a property: children which contain references to each of its
     *    children, in arbitrary order
     *  - A child has a parents property, which is key:value pairs of parentName: parentRef
     *    parentNames are arbitrary, and up to the object to name.
     *  - Each object has a 'topologicalIndex' property, which can be used to topologically sort
     *    collections of objects
     *  - Each object has an 'id' property, which is unique
     *
     * It would be nice to subclass Array so that clients who want an array have one
     * and clients who need to perform object graph operations have that too.  But
     * it can't be done easily or completely.  See this link for detailed analysis:
     * http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/
     *
     * Instead, ObjectGraph methods return an actual Array with no added methods.
     * Object Graph utilities accept an Array object as a parameter, and expect
     * (and guard through assertions) that the Array was created using the ObjectGraph
     * creation utility.
     *
     */
    GSP.ObjectGraph = {
      /*
       * Given a spec of objects keyed by id, some of which have a parents property
       * specifying the ids of their parents, creates an Object Graph which is a
       * topologically sorted array of objects in which parent properties are replaced
       * with pointers to the parent, and the parent gets a back pointer to the child.
       * Note: The actual objects passed into the spec are mutated in place.
       *
       * Example input:
       * {
       *   a: {
       *         //arbitrary data
       *   },
       *   b: {
       *         //arbitrary data
       *         parents: {
       *           someParentName: "a"
       *         }
       *   }
       * }
       *
       * If the passed in graph is going to be appended to an existing graph, and
       * some parents exist in the existing graph, clients can pass in optional
       * existingObjects and startingTopoIndex parameters to start building from.
       *
       *
       * @param {Object} objects - object in the above-specified format (These are mutated in place)
       * @param {Object} (Optional) existingObjects - map of
       *    {id:existing object that will become a parent}
       *    Note: id doesn't need to be the id of the existing object, just the id
       *    referred to in the spec
       * @param {Integer} startingTopoIndex - starting index to increment topologicalIndex from
       * @returns {ObjectGraph}
       */
      convertObjectSpec: function(objects, existingObjects, startingTopoIndex) {
        var ret = [],
          added = {},
          topologicalIndex = startingTopoIndex || 0,
          //collection of objects we're currently processing for
          //for detecting circurlar references
          processing = {};

        $.extend(added, existingObjects);
        GSP.eachKeyValue(objects, function addOne(key, obj) {
          if (!added[key]) {
            processing[key] = true;

            if (obj.parents) {
              var actualParents = {};
              $.each(obj.parents, function(parentKey, parentId) {
                var parent = added[parentId];

                if (!parent) {
                  //If the parent has not yet been added, add it first
                  //but before processing it, check to see that we're not already
                  //processing it - if so, we have a circular reference
                  if (processing[parentId]) {
                    throw GSP.createError('Circular reference in object graph');
                  }
                  if (!objects[parentId]) {
                    throw GSP.createError(
                      'Unknown parent id encountered building object graph: ' +
                        parentId
                    );
                  }

                  addOne(parentId, objects[parentId]);
                  parent = added[parentId];
                }

                //Create pointer from parent -> child
                if (parent.children === undefined) {
                  parent.children = [];
                }
                parent.children.push(obj);

                //Create pointer from child -> parent (to be assigned later)
                actualParents[parentKey] = parent;
              });
              obj.parents = actualParents;
            }

            //Now add the object to the final array
            //Objects processed by GSP.gobjectsFromSpec() have already had this done
            //to them, but other sources may not have.
            obj.id = key;
            obj.topologicalIndex = topologicalIndex++;
            ret.push(obj);

            added[key] = obj;
            processing[key] = false;
          }
        });

        return ret;
      },
      /**
       * Given a root node assumed to be part of an object graph, returns a sub-graph
       * descending from the root such that all descendants are completely contained
       * within the subgraph. Any children that also depend on parents not descending
       * from the root are not included.  Clients wishing to allow certain outside
       * parents can do so with the optExistingParents parameter
       *
       *
       * @param {type} root - a node of an objectGraph
       * @param {type} optExistingParents - a map of parents keyed by id
       * @returns {Object} ObjectGraph - the subgraph of the larger graph
       */
      subgraphFromNode: function(root, optExistingParents) {
        //Algorithm:
        //1. Start with a pool of all potential objects: the root object and all of
        //   its ancestors (and any optional passed in parents callers want to allow)
        //2. Filter the pool into 'complete' and 'incomplete'.  Incomplete means
        //   the object has parents not part of the pool of potential objects.  Complete
        //   means the object has no parental edges outside of this subgraph
        //
        //An object is complete if its parents are complete, so the algorithm for
        //checking an object for completeness is to first check to see if we've made
        //a determination for it regarding completeness.  If we haven't, we recursively
        //check its parents until we find one that is not complete, at which point we
        //can say this one is also incomplete.  If all parents are complete, we can
        //add this one to the list of complete objects.
        //
        //At this time, we also add the object to the returned array.  Since we'll never
        //make a decision on an object before making a decision on its parents, we're
        //guaranteed that the object will be added to the array after its parents.

        var allPotentialObjects = {},
          complete = optExistingParents ? $.extend({}, optExistingParents) : {},
          incomplete = {},
          ret = [root];

        complete[root.id] = root;
        $.extend(allPotentialObjects, complete);

        function addToPotential(aNode) {
          allPotentialObjects[aNode.id] = aNode;

          if (aNode.children) {
            aNode.children.forEach(function(child) {
              if (!allPotentialObjects[child.id]) {
                addToPotential(child);
              }
            });
          }
        }

        //Returns true if the object is complete
        function addIfComplete(aNode) {
          if (complete[aNode.id]) {
            return true;
          }

          if (incomplete[aNode.id]) {
            return false;
          }

          var isComplete = !!allPotentialObjects[aNode.id];

          if (isComplete && aNode.parents) {
            $.each(aNode.parents, function(key, parentNode) {
              if (!addIfComplete(parentNode)) {
                isComplete = false;
                return false;
              }
            });
          }

          if (!isComplete) {
            incomplete[aNode.id] = aNode;
            return false;
          } else {
            complete[aNode.id] = aNode;
            ret.push(aNode);
            return true;
          }
        }

        addToPotential(root);

        $.each(allPotentialObjects, function(key, obj) {
          addIfComplete(obj);
        });

        return ret;
      },
      /**
       * If the graph uses numeric ids, returns the next free id to use for adding
       * objects to the graph.  There's no requirement that ids be numeric, but in
       * practice, they are.  If this function encounters a non-numeric id, it returns
       * undefined
       *
       * @param {ObjectGraph} objectGraph
       * @returns {Number}
       */
      getNextFreeIdNumber: function(objectGraph) {
        var highestNumber = 0,
          abort = false;

        objectGraph.forEach(function(object) {
          var id = parseInt(object.id, 10);

          if (isNaN(id)) {
            abort = true;
            return false;
          }

          if (id > highestNumber) {
            highestNumber = id;
          }
        });

        if (!abort) {
          return highestNumber + 1;
        }
      },

      /**
       * Normalize topological indices of all descendants of parent so that
       * the index of every child is greater than the index of its parent.
       * If any indices are changed, the constraint list is resorted.
       *
       * @param {ObjectGraph} objectGraph
       * @param {Object} parent - the root of the subtree to be normalized
       * @returns {Bool} true if any indices were modified
       */
      normalizeTopologicalIndices: function(objectGraph, parent) {
        var sortRequired = false;

        function adjustChildIndices(parent) {
          // If a child's topological index is less than or equal to the parent, bumps the child's index.
          // sets sortRequired true iff one or more children's topological indices is bumped
          var iParent;
          if (parent.children) {
            iParent = parent.topologicalIndex;
            parent.children.forEach(function(child) {
              if (child.topologicalIndex <= iParent) {
                child.topologicalIndex = iParent + 1;
                adjustChildIndices(child);
                sortRequired = true;
              }
            });
          }
        }

        adjustChildIndices(parent);
        if (sortRequired) {
          objectGraph.sort(function(a, b) {
            return Number(a.topologicalIndex) - Number(b.topologicalIndex);
          });
        }
      },

      /**
       * Set the parents of a given gobject, and re-order the graph.
       *
       * To maintain constraint order, the new child is given an index
       * equal to 1 + the max index of all its parents. Because this might
       * produce a conflict between the topological indices of the new
       * child and one of its own children, we descend the graph rooted at
       * the new child, and recursively ensure its children succeed it in
       * the sort order (see jasmine tests for an example of this case).
       *
       * @param {ObjectGraph} objectGraph, the constraintList of the sketch
       * @param {Object} child - the new child
       * @param {Object} parents - the new parents, as a gobj.parents object
       * @returns {undefined}
       */
      setParents: function(objectGraph, child, parents) {
        var max;

        child.parents = {};
        if (parents === undefined || $.isEmptyObject(parents)) {
          return; // nothing else to do
        }

        // Find the maximum parent index. Along the way, set parent-child
        // links.

        $.each(parents, function(parentKey, parentObj) {
          child.parents[parentKey] = parentObj;
          if (parentObj.children === undefined) {
            parentObj.children = [];
          }
          if (parentObj.children.indexOf(child) === -1) {
            parentObj.children.push(child);
          }

          var i = parentObj.topologicalIndex;
          if (max === undefined || max < i) {
            max = i;
          }
        });

        if (child.topologicalIndex <= max) {
          child.topologicalIndex = max + 1;
        }
        this.normalizeTopologicalIndices(objectGraph, child);
      },

      /**
       * The inverse of convertObjectSpec, except it generates a copy rather than
       * mutate the original objects. In a way, this method is a flattening of an
       * objectGraph into a spec.
       *
       * @param {type} objectGraph
       * @returns {ret} object Spec
       */
      createSpecFromGraph: function(objectGraph) {
        var ret = {};

        objectGraph.forEach(function(obj) {
          var objCopy = $.extend({}, obj);
          ret[objCopy.id] = objCopy;
          objCopy.id = undefined;
          objCopy.topologicalIndex = undefined;
          objCopy.children = undefined;

          if (objCopy.parents) {
            var newParents = {};
            $.each(objCopy.parents, function(parentKey, parentObj) {
              newParents[parentKey] = parentObj.id;
            });
            objCopy.parents = newParents;
          }
        });

        return ret;
      },
      copy: function(objectGraph) {
        return this.convertObjectSpec(this.createSpecFromGraph(objectGraph));
      },

      /*
       * Merge ToMerge to the existingNode
       *
       * @param {ObjectGraph} objectGraph, the constraintList of the sketch
       * @param {Object} existingNode - the node to which the toMerge node will be merged
       * @param {Object} toMerge - the node to be merged
       * @returns {undefined}
       */
      mergeToNode: function(objectGraph, existingNode, toMerge) {
        //If toMerge has parents, sever those edges, as if deleting toMerge
        var toMergeParents = toMerge.parents;
        var parentOfToMerge, childIndex;

        if (toMergeParents) {
          for (var parentId in toMergeParents) {
            if (toMergeParents.hasOwnProperty(parentId)) {
              parentOfToMerge = toMergeParents[parentId];
              childIndex = parentOfToMerge.children.indexOf(toMerge);
              if (childIndex >= 0)
                parentOfToMerge.children.splice(childIndex, 1);
            }
          }
        }

        //should we search for existingNode in toMerge's subgraph?  Would be expensive...

        if (!existingNode.children) {
          existingNode.children = [];
        }

        if (toMerge.children) {
          toMerge.children.forEach(function(child) {
            // Make sure the child still exists in the sketch before moving it to the existing node
            if (existingNode.sQuery.sketch.gobjList.gobjects[child.id]) {
              existingNode.children.push(child);
              $.each(child.parents, function(key, parent) {
                if (parent === toMerge) {
                  child.parents[key] = existingNode;
                }
              });
            }

            // Also need to update child's parentsList. Is this done elsewhere? Can we be sure?
            $.each(child.parentsList, function(key, parent) {
              if (parent === toMerge) {
                child.parentsList[key] = existingNode;
              }
            });
          });
        }

        var i,
          len = objectGraph.length;

        var toMergeIndex, nodeIndex;

        //Now find and remove toMerge from the graph
        for (i = 0; i < len; ++i) {
          if (objectGraph[i] === toMerge) {
            toMergeIndex = i;
          }
          if (objectGraph[i] === existingNode) {
            nodeIndex = i;
          }
        }
        // Final merged object gets the position of the existingNode, ensuring
        // that it doesn't precede its own parents.
        objectGraph.splice(toMergeIndex, 1);

        // Finally, make sure the topologicalIndices of its children are greater than its own index.
        this.normalizeTopologicalIndices(objectGraph, existingNode);
      },

      /**
       * Deletes the given node (and any ancestors dependent on it) from the given objectGraph
       * NOTE: The ancestors deleted are potentially more than the set returned by subgraphFromNode(), since a child with
       * even one deleted parent must be deleted and a subgraph is defined as the children with all parents descending from
       * the node
       *
       * @param objectGraph
       * @param node
       *
       * @returns {array} The ids of the complete set of objects removed from the graph
       */
      deleteNode: function(objectGraph, node) {
        var toDelete = {},
          nodeToDelete;

        if (objectGraph.indexOf(node) === -1) {
          throw GSP.createError(
            'ObjectGraph.deleteNode() called on node not in graph'
          );
        }

        function isMarkedForDeletion(aNode) {
          return toDelete[aNode.id] !== undefined;
        }

        function markForDeletion(aNode) {
          toDelete[aNode.id] = aNode;
        }

        function executeDelete(aNode) {
          //sever the connection between any parents that still exist
          var parents = aNode.parents,
            parent,
            childIndex,
            nodeIndex = objectGraph.indexOf(
              aNode /*, possible efficiency here by tracking last index, provided we walk backwards */
            );

          if (parents) {
            for (var parentId in parents) {
              if (parents.hasOwnProperty(parentId)) {
                parent = parents[parentId];

                if (!isMarkedForDeletion(parent)) {
                  childIndex = parent.children.indexOf(aNode);
                  parent.children.splice(childIndex, 1);
                }
              }
            }
          }

          if (nodeIndex !== -1) {
            objectGraph.splice(nodeIndex, 1);
          }
        }

        function markNodeAndAllChildren(aNode) {
          markForDeletion(aNode);
          if (aNode.children) {
            aNode.children.forEach(function(child) {
              if (!isMarkedForDeletion(child)) {
                markNodeAndAllChildren(child);
              }
            });
          }
        }

        markNodeAndAllChildren(node);

        for (var toDeleteId in toDelete) {
          if (toDelete.hasOwnProperty(toDeleteId)) {
            nodeToDelete = toDelete[toDeleteId];
            executeDelete(nodeToDelete);
          }
        }

        //Return an array of the ids of the complete set of deleted objects
        return Object.keys(toDelete);
      },
    };
  })(GSP);

  /**
   * @class GSP.GObjList
   *
   * The GObjlist class encapsulates the Sketchpad notion
   * of a set of GObjects (in various forms), with various notions of linear order
   * applied to them.
   *
   *   gobjects: The primitive form is map id -> GObjRef
   *   constraintList: an array of the gobject sorted topologically
   *   renderList: the gobjects sorted according to render order.
   *
   */
  GSP.GObjList = (function() {
    var gObjListPrototype = function() {};

    // Set up the sketchEventHandlerPrototype
    $.extend(gObjListPrototype, {
      /**
       * Process a gobjects list of parents, producing a canonicalized form of the
       * array of parents in the canonical order from the desktop sketchpad file format.
       *
       * @param {object} gobj GObject in reference to which we generate parent info.
       * @return {array} parentsList: [ {name1 -> gobj1}, {name2 -> gobj2} ... ]
       */
      createCanonicalParentReferences: function(gobj) {
        function generateSortedParents(parentsList) {
          var i,
            returnedArray = [];

          parentsList.sort(function(a, b) {
            var indexOfA,
              indexOfB,
              constraintInfo = GSP.BapEdgeInfo[gobj.constraint];

            if (constraintInfo && constraintInfo[a.name]) {
              indexOfA = constraintInfo[a.name].sortIndex;
            }

            if (constraintInfo && constraintInfo[b.name]) {
              indexOfB = constraintInfo[b.name].sortIndex;
            }

            //first try to interpret the parents as numeric
            //Most variable parent gobjs, like polygon label their parents
            //with numbers
            if (undefined === indexOfA && undefined === indexOfB) {
              indexOfA = parseInt(a.name, 10);
              indexOfB = parseInt(b.name, 10);
            }

            //If they're still undefined, sort alphabetically, which will
            // work for parents with labels like p0, p1, etc. up to p9
            if (undefined === indexOfA && undefined === indexOfB) {
              if (a.name < b.name) {
                return -1;
              }
              if (a.name > b.name) {
                return 1;
              }
              return 0;
            }

            if (undefined === indexOfA) {
              return 1;
            }

            if (undefined === indexOfB) {
              return -1;
            }

            return indexOfA - indexOfB;
          });

          for (i = 0; i < parentsList.length; i++) {
            returnedArray.push(parentsList[i].gobj);
          }

          return returnedArray;
        }

        var orderedParents = [];

        if (gobj.parents) {
          $.each(gobj.parents, function(key, parent) {
            orderedParents.push({ name: key, gobj: parent });
          });

          return generateSortedParents(orderedParents);
        }

        return [];
      },

      mergeToGObj: function(toMerge, gobj, option) {
        var sketch = gobj.sQuery.sketch,
          self = this;
        // if toMerge has already been removed from the gobjList, there's nothing to do.
        if (!sketch.gobjList.gobjects[toMerge.id]) return;

        delete this.gobjects[toMerge.id];

        // If toMerge has parents, remove toMerge from their lists of children.
        // The original code lacked this, perhaps because this function served
        // only to merge a tool's givens (which have no parents) to existing
        // sketch objects. Now that constructibleGiven objects can be merged,
        // such objects need to be removed from their parents' lists of children.
        // Do this before calling mergeToNode, since that function normalizes
        // gobj.topologicalIndex based on gobj's parents and children.
        if (toMerge.parentsList) {
          toMerge.parentsList.forEach(function(parent) {
            var ix = parent.children.indexOf(toMerge);
            if (ix >= 0) {
              parent.children.splice(ix, 1);
            }
          });
        }

        GSP.ObjectGraph.mergeToNode(this.constraintList, gobj, toMerge);

        if (gobj.children) {
          gobj.children.forEach(function(child) {
            child.parentsList = self.createCanonicalParentReferences(child);
          });
        }

        // If we are merging something with a label, to
        // something without one, use the label, otherwise
        // you can get ugly default "Object 1" strings in
        // child labels.

        // Note, when we have a createDefaultLabel() function,
        // this will a good place to use it.
        if (!gobj.label) {
          gobj.label = toMerge.label;
          gobj.style.label.showLabel = toMerge.style.label.showLabel;
        }
        if (
          gobj.style.hidden &&
          !toMerge.style.hidden && // If gobj is hidden, use the style of toMerge.
          (!toMerge.toolRole || toMerge.toolRole !== 'givenParent')
        ) {
          // provided it's not a givenParent
          gobj.style = toMerge.style;
        }

        // Now, away with the old
        if (toMerge.destroy) {
          toMerge.destroy();
        }
        sketch.renderCleanupGObj(toMerge);

        // And fix up the new
        if (!option || !option.skipDescendantUpdate) {
          gobj.descendantGraphHasChanged();
          gobj.descendantLabelGraphHasChanged();
        }
        this.renderList = GSP.createRenderList(this.constraintList);
      },

      mergeGObjsInList: function(oldId, newId) {
        // Supports trackers that need to merge one object (oldId) to another (newId) in the gojList.
        // Clients are responsible for updating the sketch's constraintList and renderList.
        var gobjs = this.gobjects;
        if (gobjs[oldId]) {
          gobjs[newId] = gobjs[oldId];
          gobjs[newId].id = newId;
          delete gobjs[oldId];
        }
      },

      /**
       * Add new gobjects to the list
       * There is an efficiency cost to supplying a gobjPostInitFunc, as the
       * renderList must be constructed piecemeal instead of all at once.
       * In the case with a postInitFunc, the time complexity is slightly better adding a small number of objects to a
       * sketch with many objects, but without one, adding many objects to an empty sketch will perform better.
       *
       * @param {Object} gobjs - A map of id -> gobjref
       * @param {Function} gobjPostInitFunc - function called on each gobj as its added to the gobjlist
       */
      addGObjects: function(gobjs, gobjPostInitFunc, speculative) {
        // speculative is true only for toolplay

        var gobjList = this;

        function markForDeletion(gobj) {
          gobj.toDelete = true;
          for (var j = 0; j < gobj.children.length; ++j) {
            gobj.children[j].toDelete = true;
          }
        }

        var nextTopologicalIndex = 0;

        if (this.constraintList.length > 0) {
          nextTopologicalIndex =
            this.constraintList[this.constraintList.length - 1]
              .topologicalIndex + 1;
        }

        var newGraph = GSP.ObjectGraph.convertObjectSpec(
            gobjs,
            this.gobjects,
            nextTopologicalIndex
          ),
          aGObj,
          i;

        this.constraintList = this.constraintList || [];
        this.renderList = this.renderList || [];

        for (i = 0; i < newGraph.length; ++i) {
          aGObj = newGraph[i];

          try {
            if (aGObj.state.supported && !aGObj.toDelete) {
              gobjList.gobjects[aGObj.id] = aGObj;
              this.constraintList.push(aGObj);
              if (speculative) {
                aGObj.state.renderState = 'speculative'; // do this early so downstream code can discover it
              }
              aGObj.parentsList = gobjList.createCanonicalParentReferences(
                aGObj
              );
              aGObj.doPostReadFromSpec();
              aGObj.init();

              if (gobjPostInitFunc) {
                //Make sure the render list is brought up to date so the outside client
                //has a consistent and up to date gobjList to work with.  There is an
                //efficiency cost to doing this.
                GSP.addToRenderList(this.renderList, aGObj);
                gobjPostInitFunc(aGObj);
              }
            } else {
              markForDeletion(aGObj);
            }
          } catch (ex) {
            ex.message =
              'Initializing "' +
              (aGObj ? aGObj.id : 'Unknown GObject') +
              '": ' +
              ex.message;
            GSP.signalCaughtError(ex);
            aGObj.toDelete = true;
          }
        }

        if (!gobjPostInitFunc) {
          //If we don't have a postInitFunc, it is more efficient to create
          //a new renderList all at once.
          this.renderList = GSP.createRenderList(this.constraintList);
        }

        for (i = newGraph.length - 1; i >= 0; --i) {
          //Deleting in reverse order ensures that delete of one won't trigger a delete of another
          //and allows us to skip the test to see if it was already deleted.
          aGObj = newGraph[i];
          if (aGObj.toDelete) {
            GSP.ObjectGraph.deleteNode(newGraph, aGObj);
          }
        }
      },

      /**
       * Returns a list of seed and all its descendants
       *
       * @param {gObj}
       */
      compileDescendants: function(seed) {
        // The returned list is suitable for passing to removeGObjects
        var list = {};

        function addGobj(gobj) {
          // add gobj to the list and ecursively add all children of gobj
          if (list[gobj.id])
            alert(
              'addGobj in compileDescendants called for an already-listed gobj!'
            );
          list[gobj.id] = gobj;
          gobj.children.forEach(function(child) {
            if (!list[child.id]) {
              addGobj(child);
            }
          });
        }

        addGobj(seed);
        return list;
      },

      removeGObjAndDescendants: function(seed) {
        var list = this.compileDescendants(seed);
        this.removeGObjects(list, seed.sQuery.sketch);
      },

      /**
       * Remove gobjects from the list
       *
       * @param {Object} A map of id -> gobjref
       * @param {sketch} the active sketch
       */
      removeGObjects: function(gobjects, sketch) {
        var self = this,
          toDeleteIds = Object.keys(gobjects),
          deletedIds = [];

        toDeleteIds.forEach(function(id) {
          var gobject = self.gobjects[id],
            newlyDeletedIds;

          if (deletedIds.indexOf(id) !== -1) {
            //It's already been deleted
            return;
          }

          if (gobject) {
            newlyDeletedIds = GSP.ObjectGraph.deleteNode(
              self.constraintList,
              gobject
            );
            deletedIds = deletedIds.concat(newlyDeletedIds);
          }
        });

        deletedIds.forEach(function(id) {
          var gobject = self.gobjects[id];

          //Unsupported objects may have already been deleted
          if (gobject) {
            sketch.invalidateAppearance(gobject);

            if (gobject.destroy) {
              gobject.destroy();
            }

            sketch.renderCleanupGObj(gobject);
          }
          delete self.gobjects[id];
        });

        //update internals
        this.renderList = GSP.createRenderList(this.constraintList);
      },
    });

    function GObjList(gobjects) {
      this.gobjects = {};
      if (gobjects) {
        this.addGObjects(gobjects);
      } else {
        this.constraintList = GSP.ObjectGraph.convertObjectSpec({});
      }
    }
    GObjList.prototype = gObjListPrototype;

    return GObjList;
  })();

  /*
   * Squery
   * Provides ability to search gobject hierarchy using css-style selectors.
   * Supported selectors.
   *    #id: gobject id property
   *    .class: gobject class property
   *    'Unknown'|'Button'|'Circle'|'CircleInterior'|...:
   *         gobjects matching the given kind
   *    (x,y,h,w): gobjects within the specified rectangle (TBD)
   *    *: selects all gobjects
   *    a,b: selects a and b where a and b are other selectors.
   * Constructs an array like object. The usual array operators and methods may be
   * used to access selected objects. In addition a number of functions are
   * supported. The following operate on the results of an sQuery object, and
   * return an sQuery object. Returning an sQuery object facilitates chaining.
   *   each(fn): the function fn is called for each element of the array.
   *   hide(): hides the selected gobjects
   *   hideLabel(): hides the selected gobject's labels
   *   parents(): returns an sQuery object containing the parents of this sQuery
   *      object.
   *   show(): shows the selected gobjects
   *   showLabel(): shows the selected gobject's labels
   *
   * The following methods return other objects, and cannot be chained.
   *   attr(name, value): modifies the value of the selected gobject style
   *       properties.
   *   attr(name): returns the value of the first selected gobject style
   *       property.
   *   get(id): returns the gObject by id. Equivalent to "sQuery('#' + id)[0]"
   *   preferences(): returns the preferences object.
   */
  /*global GSP:false, JSONcanonical:false */

  GSP.SQuery = (function($) {
    var sQueryPrototype = [];

    /*
     * Sketch object accessor
     */
    sQueryPrototype.getSketch = function() {
      return this.sketch;
    };

    /*
     * Traverses an object and locates a property identified by a dotted name.
     * If a function is provided, returns the resulf of invoking it,
     * passing the property value as its single argument. If not returns the
     * the value of the property.
     */
    sQueryPrototype.findDottedProperty = function(obj, propName, fn) {
      var pArray = propName.split('.'),
        ix,
        tgt = obj;
      for (ix = 0; ix < pArray.length; ix += 1) {
        if (typeof tgt !== 'object') {
          return;
        }
        tgt = tgt[pArray[ix]];
      }
      if (typeof fn === 'undefined') {
        return tgt;
      }
      if (typeof tgt !== 'undefined') {
        return fn(tgt);
      }
    };

    /*
     * Executes the function for each selected gobject. The gobject is set to
     * 'this'. The function is passed the index in the selection list, and the
     * gobject as an argument.
     */
    sQueryPrototype.each = function(func) {
      var ix;
      for (ix = 0; ix < this.length; ix += 1) {
        func.call(this[ix], ix, this[ix]);
      }
      return this;
    };

    /*
     * Makes the selected gobject's hidden, if they are visible.
     */
    sQueryPrototype.hide = function() {
      this.each(function(ix, gobj) {
        gobj.hide();
      });
      return this;
    };

    /*
     * Makes the selected gobject's visible, if they are hidden.
     */
    sQueryPrototype.show = function() {
      this.each(function(ix, gobj) {
        gobj.show();
      });
      return this;
    };

    /*
     * Expose the sketch method of marking a gobj dirty.
     */
    sQueryPrototype.invalidateGeom = function(gobj) {
      this.getSketch().invalidateGeom(gobj);
    };

    /**
     * Shows the labels for all members of the jquery list.
     */
    sQueryPrototype.showLabel = function() {
      var sketch = this.getSketch();
      this.each(function(ix, gobj) {
        if (!gobj.style) {
          gobj.style = {};
        }
        if (!gobj.style.label) {
          gobj.style.label = {};
        }
        gobj.style.label.showLabel = true;
        sketch.invalidateAppearance(gobj);
      });
      return this;
    };

    /**
     * Shows the labels for all members of the jquery list.
     */
    sQueryPrototype.hideLabel = function() {
      var sketch = this.getSketch();
      this.each(function(ix, gobj) {
        if (!gobj.style) {
          gobj.style = {};
        }
        if (!gobj.style.label) {
          gobj.style.label = {};
        }
        gobj.style.label.showLabel = false;
        sketch.invalidateAppearance(gobj);
      });
      return this;
    };

    /*
     * Returns the named object, or undefined, if the id is not found.
     */
    sQueryPrototype.get = function(id) {
      var sketch = this.getSketch();
      return sketch.gobjList.gobjects[id];
    };

    /**
     * Mark the sketch dirty to request redraw of the sketch.
     */
    sQueryPrototype.dirty = function() {
      this.getSketch().isDirty = true;
    };

    /**
     * Erase Traces.
     */
    sQueryPrototype.eraseTraces = function() {
      this.getSketch().clearTraces();
    };

    /**
     * Stop Any Motions.
     */
    sQueryPrototype.stopMotions = function() {};

    /**
     * Operates on attributes of a gobject.
     *
     * Attribute names are either style properties or top-level(model) properties,
     * with preference to top-level properties. For example, the attribute 'textMFS'
     * will select gobj.textMFS from any descendant of the text kind. The attribute
     * 'color' will select gobj.style.color.
     *
     * If one string argument is provided, returns the value of the named attribute
     * of the *FIRST* item of the sQuery array.
     * If a string argument and a non-function parameter is provided then the
     * string argument is taken to be the attribute name and the other parameter
     * is a value. The named attribute of each item of the sQuery array
     * is assigned the value.
     * If a string argument and a function parameter is provided then the function
     * is called, passing the array index and with *this* set to the gobject, and
     * the return value is assigned to the attribute.
     * If one object argument is provided, the members are taken to be attribute
     * name/value pairs. Each of these name/value pairs is handled in sequence for
     * each item in the sQuery array.
     *
     * Style objects may have sub-objects. These attributes may be referred to
     * by their dotted syntax. For example: attr("trace.color", "red");
     *
     * @param {String} name The name of the attribute.
     * @param {String|Number|undefined} value If defined, the new value
     *     for the attribute.
     * @return value of the *FIRST* member of the list.
     *
     */
    sQueryPrototype.attr = function(name, value) {
      function writeAttr(objIndex, obj, attrName, value) {
        var attrs = attrName.split('.'),
          co = obj,
          ix,
          a;

        // Iterate over the paths, skipping the last one
        for (ix = 0; ix < attrs.length - 1; ix += 1) {
          a = $.trim(attrs[ix]);
          // Grab the next path's value, creating an empty
          // object if it does not exist
          if (!co[a]) {
            co[a] = {};
          }
          co = co[a];
        }

        // Assign the value to the object's last path
        if ($.type(value) === 'function') {
          co[$.trim(attrs[attrs.length - 1])] = value.call(obj, ix, obj);
        } else {
          co[$.trim(attrs[attrs.length - 1])] = value;
        }
      }

      function readAttr(obj, attrName) {
        var attrs = attrName.split('.'),
          co = obj,
          ix,
          a;
        for (ix = 0; ix < attrs.length; ix += 1) {
          a = $.trim(attrs[ix]);
          if (typeof co[a] === 'undefined') {
            return;
          }
          co = co[a];
        }
        return co;
      }

      var sketch = this.getSketch(),
        result = '',
        attrMap,
        key;
      if (value !== undefined && value.length !== 0) {
        this.each(function(ix, gobj) {
          var result;
          if (this) {
            result = readAttr(this, name);
            if (result !== undefined) {
              writeAttr(ix, gobj, name, value);
              sketch.invalidateGeom(gobj);
            } else if (this.style) {
              result = readAttr(this, 'style.' + name);
              if (result !== undefined) {
                writeAttr(ix, gobj, 'style.' + name, value);
                sketch.invalidateGeom(gobj);
              }
            }
          }
        });
      }
      if ($.type(name) === 'object') {
        attrMap = name;
        // recursively call this function for
        // each key value pair.
        for (key in attrMap) {
          if (attrMap.hasOwnProperty(key)) {
            result = this.attr(key, attrMap[key]);
          }
        }
      } else if ($.type(name) === 'string') {
        if (this[0]) {
          result = readAttr(this[0], name);
        }
        if (result === undefined && this[0].style) {
          result = readAttr(this[0], 'style.' + name);
        }
      }
      return result;
    };

    /**
     * Returns a combined list of parents of all the selected elements
     * as an sQuery list.
     * @return an sQuery object referencing the parents of this sQuery object.
     */
    sQueryPrototype.parents = function() {
      var ix, key, gobj, sketch, result;

      sketch = this.getSketch();
      result = new sketch.sQuery();

      for (ix = 0; ix < this.length; ix += 1) {
        gobj = this[ix];
        if (gobj.parents) {
          for (key in gobj.parents) {
            if (gobj.parents.hasOwnProperty(key)) {
              result.push(gobj.parents[key]);
            }
          }
        }
      }
      return result;
    };

    /**
     * For Button members of this sQuery array, execute the press function.
     * @param {boolean} active If set, specifies whether the press is a
     * press to activate a non-active button, or a press to deactivate an active one.
     * @return this.
     */
    sQueryPrototype.press = function(active) {
      var doc = this.getSketch().document;
      // hold on to the document - sketch might switch pages underneath us
      this.each(function(ix, gobj) {
        if (gobj.press) {
          if (undefined === active || active !== gobj.state.isActive) {
            doc.getFocusPage().constrain();
            gobj.press(doc.getFocusPage());
            doc.getFocusPage().constrainAndRedraw();
          }
        }
      });
      return this;
    };

    sQueryPrototype.value = function(value) {
      var sketch = this.getSketch();
      // no value - getter of first element value.
      if (undefined === value) {
        if (this[0].uValue !== undefined) {
          return this[0].uValue;
        }

        if (this[0].value !== undefined) {
          return this[0].value;
        }

        if (this[0].geom && this[0].geom.loc) {
          return this[0].geom.loc;
        }

        return undefined;
      }

      this.each(function(ix, gobj) {
        if (gobj.updateValue) {
          gobj.updateValue(value);
        } else if (gobj.geom && gobj.geom.loc && jQuery.isPlainObject(value)) {
          gobj.geom.loc.x = value.x;
          gobj.geom.loc.y = value.y;
          sketch.invalidateGeom(gobj);
        }
      });

      return this;
    };

    /**
     * Returns the preferences object.
     */
    sQueryPrototype.prefs = function() {
      return this.getSketch().preferences;
    };

    /**
     * Returns the specified resource.
     *  @param  {String}  iMapName -- Currently, "pictures" or "fontList"
     *  @param  {String}  iKey -- the key or index of the specified resource in the map
     *  @returns  {Object}  the value of the resource with the specified key
     */
    sQueryPrototype.getResource = function(iMapName, iKey) {
      var resourceMap = this.getSketch().document.resources[iMapName];
      return resourceMap && resourceMap[iKey];
    };

    /**
       * Return a JSON string reflecting the current
       * state of the sketch as a delta from the original spec for the sketch.
       
       */
    sQueryPrototype.getSketchDelta = function() {
      var sketch = this.getSketch(),
        deltaObj = sketch.document.getPageDeltaObj(sketch.metadata.id);

      return JSONcanonical.stringify(deltaObj);
    };

    /**
     * Given either an object or a JSON string of a sketch delta, apply it to
     * the current active sketch page.  It is assumed that the delta came from
     * the correct sketch page.  If that is not true, this method will fail
     * silently (with log statements).
     *
     * @param iSketchDelta
     */
    sQueryPrototype.applySketchDelta = function(iSketchDelta) {
      var diff,
        sketch = this.getSketch();

      if (typeof iSketchDelta === 'string') {
        diff = JSON.parse(iSketchDelta);
      } else {
        diff = iSketchDelta;
      }

      sketch.document.applyDeltaToActivePage(diff);
    };

    /**
     * Return a JSON string in the WSP Interchange Format reflecting the current
     * state of the sketch. This document can be used to initialize a new sketch
     * instance and will have the appearance identical to the moment this call
     * was made and behave identically.
     */
    sQueryPrototype.getSketchJSON = function() {
      return this.getSketch().document.getDocumentJSON();
    };

    // provided for backwards compatibility.
    sQueryPrototype.toString = sQueryPrototype.getSketchJSON;

    /*
     * Event API
     */

    // Worker functions for on() and onGroup() - bind or unbind an id or id-list to/from a handler
    function bindOn(events, handler, sketchBinder) {
      var sketch = this.getSketch(),
        pageId = sketch.getPageId(),
        eventList = events.split(' '); // space separated event types

      // loop over each gobj in the matched set
      this.each(function(ix, gobj) {
        // loop over each eventType
        $.each(eventList, function(ix, eventType) {
          // bind the the gobj/eventType to handler
          sketchBinder.call(
            sketch.document,
            pageId,
            gobj.id,
            eventType,
            handler
          );
        });
      });
    }

    function bindOnGroup(events, handler, sketchBinder) {
      var sketch = this.getSketch(),
        pageId = sketch.getPageId(),
        eventList = events.split(' '), // space separated event types
        ids = [];

      // Accumulate an array of ids of gobjects in the matched set
      this.each(function(ix, gobj) {
        ids.push(gobj.id);
      });

      // loop over each eventType
      $.each(eventList, function(ix, eventType) {
        // bind the the ids Group/eventType to handler
        sketchBinder.call(sketch.document, pageId, ids, eventType, handler);
      });
    }

    sQueryPrototype.on = function(events, handler) {
      bindOn.call(
        this,
        events,
        handler,
        this.getSketch().document.bindGObjEvent
      );
    };

    sQueryPrototype.off = function(events, handler) {
      bindOn.call(
        this,
        events,
        handler,
        this.getSketch().document.unbindGObjEvent
      );
    };

    sQueryPrototype.onGroup = function(events, handler) {
      bindOnGroup.call(
        this,
        events,
        handler,
        this.getSketch().document.bindGObjEvent
      );
    };

    sQueryPrototype.offGroup = function(events, handler) {
      bindOnGroup.call(
        this,
        events,
        handler,
        this.getSketch().document.unbindGObjEvent
      );
    };

    function selectAll(dummy, gList, target) {
      var key;
      for (key in gList) {
        if (gList.hasOwnProperty(key)) {
          target[key] = gList[key];
        }
      }
    }

    /**
     * Selects gList elements by property name and value.
     */
    function selectByProp(prop, value, gList, target) {
      var key, pval;
      for (key in gList) {
        if (gList.hasOwnProperty(key)) {
          pval = sQueryPrototype.findDottedProperty(gList[key], prop);
          if (typeof pval === 'undefined') {
            pval = sQueryPrototype.findDottedProperty(
              gList[key],
              'style.' + prop
            );
          }
          if (value === pval) {
            target[key] = gList[key];
          }
        }
      }
    }

    /*
     * Selects gList elements by ID.
     * Stops when it finds one.
     */
    function selectById(idSel, gList, target) {
      target[idSel.name] = gList[idSel.name];
    }

    function selectByClass(classSel, gList, target) {
      var key,
        re = new RegExp('\\b' + classSel.name + '\\b');
      for (key in gList) {
        if (gList.hasOwnProperty(key)) {
          if (gList[key]['class'] && re.test(gList[key]['class'])) {
            target[key] = gList[key];
          }
        }
      }
    }

    function selectByKind(kindSel, gList, target) {
      selectByProp('kind', kindSel.name, gList, target);
    }

    function selectByAttribute(attrSel, gList, target) {
      var name = attrSel.name,
        value = attrSel.value;
      selectByProp(name, value, gList, target);
      selectByProp('style.' + name, value, gList, target);
    }

    var selectFnList = {
      attr: selectByAttribute,
      class: selectByClass,
      global: selectAll,
      id: selectById,
      kind: selectByKind,
    };

    function selectCompound(attrSel, gList, target) {
      var fn,
        ix,
        parts = attrSel.parts,
        priorSelections = gList,
        newSelections;

      for (ix = 0; ix < parts.length; ix += 1) {
        fn = selectFnList[parts[ix].type];
        if (ix === parts.length - 1) {
          newSelections = target;
        } else {
          newSelections = {};
        }
        fn(parts[ix], priorSelections, newSelections);
        priorSelections = newSelections;
      }
    }

    // query on each selector in turn, collecting the results in
    // the associative array, assoc, to avoid recording duplicates.
    function applySelectors(selectors, gList, assoc) {
      var ix, selectComponent;

      for (ix = 0; ix < selectors.length; ix += 1) {
        selectComponent = selectors[ix];

        if (selectComponent.type === 'global') {
          selectAll(selectComponent, gList, assoc);
        } else if (selectComponent.type === 'id') {
          selectById(selectComponent, gList, assoc);
        } else if (selectComponent.type === 'class') {
          selectByClass(selectComponent, gList, assoc);
        } else if (selectComponent.type === 'kind') {
          selectByKind(selectComponent, gList, assoc);
        } else if (selectComponent.type === 'attr') {
          selectByAttribute(selectComponent, gList, assoc);
        } else if (selectComponent.type === 'selectorAnd') {
          selectCompound(selectComponent, gList, assoc);
        } else {
          GSP.log('Unclassified squery selector: ' + selectComponent);
        }
      }
    }

    function BindSQueryToRoot(root) {
      /*
       * Performs a selection and returns a new SQuery object
       * with the results.
       */
      var SQuery = function SQuery(selector) {
        // handles the case where the function was not invoked
        // with 'new'. Makes sure this is properly set.
        if (!(this instanceof SQuery)) {
          return new SQuery(selector);
        }

        var selectors,
          key,
          sketch = root.getFocusPage ? root.getFocusPage() : root, // ask for the page, or it's the page
          gList = (sketch.gobjList && sketch.gobjList.gobjects) || {},
          assoc = {};

        // copies the sketch from the closure, we will lose the closure
        // in the newly constructed object.
        this.sketch = root;

        if (selector !== undefined) {
          // if the selector is an array we use it.
          if ($.isArray(selector)) {
            selectors = selector;
          } else if ($.type(selector) === 'string') {
            selectors = GSP.sQueryParser.parse(selector);
          } else {
            selectors = [];
          }

          applySelectors(selectors, gList, assoc);

          // save found objects to an array
          for (key in assoc) {
            if (assoc.hasOwnProperty(key)) {
              this.push(assoc[key]);
            }
          }
        }
      };

      SQuery.sketch = root;
      SQuery.prototype = sQueryPrototype;
      return SQuery; // sQuery constructor instance, for method calls or chaining of selectors
    }

    return BindSQueryToRoot; // Constructor to make available globally
  })(jQuery);

  /**
   * @fileOverview Frame timing monitor
   * @version 0.0
   * @preserve (C) KCP Technologies, 2013
   */
  GSP.PerfMonitor = (function($) {
    var Stats, StatsPrototype, PerfMonitorPrototype, PerfMonitor;
    var FRAME_INTERVAL = 1000 / 60;
    StatsPrototype = {
      clear: function() {
        this.data = {};
      },
      set: function(prop, value) {
        this.data[prop] = value;
      },
      get: function(prop) {
        return this.data[prop];
      },
      increment: function(prop, count) {
        var incr = count || 1;
        if (typeof this.data[prop] !== 'number') {
          this.data[prop] = incr;
        } else {
          this.data[prop] += incr;
        }
      },
      log: function(prop, item) {
        if (typeof this.logs[prop] === 'undefined') {
          this.logs[prop] = [];
        }
        this.logs[prop].push(item);
      },
    };
    Stats = function() {
      var stats = Object.create(StatsPrototype);
      stats.data = {};
      stats.logs = {};
      return stats;
    };
    PerfMonitor = function() {
      var pm = Object.create(PerfMonitorPrototype);
      pm.stats = new Stats();
      pm.stats.set('Start', pm.now());
      pm.times = {
        idle: undefined,
        active: undefined,
        constrain: undefined,
        render: undefined,
        fade: undefined,
      };
      return pm;
    };
    PerfMonitorPrototype = {
      now: function() {
        if (window.performance && window.performance.now) {
          return window.performance.now();
        } else {
          return $.now();
        }
      },
      getFrameCount: function() {
        return this.stats.get('Activation Count');
      },
      animFrameHandler: function() {
        var lastIdle = this.times.idle,
          lastActive = this.times.active,
          now = this.now(),
          idle = now - lastIdle,
          frameTime = now - lastActive,
          idleTime = idle /*% FRAME_INTERVAL*/,
          deltaFrames = Math.max(0, idle / FRAME_INTERVAL - 1);
        this.times.last = lastIdle;
        this.times.frame = frameTime;
        this.times.active = now;
        this.times.constrain = this.times.render = this.times.fade = undefined;
        this.stats.increment('Activation Count');
        this.stats.increment('Idle Accum', idleTime);
        if (deltaFrames > 0) {
          this.stats.increment('Activation Missed', Math.round(deltaFrames));
        }
      },
      constrainHandler: function() {
        this.times.constrain = this.now();
        this.stats.increment('Constrain Count');
        this.stats.increment(
          'Touch Accum',
          this.times.constrain - this.times.active
        );
      },
      renderHandler: function() {
        this.times.render = this.now();
        this.stats.increment('Render Count');
        this.stats.increment(
          'Constrain Accum',
          this.times.render - this.times.constrain
        );
      },
      fadeHandler: function() {
        this.times.fade = this.now();
        this.stats.increment('Fade Count');
        if (typeof this.times.render !== 'undefined') {
          this.stats.increment(
            'Render Accum',
            this.times.fade - this.times.render
          );
        }
      },
      idleHandler: function() {
        var now = this.now(),
          delta = now - this.times.active;
        this.stats.increment('Idle Count');
        this.times.idle = now;
        this.stats.increment('Active Accum', delta);
        if (delta > this.FRAME_INTERVAL) {
          this.stats.increment('Late Frames');
        }
        if (typeof this.times.fade !== 'undefined') {
          this.stats.increment('Fade Accum', this.times.idle - this.times.fade);
        } else if (typeof this.times.render !== 'undefined') {
          this.stats.increment(
            'Render Accum',
            this.times.idle - this.times.render
          );
        }
        //if ((this.stats.get('Idle Count') % 300) === 0) { GSP.log('times: ' + JSON.stringify(this.times)); }
      },
      unknownStateHandler: function() {
        GSP.signalErrorWithMessage('PerfMonitor: unknown state');
      },
      stateChange: function(state) {
        var stateHandler = this[state + 'Handler'] || this.unknownStateHandler;
        stateHandler.call(this);
      },
      // compute basic performance statistics and return values
      // optionally reset counters (default).
      report: function(name, phase, reset) {
        function mean(accum, count) {
          if (count) {
            return accum / count;
          } else {
            return 0;
          }
        }

        var doReset = typeof reset === 'undefined' ? true : reset,
          rslt = GSP.stringify({
            name: name,
            phase: phase,
            frames: this.stats.get('Activation Count'),
            frameTime: mean(
              this.now() - this.stats.get('Start'),
              this.stats.get('Activation Count')
            ),
            active: mean(
              this.stats.get('Active Accum'),
              this.stats.get('Activation Count')
            ),
            missedFrames: this.stats.get('Activation Missed'),
            lateFrames: this.stats.get('Late Frames'),
            idle: mean(
              this.stats.get('Idle Accum'),
              this.stats.get('Idle Count')
            ),
            touch: mean(
              this.stats.get('Touch Accum'),
              this.stats.get('Activation Count')
            ),
            constrainCt: this.stats.get('Constrain Count'),
            constrain: mean(
              this.stats.get('Constrain Accum'),
              this.stats.get('Constrain Count')
            ),
            renderCt: this.stats.get('Render Count'),
            render: mean(
              this.stats.get('Render Accum'),
              this.stats.get('Render Count')
            ),
            fadeCt: this.stats.get('Fade Count'),
            fade: mean(
              this.stats.get('Fade Accum'),
              this.stats.get('Fade Count')
            ),
          });
        if (doReset) {
          this.stats.clear();
          this.stats.set('Start', this.now());
        }
        return rslt;
      },
    };
    return PerfMonitor;
  })(jQuery);

  /* global b64_md5:false, JSONcanonical:false, jsondiffpatch:false */

  /**
   * @fileOverview Various utilities for sketch pages.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
  
   */

  GSP.speculativeOpacity = 0.5;
  GSP.speculativeColor = '#888888';
  GSP.targetHighlightColor = 'red';
  GSP.targetHighlightPathBolding = 2; //Thickness to add to paths that are targetHighlighted
  GSP.targetFocusColor = 'red'; // Color of all gobject Highlighted on focus
  GSP.targetFocusPathBolding = 2; // Adding line width which is Highlighted on focus
  GSP.radiusExpansionOnFocus = 4; // Radius of point circle which is Highlighted on focus

  GSP.diffPatch = jsondiffpatch.create({
    objectHash: function(obj) {
      // use the object's id if it has one, or just serialize the whole thing all
      return obj.id !== undefined ? obj.id : JSONcanonical.stringify(obj);
    },
    // We don't ship with the long text diffing code, so we just
    // configure jsondiffpatch to treat all text as "short." If we
    // encounter a truly enormous piece of text, we will just throw an
    // error (missing library).
    textDiff: { minLength: 80 * 1000 },
  });

  /**
    Return the kind object for a given kind specification string.
   */
  GSP.getKindObj = function(iKindSpec) {
    var kindObj = GSP.gObjects[iKindSpec],
      doc = kindObj && kindObj.doc,
      isSupported = doc && doc.supported,
      isInstantiable =
        isSupported || (doc && GSP.gOptions.instantiateUnsupportedObjects);
    return isInstantiable ? kindObj : null;
  };

  /**
    Return the constraint object for a given constraint specification string.
   */
  GSP.getConstraintObj = function(iConstraintSpec) {
    var constraintObj = GSP.gConstraints[iConstraintSpec],
      doc = constraintObj && constraintObj.doc,
      isSupported = doc && doc.supported,
      isInstantiable =
        isSupported || (doc && GSP.gOptions.instantiateUnsupportedObjects);
    return isInstantiable ? constraintObj : null;
  };

  /**
   * Given an array of gobjs, returns an object with each gobj keyed by id
   */
  GSP.gobjIdMapFromArray = function(array) {
    var ret = {};

    array.forEach(function(gobj) {
      ret[gobj.id] = gobj;
    });

    return ret;
  };

  /**
   * Returns the actual font family from the a style object.
   * Below are the 3 different ways font info was stored in
   * a style object:
   * 1. (Current) As an index into Document-level fontList array
   * 2. As an index into Sketch-level fontList array (in preferences)
   * 3. As the font family string itself
   *
   * @param {type} style
   * @returns {GSP.getFontFamilyFromStyle.ffProp}
   */
  GSP.getFontFamilyFromStyle = function(style, sQuery) {
    var fontTable,
      fontFamily,
      ffProp = style['font-family'];

    if ($.type(ffProp) === 'number') {
      fontFamily = sQuery.getResource('fontList', ffProp);

      //Backwards compatibility - pre-tool file format
      if (!fontFamily) {
        fontTable = sQuery.prefs().fontList;
        if (fontTable && fontTable[ffProp]) {
          fontFamily = fontTable[ffProp];
        }
      }
      if (!fontFamily) {
        // rather than fail, default to the first entry
        fontFamily = sQuery.getResource('fontList', 0);
      }
    }
    if (!fontFamily) {
      fontFamily = ffProp;
    }
    return fontFamily;
  };

  /**
   * Workhorse for setting render attributes for a given line style.  The line dash
   * is determined by properties in the passed in attributes, and affects the spacing
   * of the dashes.
   *
   * @param lineStyle  - string - supported values: 'dashed' and 'dotted'
   * @param attrs - object - the attributes to modify
   */
  GSP.modifyRenderAttrsForLineStyle = function(lineStyle, attrs) {
    var dash,
      width = attrs.width || 1;

    switch (lineStyle) {
      case 'dashed':
        // dashes get longer with thicker lines
        dash = Math.round(8 * (1 + (width - 1) / 4));
        attrs.lineDash = [dash, 6];
        break;
      case 'dotted':
        // dots and spaces get larger with thicker lines
        attrs.lineDash = [width, Math.max(2, Math.round(1.2 * width))];
        break;
      default:
        attrs.lineDash = [];
    }
  };

  /**
   * Get the prototype class to use to construct a GObject
   * @param {string} kind The name of the class.
   * @param {string} constraint The name of the constraint.
   * @return {object}     A class object to use as a prototype (via GSP.makeInstance()).
   */
  GSP.gobjPrototype = (function() {
    var protoCache = {}; // JIT creation of prototype - but we'll cache it.
    return function(kind, constraint) {
      var protoKey = [kind, constraint].join(':'),
        proto = protoCache[protoKey];

      if (!proto) {
        proto = GSP.makeClass(GSP.gObjects[kind], GSP.gConstraints[constraint]);
        protoCache[protoKey] = proto;
      }

      return proto;
    };
  })();

  /**
   * Constructs a GObject instance from a JSON specification.
   * JSON specifications identify the kind and constraints for the objects and
   * override configuration defaults of other attributes.
   * @param {object} specObj A JSON object.
   * @param {string} id The id of the new GObject.
   * @param {object} sQuery The sketch sQuery object.
   * @return {object}     A GObject instance.
   */
  GSP.gobjFromSpec = function(specObj, id, sQuery, specObjs) {
    var kind = specObj.kind,
      kindObj = GSP.getKindObj(kind),
      constraint = specObj.constraint,
      constraintObj = GSP.getConstraintObj(constraint),
      newGObj,
      gobjProto,
      supportedKind = kindObj && kindObj.kindSupportsSpecObj(specObj, specObjs),
      supportedConstraint =
        constraintObj &&
        constraintObj.constraintSupportsSpecObj(specObj, specObjs);

    if (!supportedKind) {
      GSP.log('GObject ' + id + ' has undefined kind: "' + specObj.kind + '"');
      kind = 'Unknown'; // Fallback to root class
      constraint = 'Unknown'; // Fallback to root class
    } else if (!supportedConstraint) {
      GSP.log(
        'GObject ' +
          id +
          ' has undefined constraint: "' +
          specObj.constraint +
          '"'
      );

      if (kindObj.doc.defaultConstraint) {
        constraint = kindObj.doc.defaultConstraint;
      } else {
        kind = 'Unknown'; // Fallback to root class
        constraint = 'Unknown'; // Fallback to root class
      }
    }

    gobjProto = GSP.gobjPrototype(kind, constraint);

    newGObj = GSP.makeInstance(gobjProto, specObj, { doc: true });
    newGObj.id = id;
    newGObj.sQuery = sQuery;

    if (!supportedKind || !supportedConstraint) {
      newGObj.state.supported = false;
    }
    return newGObj;
  };

  /**
   * Constructs gobject instances from a collection of JSON specifications.
   * JSON specifications identify the kind and constraints for the objects and
   * override configuration defaults of other attributes.
   * @param {object} spec A collection of JSON objects keyed by id.
   * @param {object} sQuery The sketch sQuery object.
   * @return {object}     A collection of GObject instances keyed by id. There
   *                      should be a one-to-one correspondence between the
   *                      output instances and the inputs.
   */
  GSP.gobjectsFromSpec = function(spec, sQuery) {
    var specObjs = spec,
      gobjects = {},
      id,
      specObj,
      newGObj;
    for (id in specObjs) {
      if (specObjs.hasOwnProperty(id)) {
        specObj = specObjs[id];
        if (specObj) {
          newGObj = GSP.gobjFromSpec(specObj, id, sQuery, specObjs);
          gobjects[id] = newGObj;
        } else {
          GSP.signalErrorWithMessage(
            'Undefined gobject in sketch document: "' + id + '"'
          );
        }
      }
    }
    return gobjects;
  };

  /**
   * Return a string that represents a checksum (MD5 hash) of the
   * structural members of the document (kind, constraint, genus, parents)
   * as a JSON document. This can be used to determine whether two documents
   * are structurally similar. This is included in the deltas used by
   * getSketchDelta() and applySketchDelta() to assert that a given delta
   * can only be applied to a document that is structurally identical to the
   * document from which the delta was generated.
   */
  GSP.generateChecksum = function(sketchSpec) {
    // return base64-encoded MD5 hash of the JSON
    return b64_md5(JSONcanonical.stringify(sketchSpec));
  };

  /**
   * Given two sketch specs (pages of a document), produce a diff that shows the changes
   * from origSpec to newSpec.
   *
   * @param origSpec
   * @param newSpec
   * @returns {Object} - a diff object
   */
  GSP.getSketchDiff = function(origSpec, newSpec) {
    //Strips the debug property of objects from a sketch spec.
    //Both the original and new must have it stripped to prevent
    //the diff tool from writing out anything related to debug.
    function needsGeom(gobj) {
      return true; // TBD Fix this: has bugs - (measuerments, composite text). Needs a more general solution
      // return gobj.constraint === 'Free' || gobj.constraint === 'PictureFree' || gobj.kind === 'Button';
    }
    /* SS: Here's a proposed strategy for the fix, so that we can strip unneeded geom properties.
     * First, define a geomIsConstrained() function for all objects defaulting to true.
     * Objects whose geom isn't constrained should override this function.
     * For instance, ButtonKind, ExpressionKind, and TextKind would override to return false,
     * as would Free and PictureFree constraints.
     * Objects returning false would include their geom property in diffs;
     * objects returning true would not.
     */

    function specWithStrippedDebug(spec) {
      var copiedSpec = $.extend(true, {}, spec),
        objects = copiedSpec.objects,
        gobj;

      for (var key in objects) {
        if (objects.hasOwnProperty(key)) {
          gobj = objects[key];
          gobj.debug = undefined;
          // Any non-free gobj doesn't need a geom - it will be calculated from constraint.
          if (!needsGeom(gobj)) {
            if (gobj.geom) gobj.geom = undefined;
          }
        }
      }

      return copiedSpec;
    }

    var sketchDiff = {};

    sketchDiff.diff = GSP.diffPatch.diff(
      specWithStrippedDebug(origSpec),
      specWithStrippedDebug(newSpec)
    );

    sketchDiff.checksum = GSP.generateChecksum(origSpec);

    return sketchDiff;
  };

  /**
   * Apply a diff that was generated by getSketchDiff to a sketch spec.  The spec
   * must be in the same state as origSpec was when the diff was generated.
   *
   * @param spec
   * @param diffObj
   */
  GSP.applySketchDiff = function(spec, diffObj) {
    if (diffObj.checksum !== GSP.generateChecksum(spec)) {
      GSP.log('Applying sketch diff to the wrong source spec');
    }

    try {
      GSP.diffPatch.patch(spec, diffObj.diff);
    } catch (error) {
      GSP.log('applySketchDiff() aborted: ' + error.message);
    }
  };

  /**
   * Given two document specs, produce a diff that shows the changes
   * from origSpec to newSpec.
   *
   * @param origDocSpec
   * @param newDocSpec
   * @returns {{}}
   */
  GSP.getDocumentDiff = function(origDocSpec, newDocSpec) {
    var docDiff = {};

    docDiff.checksum = GSP.generateChecksum(origDocSpec);
    docDiff.metadataDiff = GSP.diffPatch.diff(
      origDocSpec.metadata,
      newDocSpec.metadata
    );
    docDiff.pageDiffs = [];

    if (origDocSpec.pages) {
      origDocSpec.pages.forEach(function(origSketch, index) {
        var newSketch = newDocSpec.pages[index];
        docDiff.pageDiffs[index] = GSP.getSketchDiff(origSketch, newSketch);
      });
    }

    return docDiff;
  };

  /**
   * Return an object with information about the layer this kind
   * should draw in.
   * @param {string} kind A GObject kind
   * @return {object} { 'z_index': numeric_sort_index, 'engine': engine name, 'construction_sort': factor}
   *   z_index: The layer - higher index drawn on top
   *   engine: name of the drawing engine that handles this layer (e.g. 'standard', or 'interior')
   *   construction_sort: factor for tie-breaking - do we draw later gobjects below earlier ones (1) or the reverse (-1)
   */
  GSP.layerInfo = (function() {
    // We'll have various z-index layers for different varieties of objects. These
    // are taken from apple_platform.h in the Sketchpad codebase.
    var layers = {
        NeverVisible: { z_index: 0, engine: null, construction_sort: 1 },
        // ExternalImagesAndInteriors objects really should have style.layerOrder set,
        // but for jsp conversion convenience, we'll sort new over old.
        ExternalImagesAndInteriors: {
          z_index: 1,
          engine: 'standard',
          construction_sort: -1,
        },
        LineLoci: { z_index: 2, engine: 'standard', construction_sort: 1 },
        CoordinateSystem: {
          z_index: 3,
          engine: 'standard',
          construction_sort: 1,
        },
        Axes: { z_index: 4, engine: 'standard', construction_sort: 1 },
        LinesCurves: { z_index: 5, engine: 'standard', construction_sort: 1 },
        Rays: { z_index: 5 + 0.1, engine: 'standard', construction_sort: -1 },
        Segments: {
          z_index: 5 + 0.2,
          engine: 'standard',
          construction_sort: -1,
        },
        PathMarkers: { z_index: 6, engine: 'standard', construction_sort: 1 },
        Tables: { z_index: 7, engine: 'html', construction_sort: 1 },
        Text: { z_index: 8, engine: 'html', construction_sort: 1 },
        Buttons: { z_index: 9, engine: 'html', construction_sort: 1 },
        DiscretePointVectors: {
          z_index: 10,
          engine: 'canvasTop',
          construction_sort: 1,
        },
        Points: { z_index: 11, engine: 'canvasTop', construction_sort: 1 },
        PointsFree: {
          z_index: 11 + 0.1,
          engine: 'canvasTop',
          construction_sort: -1,
        },
        PointsSemiFree: {
          z_index: 11 + 0.2,
          engine: 'canvasTop',
          construction_sort: -1,
        },
      },
      // Each kind will be put in a layer.
      kindSort = {
        AngleMarker: layers.LineLoci,
        Arc: layers.LinesCurves,
        ArcInterior: layers.ExternalImagesAndInteriors,
        Axis: layers.Axes,
        Button: layers.Buttons,
        Circle: layers.LinesCurves,
        CircleInterior: layers.ExternalImagesAndInteriors,
        CoordSys: layers.CoordinateSystem,
        Expression: layers.Text,
        Measure: layers.Text,
        Param: layers.Text,
        Picture: layers.ExternalImagesAndInteriors,
        Point: layers.Points,
        PointFree: layers.PointsFree,
        PointSemiFree: layers.PointsSemiFree,
        Polygon: layers.ExternalImagesAndInteriors,
        Straight: layers.LinesCurves,
        Segment: layers.Segments,
        Ray: layers.Rays,
        Text: layers.Text,
        Table: layers.Tables,
      };

    return function(gObj) {
      var layerKind = gObj.kind;

      //allow the gobj to specify a specific rendering layer, if it wants
      if (gObj.getRenderingLayer) {
        return layers[gObj.getRenderingLayer()];
      }

      // Free points sort in their own layer, as to SemiFree points
      if (gObj.kind === 'Point') {
        if (gObj.constraint === 'Free') {
          layerKind += gObj.constraint;
        } else if (gObj.value !== undefined) {
          // If the point has a value - then it's semi-free
          layerKind += 'SemiFree';
        }
      } else if (gObj.kind === 'Straight') {
        // Segments in their own layer, as with rays.
        if (gObj.genus === 'Segment' || gObj.genus === 'Ray') {
          layerKind = gObj.genus;
        }
      }

      return kindSort.hasOwnProperty(layerKind)
        ? kindSort[layerKind]
        : { z_index: 6, engine: 'standard', construction_sort: 1 };
    };
  })();

  /**
   * Render list creation/manipulation utilities
   */
  (function() {
    /**
     * Utility for getting the proper layer of a gobj
     *
     * @param gObj
     * @returns {number} z index
     */
    function kindLayer(gObj) {
      var l = GSP.layerInfo(gObj).z_index;
      if (undefined === l) {
        l = 0;
      }
      return l;
    }

    /**
     * Sort function for sorting objects in a proper render order
     *
     * @param {Object} a - GObj
     * @param {Object} b - GObj
     * @param optState - persistent state that tracks construction order and kind layer
     *   info (the latter is just for efficiency).  Clients can fill this out ahead of time
     *   (and must for construction order), or can pass an empty object to be filled just in
     *   time - and reused as long as current gobject ids are still valid
     * @return {Number} negative if a comes before b, positive if a should come after b
     */
    function sortFunction(a, b, gobjCache) {
      if (gobjCache[a.id] === undefined) {
        gobjCache[a.id] = {
          kindLayerCache: kindLayer(a),
        };
      }

      if (gobjCache[b.id] === undefined) {
        gobjCache[b.id] = {
          kindLayerCache: kindLayer(b),
        };
      }

      var r;

      r = gobjCache[a.id].kindLayerCache - gobjCache[b.id].kindLayerCache;

      if (0 !== r) {
        return r;
      }

      if (
        a.style.layerOrder !== undefined &&
        b.style.layerOrder !== undefined
      ) {
        r = a.style.layerOrder - b.style.layerOrder;
        if (0 !== r) {
          return r;
        }
      }

      if (a.style.selectable !== b.style.selectable) {
        // Selectable objects should be rendered after unselectable ones
        if (a.style.selectable) return 1;
        else return -1;
      }

      var aConstructionOrder = gobjCache[a.id].constructionOrder,
        bConstructionOrder = gobjCache[b.id].constructionOrder;

      // For tie-breaking, we'll use the reverse order in the given list.
      // SS: Instead use construction order, rendering new objects on top of old objects, and allowing tool matches (which scan the renderList in reverse order) to match to newer objects rather than older ones.
      if (
        aConstructionOrder !== undefined &&
        bConstructionOrder !== undefined
      ) {
        return aConstructionOrder - bConstructionOrder;
      }

      //Otherwise treat b as the newer one (whether it comes first or last depends on the value of construction_sort
      return GSP.layerInfo(b).construction_sort;
    }

    /**
     * Return a version of the given array in render order, where
     * later items are intended to draw over / on top of earlier ones.
     * @param {Array} gObjlist a list of GObject's.
     * @return {Array} A list of GObject instances in render order.
     */
    GSP.createRenderList = function(gObjlist) {
      var list = gObjlist.slice(),
        i,
        gobjCache = {};

      // Fill the gobjCache with construction order and kind layer info
      for (i = 0; i < list.length; i++) {
        gobjCache[list[i].id] = {
          constructionOrder: i * GSP.layerInfo(list[i]).construction_sort,
          kindLayerCache: kindLayer(list[i]),
        };
      }

      list.sort(function(a, b) {
        return sortFunction(a, b, gobjCache);
      });

      return list;
    };

    /**
     *  Returns true if the passed in position is within the bounds of the passed in element
     *  @param {Object} element - jquery wrapped element
     *  @param {Object} pos - our hybrid position element (with pageX, pageY and mouseEvent,etc)
     *      as constructed by sketch.EventToSketch()
     */
    GSP.positionInElement = function(pos, element) {
      var localCoords;

      if (!element || element.length === 0) {
        return false;
      }

      localCoords = GSP.convertPointFromPage(
        element,
        pos.pageX,
        pos.pageY,
        pos.mouseEvent
      );
      return (
        localCoords.x >= 0 &&
        localCoords.y >= 0 &&
        localCoords.x <= element.outerWidth() &&
        localCoords.y <= element.outerHeight()
      );
    };

    GSP.blurDocumentActiveElement = function(baseNode) {
      // http://tjvantoll.com/2013/08/30/bugs-with-document-activeelement-in-internet-explorer/
      // support: IE9
      // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
      try {
        if (document.activeElement) {
          // Support: IE9+
          // If the <body> is blurred, IE will switch windows
          if (document.activeElement.nodeName.toLowerCase() !== 'body') {
            // Blur any element that currently has focus
            $(document.activeElement).blur();
          }
        }
      } catch (error) {}

      var blurAllNumberpadsFunc = GSP.getConfigValue(
        'NumberpadManager.delegates.blurAllNumberpads'
      );
      blurAllNumberpadsFunc(baseNode);
    };

    /**
     * Add a single gobj to an already existing (and sorted) render list
     * It is assumed that the object being added was constructed later than all objects in the existing renderList.
     * (Construction order has an influence on render order)
     *
     * Time complexity is O(N) {more precisely, it's the complexity of
     * Array.splice() + O(Log N)}
     *
     * @param {Array} renderList - either an empty array or an already sorted renderList
     * @return {Object} gobj - GObj to insert
     */
    /*jslint bitwise:true */
    GSP.addToRenderList = function(renderList, gobj) {
      var low = 0,
        high = renderList.length,
        mid = low,
        compareResult,
        finalIndex,
        gobjCache = {};

      while (low < high) {
        mid = low + ((high - low) >> 1);

        compareResult = sortFunction(renderList[mid], gobj, gobjCache);

        if (compareResult <= 0) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }

      finalIndex = compareResult <= 0 ? low : high;
      renderList.splice(finalIndex, 0, gobj);
    };

    GSP.AutoplacementMetrics = {
      Measurement: {
        sketchLeftMargin: 10,
        sketchTopMargin: 5,
        gObjTopMargin: 1,
        rightIsolation: 60,
        bottomIsolation: 20,
      },
      Button: {
        sketchLeftMargin: 10,
        sketchTopMargin: 5,
        gObjTopMargin: 3,
        rightIsolation: 50,
        bottomIsolation: 15,
      },
      Table: {
        sketchLeftMargin: 10,
        sketchTopMargin: 5,
        gObjTopMargin: 3,
        rightIsolation: 100,
        bottomIsolation: 120,
      },
    };
  })();

  /**
   * @fileOverview Main Document object representing a set of pages.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */

  /* global JSONcanonical */

  /**
   * Constructs a document and connects it to the specified HTML
   * element.
   * @constructor
   * @param {Element} node The jQuery element to attach to.
   * @param {object} spec  The JSON specification of the sketch.
   * @return {GSP.Sketch} a sketch object.
   */
  GSP.Document = (function(/** @lends GSP.Document */) {
    var docID = 1,
      DocumentPrototype,
      //
      // This is a simple, doubly-linked list implementation of
      // undo/redo history. The history of each page is represented as a
      // list of deltas against (an assumed) original page spec.
      //
      undoHistoryPrototype = {
        pushDelta: function(delta) {
          this.current.next = { delta: delta, prev: this.current, next: null };
          this.current = this.current.next;
        },

        replaceCurrentDelta: function(delta) {
          this.current.delta = delta;
        },

        undo: function(option) {
          // option is undefined for normal operation, "all" for "undo all."
          this.current = this.current.prev || this.current;
          if (option === 'all') {
            while (this.current.prev) {
              this.current = this.current.prev;
            }
          }
        },

        redo: function() {
          this.current = this.current.next || this.current;
        },

        canUndo: function() {
          return this.current.prev !== null;
        },

        canRedo: function() {
          return this.current.next !== null;
        },

        getCurrentDelta: function() {
          return this.current.delta;
        },
      },
      // Author Preferences can be of various types, which know how to parse strings.
      // Strings should always be parsed when setting prefs, so that parsing is not
      // required when reading them.

      // Boolean prefs apply to an entire sketch, and are either true or false.
      // The value returned by getExplictPref() is always a boolean true or false.
      // To set a BoolPrefType, you can set it either to a boolean (true or false),
      // or to a string ("true" or "false").
      BoolPrefType = {
        parse: function(raw) {
          if (typeof raw === 'string') return raw.toLowerCase() === 'true';
          else return typeof raw === 'boolean' && raw;
        },
      },
      // PageArrayPrefType determines which pages have a particular pref enabled.
      // The return value is a boolean that applies to the current page only
      // Default values are 'all', 'none', or a comma-delimited list of page numbers.
      // It's ok (though not recommended) to start and end the list with '[' and ']'.
      // To set a PageArrayPrefType: you can set it to either an array or a string.
      // Valid arrays are ["all"], ["none"], or an array of page numbers.
      // Valid strings are "all", "none", or a comma-delimited list of page numbers.
      // Note that the indices of the returned array are irrelevant. For instance,
      // if element #3 contains 5, the pref is enabled for page 5; it has no bearing on page 3.
      // Therefore use pages.includes (5) to determine whether page 5 is enabled.
      PageArrayPrefType = {
        parse: function(raw) {
          var pages, i;
          if (typeof raw === 'boolean') {
            return raw ? ['all'] : [];
          } else if (Array.isArray(raw)) {
            return raw;
          } else if (typeof raw !== 'string') {
            return [];
          } else {
            // it's a string
            if (raw[0] === '[' && raw[raw.length - 1] === ']') {
              // the string might be delimited by square brackets
              raw = raw.substring(1, raw.length - 1);
            }
            raw = raw.toLowerCase().replace(/\s/g, ''); // make lower case; remove spaces
            if (raw === 'all' || raw === 'true') {
              return ['all'];
            } else if (raw === 'none' || raw === 'false') {
              return [];
            }
            pages = raw.split(',');
            for (i = 0; i < pages.length; i += 1) {
              pages[i] = pages[i].toString(); // page id's are always strings
            }
            return pages;
          }
        },
      },
      ToolLookPrefType = {
        parse: function(raw) {
          raw = raw.toLowerCase();
          switch (raw) {
            case 'classic':
            case 'new':
            case 'compact':
              return raw;
          }
          return 'Invalid toolLook pref.';
        },
      },
      authorPreferenceSpecs = {
        // use lowercase identifiers so that user prefs are case-insensitive
        tool: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // tools appear on all pages by default
        },
        disablescrolling: {
          type: BoolPrefType,
          defaultValue: false,
        },
        sequentialsnapping: {
          type: BoolPrefType,
          defaultValue: true,
        },
        toolplaynewlook: {
          type: BoolPrefType,
          defaultValue: false,
        },
        removeinaccessibleobjects: {
          type: BoolPrefType,
          defaultValue: false,
        },
        pagecontrol: {
          type: BoolPrefType,
          defaultValue: true, // page controls should be true by default
        },
        enablelabeldragging: {
          type: BoolPrefType,
          defaultValue: true, // labelDragging should be true by default
        },
        enablelabelediting: {
          type: PageArrayPrefType,
          defaultValue: ['none'], // old-style (non-widget) label editing is off by default
        },
        enabletracing: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // enableTracing is true by default
        },
        stylewidget: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // all pages enable the style widget, because widgets are enabled only via an exporter checkbox; perhaps should be 'none' if widgets become integrated into main code.
        },
        visibilitywidget: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // all pages enable the visibility widget
        },
        labelwidget: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // all pages enable the label widget
        },
        tracewidget: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // all pages enable the trace widget
        },
        deletewidget: {
          type: PageArrayPrefType,
          defaultValue: ['none'], // no pages enable the delete widget (for compatibility with old sketches)
        },
        showwidgetpanelonpagestart: {
          type: BoolPrefType,
          defaultValue: true, // set true to show the widget panel on page start; otherwise user must tap the Widgets button to show it
        },
        uploadutil: {
          type: BoolPrefType, // may change if we allow uploading of pages rather than docs
          defaultValue: false, // all pages enable the upload command in the utility menu
        },
        downloadutil: {
          type: BoolPrefType, // may change if we allow downloading of pages rather than docs
          defaultValue: false, // all pages enable the download command in the utility menu
        },
        resetbutton: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // include a reset button beneath the sketch
        },
        wsplogo: {
          type: BoolPrefType,
          defaultValue: true, // include a Web Sketchpad logo beneath the sketch
        },
        animatetoolmatching: {
          type: BoolPrefType,
          defaultValue: true, // animated matching should be true by default
        },
        toollook: {
          type: ToolLookPrefType,
          defaultValue: 'compact',
        },
        enabledragmerging: {
          type: PageArrayPrefType,
          defaultValue: ['all'], // drag merging should be on by default
        },
        undoredoinbuttonbar: {
          type: PageArrayPrefType,
          defaultValue: ['none'], // none until we vet the UI.
        },
      };

    function makeUndoHistory() {
      var ret = Object.create(undoHistoryPrototype);
      ret.current = { delta: null, prev: null, next: null };
      return ret;
    }

    DocumentPrototype = {
      // given a DOM node where the document will live,
      // attach ourselves to it.
      attachToNode: function(node) {
        var versionCSS = 'wsp-version-4-8-0',
          $node = $(node),
          self = this,
          docWidth = self.docSpec.metadata.width,
          docHeight = self.docSpec.metadata.height,
          $baseNode = $(
            '<div class="wsp-base-node ' +
              versionCSS +
              '">' +
              '<div class="wsp-transform-node"><div class="wsp-main-row wsp-clearfix-group"></div></div>' +
              '<div class="wsp-transform-large"></div>' +
              '<div class="wsp-transform-medium"></div>' +
              '<div class="wsp-transform-small"></div>' +
              '</div>'
          ),
          $mainRowNode,
          $buttonArea = $node.parent().find('.button_area'),
          nodeCSS = {},
          undoRedoBelow = this.focusPage.getAuthorPreference(
            'undoRedoInButtonBar'
          );

        $node.empty().append($baseNode);
        $node.append(
          $(
            '<div class="wsp-live-node wsp-sr-only" role="log" aria-live="polite"></div>'
          )
        );
        $mainRowNode = $('.wsp-main-row', $baseNode[0]);

        if (this.hasTools()) {
          self.removeUndoRedo($buttonArea); // remove any stand-alone undo/redo, as it should be in the toolbox.
          self.attachToolsToNode(
            $mainRowNode,
            docWidth,
            docHeight,
            true /* shows undoRedo */
          );
          // we have not yet added the sketch, so current
          // width is tools only.
          docWidth += $mainRowNode.outerWidth();
        } else if (
          this.focusPage.getAuthorPreference('enableDragMerging') &&
          undoRedoBelow &&
          $buttonArea &&
          $buttonArea.length
        ) {
          // Put undo/redo in the button_area.
          self.attachUndoRedo($buttonArea);
        }
        $mainRowNode.append(
          $(
            '<div role="application" class="wsp-sketch-container" aria-label="Use arrow keys to move all objects in 4 directions."></div>'
          )
        );

        $('.wsp-transform-large', $baseNode[0]).css({
          width: docWidth,
          height: docHeight,
        });
        $('.wsp-transform-medium', $baseNode[0]).css({
          width: docWidth * 0.75,
          height: docHeight * 0.75,
        });
        $('.wsp-transform-small', $baseNode[0]).css({
          width: docWidth * 0.5,
          height: docHeight * 0.5,
        });

        if (this.docOptions.responsiveSizing === true) {
          $baseNode.addClass('wsp-responsiveSizing');

          // css provides support for 2 breaks (size change at different window width
          // and two sizes.

          if (docWidth > 400) {
            // [400, inf]
            // Medium break -> medium size; small break -> small size
            $baseNode.addClass('wsp-responsiveSizing-medium-break');
            $baseNode.addClass('wsp-responsiveSizing-medium-size');
            $baseNode.addClass('wsp-responsiveSizing-small-break');
            $baseNode.addClass('wsp-responsiveSizing-small-size');
          } else if (docWidth > 300) {
            // (300,400]
            // Small break -> medium size
            $baseNode.addClass('wsp-responsiveSizing-medium-size');
            $baseNode.addClass('wsp-responsiveSizing-small-break');
          }
          // [0,300] no size change
        }

        // block divs will be default set from block to inline-block,
        // so that the expected behavior of node -> sketch content size prevails.
        if (this.docOptions.sizeParentToContent) {
          if (
            $node.prop('nodeName').toLowerCase() === 'div' &&
            $node.css('display') === 'block'
          ) {
            nodeCSS.display = 'inline-block';
          }
        }
        $node.css(nodeCSS);

        this.canvasNode = $node;
        this.eventEmitter = GSP.EventEmitter(this.canvasNode);
      },

      /**
       * Notify client/container that a particular event has occurred.  This is the method that should
       * be called when events happen, in order to trigger the eventApi to officially "trigger" that
       * event for listeners.
       *
       * The page id(index) is returned to the event listener as context.document.focusPage.id if
       * you want to only execute code on specific pages.
       *
       * @param  {String}  message -- event name, e.g. 'DidChangeCurrentPage'
       * @param  {Object}  context -- additional arguments to be passed along to handler
       * @param  {Object}  attributes -- additional arguments to be passed along to handler
       */
      event: function(message, context, attributes) {
        context = context || {};
        context.document = this;

        this.eventEmitter.trigger(message, context, attributes);
      },

      /**
       *  Get the current active page
       */
      getFocusPage: function() {
        return this.focusPage;
      },

      /**
       *  Returns the number of pages in the document
       */
      getPageCount: function() {
        return this.docSpec.pages.length;
      },
      getCurrentPageSpec: function(iPageId) {
        var pageSpec = $.extend(true, {}, this.getOrigPageSpec(iPageId)),
          pageDiff = this.getPageDeltaObj(iPageId);

        if (pageDiff && !$.isEmptyObject(pageSpec)) {
          GSP.applySketchDiff(pageSpec, pageDiff);
        }

        return pageSpec;
      },
      /**
       *  Fetch the JSON object specification for the given page ID
       */
      getOrigPageSpec: function(pageId) {
        if (undefined === pageId) {
          pageId = this.docSpec.metadata['start-page'];
          if (undefined === pageId || this.getIndexForPageId(pageId) === null) {
            pageId = this.docSpec.pages[0].metadata.id;
          }
        }
        if (this.pageData[pageId] === undefined) {
          GSP.signalErrorWithCode('GSP.Error.invalidSwitchPage');
          return null;
        } else {
          return this.pageData[pageId].spec;
        }
      },
      getPageIdAtIndex: function(iIndex) {
        if (iIndex < 0 || iIndex >= this.docSpec.pages.length) {
          return null;
        }

        var pageSpec = this.docSpec.pages[iIndex],
          pageId =
            pageSpec && pageSpec.metadata && pageSpec.metadata.id !== null
              ? pageSpec.metadata.id
              : String(iIndex + 1);
        return pageId;
      },

      // Given iPageId, find the index of the page with this id in docSpec.pages[]
      // The input (iPageId) is a string; the output is a numeric index into the array
      getIndexForPageId: function(iPageId) {
        if (this.docSpec.pages) {
          var pageSpec, pageIndex, pageId;
          for (
            pageIndex = 0;
            pageIndex < this.docSpec.pages.length;
            pageIndex++
          ) {
            pageSpec = this.docSpec.pages[pageIndex];
            pageId = GSP._get(pageSpec, 'metadata,id');
            if (pageId === undefined) {
              pageId = String(pageIndex + 1);
            }
            if (pageId === iPageId) {
              return pageIndex;
            }
          }
        }
        return null;
      },

      /**
       * Creates an event handlers object which will store registered handlers for gobjects.  These
       * handlers will not be destroyed on page switching.
       *
       * @param {object} sketch
       */
      createSketchEventHandlersForPage: function(sketch) {
        var pageId = sketch.getPageId(),
          document = this;
        this.gobjectEventHandlers[pageId] = new GSP.SketchEventHandler(function(
          event
        ) {
          var singleTarget,
            currentSketch = document.getFocusPage();

          if (currentSketch.getPageId() !== pageId) {
            throw GSP.createError('Event generated by an unexpected page');
          }

          // if the map has exactly one key, return that. Otherwise undefined.
          function singleKey(map) {
            var id,
              counter = 0,
              ret;
            for (id in map) {
              if (map.hasOwnProperty(id)) {
                if (counter !== 0) {
                  ret = undefined;
                  break;
                }
                counter++;
                ret = id;
              }
            }

            return ret;
          }

          // If there is only one target in the target map, augment the event
          // with a target field which is the gobject itself (rather than the gobject id).
          singleTarget = singleKey(event.targetMap);
          if (singleTarget) {
            event.target = currentSketch.gobjList.gobjects[singleTarget];
          }
        });
      },

      /**
       * Bind the given set of gobjects to a handler(event) callback
       *
       * You can unbind the handler with unbindGObjEvent() q.v.
       *
       * @param {number} the sketch page index
       * @param {array|string} id list of GObject id's to monitor (a single id is also allowed)
       * @param {string} eventType name of event type the will bound
       * @param {function} handler(event) Event handler callback.
       */
      bindGObjEvent: function(pageId, id, eventType, handler) {
        this.gobjectEventHandlers[pageId].addHandler(id, eventType, handler);
      },

      /**
       * Unbind the given set of gobjects from the given handler(event) callback
       * Parameters to unbindGObjEvent() should match the corresponding original call to bindGObjEvent
       *
       * @param {number} the sketch page index
       * @param {array|string} id list of GObject id's to monitor (a single id is also allowed)
       * @param {string} eventType name of event type the will bound
       * @param {function} handler(event) Event handler callback.
       */
      unbindGObjEvent: function(pageId, id, eventType, handler) {
        this.gobjectEventHandlers[pageId].removeHandler(id, eventType, handler);
      },

      /**
       * Triggers a sketch/gobject event to be triggered.
       *
       * @param pageId
       * @param gobjId
       * @param eventType
       */
      raiseSketchEvent: function(iPageId, gobjId, eventType) {
        var sketchEventHandler = this.gobjectEventHandlers[iPageId],
          document = this,
          curSketch = this.focusPage;

        if (iPageId !== curSketch.metadata.id) {
          throw GSP.createError(
            'Document.raiseSketchEvent() can only raise events for the active page'
          );
        }

        sketchEventHandler.raiseSketchEvent(gobjId, eventType);

        //If we haven't cued a job to process the sketch events, do it now.  This
        //guarantees that the processing of events happens at a point in time when
        //the sketch is stable.
        if (!GSP.JobScheduler.isActive(sketchEventHandler.processEventsJob)) {
          sketchEventHandler.processEventsJob = curSketch.jobScheduler.addJob(
            function() {
              document.processSketchEvents(iPageId);
              sketchEventHandler.processEventsJob = null;
            },
            { priority: 'preprocess' }
          );
        }
      },

      /**
       * Fires off the gobject event handler process sketch events for
       * the specified page.
       *
       * @param {string} iPageId
       */
      processSketchEvents: function(iPageId) {
        var eventHandler = this.gobjectEventHandlers[iPageId],
          frameIndex = eventHandler.getFrameIndex();

        if (eventHandler.hasSketchEvents()) {
          this.focusPage.event(
            'StartSketchFrame',
            {},
            { frameIndex: frameIndex }
          );

          eventHandler.processSketchEvents();

          this.focusPage.event(
            'EndSketchFrame',
            {},
            { frameIndex: frameIndex }
          );
        }
      },

      /**
       * Wrapper function to test whether the loaded page has already been loaded.  If
       * it has, then do not fire off this event because this should only be fired the
       * first time a page is loaded.
       */
      triggerLoadPage: function() {
        var pageId = this.getActivePageId();
        if (!this.cacheSketchPagesLoaded[pageId]) {
          this.event(
            'LoadPage',
            { document: this, sQuery: this.focusPage.sQuery },
            { pageId: pageId }
          );
        }
        this.cacheSketchPagesLoaded[pageId] = true;
      },

      /**
       * Triggers the post-focus page changed event.
       *
       * @param previousPageId
       */
      triggerDidChangeCurrentPage: function(oldPageId) {
        this.event(
          'DidChangeCurrentPage',
          { document: this, sQuery: this.focusPage.sQuery },
          { oldPageId: oldPageId, pageId: this.getActivePageId() }
        );
      },

      /**
       * Triggers an event to signify that the focus page will change.
       *
       * @param newPageId
       */
      triggerWillChangeCurrentPage: function(newPageId) {
        var pageId = this.focusPage ? this.getActivePageId() : null;
        this.event(
          'WillChangeCurrentPage',
          { document: this },
          { pageId: pageId, newPageId: newPageId }
        );
      },

      /**
       * Reset the stored session state of each page.
       * This means that the state of the document
       * is the same as when the document was created.
       */
      resetPageSessions: function() {
        var k;
        for (k in this.pageData) {
          if (this.pageData.hasOwnProperty(k)) {
            this.resetSession(k);
          }
        }
      },

      getInitialPageId: function() {
        return this.docSpec.metadata['start-page'];
      },
      isInitialPage: function(pageId) {
        return pageId === this.getInitialPageId();
      },
      getActivePageId: function() {
        return this.focusPage.metadata.id;
      },
      isOnInitialPage: function() {
        return this.isInitialPage(this.getActivePageId());
      },

      /**
       * Reset the whole document to its original spec
       *
       * This is an external API: documentation/Document/document.html
       */
      resetDocument: function() {
        this.resetPageSessions();

        // If we're on the initial page, use an empty delta to reconstitute it.
        if (this.isOnInitialPage()) {
          this.applyDeltaToActivePage(null);
        } else {
          // Otherwise, just switch.
          this.switchPage(
            this.getInitialPageId(),
            true /* suppressPageDelta */
          );
        }
      },

      /**
       * Reset the active page to its original spec
       *
       * This is an external API: documentation/Document/document.html
       */
      resetActivePage: function() {
        // First reset the session, ensuring that undo/redo button states will be clean.
        this.resetSession(this.getActivePageId());
        this.applyDeltaToActivePage(null);
      },

      /**
       * Given a Sketch delta object, apply it to the current focused sketch page.
       *
       * Do not call when switching pages. Use switchPage for that.
       *
       * @param delta - sketch delta object
       */
      applyDeltaToActivePage: function(delta, mode) {
        //This works by reinstantiating the sketch with the delta applied.
        //Since this is not ideal, and there may be more elegant API in the future,
        //the implementation is largely a cut-paste job of code found in switchPage.
        var activePageId = this.getActivePageId();

        this.stopCurrentFocusedSketch();
        this.setPageDeltaObj(activePageId, delta);
        this.focusPage = null;
        var pageSpec = this.getCurrentPageSpec(activePageId);

        this.focusPage = GSP.Sketch(this, pageSpec, this.docOptions);
        this.focusPage.attachToNode(this.canvasNode);
        this.triggerLoadPage(activePageId);
        // This is NOT a page switch.
        this.startCurrentFocusedSketch(mode);
        // update sQuery property to point to current(new) page
        this.sQuery = this.focusPage.sQuery;
      },

      /**
       *  Attempt to switch to the page with the given pageId
       *
       *  @param {string} iPageId
       *  @param {boolean} suppressPageDelta - pass true if you don't
       * want to capture current page state as you leave the page,
       * probably because you have just modified the pageData states.
       */
      switchPage: function(iPageId, suppressPageDelta) {
        var oldSketch = this.focusPage,
          oldPageId = oldSketch.metadata.id,
          newPageId = iPageId,
          newPageSpec;

        // Bail if there's nothing to do
        if (newPageId === oldPageId) return;

        //Remove any in progress touch modality before capturing the delta
        while (oldSketch.hasTouchRegimes()) {
          oldSketch.popTouchRegime();
        }
        this.triggerWillChangeCurrentPage(newPageId);
        if (!suppressPageDelta) {
          this.recordActivePageDelta();
        }

        // Always use the current version of the new page: never supress
        // its state delta.
        newPageSpec = this.getCurrentPageSpec(newPageId);

        this.stopCurrentFocusedSketch();
        this.focusPage = GSP.Sketch(this, newPageSpec, this.docOptions);
        this.focusPage.attachToNode(this.canvasNode);
        this.triggerLoadPage(iPageId);

        this.metadata['start-page'] = newPageId;

        this.startCurrentFocusedSketch('pageSwitch');
        // update sQuery property to point to current(new) page
        this.sQuery = this.focusPage.sQuery;
        this.triggerDidChangeCurrentPage(oldPageId);
      },

      /**
       * Starts the current sketch that is set to the focus page.
       * mode is "pageSwitch", "undoRedo", or "toolDone"
       */
      startCurrentFocusedSketch: function(mode) {
        this.focusPage.start(mode);
        this.setUndoButtonStates();
        this.event(
          'StartCurrentPage',
          { document: this, sQuery: this.focusPage.sQuery },
          { pageId: this.getActivePageId() }
        );
      },

      /**
       * Stops the current sketch that is set to the focus page.
       */
      stopCurrentFocusedSketch: function() {
        this.event(
          'StopCurrentPage',
          { document: this },
          { pageId: this.getActivePageId() }
        );
        this.focusPage.stop();
      },

      /**
       * Starts the document.
       *
       */
      start: function() {
        this.startCurrentFocusedSketch();
      },

      /**
       * Stops the document and cleans up resources.
       */
      stop: function() {
        this.stopCurrentFocusedSketch();
        this.cleanUp();
      },

      /**
       * Cleanup and remove document resources in preparation for the
       * document going away. Internal method - assumes e.g. current page
       * is already cleaned up.
       */
      cleanUp: function() {
        // Currently we assume garbage collection will handle any needed cleanup.
        this.event('UnloadDocument', { document: this }, {});
      },
      recordActivePageDelta: function() {
        var curPage = this.getFocusPage(),
          curPageId = curPage && curPage.metadata.id,
          pageSpec = this.getOrigPageSpec(curPageId),
          pageDelta = GSP.getSketchDiff(pageSpec, curPage.toSpecObj());

        this.setCurrentPageDelta(pageDelta);
      },
      /**
        Returns the delta object for the specified page.
        This will be computed live for the current page, or
        returned from the set of saved page deltas for other pages.
        @param  {String}  iPageId - the ID of the page whose delta is to be returned
        @returns {Object} the delta object for the specified page
       */
      getPageDeltaObj: function(iPageId) {
        var currPage = this.getFocusPage(),
          currPageId = currPage && currPage.metadata.id,
          pageDelta,
          pageSpec;
        if (iPageId === currPageId) {
          // compute the delta for the current page
          pageSpec = this.getOrigPageSpec(currPageId);
          pageDelta = GSP.getSketchDiff(pageSpec, currPage.toSpecObj());
        } else {
          pageDelta = this._getPageDeltaObj(iPageId) || null;
        }
        return pageDelta;
      },
      /**
       * Returns the Object form of the document spec in its current state.
       *
       * @returns {Object} Document Spec
       */
      getCurrentSpecObject: function() {
        var docSpec = $.extend(true, {}, this.docSpec),
          pageIndex;

        // apply any local metadata changes (e.g. 'start-page')
        $.extend(true, docSpec.metadata, this.metadata);

        // Loop through the pages of the document spec
        for (pageIndex = 0; pageIndex < docSpec.pages.length; ++pageIndex) {
          docSpec.pages[pageIndex] = this.getCurrentPageSpec(
            this.getPageIdAtIndex(pageIndex)
          );
        }
        return docSpec;
      },
      /**
        Returns a JSON string representing the complete current state
        of the document. Clients may use this if they'd rather deal
        with complete documents than original documents plus deltas.
  
        @returns  {String}  the JSON representation of the document
       */
      getDocumentJSON: function() {
        return JSONcanonical.stringify(this.getCurrentSpecObject());
      },

      /**
        Returns a document-wide delta representing the differences between
        the current state of the document and the original specification of
        the document, including the differences for each page of multipage
        documents.
        @returns  {String}  a JSON representation of the document deltas
       */
      getDocumentDelta: function() {
        var diffObj = GSP.getDocumentDiff(
          this.docSpec,
          this.getCurrentSpecObject()
        );

        return JSONcanonical.stringify(diffObj);
      },

      // Applies a document delta (unparsed string or parsed object).
      //
      // This does not start a page or switch pages, so it can be called
      // BEFORE starting a document; It should not be called directly,
      // but invoked by passing a documentDelta option to the Document
      // constructor, or a delta option to the Runner's $.WSP plugin. If
      // you need to apply a delta to a document that is already
      // started, use applyDocumentDelta.
      _applyDocumentDelta: function(iDocDelta) {
        var diff, i, pageId, pageDiff;

        try {
          switch (typeof iDocDelta) {
            case 'string':
              diff = JSON.parse(iDocDelta);
              break;
            case 'object':
              diff = iDocDelta;
              break;
            default:
              throw GSP.createError('invalid doc delta');
          }
        } catch (e) {
          e.code = 'GSP.Error.invalidDocDelta';
          GSP.signalCaughtError(e);
        }
        if (!diff || !diff.pageDiffs) return;

        this.initMetadata();
        GSP.diffPatch.patch(this.metadata, diff.metadataDiff);

        //
        // Apply any page diffs to our internal pageData map
        //
        for (i = 0; i < diff.pageDiffs.length; i++) {
          pageDiff = diff.pageDiffs[i];
          // pagedata is indexed by page id, not index
          pageId = this.getPageIdAtIndex(i);
          this.setPageDeltaObj(pageId, pageDiff || null);
        }
      },

      // To be called on an already-started document
      applyDocumentDelta: function(iDocDelta) {
        var currentPageId = this.getFocusPage().metadata.id,
          startPageId;

        this._applyDocumentDelta(iDocDelta);

        startPageId = this.metadata['start-page'];

        if (startPageId !== currentPageId) {
          this.switchPage(startPageId, true);
        } else {
          this.applyDeltaToActivePage(this._getPageDeltaObj(startPageId));
        }
      },

      initMetadata: function() {
        this.metadata = $.extend(true, {}, this.docSpec.metadata);
      },

      cleanPrefName: function(prefName) {
        // pref keys are lower case with no spaces
        return prefName.toLowerCase().replace(/\s/g, '');
      },

      prefSpecFromName: function(prefName) {
        // All tool prefs use the tool spec.
        return authorPreferenceSpecs[
          prefName.match(/tool$/) ? 'tool' : prefName
        ];
      },

      getAuthorPreference: function(iPrefName, optionalCurPageId) {
        // Returns the author preference: a boolean, a string, or a pageArray.
        // For a pageArray, if an optionalCurPage is provided, return true if that page is in the array.
        // If optionalCurPage is not provided, returns the value for the current page.
        // We now standardize metadata.authorPreferences by parsing values before storing them.
        // Thus we no longer need to check values by parsing them when a caller gets them.

        var prefName = this.cleanPrefName(iPrefName),
          prefSpec = this.prefSpecFromName(prefName),
          curPage,
          prefType,
          prefDefaultValue,
          explicitPref, // overrides the default
          webPagePref, // overrides default or explicit
          webPageGetter,
          value,
          trueValues = ['true', 'all', true];

        if (!prefSpec) throw GSP.createError('unknown author preference');
        curPage = optionalCurPageId || GSP._get(this, 'focusPage.metadata.id');
        if (!curPage)
          throw GSP.createError(
            'getAuthorPreference called with no sketch page available'
          );
        prefType = prefSpec.type;
        if (!prefType) throw GSP.createError('Bad author preference type');
        prefDefaultValue = prefSpec.defaultValue;
        if (prefDefaultValue === undefined)
          throw GSP.createError('Bad author preference default');
        if (prefSpec.type.parse(prefDefaultValue) !== prefDefaultValue)
          throw GSP.createError('Bad author preference default');
        explicitPref = this.getExplicitPref(prefName);
        value = explicitPref.exists ? explicitPref.value : prefDefaultValue;
        webPageGetter = GSP._get(window, 'WSP.PREF.getWebPagePref');
        if (webPageGetter) {
          webPagePref =
            webPageGetter &&
            webPageGetter(this, prefName, '', optionalCurPageId);
          if (webPagePref !== undefined) {
            value = webPagePref;
          }
        }
        if (prefType === PageArrayPrefType) {
          if (Array.isArray(value)) {
            return value.indexOf(curPage) >= 0 || trueValues.includes(value[0]);
          } else {
            // not an array, although it should be, so log and fall through
            console.log(
              'getAuthorPreference() did not find an array for iPrefName'
            );
          }
        }
        return trueValues.includes(value);
      },

      // prefName: the name of an authorPref. (We depend on cleanPrefs() to have cleaned the sketch's prefs)
      // spec: the authorPreferenceSpec for this pref.
      // Return value is an object: {exists: boolean, value: current pref value}
      // If exists is false, the returned value is the default value for this pref.
      getExplicitPref: function(prefName) {
        var key,
          test,
          retVal,
          spec = this.prefSpecFromName(prefName),
          authorPrefs = this.metadata.authorPreferences;

        // Do some error checking to determine whether such a pref exists and
        // to determine whether its value is of an appropriate type.
        // ALSO CHECK TO MAKE SURE THE PREF IS ALREADY PARSED.
        // (All keys in authorPreferences should be lower-case without spaces,
        // as should the sketch metadata keys.
        for (key in authorPrefs) {
          test = key.toLowerCase().replace(/\s/g, '');
          if (test !== key) {
            console.log(
              'Stored key ' + key + " doesn't match parsed key " + test
            );
          }
          if (test === prefName) {
            retVal = spec.type.parse(authorPrefs[key]);
            if (retVal !== authorPrefs[key]) {
              console.log(
                'Stored authorPrefs[' + key + "] doesn't match parsed value."
              );
            }
            return { exists: true, value: retVal };
          }
        }
        return { exists: false };
      },

      authorPreferenceIsExplicitlySet: function(prefName) {
        var authorPrefs = this.metadata.authorPreferences;
        return (
          authorPrefs && authorPrefs[this.cleanPrefName(prefName)] !== undefined
        );
      },

      setLocale: function(locale) {
        // If a locale is passed, use it; otherwise sniff the browser
        var numberWithDecimalSeparator = 1.1,
          decimalSeparator;

        function getDecimalSeparator(locale) {
          if (!window.Intl) {
            return '.';
          }
          return window.Intl.NumberFormat(locale)
            .formatToParts(numberWithDecimalSeparator)
            .find(function(part) {
              return part.type === 'decimal';
            }).value;
        }

        function sniffBrowser() {
          return /^1(.+)1$/.exec(
            numberWithDecimalSeparator.toLocaleString()
          )[1];
        }

        if (locale) {
          decimalSeparator = getDecimalSeparator(locale);
        } else {
          decimalSeparator = sniffBrowser();
        }

        this.formatOptions.decimalSeparator = decimalSeparator;
        // listSeparator is not formally defined, but generally speaking
        // it's a comma, unless the decimalSeparator is a comma. Then, it's a semicolon.
        this.formatOptions.listSeparator = decimalSeparator === '.' ? ',' : ';';
      },

      /**
       *  Model level init for document
       */
      initModel: function(docSpec, options) {
        var pageIndex, pageId, pageSpec;

        function cleanPrefs() {
          // clean the names and values of the docSpec's author prefs
          var prefs = docSpec.metadata.authorPreferences;
          if (prefs) {
            $.each(prefs, function(oldKey, oldValue) {
              // lowercase and strip spaces from the key
              var newKey, prefSpec, isToolPref;
              newKey = oldKey.toLowerCase().replace(/\s/g, '');
              if (newKey !== oldKey) {
                prefs[newKey] = oldValue;
                delete prefs[oldKey];
              }
              isToolPref = newKey.match(/tool$/);
              prefSpec = authorPreferenceSpecs[isToolPref ? 'tool' : newKey];
              // Make sure prefSpec exists; for instance, 'widgets' might be an authorPref, but only individual widgets have prefSpecs
              if (prefSpec && prefSpec.type.parse) {
                prefs[newKey] = prefSpec.type.parse(oldValue);
              }
            });
          }
        }

        cleanPrefs();
        this.docSpec = docSpec;
        this.initMetadata();
        // Shallow copy of resources so as not to duplicate resource data
        this.resources = docSpec.resources || {};
        this.docOptions = options || {};
        this.formatOptions = {
          decimalSeparator: '.',
          listSeparator: ',',
        };

        this.setLocale(this.docOptions.locale);

        this.pageData = {};
        if (docSpec.pages) {
          for (pageIndex = 0; pageIndex < docSpec.pages.length; pageIndex++) {
            pageSpec = docSpec.pages[pageIndex];
            pageId =
              pageSpec && pageSpec.metadata && pageSpec.metadata.id != null
                ? pageSpec.metadata.id
                : String(pageIndex + 1);

            pageSpec.metadata.id = pageId;

            this.pageData[pageId] = { spec: pageSpec };
            this.resetSession(pageId);
          }
        }

        if (docSpec.tools) {
          this.addTools(docSpec.tools);
        }
      },

      /**
       * addTools creates tools from the passed in spec.  If no spec is passed in, it acts on its own
       * spec (essentially reinstantiating its tools. Useful, for instance, during
       * page switch)
       *
       * Note that this only creates the model level of the tools. For instantiating the UI
       * see attachToolsToNode()
       *
       * @param {object} spec - optional
       */
      addTools: function(specTools) {
        var document = this;

        if (!document.tools) {
          document.tools = [];
        }

        specTools.forEach(function(tool) {
          document.tools.push(GSP.Tool.createWithSpec(tool));
        });
      },
      hasTools: function() {
        return this.tools && this.tools.length > 0;
      },

      getPageData: function(pageId) {
        return this.pageData[pageId];
      },
      getPageSession: function(pageId) {
        return this.getPageData(pageId).session;
      },
      _getPageDeltaObj: function(pageId) {
        return this.getPageSession(pageId).delta;
      },

      setPageDeltaObj: function(pageId, delta) {
        this.getPageSession(pageId).delta = delta;
      },

      getCurrentPageData: function() {
        var currentPageId = this.getFocusPage().metadata.id;
        return this.getPageData(currentPageId);
      },
      getCurrentPageSession: function() {
        return this.getCurrentPageData().session;
      },
      getCurrentPageHistory: function() {
        return this.getCurrentPageSession().history;
      },
      getCurrentPageDelta: function() {
        return this.getCurrentPageSession().delta;
      },
      setCurrentPageDelta: function(delta) {
        this.getCurrentPageSession().delta = delta;
      },

      resetSession: function(iPageId) {
        this.pageData[iPageId].session = {
          delta: null,
          history: makeUndoHistory(),
        };
      },

      //
      // We are about to play a tool, or invoke undo or redo. If
      // anything has changed since the last time we took a snapshot, we
      // remember those changes as a delta. In the case of toolplay,
      // once the tool completes, we will save this delta AND THEN the
      // delta for the completed tool. The first will be the undo
      // target, and the second will be the redo target starting from
      // that undo. If there is no recentChangesDelta now, then we already
      // have a sufficient undo target: either a played tool or an
      // original page.
      //
      // For undo/redo, this delta simply replaces the current history
      // delta, and then we perform the undo or redo, so as to remember
      // any changes made since the last snapshot.
      getRecentChangesDelta: function() {
        var currentPageId = this.getFocusPage().metadata.id,
          pageDelta,
          baseState;

        // Get the page version corresponding to: 1) the end of the
        // latest tool snapshot or 2) if no tools have run, then the
        // original state of the sketch.
        baseState = $.extend(true, {}, this.getOrigPageSpec(currentPageId));
        // Although this is the "current" delta, subsequent changes may
        // have been made to the sketch.
        pageDelta = this.getCurrentPageHistory().getCurrentDelta();
        if (pageDelta) {
          GSP.applySketchDiff(baseState, pageDelta);
        }

        // We'll need to remember the delta if there's been any
        // activity since then.
        pageDelta = GSP.getSketchDiff(
          baseState,
          this.getFocusPage().toSpecObj()
        );
        if (pageDelta && pageDelta.diff) {
          return this.getPageDeltaObj(currentPageId);
        }

        // Avoid storing consecutive, equivalent deltas.
        return null;
      },

      //
      // Update the current undo delta to include any changes since the last snapshot.
      //
      updateCurrentDelta: function() {
        var newDelta = this.getRecentChangesDelta();
        if (newDelta) {
          this.getCurrentPageHistory().replaceCurrentDelta(newDelta);
        }
      },

      //
      // A tool has been played or objects deleted. Push the preOpDelta (if any)
      // and then push the completed op delta.
      //
      pushConfirmedSketchOpDelta: function(preOpDelta) {
        var currentPageId = this.getFocusPage().metadata.id;
        var history = this.getCurrentPageHistory();
        if (preOpDelta && history.current.prev) {
          // pop off the last completed undo/redo op (toolplay or gobj-deletion).
          // Replace it with the potentially more expansive: last undo-redo
          // op + any subsequent non-toolplay changes (e.g. position changes)
          history.undo();
          history.pushDelta(preOpDelta);
        }
        var delta = this.getPageDeltaObj(currentPageId);
        history.pushDelta(delta);
        return delta; // Allow caller to refer to delta in ToolPlayed event
      },

      undo: function(option) {
        // option is undefined for normal operation, "all" for "undo all."
        var history, delta;

        if (option !== 'all' && !this.canUndo()) {
          return;
        }
        this.getFocusPage().event(
          'WillUndoRedo',
          {},
          {
            type: 'undo',
            context: 'toolplay',
          }
        );
        this.updateCurrentDelta();
        history = this.getCurrentPageHistory();
        history.undo(option);

        delta = option === 'all' ? null : history.getCurrentDelta();
        this.applyDeltaToActivePage(delta, 'undoRedo');
        this.setUndoButtonStates();

        this.getFocusPage().event(
          'UndoRedo',
          {},
          {
            type: 'undo',
            context: 'toolplay',
            delta: delta,
          }
        );
      },
      isCurrentlyInToolplay: function() {
        var toolController = this.focusPage && this.focusPage.toolController;
        return Boolean(toolController && toolController.activeTool);
      },
      // Either toolplay was entered/left, or a modal dialog went up or down
      changedUIMode: function() {
        this.setUndoButtonStates();
      },
      undoRedoAllowedByRegime: function() {
        return (
          !this.isCurrentlyInToolplay() &&
          !this.focusPage.touchRegimeBlocksOtherButtons()
        );
      },
      canUndo: function() {
        return (
          this.undoRedoAllowedByRegime() &&
          this.getCurrentPageHistory().canUndo()
        );
      },
      canRedo: function() {
        return (
          this.undoRedoAllowedByRegime() &&
          this.getCurrentPageHistory().canRedo()
        );
      },
      redo: function() {
        var history, delta;

        if (!this.canRedo()) {
          return;
        }
        this.getFocusPage().event(
          'WillUndoRedo',
          {},
          {
            type: 'redo',
            context: 'toolplay',
          }
        );
        this.updateCurrentDelta();
        history = this.getCurrentPageHistory();
        history.redo();

        delta = history.getCurrentDelta();
        this.applyDeltaToActivePage(delta, 'undoRedo');
        this.setUndoButtonStates();

        this.getFocusPage().event(
          'UndoRedo',
          {},
          {
            type: 'redo',
            context: 'toolplay',
            delta: delta,
          }
        );
      },
      setUndoButtonStates: function() {
        var $undoRedo,
          canUndo = this.canUndo(),
          canRedo = this.canRedo();
        if (this.hasTools()) {
          $undoRedo = $('.wsp-undo-redo', this.canvasNode);
          $undoRedo.toggleClass('wsp-undo-disabled', !canUndo);
          $undoRedo.toggleClass('wsp-redo-disabled', !canRedo);
        } else if (this.focusPage.getAuthorPreference('undoRedoInButtonBar')) {
          $undoRedo = this.canvasNode.parent().find('.wsp-undo-redo-container');
          $undoRedo.find('.wsp-undo-button').css('opacity', canUndo ? 1 : 0.3);
          $undoRedo.find('.wsp-redo-button').css('opacity', canRedo ? 1 : 0.3);
        }
      },

      /**
       * attachUndoRedo creates undo/redo buttons for sketches without tools.
       * This is required for drag merge; otherwise the user has no way to undo a merge.
       *
       * @param {object} node - node that receives the undo/redo buttons
       */
      attachUndoRedo: function($node) {
        var undoRedoButtons,
          undoImg =
            '<img width="20" height="20" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAACEZVhJZk1NACoAAAAIAAYBBgADAAAAAQACAAABEgADAAAAAQABAAABGgAFAAAAAQAAAFYBGwAFAAAAAQAAAF4BKAADAAAAAQACAACHaQAEAAAAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQACoAIABAAAAAEAAAAWoAMABAAAAAEAAAAWAAAAAI8BckgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAK0aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KEb7JgwAAAe9JREFUOBHtVMtKw1AQTZqkIS12IVUqdCUIoriQ7sSFgiDqrujKvxDcuNGdIIJf4g/4AYK/oCtBcFGwahDamIfnpHeSW9q0uO/AdObO49yZuZMaxozUBEzIEjieMBHG6JzgTJ6Uk8FZmZYrvNDOjyMaL6OfcoQsz/O2wzB8hYdBrEISIp5brZbj+/6q4zibpVJpHfFLYLPf73dVPESWS31Apml2Lcs6VEdX7LVabcW27Tv4X8ARONHYR86T67pn9Xp9TuUMd43gbyYAZF9Ay+XyFWyhBhRD72nn9BLEU36hg2OVy/Glo4Hd7OBQB8cIaKPF0yiKTmBnbAjmQzk8gD7Bj6j2GbKXJMkieCeO42UUcxsEwTnsg2UAwAdYb5M6q2WVUnWAxItGo7GAxBGqVqt7iH1D19fKaRswCDDnKCzglO9I3NDQOEs+tHDmQux9pVI5Sg0aMCuUykX3NVA+bDqfDClXZFQGNuey2Wx6esUCRvBfXoLWblRuJcco1NiBwW3CW20VAcslP9q2ZFUVQquO8B5rBO6oEbBKPpZwoOwhwHcV2PCujt6QjgpVzxNYAGS+YyVWrK1wuE4TiV+ria/nALtYxgXyOUsS95cUwe/B72PHHwamqb9Fjzw1cWoAkTk3SqlwXJL4+cc0o/9N4A+1LqEMpkN8awAAAABJRU5ErkJggg==">',
          redoImg =
            '<img width="20" height="20" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAACEZVhJZk1NACoAAAAIAAYBBgADAAAAAQACAAABEgADAAAAAQABAAABGgAFAAAAAQAAAFYBGwAFAAAAAQAAAF4BKAADAAAAAQACAACHaQAEAAAAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQACoAIABAAAAAEAAAAWoAMABAAAAAEAAAAWAAAAAI8BckgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAK0aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODg8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KEb7JgwAAAdtJREFUOBHtU7tKA0EUnX3ksRuTgCSQIiAWNkpESCcWCqKgnfglljbaCVroj4hg5ycI/oGtsoUQH0E0m2zWc4a5OIa8wE68cPbe2Xvn3MfMKPUvZgLOFJNwEcM4Ih0AlkOFe4YKSXxgXGL6hxF4ZNQfGpZwQ99Alcvl+Uwms+I4znI+n5/LQRqNxksURT3EsAPGU1NoJ0EQrOmV9dGJKpVKEfsPPM+7BWEbSC0ksO993z8vlUoL1t4cbezZgf9Z/rNl3Ray7cPxirVNJvYnfH1A1r1sNnssJEi2bXxvMgqS9hF01ul0LlzXfQSugBvgLk3TFvxVYAZgEV1AjyFJknVUuYSCYsi18beh9VwUsp0g20OhUNjkz0Gp1WpVJD5ETGyq6kGzemrpQDQLUSoMw104LwfIeBAC6UwhcQOxkSETUs5dQPKWqtfrAdo9skgzlm2bHIE+IEMuh2rPXOyWwmxWrdNlhZMkZABGd2qq7hrNSr+JMbdFwzTuMUgy3Y05/XdDKGQ/iVHt7JTEes4g3QChzJYHSVsg1T+pZrM5aqZSJbW+47hWeyCRkx+nY7ZPyJMkyUjBa9zCnS6C/ANBclPsEcKduvDHI0l+67CzTcPFKid1OMk/TZ6/FPMFReeRA2gpjDMAAAAASUVORK5CYII=">',
          self = this;
        undoRedoButtons =
          "<button class='wsp-undo-button'>" +
          undoImg +
          '</button>' +
          "<button class='wsp-redo-button'>" +
          redoImg +
          '</button>';
        if ($node.find('.wsp-undo-redo-container').length)
          this.removeUndoRedo($node); // Remove old buttons, linked to an old document
        $node.prepend(
          $(
            '<div class="wsp-undo-redo-container wsp-undo-disabled wsp-redo-disabled" style="float: left">' +
              undoRedoButtons +
              '</div.'
          )
        );

        $node.find('.wsp-undo-button').on('click', function(ev) {
          self.undo();
          ev.preventDefault();
        });
        $node.find('.wsp-redo-button').on('click', function(ev) {
          self.redo();
          ev.preventDefault();
        });
      },

      removeUndoRedo: function($node) {
        var $container = $node.find('.wsp-undo-redo-container');
        if ($container.length) $container.remove();
      },

      /**
       * attachToolsToNode creates the UI tools currently in the model.
       *
       * @param {object} node - node that receives the UI for each tool.
       */
      attachToolsToNode: function(node, docWidth, docHeight, includeUndoRedo) {
        var theDoc = this,
          squery = theDoc.focusPage.sQuery(),
          $toolPalette,
          fixedButtonsHeight,
          userButtonsHeight,
          undoInner,
          redoInner,
          undoRedoButtons = '',
          newContent,
          $existingNode,
          toolColumnWidth, // We'll increase our width if there are wider images
          // There are three possible "looks" for tools and tool columns -- classic, new, and compact
          // User prefs to set them are "ToolLook = 'classic'", "ToolLook = 'new'", or "ToolLook  = 'compact'".
          // If the toolLook variable isn't set by pref, it defaults to 'compact'
          // For legacy sketches, we still support the pref "toolplayNewLook = true".
          usingNewLook = this.getAuthorPreference('toolplayNewLook'),
          lookPref = this.getAuthorPreference('toollook'),
          toolPref =
            usingNewLook || lookPref === 'new'
              ? 'new'
              : lookPref === 'classic'
              ? 'classic'
              : 'compact',
          columnLook;

        function nodeOuterWidth(selector) {
          return $(selector, node[0]).outerWidth();
        }

        switch (toolPref) {
          case 'new':
            columnLook = {
              toolsLookClass: 'wsp-tools-newLook',
              hasIcons: true,
            };
            break;
          case 'classic':
            columnLook = {
              toolsLookClass: 'wsp-tools-classicLook',
              hasIcons: false,
            };
            break;
          case 'compact':
            columnLook = {
              toolsLookClass: 'wsp-tools-compactLook',
              hasIcons: false,
            };
            break;
        }

        if (includeUndoRedo) {
          undoInner =
            '<div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
            GSP.Strings.loc('GSP.UI.undo') +
            '</div>';
          redoInner =
            '<div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
            GSP.Strings.loc('GSP.UI.redo') +
            '</div>';
          undoRedoButtons =
            '<button class="wsp-undo-button">' +
            undoInner +
            '</button>' +
            '<button class="wsp-redo-button">' +
            redoInner +
            '</button>';
        }

        newContent =
          '<div class="wsp-tool-container ' +
          columnLook.toolsLookClass +
          '"><div class="wsp-tool-column">' +
          '<div class="wsp-tool-logo wsp-fixed-tool"></div>' +
          '<div class="wsp-ok-cancel-container wsp-undo-redo wsp-undo-redo-top wsp-fixed-tool">' +
          undoRedoButtons +
          '</div>' +
          '<div class="wsp-user-tools"><div class="wsp-tools-inner"></div></div>' +
          '<div class="wsp-ok-cancel-container wsp-undo-redo wsp-undo-redo-bottom wsp-fixed-tool">' +
          undoRedoButtons +
          '</div>' +
          '</div></div>';

        $existingNode = node.find('.wsp-tool-container');
        if ($existingNode.length) {
          // if the tool-container already exists, replace it
          $existingNode.replaceWith(newContent);
        } else {
          // Use prepend rather than append, in case the sketch-container is already present
          node.prepend(newContent);
          // When adding tools to an existing sketch without tools, adjust the width of the base-node
          // to fit the tools plus the sketch width
          node
            .closest('.wsp-base-node')
            .css({ width: docWidth + $('.wsp-tool-container').outerWidth() });
        }

        $toolPalette = $('.wsp-tools-inner', node[0]);
        // Handle buttons on either the top or the bottom
        $('.wsp-undo-redo', node[0]).each(function(_i, elt) {
          GSP.FastClick.attach(elt);
        });

        function onButtonPress(buttonClass, func) {
          var $button = $(buttonClass, node[0]);
          $button.on('click', function(ev) {
            func.call(theDoc);
            ev.preventDefault();
          });
        }

        onButtonPress('.wsp-undo-button', theDoc.undo);
        onButtonPress('.wsp-redo-button', theDoc.redo);

        toolColumnWidth = Math.max(
          toolColumnWidth,
          nodeOuterWidth('.wsp-undo-redo')
        );
        /*
        // You can drag a tool button into a sketch to start toolplay.
        var touchDrag;
  
        // returns a { draggable, liveTouchId }, or undefined
        function getTouchDrag() { return touchDrag; }
        function setTouchDrag($draggable, touch) {
          touchDrag = {
            draggable: $draggable,
            // Allow only one touch drag at a time. The liveTouchId is the
            // identifier of the currently dragging touch.
            liveTouchId: touch.identifier
          };
        }
        function assertDragging() {
          if (getTouchDrag() === undefined) throw GSP.createError("No drag in progress");
        }
        function getDraggable() { assertDragging(); return getTouchDrag().draggable; }
        function hideDraggable() { getDraggable().css('visibility', 'hidden'); }
        function showDraggable() { getDraggable().css('visibility', 'visible'); }
        function destroyDraggable() {
          getDraggable().remove();
          touchDrag = undefined;
        }
        function isDragging() {  return getTouchDrag() !== undefined; }
        function isLiveTouch(touch) {
          return isDragging() && getTouchDrag().liveTouchId === touch.identifier;
        }
  */
        function addTool(tool) {
          var $toolElement,
            hasImage = tool.metadata.image !== undefined,
            imgAttrs =
              squery.getResource('pictures', tool.metadata.image) || {},
            addTextElement = function() {
              var $toolTextElement = $('<div class="wsp-tool-text"></div>');
              $toolTextElement.text(tool.metadata.name);
              $toolElement.append($toolTextElement);
            },
            compactToolLook = {
              // These settings apply to both compact and classic looks

              // Either text or image, but not both
              addImage: function() {
                if (hasImage) {
                  var $imageElement = newImageElement(
                    $('<img class="wsp-tool-image"/>')
                  );
                  $toolElement.append($imageElement);
                }
              },
              addText: function() {
                if (!hasImage) {
                  addTextElement();
                }
              },
              finishAddingTool: function() {
                if (hasImage) {
                  // the tool column has at least one icon
                  columnLook.hasIcons = true;
                }
              },

              // When dragging to start toolplay, we set the
              // draggable's dimensions to be the same as that of the
              // tool button. Note that the inner image is sometimes
              // bigger than its containing element.
              setDraggableDimensions: function($draggable) {
                var $img = $toolElement.find('img');

                if (hasImage) {
                  $draggable.width(
                    Math.max($img.width(), $toolElement.width())
                  );
                  $draggable.height(
                    Math.max($img.height(), $toolElement.height())
                  );
                } else {
                  $draggable.width($toolElement.width());
                  $draggable.height($toolElement.height());
                }
              },
            },
            newToolLook = {
              // Both text and image

              addImage: function() {
                var $mediaElement, $imageElement;

                // This toolLook always has an image, if only the default.
                if (!imgAttrs.src) {
                  imgAttrs.src = GSP.Resources.defaultToolImage;
                }

                // Override the natural/exported image size to conform
                // to our required dimensions.  We might want to
                // change the exporter along these lines. AND/OR we
                // could use a css only, slightly less portable (?)
                // strategy: set the image as a background image with
                // background-size: 100%.
                imgAttrs.height = '40px';
                imgAttrs.width = '40px';

                $imageElement = newImageElement($('<img/>'));
                $mediaElement = $('<div class="wsp-tool-media"></div>');
                $mediaElement.append($imageElement);
                $toolElement.append($mediaElement);
              },
              addText: addTextElement,

              setDraggableDimensions: function($draggable) {
                $draggable.width($toolElement.width());
                $draggable.height($toolElement.height());
              },
            },
            toolLook = lookPref === 'new' ? newToolLook : compactToolLook;

          $toolElement = $('<div class="wsp-tool"></div>');

          function newImageElement($img) {
            $img.attr(imgAttrs);
            $img.attr('title', tool.metadata.name);
            return $img;
          }

          toolLook.addImage();
          toolLook.addText();

          // Check whether a mouse/touch event occurs inside an element.
          // Adapted from http://stackoverflow.com/a/12405910/692065
          // Note: we do not handle multitouch.
          function isInside($elt, touch) {
            var eventX = touch.pageX,
              eventY = touch.pageY,
              inElt = GSP.convertPointFromPage($elt, eventX, eventY);

            return (
              inElt.y >= 0 &&
              inElt.x >= 0 &&
              inElt.x <= $elt[0].offsetWidth &&
              inElt.y <= $elt[0].offsetHeight
            );
          }

          function modalIsUp() {
            return theDoc.getFocusPage().touchRegimeBlocksOtherButtons();
          }

          /* Temporarily eliminate touchDragging of tools; it just gives rise to confusion.
   * Once we are satisfied that this decision is correct, remove all touchDrag code
  
          // Play the tool if the mouse/touch ends inside the button or the sketch area.
          // Send the event timeStamp so the tool controller can detect a double tap
          function maybePlayTool(touch, timeStamp) {
            var toolController = theDoc.focusPage && theDoc.focusPage.toolController,
                $canvasNode = $('.wsp-clip-node', node);
  
            if (toolController &&
                (isInside($toolElement, touch) || isInside($canvasNode, touch))) {
              toolController.toggleTool(tool, timeStamp);
            }
          }
  
          function highlightCanvasAsTarget(touch) {
            var $canvasNode = $('.wsp-clip-node', node);
  
            if ( isInside($canvasNode, touch) ) {
              $canvasNode.addClass('wsp-drop-target');
            }
            else {
              $canvasNode.removeClass('wsp-drop-target');
            }
          }
  
          function createDraggable(touch) {
            var $draggable = $toolElement.clone();
            setTouchDrag($draggable, touch);
            $draggable.addClass('wsp-draggable-toolButton');
            toolLook.setDraggableDimensions($draggable);
  
            // As of now it's just a click; Don't show feedback until
            // it's a drag.
            hideDraggable();
            // Ensure proper css is applied to the clone by making it a
            // sibling of the cloned element. Use prepend rather than
            // append to avoid messing up a :last-child selector!
            $draggable.prependTo($toolElement.parent());
            moveDraggable(touch);
            return $draggable;
          }
  
          // The draggable is absolutely positioned with the transform
          // node as the offset parent.
          function moveDraggable(touch) {
            var eventX = touch.pageX,
                eventY = touch.pageY,
                $draggable = getDraggable(),
                $parent = $draggable.offsetParent(),
                inParent = GSP.convertPointFromPage($parent, eventX, eventY),
                // Appear to drag the center of the button.
                newX = inParent.x - $draggable.width() / 2,
                newY = inParent.y - $draggable.height() / 2;
  
            $draggable.css({left: newX+'px', top: newY+'px'});
          }
  */

          // Play the tool if the mouse/touch ends inside the button.
          // Send the event timeStamp so the tool controller can detect a double tap
          function maybePlayTool(touch, timeStamp) {
            var toolController =
              theDoc.focusPage && theDoc.focusPage.toolController;
            if (toolController && isInside($toolElement, touch)) {
              toolController.toggleTool(tool, timeStamp);
            }
          }

          GSP.mouseTouch($toolElement);

          // Do some of the following functions need to be removed from touchDrag?
          // Note removal of calls that relate to the draggable...
          // Does the wsp-tool-active need to be removed?
          // The wsp-drop-target class definitely needs go..

          function eachTouch(event, func) {
            for (var i = 0; i < event.changedTouches.length; i++) {
              func(event.changedTouches[i]);
            }
          }

          $toolElement.on('touchstart', function(event) {
            eachTouch(event, function(touch) {
              //var prohibitNewDrags = modalIsUp() || isDragging();
              //if (!prohibitNewDrags) {
              //  $toolElement.addClass("wsp-tool-active");
              //  createDraggable(touch);
              //}
              if (!modalIsUp()) {
                $toolElement.addClass('wsp-tool-active');
              }
            });
            return false;
          });

          $toolElement.on('touchmove', function(event) {
            //eachTouch(event, function(touch) {
            //  if (!modalIsUp() && isLiveTouch(touch)) {
            //    highlightCanvasAsTarget(touch);
            //    moveDraggable(touch);
            //    showDraggable();
            //  }
            //});
            return false;
          });

          $toolElement.on('touchend', function(event) {
            eachTouch(event, function(touch) {
              $toolElement.removeClass('wsp-tool-active');
              maybePlayTool(touch, event.timeStamp);
              /*         
             if (isLiveTouch(touch)) {
               //var $canvasNode = $('.wsp-clip-node', node);
               $toolElement.removeClass("wsp-tool-active");
               maybePlayTool(touch, event.timeStamp);
               $canvasNode.removeClass('wsp-drop-target');
               destroyDraggable();
             }
  */
            });
            return false;
          });

          tool.$element = $toolElement;
          $toolPalette.append($toolElement);

          if (toolLook.finishAddingTool) toolLook.finishAddingTool();

          toolColumnWidth = Math.max(
            toolColumnWidth,
            $toolElement.outerWidth()
          );
        }

        theDoc.tools.forEach(addTool);

        // Now, we fix up the height of the tool-container to be full height.
        fixedButtonsHeight = 0;
        $('.wsp-fixed-tool', node[0])
          .filter(':visible')
          .each(function() {
            fixedButtonsHeight += $(this).outerHeight();
          });
        if (columnLook.hasIcons) {
          if (toolColumnWidth > 0) {
            $('.wsp-tool-column', node[0]).outerWidth(toolColumnWidth);
          }
        } else {
          // All tool buttons are text only. Provide a css hook to set
          // the width to a large enough size, to prevent aggressive
          // word wrapping (WSP-1808).
          $('.wsp-tool-column', node[0]).addClass('wsp-no-tool-icons');
        }

        // Fix the user tools height,so that scroll overflow will work.
        userButtonsHeight = $('.wsp-tools-inner', node[0]).outerHeight();
        $('.wsp-user-tools', node[0]).outerHeight(
          docHeight - fixedButtonsHeight - 2
        ); // Keep 2px shadow within the sketch_canvas
        if (fixedButtonsHeight + userButtonsHeight > docHeight) {
          $('.wsp-user-tools', node[0]).addClass('wsp-tool-overflow-y');
        }
      },
    };

    function compareDocumentVersion(iDocumentMetadata) {
      var wspMajorVersion = Number(GSP.version.major),
        wspMinorVersion = Number(GSP.version.minor),
        //wspPatchVersion = Number(GSP.version.patch),
        /// set wspMinSupportedMajorVersion to the lowest major version
        // this version of WSP supports. Or strip this out an implement
        // a more subtle system, e.g. based on optionally included shims.
        wspMinSupportedMajorVersion = Number('4'),
        sketchVersionStr =
          iDocumentMetadata && iDocumentMetadata['wsp-version'],
        sketchVersionArr = sketchVersionStr && sketchVersionStr.split('.'),
        sketchMajorVersion =
          sketchVersionArr && sketchVersionArr.length > 0
            ? Number(sketchVersionArr[0])
            : null,
        sketchMinorVersion =
          sketchVersionArr && sketchVersionArr.length > 1
            ? Number(sketchVersionArr[1])
            : 0;
      //sketchPatchVersion = sketchVersionArr && sketchVersionArr.length > 2
      //                      ? Number(sketchVersionArr[2]) : 0;

      function signalVersionIncompatibility(iType) {
        return GSP.signal({
          code: 'GSP.Error.incompatibleSketchVersion',
          message: GSP.Strings.loc(
            'GSP.Error.incompatibleSketchVersion',
            GSP.version.number,
            sketchVersionStr
          ),
          logType: iType,
          sketchData: iDocumentMetadata,
        });
      }

      //
      // Major version compatibility
      //
      if (wspMajorVersion < sketchMajorVersion) {
        return signalVersionIncompatibility('error');
      }
      if (wspMajorVersion > sketchMajorVersion) {
        // Older sketch major version
        return signalVersionIncompatibility(
          wspMinSupportedMajorVersion > sketchMajorVersion ? 'error' : 'warning'
        );
      }
      if (wspMajorVersion === sketchMajorVersion) {
        //
        // Minor version compatibility
        //
        if (wspMinorVersion < sketchMinorVersion) {
          return signalVersionIncompatibility('debug');
        }
        // Assume backward compatibility is maintained across minor versions
        // and that patch version does not factor into compatibility.
        return;
      }
      // Invalid major version detected
      return GSP.signal({
        code: 'GSP.Error.invalidSketchVersion',
        message: GSP.Strings.loc(
          'GSP.Error.invalidSketchVersion',
          GSP.version.number,
          sketchVersionStr
        ),
        logType: 'error',
        sketchData: iDocumentMetadata,
      });
    }

    function createDocOptions(givenOptions, responsive) {
      return $.extend(
        true,
        {
          sizeParentToContent: responsive,
          responsiveSizing: responsive,
        },
        givenOptions
      );
    }

    /*
     * Document constructor
     *
     * @param {Object} DOM node to attach to.  A null node is valid, eg. in Unit Test scenarios
     */
    var Document = function(node, docSpec, options) {
      var document, errorEvent, errorNode, sketch, spec;

      errorEvent = compareDocumentVersion(docSpec.metadata);

      if (errorEvent && errorEvent.logType === 'error') {
        if (node) {
          errorNode = $('<div class="wsp-error-message"></div>');
          errorNode.text(errorEvent.message);
          $(node)
            .empty()
            .append(errorNode);
        }
        throw GSP.createError(errorEvent.message, errorEvent.code);
      }

      document = Object.create(DocumentPrototype);

      document.initModel(
        docSpec,
        createDocOptions(options, $(node).hasClass('wsp-responsiveSizing'))
      );
      document.id = docID++; // unique only in this run ...
      // stores the gobject handlers for each page
      document.gobjectEventHandlers = {};
      // Remembers which pages of a sketch have already been loaded
      // so that loadPage doesn't trigger again on it.
      document.cacheSketchPagesLoaded = {};

      // This cache avoids UI flicker that results from loading freshly created images.
      document.pictureCache = {};

      if (document.docOptions.documentDelta) {
        document._applyDocumentDelta(document.docOptions.documentDelta);
      }

      // We want the current spec, as there may have been a delta
      spec = document.getCurrentPageSpec(document.metadata['start-page']);
      sketch = GSP.Sketch(document, spec, options);
      document.focusPage = sketch;

      // document.sQuery is accessable externally: documentation/Document/document.html
      document.sQuery = sketch.sQuery;

      if (node) {
        document.attachToNode(node);
        $(node).data('document', document); // The document should be available before rendering gobjs & sending events
        sketch.attachToNode(node);

        document.event('LoadDocument', { document: document }, {});
        document.triggerLoadPage();
        document.triggerDidChangeCurrentPage(null);
      }

      return document;
    };

    return Document;
  })();

  GSP.Resources = {
    // public domain image from https://thenounproject.com/term/hammer/12845/
    defaultToolImage:
      'data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIiB2aWV3Qm94PSIwIDAgODAgODAiIHZlcnNpb249IjEuMSIgeD0iMHB4IiB5PSIwcHgiPjxwYXRoIHN0eWxlPSIiIGQ9Im0gMTEuOTU4MzQ3LDE1LjUzNjQzMiBjIC0wLjQxNzU2NiwwLjA1MjQ1IC0wLjY5OTA3MiwwLjQxNjQ1NSAtMS4zMzMyMDgsMS41NzMxODYgLTAuMzEyMzE4LDAuNTM5MzQgLTAuNjc0MDkzLDEuMjMyMjAxIC0xLjA2NjU2NywyLjAyNjQ3NiAtMC4wNTI1OCwwLjEwMDY2MyAtMC4wNzc2OSwwLjEzMzYxOSAtMC4xMzMzMjEsMC4yMzk5NzggLTMuMTA1MTE5NSw1LjkzNjY2MyAtOC4xODU4OTg4LDE5LjQ3MDg1NyAtOC4xODU4OTg4LDIxLjgxMTI4NyAwLDAuMTQ2ODY1IDAuMDQ2MzE2LDAuMjk2NjkyIDAuMTMzMzIwOSwwLjQ1MzI5MSAwLjAwMTk1LDAuMDA3NCAtMC4wMDIxMiwwLjAxOTQ1IDAsMC4wMjY2NiAwLjAyNjMwNCwwLjA0NTQgMC4wNDU5OCwwLjA4Njc4IDAuMDc5OTkyLDAuMTMzMzIxIDAuMDY5NTMxLDAuMTI1ODA4IDAuMTUzNTc5NywwLjIzMzY5MiAwLjI5MzMwNTgsMC4zNDY2MzQgMC4xMDM1NDEyLDAuMDgzNjkgMC4yMDU3NTAyLDAuMTg1NDMyIDAuMzQ2NjM0MSwwLjI5MzMwNiAwLjAyNDg4NywwLjAxOTA2IDAuMDc5MDc1LDAuMDMzNSAwLjEwNjY1NjcsMC4wNTMzMyAwLjEwNjg3NiwwLjA3NjgzIDAuMjI4NTg4MSwwLjE3OTE4NCAwLjM3MzI5ODMsMC4yNjY2NDIgMC42NTgyNzMyLDAuNDM1OTM0IDEuNTY4ODUyOCwwLjkyOTM3NSAyLjc5OTczNzMsMS41MTk4NTcgMy43OTkwNjk3LDEuODIyNTA1IDguMTM5MjMwNywzLjIzMjYyOSAxMC4wNzkwNTQ3LDMuMzU5Njg1IDAuMDI0NCwwLjAwMzYgMC4wNTY3MywwLjAyMzYgMC4wNzk5OSwwLjAyNjY2IDAuMDE1MDMsNy41NWUtNCAwLjAzODYxLC01Ljg2ZS00IDAuMDUzMzMsMCAwLjEzNzI3NywwLjAxNTY4IDAuMjU3MTUsMC4wMzM1IDAuMzQ2NjM1LDAuMDI2NjYgMC41OTU5MzUsLTAuMDQ1NTEgMC43MTYwMTksLTAuMTQ4MTA0IDEuNDEzMiwtMS4yNTMyMTYgMC40MTU0NDcsLTAuNjU4NTMyIDEuMDQxODM1LC0xLjc2Mjg3NyAxLjM4NjUzNywtMi40NTMxMDMgMS42NDk4MSwtMy4zMDM1NzkgMi40MjE4NTksLTQuODg3ODAzIDMuMDEzMDUsLTUuNTQ2MTQ2IDAuMjMxNDI4LDAuMDkyMDggMS40Nzc5MTksMC41ODI0NzkgMi45NTk3MjMsMS4xNzMyMjMgMS41MzcxMSwwLjYxMjc5NCAzLjA1MjI2MiwxLjIxMTQ4MiAzLjM1OTY4NSwxLjMwNjU0NCAwLjMwNzQyMSwwLjA5NTA2IDEuNzA1NTY1LDAuNzE2MTAzIDMuMTE5NzA3LDEuMzg2NTM3IDEuNDE0MTQyLDAuNjcwNDM1IDMuNjQxNjk4LDEuNjU4NDMxIDQuOTMyODcsMi4yMTMxMjUgMS4yOTExNzMsMC41NTQ2OTcgMi42ODc0MiwxLjE5Mjg4NiAzLjExOTcwOCwxLjQxMzIwMSAwLjQzMjI4MywwLjIyMDMxMyAyLjE1NDc4OSwwLjk1MDQwNyAzLjgxMjk3NSwxLjYyNjUxNCAxLjY1ODE4NCwwLjY3NjEwNSA0LjgyNTg5OSwxLjk4MzEzNSA3LjAzOTM0MSwyLjkwNjM5NCAyLjIxMzQzOCwwLjkyMzI1OSA1LjM3OTI1OCwyLjE3MDExIDcuMDM5MzM5LDIuNzQ2NDA5IDMuOTEyNjI0LDEuMzU4Mjc2IDguNzg1MjEsMy4yNzE2MTUgMTEuMTE4OTU3LDQuMzcyOTIzIDEuMDE2ODczLDAuNDc5ODcgMS44OTM0MjIsMC44Nzk5MTggMS45NDY0ODQsMC44Nzk5MTggMC4wNTMwNiwwIDEuMDQyOTYyLDAuNDIxMTc3IDIuMTg2NDYyLDAuOTU5OTEgMS4xNDM1LDAuNTM4NzM0IDIuMjE1MzIxLDEuMDM3MTQxIDIuMzk5Nzc1LDEuMDkzMjMgMC4xNzY2MywwLjA1MzcyIDAuMzYyMDA0LDAuMDU2NzMgMC41MzMyODMsMC4wMjY2NyAwLjAwMTQsMC4wMjU5NiAtOS41NmUtNCwwLjA1Mzc1IDAuMDI2NjYsMC4wNzk5OSAwLjI0NTc5NiwwLjIzMzUyOSAxLjA3MTc2MywtMC4zNTkxNTIgMS44MTMxNjMsLTEuMzA2NTQ0IDAuNTc5NDgyLC0wLjc0MDQ4OSAxLjA4NTUxMywtMS45MzM2MjggMS4zNTk4NzMsLTMuMDkzMDQzIDAuMDA0NSwtMC4wMTg3NCAwLjAyMjM2LC0wLjAzNDYgMC4wMjY2NiwtMC4wNTMzMyAwLjAzMDY5LC0wLjEwMTYwMiAwLjAyNzg4LC0wLjE5Mzk3MiAwLjA1MzMzLC0wLjI5MzMwNiAwLjA3Mjk1LC0wLjI4NDgxNCAwLjEzNTU0LC0wLjU0NTU0MyAwLjE1OTk4NSwtMC43OTk5MjUgMC4xMTA3NDcsLTEuMTUyNTg0IC0wLjA1ODA3LC0yLjExNTAxMSAtMC4zNzMyOTgsLTIuMTg2NDYyIC0wLjAwNzksLTAuMDA5MSAtMC4wMTg0OCwtMC4wMTc5NSAtMC4wMjY2NiwtMC4wMjY2NiAtMC4wODk5OCwtMC4wOTU4MiAtMC4xOTI5NTYsLTAuMTc2MzIzIC0wLjMxOTk3LC0wLjIzOTk3NyAtMC4xNzIzNTcsLTAuMDg2MzggLTEuMzA2MzYxLC0wLjQ4Mjg1MiAtMi41MDY0MzIsLTAuODc5OTE4IC0xLjIwMDA2OCwtMC4zOTcwNjYgLTIuMjAxMzE4LC0wLjc2MzM3MiAtMi4yMzk3OSwtMC43OTk5MjUgLTAuMDM4NDcsLTAuMDM2NTUgLTAuOTMyMDg4LC0wLjM0MDc0OCAtMS45OTk4MTIsLTAuNjkzMjY4IC0yLjQ1MDQ1LC0wLjgwOTA0MiAtNy4zMjAyMTgsLTIuNzY5MzIgLTExLjA5MjI5MywtNC40Nzk1OCAtMS42MDA0NDcsLTAuNzI1NjQ1IC00Ljc0NTQxOSwtMi4wMjQ0NzIgLTYuOTg2MDExLC0yLjg3OTczIC0yLjI0MDU5MywtMC44NTUyNTUgLTUuNDUxNTE2LC0yLjA5NDQyNyAtNy4xMTkzMzIsLTIuNzQ2NDA5IC0xLjY2NzgyLC0wLjY1MTk4MiAtMy40MDExNjYsLTEuMzAxODMyIC0zLjg2NjMwNCwtMS40Mzk4NjQgLTAuNDY1MTQzLC0wLjEzODAzMiAtMS45MzQ5MDUsLTAuNjU5MzUzIC0zLjI1MzAyOCwtMS4xNDY1NiAtMS4zMTgxMjIsLTAuNDg3MjA4IC0zLjYwNTg2NiwtMS4yNzE4MzQgLTUuMDkyODU1LC0xLjc1OTgzNCAtMS40ODY5OTEsLTAuNDg4MDAxIC0yLjkzODAxMywtMS4wMDM3MzMgLTMuMjI2MzY0LC0xLjE0NjU2IC0wLjI4ODM0OSwtMC4xNDI4MyAtMS43Njk5MjQsLTAuNzcyMDUgLTMuMzA2MzU3LC0xLjM4NjUzNiAtMS41MzY0MzYsLTAuNjE0NDg2IC0yLjk0MDI5MywtMS4xNjUyNjEgLTMuMDkzMDQzLC0xLjIyNjU1MiAtMC4wMzYzMiwtMC4wMTQ1NyAtMC4wMzAzNCwtMC4wOTY1NiAtMC4wMjY2NiwtMC4yMTMzMTMgMC4wMDMyLC0wLjEwMTg0NiAwLjA0NzA4LC0wLjI3Njc3MiAwLjA3OTk5LC0wLjQ1MzI5MSAwLjAxODc5LC0wLjEwNDYxOSAwLjAyNzA4LC0wLjIwMDI1OSAwLjA1MzMzLC0wLjMxOTk3IDAuMDcxNjcsLTAuMzEwNjgxIDAuMTY1NzEsLTAuNjk5NTY5IDAuMjkzMzA1LC0xLjE0NjU1OSAwLjAwMzMsLTAuMDExODggLTAuMDAzNCwtMC4wNDEzNCAwLC0wLjA1MzMzIDAuMTMwODc3LC0wLjQ1NTg2MyAwLjI5NDMyMSwtMC45NjA4MSAwLjQ3OTk1NSwtMS41NDY1MjIgMC4wOTM3NSwtMC4yOTU4MTUgMC4xNTUyMDgsLTAuNDc1ODM0IDAuMjM5OTc4LC0wLjc0NjU5NiAwLjE3MjkzNywtMC41Njg5MjcgMC4yNjI4MTksLTAuOTE2MTQyIDAuNDc5OTU1LC0xLjYyNjUxNCAwLjgzNjM2NCwtMi43ODM2MzIgMS4wNDc4OCwtMy44OTEzNTEgMC44MjY1ODksLTQuMjkyOTMxIC0wLjYxOTk0MSwtMS4xMjUwMDkgLTUuNDgzMDcyLC0zLjU1NTM1NiAtMTAuMTU5MDQ3LC01LjA2NjE5MSAtMC45MzU5MDIsLTAuMzAyMzk3IC0xLjcxNTU5MiwtMC41MTE2ODcgLTIuMzczMTExLC0wLjY2NjYwNCAtMC4wNjQ2MiwtMC4wMTUyMyAtMC4xMjQ1MDIsLTAuMDM5NTEgLTAuMTg2NjQ5LC0wLjA1MzMzIC0wLjEwNjkyMSwtMC4wMjk5OCAtMC4xOTQzMjYsLTAuMDI3NzMgLTAuMjkzMzA1LC0wLjA1MzMzIC0wLjM3Mzk5OCwtMC4wOTY3MyAtMC42OTI5NSwtMC4xODc2NjEgLTAuOTMzMjQ2LC0wLjIxMzMxMyAtMC4zMzQzMDMsLTAuMDM1NjkgLTAuNTY3NzEsLTAuMDc5MTUgLTAuNzczMjYxLC0wLjA1MzMzIHoiIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAuODUzMjUzMyI+PC9wYXRoPjwvc3ZnPg==',
  };

  /**
   * @fileOverview Main Sketch object representing geometric objects.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * Constructs an interactive sketch and attaches it to the specified HTML
   * element.
   * @constructor
   * @param {Element} node The jQuery element to attach to.
   * @param {object} spec  The JSON specification of the sketch.
   * @return {GSP.Sketch} a sketch object.
   */
  GSP.Sketch = (function(/** @lends GSP.Sketch */) {
    var SketchPrototype = {
      /** @scope GSP.Sketch */

      /**
       * Convert an event position to sketch coordinates.
       * @param {Event} e The jQuery event.
       * @return {object} an object containing (x,y) sketch coordinates,
       * and for clients that think in global coordinates, the events
       * pageX and pageY.
       */
      EventToSketch: function(e) {
        var ret = GSP.convertPointFromPage(this.canvasNode, e.pageX, e.pageY);

        // Sketch designers are biased towards integer coordinates, so we
        // snap to lattice here.
        var point = GSP.GeometricPoint(Math.round(ret.x), Math.round(ret.y));

        this.viewToPrimalTransform().transform(point);
        ret.x = point.x;
        ret.y = point.y;

        // Some clients will want to go back to the original pageX, pageY, or mouseEvent
        ret.pageX = e.pageX;
        ret.pageY = e.pageY;
        ret.mouseEvent = e.mouseEvent;

        return ret;
      },

      // Should we attempt to avoid this gobject during autoplacement.
      // Yes if it's visible, or we think it might become visible.
      avoidableGObject: function(aGObj) {
        return (
          aGObj.state &&
          aGObj.state.exists &&
          (!aGObj.style.hidden || aGObj.latentVisibility)
        );
      },

      getCenterPoint: function() {
        var sketchRect = this.sketchRect(),
          sketchRectHeight = sketchRect.bottom - sketchRect.top,
          sketchRectWidth = sketchRect.right - sketchRect.left,
          x = sketchRect.right - sketchRectWidth / 2,
          y = sketchRect.bottom - sketchRectHeight / 2;
        return GSP.GeometricPoint(x, y);
      },

      /***
       * Internal utility for autoplacing an object in a sketch.  Some
       * objects are placed by an algorithm beneath the last object of
       * that type, attempting to avoid clutter. Other objects are
       * placed as a group. This function handles both kinds of
       * placement by finding space for a bounding box.
       *
       * See GObject_GetNextDefaultPosition() in gobjdef.c for reference implementation
       * @param params - an object with the following required fields:
       *  boxDimensions - width/height size of bounding box we are placing
       *  mustAvoid(gobj) - returns true if placement must not conflict with gobj
       *  metrics - autoplacement Metrics
       *  start - where to start positioning
       *  placingOneGobjOnly - true if our bounding box contains only one gobj
       */
      findPositionForBoundingBox: function(params) {
        var boxDimensions = params.boxDimensions,
          mustAvoid = params.mustAvoid,
          metrics = params.metrics,
          start = params.start,
          placingOneGobjOnly = params.placingOneGobjOnly,
          self = this,
          sketchRect = this.sketchRect(),
          position,
          success;

        function avoidClutter() {
          var success;
          var qRect = {};

          do {
            success = true; /* assume this one's the magic try */
            qRect.left = position.x;
            qRect.right = qRect.left + boxDimensions.width;
            qRect.top = position.y;
            qRect.bottom = qRect.top + boxDimensions.height;

            if (qRect.bottom > sketchRect.bottom) {
              /* We've moved off the bottom of the screen. Can we go right? */
              /* Try a fairly arbitrary distance to the right, in that we'll bump down
               past geometry from there, as well. */
              /* SS: More importantly, do we want to go right at all? Probably not. */
              position.x += (sketchRect.right - sketchRect.left) / 8;

              if (position.x + boxDimensions.width > sketchRect.right) {
                /* Make sure the new position doesn't push the box off the right edge */
                return false; /* We've failed to fit below or to the right */
              } else {
                success = false; /* Request tail recursive retry */
                position.y = sketchRect.top + metrics.sketchTopMargin;
              }
            } else {
              /* q is potentially on-screen. Does it conflict with an object? */
              var aGObj,
                aGObjGeomBounds,
                constraintList = self.gobjList.constraintList;

              for (var i = constraintList.length - 1; i >= 0; --i) {
                aGObj = constraintList[i];

                if (
                  mustAvoid(aGObj) &&
                  self.avoidableGObject(aGObj) &&
                  (aGObjGeomBounds = self.getGObjGeomBounds(aGObj)) &&
                  GSP.Geom.isFiniteRect(aGObjGeomBounds) &&
                  GSP.Geom.isIntersectRects(aGObjGeomBounds, qRect)
                ) {
                  /* Conflicts with position. Move down and try again. */
                  success = false;
                  /* If there is only one gobj to place, left-align it with the one we just hit */
                  if (placingOneGobjOnly) {
                    /* MAX so we never get sucked left into an endless loop */
                    position.x = Math.max(position.x, aGObjGeomBounds.left);
                  }
                  position.y = aGObjGeomBounds.bottom + metrics.gObjTopMargin;
                  break;
                }
              }
            }
          } while (!success);

          return true;
        } /* avoidClutter */

        position = GSP.GeometricPoint(start.x, start.y);
        success = avoidClutter();

        if (!success) {
          //reset position to top left
          position = GSP.GeometricPoint(sketchRect.left, sketchRect.top);
          position.x += metrics.sketchLeftMargin;
          position.y += metrics.sketchTopMargin;
        }

        return {
          success: success,
          position: position,
        };
      },

      autoplaceGObj: function(gobj, options) {
        var sketchRect = this.sketchRect(),
          metrics = gobj.getAutoplacementMetrics(),
          ignoreConflictIf = options && options.ignoreConflictIf;

        if (!metrics) return false;

        var start = GSP.GeometricPoint(
            sketchRect.left + metrics.sketchLeftMargin,
            sketchRect.top + metrics.sketchTopMargin
          ),
          constraintList = this.gobjList.constraintList,
          boxDimensions = {
            width: metrics.rightIsolation,
            height: metrics.bottomIsolation,
          },
          existingGObj,
          existingGObjBounds,
          existingGObjMetrics;

        //search in backwards construction order for objects of the same automatch type
        for (var i = constraintList.length - 1; i >= 0; --i) {
          existingGObj = constraintList[i];
          if (existingGObj === gobj) {
            continue;
          }
          existingGObjMetrics = existingGObj.getAutoplacementMetrics();
          if (
            existingGObjMetrics &&
            existingGObj.autoplacementType === gobj.autoplacementType &&
            this.avoidableGObject(existingGObj) &&
            (existingGObjBounds = this.getGObjGeomBounds(existingGObj)) &&
            GSP.Geom.isFiniteRect(existingGObjBounds) &&
            GSP.Geom.isIntersectRects(existingGObjBounds, sketchRect)
          ) {
            // So far so good. Make sure the box won't go outside the sketchRect before we commit to this location
            if (
              existingGObjBounds.left + boxDimensions.width <
                sketchRect.right &&
              existingGObjBounds.bottom + boxDimensions.height <
                sketchRect.bottom
            ) {
              start.x = existingGObjBounds.left;
              start.y = existingGObjBounds.bottom + metrics.gObjTopMargin;
              break;
            }
          }
        }
        gobj.geom = {
          loc: this.findPositionForBoundingBox({
            boxDimensions: boxDimensions,
            mustAvoid: function(gobj2) {
              if (ignoreConflictIf && ignoreConflictIf(gobj2)) return false;
              return gobj2.autoplacementType && gobj2 !== gobj;
            },
            metrics: metrics,
            start: start,
            placingOneGobjOnly: true,
          }).position,
        };
        return true;
      },

      /**
       * Initializes GObjects, specified in a spec, and adds them to the sketch.
       * Note: This does no initialization of rendering and is safe to call when
       * there is no rendering context (eg. DOM canvas node)
       *
       * @param {specObjs} a map id -> GObject Specification.
       * @param {Object} props - property object optionally containing the following fields:
       *  - speculative - Bool - if true, the gobj will be instantiated with a 'speculative' render state
       *  - autoplace - Bool - if true, gobjs that support autoplacement will be autoplaced
       */
      initGObjects: function(specObjs, props) {
        var gobjects = GSP.gobjectsFromSpec(specObjs, this.sQuery);
        var sketch = this;
        var gobjList = this.gobjList;
        var autoplace = props && props.autoplace;
        var speculative = props && props.speculative;
        var forceConstrain = props && props.forceConstrain; // invalidates Geom

        function postInit(gobj) {
          var autoplacementOccurred;

          if (autoplace) {
            //This is a no-op for non-autoplaceable gobjs
            autoplacementOccurred = sketch.autoplaceGObj(gobj);
          }

          if (gobj.postInit) {
            gobj.postInit(props); // Only current use: tool-created measures show parent labels
          }

          gobj.invalidateGeom();

          if (autoplacementOccurred) {
            //Render it now so the next gobject can query this gobjs bounds
            sketch.renderPrepare();
            sketch.constrainAndRedraw();
          }
        }

        gobjList.addGObjects(
          gobjects,
          autoplace || speculative || forceConstrain ? postInit : undefined,
          speculative
        );

        return gobjects;
      },
      /**
       * Construct new gobjects and add them to an already initialized sketch.
       * Performs all of the required initializations for instantiation and rendering,
       * assuming a sketch with an initialized view.
       *
       * @param {Object} specObjs - a map id -> GObject Specification.
       * @param {Object} props - property object optionally containing the following fields:
       *  - speculative - Bool - if true, the gobj will be instantiated with a 'speculative' render state
       *  - autoplace - Bool - if true, gobjs that support autoplacement will be autoplaced
       *
       * @return {Object} map of instantiated object indexed by id
       */
      constructGObjects: function(specObjs, props) {
        var returnedObjects = this.initGObjects(specObjs, props);

        this.renderPrepare();

        return returnedObjects;
      },

      /**
       * Constrain the GObjects in a drive chain.
       *
       * Updated the fundamental geometry of the gobjects
       * in the drive chain array by calling their constraint function.
       * This is intended to be fairly low level. It assumes you've ordered
       * driveChain in a meaningful, and that you understand the consequences of
       * simply updating the geometry without further ado.
       *
       * @param {Array} driveChain An array of GObjRefs
       */
      constrainDriveChain: function(driveChain) {
        var i, gobj;
        for (i = 0; i < driveChain.length; i++) {
          gobj = driveChain[i];
          if (gobj.checkParentsExist()) {
            gobj.constrain(this);
          }
          if (gobj.state) {
            gobj.state.constraintCache = {};
          }
        }
      },

      /**
        Returns the geomBounds for the specified object. Developed in parallel with
        the geomBounds implementation, and so currently corrects for any API mismatch,
        e.g. with the rectangle definition. These corrections can be eliminated once
        the API settles down.
        @param  {Object}  GObj for which the geomBounds is desired
        @returns  {Object}  Rectangle in { left, top, right, bottom } form
       */
      getGObjGeomBounds: function(gobj) {
        var bounds =
          (gobj.getGeomBounds && gobj.getGeomBounds()) ||
          GSP.Geom.kInfiniteRect;
        if (!GSP.Geom.isValidRect(bounds)) {
          GSP.signalErrorWithCode('GSP.Error.invalidGeomBounds', [
            gobj.id,
            gobj.kind,
          ]);
          bounds = GSP.Geom.kInfiniteRect;
        }
        return bounds;
      },

      /**
        Returns the geomBounds for the specified object's label.
        @param  {Object}  GObj for which the geomBounds is desired
        @returns  {Object}  Rectangle in { left, top, right, bottom } form
       */
      getGObjLabelBounds: function(gobj) {
        var dc = this.renderRefCon.dcForGObjLabel || this.dcForGObjLabel(gobj);
        return (
          (gobj.getLabelBounds && gobj.getLabelBounds(dc)) ||
          GSP.Geom.kInfiniteRect
        );
      },

      /**
       * Grows the significant bounds of the sketch to include the passed in gobj
       * if it's visible.
       *
       * @param {Object} gobj
       */
      updateSignificantBoundsWithGObj: function(gobj) {
        if (gobj.style.hidden) {
          return;
        }
        var optDisplayObj = this.renderRefCon.gobj[gobj.id];
        this.significantBounds = GSP.Geom.unionRects(
          this.significantBounds,
          gobj.getSignificantBounds(optDisplayObj)
        );
      },

      ignoreIfDragged: function(gobj) {
        // children can ignore this parent if it's being dragged
        // We test by checking against the shorter list of ones that don't
        // A code improvement would be to have a childrenIgnoreDrag flag in the parent constructors.
        // The sketch shouldn't get into this level of detail of handling different gobjs.
        // BUT HOW do we handle the problem of a dragged parent param, calc, or measure whose value
        // is changing at the same time? For such parents, we need to go ahead and invalidate their children.
        // AND HOW can we tell that the parent is actually being dragged?
        // Perhaps we can set parent.state.inDrag at the start of a drag, and unset it either at drag end
        // or if the value is changed.
        return (
          gobj.isOfKind('Button') ||
          gobj.isOfKind('Text') ||
          gobj.isOfKind('Expression')
        );
        // Are all Expresions are also Text?
      },

      /**
       * Applies constraints to each gobject instance in topological sort order.
       * Basically, this gives the gobject instances a chance to correct their
       * state in response to events that have been processed for their parents.
       * For some parents, changes to their geometry affects children.
       * But for value-based parents, only the value, not the geometry, affects children.
       * Such parents (dragged parameters, calculations, measurements, functions, buttons)
       * do not cause their children to be reconstrained.
       */
      constrain: function() {
        if (this.state === 'stopped') {
          return;
        }
        this.monitor.stateChange('constrain');

        function updateOneConstraintFrame(index, gobj, sketch) {
          var i, parentGObj;
          for (i = 0; i < gobj.numParents(); i++) {
            parentGObj = gobj.parentsList[i];
            if (
              parentGObj.state.constraintFrame > gobj.state.constraintFrame &&
              !(sketch.ignoreIfDragged(parentGObj) && parentGObj.state.inDrag)
            ) {
              // parent has changed in a way that affects descendants
              gobj.state.constraintFrame = parentGObj.state.constraintFrame;
              // Invalidating an object invalidates its previous (last-rendered) bounds.
              sketch.invalidateRect(sketch.renderRefCon.renderBounds[gobj.id]);
              sketch.invalidateRect(sketch.renderRefCon.labelBounds[gobj.id]);
              sketch.isDirty = true;
            }
          }
        }

        function constrainOneGObj(index, gobj, sketch) {
          var id, dc;
          try {
            if (
              gobj.state.constraintFrame >= sketch.constraintFrame &&
              gobj.checkParentsExist()
            ) {
              gobj.constrain(sketch);
              // Constraining an object invalidates its current (to-be-rendered) bounds
              if (!gobj.style.hidden) {
                dc = sketch.dcForGObj(gobj);
                if (dc && dc.preclear)
                  sketch.invalidateRect(sketch.getGObjGeomBounds(gobj));
                dc = sketch.dcForGObjLabel(gobj);
                if (dc && dc.preclear)
                  sketch.invalidateRect(sketch.getGObjLabelBounds(gobj));
                sketch.isDirty = true;
              }
              if (gobj.state) {
                gobj.state.constraintCache = {};
              }
              if (gobj.hasLabel && gobj.constrainLabel) {
                gobj.constrainLabel();
              }
              sketch.document.raiseSketchEvent(
                sketch.getPageId(),
                gobj.id,
                'update'
              );
            }
          } catch (ex) {
            if (gobj.id) {
              id = gobj.id;
            } else {
              id = '#' + index;
            }
            ex.code = 'GSP.Error.constraintException';
            ex.message =
              GSP.Strings.loc('GSP.Error.touchStartException', id) +
              ': ' +
              ex.message;
            GSP.signalCaughtError(ex);
          }
        }

        // Calculate the gobjects that need constraint.
        // gobj.state.constraintFrame == sketch.constraintFrame is the signal,
        // and we need to propagate this signal down to children.
        // We do this in a pass here. You could roll this calculation into
        // constrainOneGObj, but it's better to isolate it for future potential
        // optimizations (e.g. caching a list of gObjects to constrain, and tracking
        // when the list needs updating...)
        this.eachGObj(this.gobjList.constraintList, updateOneConstraintFrame);

        // Main constraint loop
        this.eachGObj(this.gobjList.constraintList, constrainOneGObj);
        this.constraintFrame++;

        if (this.isDirty) {
          //If constraining anyone, we must recalculate significant bounds for everyone
          this.significantBounds = null;
          this.eachGObj(this.gobjList.constraintList, function(
            index,
            gobj,
            sketch
          ) {
            sketch.updateSignificantBoundsWithGObj(gobj);
          });
        }
        this.monitor.stateChange('idle');
      },
      /**
        Accumulates the bounds of the specified object into the dirtyRect.
        Currently, we simply maintain a single dirtyRect which represents
        the union of all invalid rects. Optimizations such as maintaining
        a list of all separate dirty rects are possible down the road.
        @param  {Object}  gobjBounds -- rectangle in { left, top, right, bottom } form
       */
      invalidateRect: function(gobjBounds) {
        this.dirtyRect = GSP.Geom.unionRects(this.dirtyRect, gobjBounds);
      },
      /**
       * Marks the appearance (but not the geometry) of the gobj as out of date.
       * Requests a redraw but not reconstraint.  Children are not affected.
       *
       * @param {type} gobj
       * @returns {undefined}
       */
      invalidateAppearance: function(gobj) {
        // Invalidating an object invalidates its previous (last-rendered) bounds, and measuring
        // its label (if showing) so that the next rerender step doesn't clip a possibly changed label.
        var bounds = gobj.labelRenderBounds, // bounds may be undefined, if the label hasn't yet been rendered.
          refCon = this.renderRefCon,
          size;
        this.invalidateRect(refCon.renderBounds[gobj.id]);
        if (
          bounds &&
          gobj.style.label &&
          gobj.style.label.showLabel &&
          refCon.label[gobj.id]
        ) {
          size = gobj.measureLabel(
            refCon.dcForGObjLabel,
            refCon.label[gobj.id]
          );
          bounds.right = Math.max(bounds.right, bounds.left + size.width);
          bounds.bottom = Math.max(bounds.bottom, bounds.top + size.height);
          refCon.labelBounds[gobj.id] = bounds;
        }
        this.invalidateRect(refCon.labelBounds[gobj.id]);
        this.isDirty = true;
        this.setNeedsDisplay();
      },
      /**
       * Marks the geometry of the gobject as out of date,
       * with accompanying sketch-wide side-effects.
       * @param {Object} gobj -- the GObj whose geometry is to be invalidated
       * @param {String} source -- optional: pass 'drag' if gobj is being dragged
       * @return {GSP.Sketch} the sketch
       */
      invalidateGeom: function(gobj, source) {
        if (gobj) {
          if (this.ignoreIfDragged(gobj)) {
            // Track gobjs for which a drag might not constrain children
            if (source === 'drag') {
              gobj.state.inDrag = true;
              if (!gobj.state.inDrag)
                console.log('Setting inDrag for ' + gobj.id, gobj);
            } else if (gobj.state.inDrag !== undefined) {
              // not a drag, so clear the flag
              console.log('Clearing inDrag for ' + gobj.id, gobj);
              delete gobj.state.inDrag;
            }
          }

          gobj.state.constraintFrame = this.constraintFrame;
          this.invalidateAppearance(gobj);
        }
        return this;
      },

      /**
        Notify client/container that a particular event has occurred.
        Currently forwards to GSP.event() but may notify differently at some point.
        @param  {String}  message -- event name, e.g. 'DidChangeCurrentPage'
        @param  {Object}  args -- additional arguments to be passed along to handler
       */
      event: function(message, context, attributes) {
        context = context || {};
        attributes = attributes || {};

        context.sketch = this;
        context.sQuery = this.sQuery;

        if (context.gobj) {
          // if this event has a gobj, send its id (which can be stringified) in attributes
          attributes.gobjId = context.gobj.id;
        }

        if (context.touch) {
          attributes.touchIdentifier = context.touch.identifier;
        }

        if (context.position) {
          attributes.position = {
            x: context.position.x,
            y: context.position.y,
          };
        }

        if (context.sketch.document.focusPage.metadata.id) {
          attributes.pageId = context.sketch.document.focusPage.metadata.id;
        }

        this.document.event(message, context, attributes);
      },

      /**
       * An event handler for touch start events.
       * Called when one or more new touches occur. There can be several new
       * touches. Other touches can be in progress or ending. For each new touch,
       * identifies touched objects, calls Drag.Start on each. Updates display.
       * @param {Event} e A touch event.
       * @return {boolean} jQuery event handler return (false means suppress default/propagation)
       */
      handleTouchStart: function(e) {
        var i, touch, pos, tracker;
        var ret = true;

        if (!e || !e.changedTouches) {
          GSP.signalErrorWithMessage(
            'sketch.handleTouchStart: missing e.changedTouches'
          );
          return ret;
        }
        for (i = 0; i < e.changedTouches.length; i += 1) {
          try {
            touch = e.changedTouches[i];
            pos = this.EventToSketch(touch);
            tracker = this.currentTouchRegime().createTracker(touch, pos);

            if (tracker) {
              GSP.TouchManager.registerTouchWithTracker(
                touch.identifier,
                tracker
              );
              tracker.startTime = e.timeStamp || Date.now();
              tracker.touchBegan(pos, touch);
              // This ret = false with the comment "in devices due to return false button(gojb html reference) click is not working."
              // presumably meaning there's a bug in keyboard accessibility of buttons now.
              // Similar code was in handleTouchEnd
              ret = false;
            }
          } catch (ex) {
            ex.code = 'GSP.Error.touchStartException';
            ex.message =
              GSP.Strings.loc(
                'GSP.Error.touchStartException',
                touch.identifier
              ) + ex.message;
            GSP.signalCaughtError(ex);
          }
        }

        return ret;
      },

      /**
       * Handles a touch move event. The event may contain moves for multiple
       * touches. For each moving touch, if there is a drag in process updates it.
       * If none, creates a drag object to manage the drag. After all moves have
       * been processed, updates the display.
       * @param {Event} e The touch move event.
       * @return {boolean} jQuery event handler return (false means suppress default/propagation)
       */
      handleTouchMove: function(e) {
        var i, touch, tracker, pos;
        var ret = true;

        if (!e || !e.changedTouches) {
          GSP.signalErrorWithMessage(
            'sketch.handleTouchMove: missing e.changedTouches'
          );
          return ret;
        }
        for (i = 0; i < e.changedTouches.length; i += 1) {
          try {
            touch = e.changedTouches[i];
            tracker = GSP.TouchManager.trackerForTouch(touch.identifier);
            if (tracker) {
              pos = this.EventToSketch(touch);
              tracker.touchMoved(pos, touch);
              ret = false;
            }
          } catch (ex) {
            ex.code = 'GSP.Error.touchMoveException';
            ex.message =
              GSP.Strings.loc(
                'GSP.Error.touchMoveException',
                touch.identifier
              ) + ex.message;
            GSP.signalCaughtError(ex);
          }
        }

        this.gObjectUpdate = true;

        return ret;
      },

      /**
       * Handles touch end events. Several touches may end simultaneously. This
       * method handles them all. Mainly, this routine ends the drag operation
       * for each touch that is ending.
       * @param {Event} e The touch event.
       * @return {boolean} jQuery event handler return (false means suppress default/propagation)
       */
      handleTouchEnd: function(e) {
        var i, pos, touch, tracker;
        var ret = true;

        if (!e || !e.changedTouches) {
          GSP.signalErrorWithMessage(
            'sketch.handleTouchEnd: missing e.changedTouches'
          );
          return ret;
        }

        for (i = 0; i < e.changedTouches.length; i += 1) {
          try {
            touch = e.changedTouches[i];
            tracker = GSP.TouchManager.trackerForTouch(touch.identifier);

            if (tracker) {
              pos = this.EventToSketch(touch);
              tracker.endTime = e.timeStamp || Date.now();
              tracker.touchEnded(pos, touch);
              ret = false; // line comment by magic, in devices due to return false button(gojb html reference) click is not working.
            }

            GSP.TouchManager.deregisterTouch(touch.identifier);
          } catch (ex) {
            ex.code = 'GSP.Error.touchEndException';
            ex.message =
              GSP.Strings.loc('GSP.Error.touchEndException', touch.identifier) +
              ex.message;
            GSP.signalCaughtError(ex);
          }
        }

        this.setGobjPositionInDocumentBound();

        if (this.gObjectUpdate === true) {
          if (this.focusedGobj && this.focusedGobj.htmlNode) {
            this.focusedGobj.htmlNode.focus();
          }
          if (this.isTouchScreenDevice) {
            var self = this;
            setTimeout(function() {
              self.updateSpeakableText();
            }, 300);
          } else {
            this.updateSpeakableText();
          }
          this.gObjectUpdate = false;
        }

        return ret;
      },
      _deferredGObjCalls: null,

      toggleKeyPressClass: function(add) {
        if (add) {
          if (!$(this.baseNode).hasClass('keypressed')) {
            $(this.baseNode).addClass('keypressed');
            $('.wsp-Numpads').addClass('keypressed');
          }
        } else {
          if ($(this.baseNode).hasClass('keypressed')) {
            $(this.baseNode).removeClass('keypressed');
            $('.wsp-Numpads').removeClass('keypressed');
          }
        }
      },

      isTouchScreen: function() {
        function isIpad() {
          var ua = window.navigator.userAgent;
          if (ua.indexOf('iPad') > -1) {
            return true;
          }

          if (ua.indexOf('Macintosh') > -1) {
            try {
              document.createEvent('TouchEvent');
              return true;
            } catch (e) {}
          }
          return false;
        }

        return (
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || isIpad()
        );
      },

      /**
       * Add keyboard keyup and keydown event to the gobj.
       * Adding events for focusIn & focusOut.
       * This method is called in the load method of gobj.
       * @param {GObject} gobj The GObject which is scheduling the call.
       */
      gobjAddKeyEvents: function(gobj) {
        GSP.KeyTracker.create(gobj);
      },

      setSpeakabletext: function(text) {
        if (!this.firstLiveNodeHasText) {
          $('.wsp-live-node.live-node-1').html(text);
          $('.wsp-live-node.live-node-2').html('');
          this.firstLiveNodeHasText = true;
        } else {
          $('.wsp-live-node.live-node-1').html('');
          $('.wsp-live-node.live-node-2').html(text);
          this.firstLiveNodeHasText = false;
        }
      },

      updateSpeakableText: function() {
        if (this.wspSaysAndTabsObjects.wspSaysExist) {
          this.updateSpeakableTextForSketch();
        } else {
          this.updateSpeakableTextForGobjs();
        }
      },

      updateSpeakableTextForGobjs: function() {
        var liveText = '';
        var renderRefConGobjs = this.renderRefCon.gobj;

        for (var id in renderRefConGobjs) {
          if (renderRefConGobjs[id]) {
            var gobj = renderRefConGobjs[id];
            if (gobj.speakableText && gobj.visible && gobj.kind !== 'Button') {
              if (gobj.lastSpeakableText !== gobj.speakableText) {
                liveText += gobj.speakableText + ' ' || '';
                gobj.lastSpeakableText = gobj.speakableText;
              }
            }
          }
        }

        this.setSpeakabletext(liveText);
      },

      updateSpeakableTextForSketch: function() {
        var liveText = '';
        var liveTextUpdate = false;
        var wspSaysGobjsId = this.wspSaysAndTabsObjects.wspSaysGobjsId;
        var renderRefConGobjs = this.renderRefCon.gobj;

        for (var id = 0; id < wspSaysGobjsId.length; id++) {
          if (renderRefConGobjs[wspSaysGobjsId[id]]) {
            var gobj = renderRefConGobjs[wspSaysGobjsId[id]];
            if (gobj.lastSpeakableText !== gobj.speakableText) {
              liveTextUpdate = true;
            }
            liveText += gobj.speakableText + ' ' || '';
            gobj.lastSpeakableText = gobj.speakableText;
          }
        }

        if (liveTextUpdate) {
          this.setSpeakabletext(liveText);
        }
      },

      updateWSPButtonSpeakableText: function(wspButtonGobj) {
        var liveText = '';
        var renderRefConGobjs = this.renderRefCon.gobj;
        for (var id = 0; id < wspButtonGobj.length; id++) {
          if (renderRefConGobjs[wspButtonGobj[id]]) {
            var gobj = renderRefConGobjs[wspButtonGobj[id]];
            liveText += gobj.speakableText + ' ' || '';
          }
        }

        this.setSpeakabletext(liveText);
      },

      updateWSPButtonDownSpeakableText: function(gobj) {
        if (
          this.wspSaysAndTabsObjects.wspButtonDownSaysExist &&
          this.wspSaysAndTabsObjects.wspButtonDownSaysGobjId[gobj.id]
        ) {
          var wspButtonGobj = this.wspSaysAndTabsObjects
            .wspButtonDownSaysGobjId[gobj.id];
          this.updateWSPButtonSpeakableText(wspButtonGobj);
        }
      },

      updateWSPButtonUpSpeakableText: function(gobj) {
        if (
          this.wspSaysAndTabsObjects.wspButtonUpSaysExist &&
          this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId[gobj.id]
        ) {
          var wspButtonGobj = this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId[
            gobj.id
          ];
          this.updateWSPButtonSpeakableText(wspButtonGobj);
        }
      },

      /**
       * Make gobj elements unaccessible, which are located on outside of visible canvas area.
       */
      setGobjPositionInDocumentBound: function() {
        var sketchRef = this.sQuery.sketch;
        var gobjList = sketchRef.gobjList.gobjects,
          gobj;

        if (sketchRef.wspSaysAndTabsObjects.wspTabsExist) return;

        for (var id in gobjList) {
          gobj = gobjList[id];
          if (gobj.htmlNode) {
            if (
              (gobj.kind === 'Text' && gobj.isCompositeText()) ||
              (gobj.kind === 'Expression' && gobj.isParameter())
            ) {
              if (gobj.isGobjInsideDocumentBound()) {
                gobj.htmlNode
                  .find('.mfs-input, .mfs-param, .wsp-parameter-sr-only')
                  .attr('tabindex', '0')
                  .removeAttr('aria-hidden');
              } else {
                gobj.htmlNode
                  .find('.mfs-input, .mfs-param, .wsp-parameter-sr-only')
                  .attr('aria-hidden', 'true')
                  .removeAttr('tabindex');
                gobj.htmlNode.find('button').attr('tabindex', '-1');
              }
            } else {
              if (gobj.isGobjInsideDocumentBound()) {
                gobj.htmlNode
                  .attr('tabindex', '0')
                  .removeAttr('aria-hidden')
                  .find("[role='document']")
                  .attr('tabindex', '0');
              } else {
                gobj.htmlNode
                  .attr({ 'aria-hidden': 'true', tabindex: '-1' })
                  .find("[role='document']")
                  .removeAttr('tabindex');
              }
            }
          }
        }
      },

      /**
       * Schedule a deferred call for a GObject.
       * This is a call will be made during in event loop, before constraint and redraw.
       * @param {GObject} gobj The GObject which is scheduling the call.
       * @return {undefined}
       */
      addDeferredCall: function(gobj, callback) {
        var sketch = this;

        if (!sketch._deferredGObjCalls[gobj.id]) {
          sketch._deferredGObjCalls[gobj.id] = [];
        }

        var newJob = sketch.jobScheduler.addJob(
          function() {
            callback.apply(gobj, [sketch]);
          },
          {
            done: function() {
              var i,
                deferredCalls = sketch._deferredGObjCalls[gobj.id];

              for (i = 0; i < deferredCalls.length; ++i) {
                if (deferredCalls[i] === newJob) {
                  deferredCalls.splice(i, 1);
                  break;
                }
              }
            },
          }
        );

        sketch._deferredGObjCalls[gobj.id].push(newJob);
      },
      /**
       * Cancel all deferred calls for a GObject.
       * @param {GObject} gobj The GObject which is cancelling the call.
       * @return {undefined}
       */
      cancelDeferredCall: function(gobj) {
        var sketch = this;

        this._deferredGObjCalls[gobj.id].forEach(function(job) {
          sketch.jobScheduler.clearJob(job);
          sketch._deferredGObjCalls[gobj.id] = undefined;
        });
      },

      getRenderList: function() {
        return this.gobjList.renderList;
      },

      /**
       * Internal function: returns generic preferred graphics engine for standard uses.
       */
      standardGraphicsEngine: function() {
        var preferred = this.getOption('graphics-engine');
        return this.draw.engines[preferred] || this.draw.engines.canvas;
      },

      /*
       * returns a drawContext, aka engine, for the gobj
       */
      dcForGObj: function(gobj, mode) {
        var layer;

        if ('traced' === mode) {
          return this.draw.engines.trace;
        }

        var dcForGObjMap = this.renderRefCon.dcForGObj,
          dc = dcForGObjMap[gobj.id];
        if (dc) return dc;

        layer = GSP.layerInfo(gobj);

        if (layer.engine === 'standard') {
          dc = dcForGObjMap[gobj.id] = this.standardGraphicsEngine();
          return dc;
        }

        dc = dcForGObjMap[gobj.id] = this.draw.engines[layer.engine];
        return dc;
      },

      dcForGObjLabel: function(gobj) {
        if (this.renderRefCon.dcForGObjLabel)
          return this.renderRefCon.dcForGObjLabel;

        var labelEngineOption = 'canvas', // engine must support measureText
          labelEngine = this.draw.engines[labelEngineOption];
        this.renderRefCon.dcForGObjLabel = labelEngine;
        return this.renderRefCon.dcForGObjLabel;
      },
      //cues translation to be performed on the trace layer
      translateTraceLayer: function(dx, dy) {
        if (this.traces.saturation > 0) {
          if (!this.traces.translate) {
            this.traces.translate = { dx: 0, dy: 0 };
          }
          this.traces.translate.dx += dx;
          this.traces.translate.dy += dy;
        }
      },
      //Actually realize any translation that has been cued on the trace layer
      //on the screen.  Should occur during rendering
      realizeTraceLayerTranslation: function() {
        if (
          this.traces.saturation > 0 &&
          this.traces.translate &&
          (this.traces.translate.dx || this.traces.translate.dy)
        ) {
          this.draw.translate(
            this.traces.translate.dx,
            this.traces.translate.dy
          );
          this.traces.translate.dx = 0;
          this.traces.translate.dy = 0;
        }
      },

      /**
       * Fades the trace layer.
       */
      fadeTraces: function() {
        var now = Date.now(),
          deltaSecs,
          accumulatedAlpha,
          alpha;

        deltaSecs = (now - this.traces.fadeStartTime) / 1000;

        accumulatedAlpha = Math.exp(
          -deltaSecs * (Math.log(2) / this.preferences.fadeHalfLife)
        );
        alpha = accumulatedAlpha / this.traces.appliedAlpha;

        // If the alpha is too close to 0, then it won't be enough to clear the last remnants of color
        // even after repeated, so we add some random noise.
        alpha += Math.random() * 2 * 0.2 - 0.2;
        if (alpha < 0) {
          alpha = 0;
        }

        if (alpha < 1) {
          this.draw.fade(alpha);

          this.traces.saturation *= alpha;
          this.traces.appliedAlpha *= alpha;
        }
      },

      /**
       * Clear the trace layers
       */
      clearTraces: function() {
        this.draw.fade(0.0);
        this.traces.saturation = 0;
        this.traces.appliedAlpha = 1.0;
        this.traces.fadeStartTime = 0;
        this.event('ClearTraces', { document: this });
      },

      /**
       * Renders the gobject using the appropriate engine.
       * @param {gobj} e The gobject to draw.
       * @param {drawArgs} drawing parameters
       */
      renderGObj: function(gobj, drawArgs) {
        var mode = drawArgs.traced ? 'traced' : 'normal',
          dc = this.dcForGObj(gobj, mode);
        if (dc) {
          gobj.render(dc, this.renderRefCon.gobj[gobj.id], drawArgs);
        }
      },

      /**
       * Renders the geometric bounds of an object if the object is visible.
       * This is intended as a debug feature.
       */
      renderBounds: function(ix, gobj, sketch) {
        try {
          var geomBounds = sketch.getGObjGeomBounds(gobj),
            labelBounds = sketch.getGObjLabelBounds(gobj),
            drawArgs = { rect: geomBounds },
            dc = sketch.standardGraphicsEngine();

          if (!gobj.style.hidden) {
            if (geomBounds && dc.drawRectangle) {
              drawArgs = { rect: geomBounds };
              dc.drawRectangle(
                sketch.renderRefCon.geomBounds[gobj.id] || this,
                drawArgs
              );
            }
            if (labelBounds && dc.drawRectangle) {
              drawArgs = { rect: labelBounds };
              dc.drawRectangle(
                sketch.renderRefCon.geomBounds[gobj.id] || this,
                drawArgs
              );
            }
          }
        } catch (ex) {
          ex.code = 'GSP.Error.renderBoundsException';
          ex.message =
            GSP.Strings.loc(
              'GSP.Error.renderBoundsException',
              gobj.id,
              gobj.kind
            ) + ex.message;
          GSP.signalCaughtError(ex);
        }
      },

      /**
       * Renders the gobject's label using the appropriate engine.
       * @param {gobj} e The gobject to draw.
       * @param {drawArgs} drawing parameters
       */
      renderGObjLabel: function(gobj, drawArgs) {
        var mode = drawArgs.traced ? 'traced' : 'normal',
          dc = this.dcForGObjLabel(gobj, mode);
        if (gobj.hasLabel) {
          if (dc) {
            gobj.renderLabel(
              dc,
              this.renderRefCon.label[gobj.id] || this,
              drawArgs
            );
          }
        }
      },

      _fadeTracesJob: null,

      startFadeJob: function(restart) {
        // Starts the fade job if it's not already running
        // clients (e.g., VMT) may need to force starting from scratch after traces are cleared.
        var sketch = this,
          options = {
            repeat: true,
            done: function() {
              sketch._fadeTracesJob = null;
            },
          };
        this.traces.saturation = 1.0;
        if (
          this.traces.appliedAlpha < this.preferences.fadeSaturationFloor ||
          restart
        ) {
          this.traces.appliedAlpha = 1.0;
          this.traces.fadeStartTime = Date.now();
        }
        if (
          this.preferences.fadeTraces &&
          !GSP.JobScheduler.isActive(this._fadeTracesJob)
        ) {
          this._fadeTracesJob = this.jobScheduler.addJob(function() {
            var keepGoing = true;

            sketch.monitor.stateChange('fade');
            if (
              sketch.traces.saturation > sketch.preferences.fadeSaturationFloor
            ) {
              sketch.fadeTraces();
            } else {
              sketch.clearTraces();
              keepGoing = false;
            }
            sketch.setNeedsDisplay();
            sketch.monitor.stateChange('idle');

            return keepGoing;
          }, options);
        }
      },

      stopFadeJob: function() {
        if (this._fadeTracesJob) {
          this.jobScheduler.clearJob(this._fadeTracesJob);
        }
      },

      /**
       * Renders each gobject in turn in topological order.
       */
      render: function() {
        var tracesAdded = false,
          isDragging = false, // first pass (false) is for traces & undragged objects, second (true) for dragged
          renderList,
          renderRect; // cache the dirtyRect while rendering so other clients can safely change the dirtyRect

        if (this.state === 'stopped') {
          return;
        }
        renderList = this.getRenderList();
        this.monitor.stateChange('render');

        function renderOneGObj(index, gobj, sketch) {
          var engine = sketch.dcForGObj(gobj),
            isRasterized = engine && engine.preclear,
            bounds,
            doTrace;
          try {
            // If we are traced, and not drawing the drag-appearance, then trace it out.
            doTrace =
              !isDragging &&
              gobj.style.traced &&
              sketch.preferences.tracesEnabled &&
              !sketch.touchRegimeDisablesTracing(gobj) &&
              gobj.state.traceConstraintFrame !== gobj.state.constraintFrame;
            if (doTrace) {
              sketch.renderGObj(gobj, { traced: true });
              tracesAdded = true;
              gobj.state.traceConstraintFrame = gobj.state.constraintFrame;
            }
            // For visible canvas objects, cache the render bounds for future invalidation
            if (isRasterized && !gobj.style.hidden) {
              bounds = sketch.getGObjGeomBounds(gobj);
              sketch.renderRefCon.renderBounds[gobj.id] = bounds;
            }
            // Skip canvas engine objects that don't need to be rendered
            if (
              !isRasterized ||
              GSP.Geom.isIntersectValidRects(renderRect, bounds)
            ) {
              sketch.renderGObj(gobj, { drag: isDragging, zIndex: index });
            }
          } catch (ex) {
            ex.code = 'GSP.Error.renderObjectException';
            ex.message = GSP.Strings.loc(
              'GSP.Error.renderObjectException',
              gobj.id,
              gobj.kind,
              ex
            );
            GSP.signalCaughtError(ex);
          }
        }

        function renderOneLabel(index, gobj, sketch) {
          var engine = sketch.dcForGObjLabel(gobj),
            isRasterized = engine && engine.preclear,
            bounds;
          try {
            // For visible labels, cache the render bounds for future invalidation
            if (isRasterized && !gobj.style.hidden) {
              bounds = sketch.getGObjLabelBounds(gobj);
              sketch.renderRefCon.labelBounds[gobj.id] = bounds;
            }
            // Skip labels that don't need to be rendered
            if (
              !isRasterized ||
              GSP.Geom.isIntersectValidRects(renderRect, bounds)
            ) {
              sketch.renderGObjLabel(gobj, {
                sketch: sketch,
                drag: isDragging,
              });
            }
          } catch (label_err) {
            label_err.code = 'GSP.Error.renderLabelException';
            label_err.message = GSP.Strings.loc(
              'GSP.Error.renderLabelException',
              gobj.id,
              gobj.kind,
              label_err.message
            );
            GSP.signalCaughtError(label_err);
          }
        }

        //Returns true if the gobj's current renderState is such that it should render on top of other objects
        function renderStateRendersOnTop(gobj) {
          return (
            gobj.state.renderState === 'unmatchedGiven' ||
            gobj.state.renderState === 'matchedGiven' ||
            gobj.state.renderState === 'targetHighlit'
          );
        }

        if (this.isDirty) {
          this.realizeTraceLayerTranslation();
          renderRect = this.dirtyRect;
          // Cache the dirtyRect for use while rendering; meanwhile other objects might re-dirty the sketch and have their changes lost.
          this.dirtyRect = null;
          this.isDirty = false;

          this.draw.prepareFrame(renderRect, this.primalToViewTransform());

          //Render the objects in their normal render layer, unless we will render them on top
          this.eachGObj(renderList, function(index, gobj, sketch) {
            if (!renderStateRendersOnTop(gobj)) {
              renderOneGObj(index, gobj, sketch);
            }
          });

          if (tracesAdded) {
            this.startFadeJob();
          }

          this.eachGObj(renderList, renderOneLabel);

          isDragging = true;

          //Render dragging objects and any onTop render state gobjs that we skipped earlier
          this.eachGObj(renderList, function(index, gobj, sketch) {
            if (gobj.state.isDragging || renderStateRendersOnTop(gobj)) {
              renderOneGObj(index, gobj, sketch);
            }
          });

          if (this.getOption('debug-geom-bounds')) {
            this.eachGObj(renderList, this.renderBounds);
          }

          this.draw.cleanupFrame(renderRect);
        }
        this.monitor.stateChange('idle');
      },
      /* Prepares all gobjs in the sketch for render, if they haven't been prepared already */
      // SS: As far as I can tell, this is called only from AttachToNode().
      renderPrepare: function() {
        var renderList = $.grep(this.gobjList.renderList, function(gobj) {
          return gobj.needsRenderInit;
        });

        function prepareOneGObj(index, gobj, sketch) {
          var dc;
          try {
            dc = sketch.dcForGObj(gobj);
            if (dc) {
              // renderPrepare may modify its second argument, so we
              // pass in a fresh object with every call.  Jon and Lyn
              // think this interface should be rewritten to remove
              // the second argument.
              sketch.renderRefCon.gobj[gobj.id] = gobj.renderPrepare(dc, {});
            }
            if (gobj.hasLabel) {
              dc = sketch.dcForGObjLabel(gobj);
              if (dc) {
                // Pass another fresh object.
                sketch.renderRefCon.label[gobj.id] = gobj.renderLabelPrepare(
                  dc,
                  {}
                );
              }
            }
            gobj.needsRenderInit = false;
          } catch (ex) {
            ex.code = 'GSP.Error.renderPrepareException';
            ex.message = GSP.Strings.loc(
              'GSP.Error.renderPrepareException',
              gobj.id,
              gobj.kind,
              ex
            );

            GSP.signalCaughtError(ex);
          }
        }

        this.eachGObj(renderList, prepareOneGObj);
      },
      renderCleanupGObj: function(gobj) {
        var sketch = this;

        try {
          var dc = sketch.dcForGObj(gobj);
          if (dc) {
            gobj.renderCleanup(dc, sketch.renderRefCon.gobj[gobj.id]);
          }

          if (gobj.hasLabel) {
            dc = sketch.dcForGObjLabel(gobj);
            if (dc) {
              gobj.renderLabelCleanup(dc, sketch.renderRefCon.label[gobj.id]);
            }
          }

          if (sketch.renderRefCon.gobj[gobj.id]) {
            delete sketch.renderRefCon.gobj[gobj.id];
          }

          if (sketch.renderRefCon.label[gobj.id]) {
            delete sketch.renderRefCon.label[gobj.id];
          }

          if (sketch.renderRefCon.dcForGObj[gobj.id]) {
            delete sketch.renderRefCon.dcForGObj[gobj.id];
          }

          if (sketch.renderRefCon.geomBounds[gobj.id]) {
            delete sketch.renderRefCon.geomBounds[gobj.id];
          }

          if (sketch.renderRefCon.renderBounds[gobj.id]) {
            delete sketch.renderRefCon.renderBounds[gobj.id];
          }

          if (sketch.renderRefCon.labelBounds[gobj.id]) {
            delete sketch.renderRefCon.labelBounds[gobj.id];
          }
        } catch (ex) {
          ex.code = 'GSP.Error.renderCleanupException';
          ex.message = GSP.Strings.loc(
            'GSP.Error.renderCleanupException',
            gobj.id,
            gobj.kind,
            ex
          );

          GSP.signalCaughtError(ex);
        }
      },
      renderCleanUp: function() {
        var sketch = this;

        this.eachGObj(
          this.getRenderList(),
          function(index, gobj) {
            sketch.renderCleanupGObj(gobj);
          },
          { direction: 'reverse' }
        );
      },
      getName: function() {
        var metadata = this.spec.metadata;
        return metadata.title;
      },
      toSpecObj: function() {
        var json = {},
          gobjects = this.gobjList.gobjects;

        json.metadata = $.extend(true, {}, this.metadata);
        //This would be incorrect if we ever made changes to our local preferences that we wanted preserved in the file spec
        json.preferences = $.extend(true, {}, this.spec.preferences);
        json.objects = {};

        for (var key in gobjects) {
          if (gobjects.hasOwnProperty(key)) {
            json.objects[key] = gobjects[key].toSpecObj();
          }
        }

        // The exporter may leave this field blank if there are no
        // objects in a page, so this avoids spurious diffs.
        if ($.isEmptyObject(json.objects)) delete json.objects;

        return json;
      },

      /**
       * Destroys and cleans up all gobjects.
       */
      cleanUp: function() {
        // we should not clean up things twice. The presense of this method
        // is taken to betoken whether we have already been called.
        if (this.draw === null) {
          return;
        }
        this.event('UnloadPage', { document: this });
        this.eachGObj(
          function(i, gobj, sketch) {
            try {
              if (gobj.destroy) {
                gobj.destroy();
              }
            } catch (ex) {
              ex.code = 'GSP.Error.destroyObjectException';
              ex.message = GSP.Strings.loc(
                'GSP.Error.destroyObjectException',
                gobj && gobj.id,
                gobj && gobj.kind,
                ex
              );

              GSP.signalCaughtError(ex);
            }
          },
          { direction: 'reverse' }
        );

        if (this.canvasNode) {
          this.canvasNode.off();
        }
        this.renderCleanUp();
        if (this.draw) {
          this.draw.destroy();
        }
        this.gobjList = null;
        this.draw = null;
        GSP.logPerf(this.monitor.report(this.getName(), 'final'));
      },
      getAuthorPreference: function(prefName) {
        var pageId = this.metadata.id,
          pref = this.document.getAuthorPreference(prefName, pageId);
        if (Array.isArray(pref)) {
          // Array prefs are assumed to be page arrays or "all"
          return pref[0] === 'all' || pref.indexOf(pageId) >= 0;
        } else {
          return pref;
        }
      },
      /**
       * Constrains and redraws synchronously.
       *
       * @returns {undefined}
       */
      constrainAndRedraw: function() {
        this.constrain();
        this.render();
      },

      _displayJob: null,

      /**
       * Requests a draw job - which executes asynchronously.  It is safe to call
       * this method repeatedly before the render occurs.  In that case, only one
       * render will occur.
       *
       * @returns {undefined}
       */
      setNeedsDisplay: function() {
        var sketch = this;

        if (!GSP.JobScheduler.isActive(sketch._displayJob)) {
          sketch._displayJob = this.jobScheduler.addJob(
            function() {
              sketch.constrain();
              sketch.render();
              sketch._displayJob = null;
              return false;
            },
            {
              priority: 'render',
            }
          );
        }
      },

      /**
       * Is called after the sketch is fully initialized, but before it has begun
       * handling normal user interaction. Invokes the onLoad method of every
       * gObject, giving gObjects the opportunity do final setup.
       * Once all setup is completed, sorting will be perform.
       * @param {String} mode is "pageSwitch", "undoRedo", or "toolDone"
       */
      onLoad: function(mode) {
        var ix;
        if (this.gobjList.constraintList) {
          for (ix = 0; ix < this.gobjList.constraintList.length; ix += 1) {
            this.gobjList.constraintList[ix].onLoad(this, mode);
          }
          this.sortAllGobj();
        }

        this.setGobjPositionInDocumentBound();
      },

      /**
       * Is called after all sketch user interaction has ceased but before the
       * objects have been cleaned up. Invokes the onUnload method of every
       * gObject.
       */
      onUnload: function() {
        var ix;
        if (this.gobjList.constraintList) {
          for (ix = 0; ix < this.gobjList.constraintList.length; ix += 1) {
            this.gobjList.constraintList[ix].onUnload();
          }
        }
      },

      /**
       * Sort gobj elements once all are created.
       */
      sortAllGobj: function() {
        var sortNum = 0,
          customTabOrderArr = this.wspSaysAndTabsObjects.wspTabsGobjsId;
        var $textLayer = this.selector('.wsp-text-layer');

        function isSorted(arr) {
          // Return true if Array is sorted.
          var limit = arr.length - 1;
          return arr.every(function(_, i) {
            return i < limit ? arr[i] <= arr[i + 1] : true;
          });
        }

        if (this.wspSaysAndTabsObjects.wspTabsExist) {
          // Sorting for custom tab order with WSP-TABS
          $textLayer.find('.wsp-accessible').each(function() {
            if (customTabOrderArr.indexOf($(this).attr('wsp-id')) > -1) {
              $textLayer.append(
                $('[wsp-id=' + customTabOrderArr[sortNum] + ']')
              );
              sortNum++;
            } else {
              $(this).attr({ 'aria-hidden': 'true', tabindex: '-1' });
            }
          });
        } else {
          // Sorting for default tab order on the basis of JSON order
          var wspIdArr = [];
          this.selector('.wsp-accessible').each(function(index, element) {
            wspIdArr.push($(element).attr('wsp-id'));
          });
          if (isSorted(wspIdArr)) return;

          $textLayer
            .find('.wsp-accessible')
            .sort(function(a, b) {
              return $(a).attr('wsp-id') - $(b).attr('wsp-id');
            })
            .appendTo($textLayer);
        }
      },

      /**
       * Starts the sketch.
       * Runs constrainAndRedraw() to make sure that the model
       * is consistent and to construct the display for the first time.
       * This process also starts the frame rate timeout.
       * @param {String} mode is "pageSwitch", "undoRedo", "toolDone", or undefined
       */
      start: function(mode) {
        var sketch = this;

        if (sketch.state !== 'started') {
          sketch.state = 'started';
          sketch.constrainAndRedraw();
          // Complete the performance logging for the init phase, and
          // begin performance logging for the operational phase.
          GSP.logPerf(sketch.monitor.report(sketch.getName(), 'init'));
          sketch.monitor = new GSP.PerfMonitor();
          mode = mode ? mode : '';
          sketch.onLoad(mode);

          // in performance test mode we want to exercise the system under
          // stress, so we set the dirty rect on each frame.
          if (sketch.getOption('perfTestMode')) {
            sketch.jobScheduler.addJob(
              function() {
                sketch.dirtyRect = GSP.Geom.kInfiniteRect;
                sketch.isDirty = true;
                sketch.setNeedsDisplay();
              },
              { repeat: true }
            );
          }
        } else {
          GSP.signalErrorWithCode('GSP.Error.invalidSketchStart');
        }
        return this;
      },

      /**
       * Gets the sketch page's ID.
       *
       * @returns String
       */
      getPageId: function() {
        return this.metadata.id;
      },

      /**
       * Stops the sketch.
       * Sets the ended flag which will cause the frame rate handler to
       * stop and initiate cleanup of sketch resources.
       */
      stop: function() {
        if (this.state !== 'stopped') {
          this.popAllTouchRegimes();
          this.jobScheduler.clearAllJobs();
          this._displayJob = null;
          this.onUnload();
          this.state = 'stopped';
          this.cleanUp();
        } else {
          GSP.signalErrorWithCode('GSP.Error.invalidSketchStop');
        }
        return this;
      },

      pause: function() {
        this.jobScheduler.clearAllJobs();
        this._displayJob = null;
        GSP.log('Paused sketch.');
        return this;
      },

      resume: function() {
        this.setNeedsDisplay();
        GSP.log('Resumed sketch.');
        return this;
      },

      /**
       * Creates clones of the gobjlist.
       *
       * A GObject clone is a lightweight copy of the original gobject. Only certain of the fields
       * in the clone should be considered editable - everything else should be treated as read-only.
       * (an edit of the "read-only" fields will actually write to the parent gobject).
       *
       * Valid cloned GObject fields to change:
       *   geom and sub-attributes
       *   state and sub-attributes
       *   style.* (only one level deep)
       *
       * In addition, the set of cloned gobjects form a cohort with respect to gobject parentage.
       * This means that the parent gobject list of the clone preferentially reference any fellow
       * clones of this cohort. Thus, reconstraint of the cohort will propagate down a topologically
       * ordered cohort of clones - and because they are clones, the original non-cloned objects
       * will not be affected by this reconstraint.
       *
       * @param {array} gobjlist Array of GObjects to clone sorted in topological order
       * @return {Array} list of cloned GObjects sorted in topological order
       */
      cloneGObjects: function(gobjlist) {
        var i,
          j,
          clone,
          tmp,
          clones = [],
          cloneMap = {},
          dest;

        // Create the clones
        for (i = 0; i < gobjlist.length; i++) {
          clone = Object.create(gobjlist[i]);
          cloneMap[clone.id] = clone;
          clones.push(clone);

          // Mark as a clone for debugging sanity.
          clone.isClone = true;
        }

        // Re-target parent references to clone-cohort fellows.
        for (i = 0; i < clones.length; i++) {
          clone = clones[i];

          tmp = clone.parents; // Originals copy of parents
          clone.parents = {};
          for (j in tmp) {
            dest = tmp[j];
            clone.parents[j] = cloneMap[dest.id] ? cloneMap[dest.id] : dest;
          }

          tmp = clone.parentsList; // Originals copy of parentsList
          clone.parentsList = [];
          for (j = 0; j < tmp.length; j++) {
            dest = tmp[j];
            clone.parentsList.push(
              cloneMap[dest.id] ? cloneMap[dest.id] : dest
            );
          }

          clone.initializeClone(gobjlist[i]);
        }

        return clones;
      },

      getDisplayObjForGObj: function(gobj) {
        return this.renderRefCon.gobj[gobj.id];
      },

      /**
       * hitGObj() selects a gobject to respond to a touch.
       * Searches gobjects in reverse topological order and returns object(s) in the vicinity of the cursor.
       * @param {object} rect: A rectangle describing an area of the canvas in canvas coordinates.
       * @param {Object} options:
       *   hotSpot: {Object} If present, has pageX, pageY, mouseEvent fields from source hit event.
       *   gobjArray: {Array} A list of gobjects to test for hit. If undefined, defaults to the current renderList.
       *     Note that the gobjArray is searched in reverse order, preferring newer objects over older ones.
       *   filter: {Function} Optional callback that will filter objects from hit test
       *   postHitFilter: {Function} Optional callback that will filter objects after verifying that they are hit
       *   maxResults: {Number} if defined, this function will return an array of hit objects up to maxResults
       *   assumeArrowSelectable: {Boolean} If true, finds hit gobjects whether or not they're arrow selectable
       *    (If assumeArrowSelectable is true and maxResults > 1, the caller is responsible for deciding
       *    whether to prioritize selectable objects in the returned array.
       *
       *   When called during toolplay for matching given objects, the desired criteria are as follows:
       *   1. Front-most objects are preferred.
       *   2. Selectable objects are preferred to unselectable objects if maxResults === 1.
       *   3. Newly-constructed objects are preferred.
       *   Searching the renderList in reverse order takes care of criteria 1 and 3.
       *   Criterion #2 is more complicated; both toolplay and widgets use it.
       *   If assumeArrowSelectable===true and maxResults===1, this call may be a toolplay match-given scenario,
       *   so we cache the first hit if it's non-selectable, and keep looking for a selectable object with the same z-index.
       *   If we find a selectable object, return it; otherwise if we've cached an unselectable object return it.
       *
       *   Desktop allows repeated taps to cycle through overlapping object in the same layer.
       *   To implement this in WSP, we employ a similar approach, keeping track of the last-hit object
       *   and (if it's still in the front-most layer of candidates) use it as the starting place
       *   for a circular search of that front-most layer.
       *
       * @return {Object} with properties:
       *   - customTracker (possibly undefined): the touchTracker that should handle the hit
       *   if no maxResults option:
       *     - hitGObj: the gobj that was hit (possibly null)
       *   if maxResults option is defined:
       *     - hitArray: the array of hit objects
       */
      hitGObj: function(rect, options) {
        options = options || {};

        if (this.focusedGobj) {
          return {
            hitArray: [this.focusedGobj],
          };
        }

        var hit = false,
          results = [],
          hotSpot = options.hotSpot,
          maxResults = options.maxResults || 1,
          arrayOfGObjs = options.gobjArray || this.gobjList.renderList,
          filter = options.filter,
          postHitFilter = options.postHitFilter,
          gobjHitTestOptions = options.gobjHitTestOptions,
          ret = {},
          canHitGObj,
          pushInLayer,
          hitZ,
          gobjZ;

        function hitOneGObj(index, gobj) {
          if (filter && filter(gobj) === false) {
            return undefined;
          }

          if (
            canHitGObj(gobj) &&
            GSP.Geom.isIntersectRects(gobj.getGeomBounds(), rect)
          ) {
            hit = gobj.hitTest(rect, hotSpot, gobjHitTestOptions);
            gobjZ = Math.floor(GSP.layerInfo(gobj).z_index);
            if (results.length === 0) {
              hitZ = gobjZ;
            }
            if (hit && (!postHitFilter || postHitFilter(gobj))) {
              if (maxResults === 1 && options.assumeArrowSelectable) {
                // looking for a single hit for a tool
                // Return the most recently constructed selectable gobj in top z layer, or most recently constructed unselectable gobj in same layer.
                // gobj.id corresponds to construction order, so use it to tell which gobj in highest layer to return.
                // If the hit gobj is unselectable, cache it and keep going; return it only if there's no selectable object in the same layer.
                if (results.length === 0) {
                  results.push(gobj); // no results yet, so track this gobj
                } else if (gobjZ < hitZ) {
                  return false; // Bail if we hit a lower layer than the current result
                } else if (gobj.style.selectable) {
                  // prefer selectable to non-selectable or higher id to lower id
                  if (!results[0].style.selectable || +gobj.id > +results[0].id)
                    results[0] = gobj;
                } else if (
                  !results[0].style.selectable &&
                  +gobj.id > +results[0].id
                )
                  // if both are non-selectable prefer higher id
                  results[0] = gobj;
              } else {
                // push, but in front of any unselectable gobjs of the same layer.
                pushInLayer(gobj); // push even if !gobj.style.selectable; caller must discriminate
              }
              if (hit !== true)
                // Bail early if custom tracker, even if maxResults not reached
                return false;
              if (maxResults > 1 && results.length === maxResults)
                // If looking for a single gobj don't bail until we know it's the most recently constructed
                return false;
            }
          }
          return undefined;
        }

        if (options.assumeArrowSelectable || options.unselectableTapOK) {
          canHitGObj = function(gobj) {
            var wasSelectable = gobj.style.selectable,
              ret;
            gobj.style.selectable = true;
            ret = gobj.isHittable();
            gobj.style.selectable = wasSelectable;
            return ret;
          };
          pushInLayer = function(gobj) {
            // Push the gobj into results.
            // If it's selectable, put it in front of any unselectable gobjs in the same layer.
            var ix = results.length,
              z = Math.floor(GSP.layerInfo(gobj).z_index),
              prev;
            if (gobj.style.selectable) {
              for (; ix > 0; ix--) {
                prev = results[ix - 1];
                if (
                  prev.style.selectable ||
                  z < Math.floor(GSP.layerInfo(prev).z_index)
                ) {
                  break;
                }
              }
            }
            results.splice(ix, 0, gobj);
          };
        } else {
          canHitGObj = function(gobj) {
            return gobj.isHittable();
          };
          pushInLayer = function(gobj) {
            results.push(gobj);
          };
        }
        this.eachGObj(arrayOfGObjs, hitOneGObj, { direction: 'reverse' });
        if (options.maxResults === undefined) {
          ret.hitGObj = results[0];
        } else {
          ret.hitArray = results;
        }
        if (hit !== true && (results.length === 1 || gobjZ >= hitZ)) {
          // return the custom tracker if it's not behind other hits
          ret.customTracker = hit;
        }

        return ret;
      },

      hitLabel: function(rect) {
        var result;

        function hitOneLabel(_index, gobj) {
          if (
            !gobj.style.hidden &&
            gobj.labelRenderBounds &&
            gobj.style.label.showLabel &&
            GSP.Geom.isIntersectRects(gobj.labelRenderBounds, rect)
          ) {
            result = gobj;
            return false;
          }
          return undefined;
        }

        this.eachGObj(this.gobjList.renderList, hitOneLabel, {
          direction: 'reverse',
        });
        return result;
      },

      /**
       * GObject list iteration idiom.
       * @param {array} gobjList A list of GObjects to iterate over. Defaults to the sketch gobjList.
       * @param {function} callback callback function callback(index, gobj, sketch)
       *  callback is given index, gobj (same as this), sketch (calling sketch)
       *  callback's context is the current gobj.
       *  return false to terminate iteration.
       * @param {object} options
       *    'direction': 'forward' (default), 'reverse'
       * @return {GSP.Sketch} the Sketch
       */
      eachGObj: function(gobjList, callback, options) {
        var opt,
          i,
          gobj,
          ret,
          forward,
          sketch = this;

        // If there's no gobjList, shift and default.
        if (!$.isArray(gobjList)) {
          options = callback;
          callback = gobjList;

          gobjList = sketch.gobjList.constraintList;
        }

        opt = $.extend({ direction: 'forward' }, options);
        forward = opt.direction === 'forward';

        for (i = 0; i < gobjList.length; i++) {
          gobj = forward ? gobjList[i] : gobjList[gobjList.length - i - 1];
          ret = callback.call(gobj, i, gobj, sketch);
          if (false === ret) {
            break;
          }
        }

        return this;
      },
      /**
       * Search for an existing coordinate system in the sketch.  Prefer visible over hidden,
       * then prefer matching axis tick numbering (trig vs decimal).
       *
       * see AutomarkCoordSysInternal() for reference implementation
       *
       * @param sketch
       * @param automatchSpec
       * @returns {Object} coordSys
       */
      findExistingCoordSys: function(automatchSpec) {
        var foundCoordSys = null,
          curMatchScore = -1,
          kMaxMatchScore = 6,
          desiredXNumbering,
          desiredYNumbering;

        if (automatchSpec) {
          desiredXNumbering = automatchSpec.xAxisTrig
            ? 'trigonometric'
            : 'decimal';
          desiredYNumbering = automatchSpec.yAxisTrig
            ? 'trigonometric'
            : 'decimal';
        }

        this.eachGObj(function(index, gobj) {
          var thisMatchScore = 0;
          if (gobj.constraint === 'CoordSys' && gobj.state.exists) {
            if (gobj.isVisible()) {
              thisMatchScore += 4;
            }

            if (
              gobj.getParent('axisX').style.tickNumbering === desiredXNumbering
            ) {
              thisMatchScore += 1;
            }

            if (
              gobj.getParent('axisY').style.tickNumbering === desiredYNumbering
            ) {
              thisMatchScore += 1;
            }

            if (thisMatchScore === kMaxMatchScore) {
              foundCoordSys = gobj;
              return false;
            }

            if (thisMatchScore > curMatchScore) {
              foundCoordSys = gobj;
              curMatchScore = thisMatchScore;
            }
          }
        });

        return foundCoordSys;
      },

      /*
       * Debug function to diagnose the correctness of the constrained
       * sketch against debug values suppled in the sketch spec (put there
       * generally by Web Exporter output).
       */
      verifyFromSpec: function(args) {
        var ret = { success: true, failures: {} },
          failedOrExemptedGObjs = {}; // Track failed gobjs to prevent testing of ancestors

        this.eachGObj(function(i, gobj, sketch) {
          var msg, specGObj;

          function verificationString(specGObj) {
            try {
              return gobj.verificationString(specGObj);
            } catch (error) {
              return 'Verification Failed: ' + String(error);
            }
          }

          // If a parent has failed, then we're failed too
          gobj.eachParent(function(index, parentGObj) {
            if (failedOrExemptedGObjs[parentGObj.id]) {
              failedOrExemptedGObjs[gobj.id] = true;
              return false;
            }
          });

          // Ok, now if we haven't yet failed, do stuff ...
          if (!failedOrExemptedGObjs[gobj.id]) {
            specGObj = sketch.spec.objects[gobj.id].debug;
            msg = specGObj ? verificationString(specGObj) : 'no expected data';
            if (msg === 'NO_VERIFICATION') {
              failedOrExemptedGObjs[gobj.id] = true; // Suppress downstream children errors.
            } else if (msg !== '') {
              ret.success = false;
              ret.failures[gobj.id] = msg;
              failedOrExemptedGObjs[gobj.id] = true; // Suppress downstream children errors.
            }
          }
        });

        return ret;
      },

      /**
       * Wrapper for standard jQuery selector $(cssSelector) whose search is
       * rooted at the current sketch canvas.
       * @return {object} jQuery Object
       */
      selector: function(cssSelector) {
        return $(cssSelector, this.canvasNode);
      },
      /**
       * Accessor for the run-time option configuration of the sketch.
       *
       * Supported options are currently private, in the sense that
       * we don't document them - they are mostly intended for testing.
       *
       * This method first tests sketch-specific options, which can be part of
       * the sketch specification and then checks the global gOptions if there
       * is no sketch-specific option by that name.
       *
       * Options:
       *   'bap-useDebugControlList': will prefer the controlList pre-computed in the debug
       *           attribute of the gobj, if present. Presumably that's a better list, until the full BAP
       *           algorithm is implemented in WSP!
       *   'perfTestMode': run performance tests
       *   'instantiateUnsupportedObjects': instantiate kinds, constraints, etc. marked as unsupported
       *                                    This is useful for development, testing, etc.
       *
       */
      getOption: function(opt) {
        var sketchOption = this.options[opt];
        return sketchOption !== undefined ? sketchOption : GSP.gOptions[opt];
      },
      /**
       * Translates the sketch with respect to its view
       * @param {number} dx
       * @param {number} dy
       * @param {Boolean} constrain - if true, constrains the translation to the current
       * significantBounds rect
       */
      translate: function(dx, dy, constrain) {
        var diff, testBounds;

        if (constrain) {
          if (this.preferences.limitScrolling) {
            var sketchRect = this.metadata.sketchRect,
              originalSketchRect = this.spec.metadata.sketchRect,
              sketchRectWidth = sketchRect.right - sketchRect.left,
              sketchRectHeight = sketchRect.bottom - sketchRect.top,
              originalSketchRectWidth =
                originalSketchRect.right - originalSketchRect.left,
              originalSketchRectHeight =
                originalSketchRect.bottom - originalSketchRect.top;
            testBounds = $.extend(true, {}, sketchRect);
            if (originalSketchRectWidth > sketchRectWidth) {
              testBounds.left = originalSketchRect.left;
              testBounds.right = originalSketchRect.right;
            }
            if (originalSketchRectHeight > sketchRectHeight) {
              testBounds.top = originalSketchRect.top;
              testBounds.bottom = originalSketchRect.bottom;
            }
          } else {
            // Allow some "slop" for scrolling.
            testBounds = $.extend(true, {}, this.significantBounds);
            var width =
                this.metadata.sketchRect.right - this.metadata.sketchRect.left,
              height =
                this.metadata.sketchRect.bottom - this.metadata.sketchRect.top;
            testBounds = GSP.Geom.insetRect(
              testBounds,
              -width / 2,
              -height / 2
            );
          }
          if (dx < 0) {
            diff = testBounds.left - this.metadata.sketchRect.left;
            dx = diff > dx ? diff : dx;
          } else if (dx > 0) {
            diff = testBounds.right - this.metadata.sketchRect.right;
            dx = diff < dx ? diff : dx;
          }
          if (dy < 0) {
            diff = testBounds.top - this.metadata.sketchRect.top;
            dy = diff > dy ? diff : dy;
          } else if (dy > 0) {
            diff = testBounds.bottom - this.metadata.sketchRect.bottom;
            dy = diff < dy ? diff : dy;
          }
        }

        this.translateTraceLayer(dx, dy);

        if (!(dx === 0 && dy === 0)) {
          this.metadata.sketchRect.left += dx;
          this.metadata.sketchRect.right += dx;
          this.metadata.sketchRect.top += dy;
          this.metadata.sketchRect.bottom += dy;

          this.invalidateRect(this.sketchRect());
          this.isDirty = true;
          this.setNeedsDisplay();
        }
      },
      //todo - these methods do not yet handle scaling transforms
      //(and our canvas rect management system will not be able to handle
      // rotations that aren't axis-aligned)
      primalToViewTransform: function() {
        return new GSP.AffineTransform({
          m00: 1,
          m01: 0,
          m10: 0,
          m11: 1,
          m20: -this.metadata.sketchRect.left,
          m21: -this.metadata.sketchRect.top,
        });
      },
      viewToPrimalTransform: function() {
        return new GSP.AffineTransform({
          m00: 1,
          m01: 0,
          m10: 0,
          m11: 1,
          m20: this.metadata.sketchRect.left,
          m21: this.metadata.sketchRect.top,
        });
      },
      sketchRect: function() {
        return $.extend(true, {}, this.metadata.sketchRect);
      },

      /*
       * Push a new touch regime on to the regime stack, and make it the active
       * regime.
       *
       * @param {type} regime.  Regime should be a subclass of TouchRegime.
       * @returns {undefined}
       */
      pushTouchRegime: function(regime) {
        this._touchRegimes.push(regime);
        regime.isPushed = true;
      },
      /*
       * Pops the current touch regime off the stack.  Note: Clients should ensure
       * not to pop the last touch regime.
       *
       * @returns {TouchRegime}
       */
      popTouchRegime: function() {
        var regime = this._touchRegimes.pop();
        regime.isPushed = false;

        if (regime.delegate && regime.delegate.regimeDidPop) {
          regime.delegate.regimeDidPop(regime);
        }

        return regime;
      },
      /**
       * Typical method for clients who want to restore sketch touch regime
       * state back to how they found it.  Pops all touch regimes off the
       * touch regime stack including the passed in regime.  The pops happen
       * in LIFO order.
       *
       * This method is a no-op if this regime is not on the stack.
       *
       * @param regime
       */
      popAllTouchRegimesIncluding: function(regime) {
        if (!regime.isPushed) return;

        var poppedRegime;

        do {
          poppedRegime = this.popTouchRegime();
        } while (poppedRegime !== regime);
      },

      popAllTouchRegimes: function() {
        if (!this.hasTouchRegimes()) return;
        this.popAllTouchRegimesIncluding(this._touchRegimes[0]);
      },

      hasTouchRegimes: function() {
        return this._touchRegimes.length > 0;
      },
      /*
       * Gets the active touch regime.  Throws an error if there are no touch regimes.
       * @returns {Object} the active touch regime
       */
      currentTouchRegime: function() {
        var topIndex = this._touchRegimes.length - 1;

        if (topIndex < 0) {
          throw GSP.createError(
            'currentTouchRegime called with no touch regime active'
          );
        }

        return this._touchRegimes[topIndex];
      },

      // Returns whether the regime should prevent undo, toolplay
      // confirm/cancel from occurring.
      touchRegimeBlocksOtherButtons: function() {
        // Need to check hasTouchRegime() first
        return (
          this.hasTouchRegimes() &&
          this.currentTouchRegime().blocksOtherButtons()
        );
      },

      touchRegimeDisablesTracing: function(gobj) {
        //  Don't trace a tool's objects until the tool is finished.
        var touchRegime = this.currentTouchRegime();
        if (touchRegime.name !== 'ToolRegime') return false;
        return touchRegime.toolplaySession.constructedObjects[gobj.id]
          ? true
          : false;
      },

      getGivenMatchedToCandidate: function(candidate) {
        var activeRegime =
            this.toolController && this.toolController.activeRegime,
          matchedGiven;
        if (activeRegime) {
          matchedGiven = activeRegime.toolplaySession.existingMatchedGivenForMergeCandidate(
            candidate
          );
          if (matchedGiven) return matchedGiven.given;
        }
        return undefined;
      },

      /* Supports merging one sketch object (the mergeGObj) to another (the candidate).
       * Merging occurs during dragging when a mergeGObj dragTracker detects that it should be merged to a candidate.
       * Merging also occurs at the end of toolplay when a matchedGiven is finalized by merging to its candidate.
       */
      mergeGobjToCandidate: function(mergeGobj, candidate, option) {
        var sketch = this,
          list = sketch.gobjList,
          commonChildren = [], // array of gobjs that have both mergeGobj and candidate as parents.
          session;

        /* When two objects are merged during toolplay, it's often the case that they have children that
         * should also be merged; otherwise we end up with (for instance) multiple segments from A to B.
         * This function compares the children of mergeGobj with those of candidate to find and merge
         * pairs of children as appropriate. "Appropriate" is the key word here; the test necessarily
         * varies by kind and by constraint.
         * Each kind or constraint that supports merging should provide its gobjs with
         * a canMergeTo(gobj) function that determines whether the passed gobj can be merged to it.
         * NOTE: only a few objects currently provide such a function.
         * NOTE: children of non-points are not currently tested. For instance, merging two segments with midpoints
         * will create two midpoints on the same segment. The proper place for checkGivenChildren()
         * is in mergeToGObj(), so that it operates recursively.
         * FURTHER, if the merged objects both have the same child (e.g., endpoints of a segment are merged)
         * the result may be to collapse the child. In the segment example, a midpoint or point-on-segment
         * should be merged to the merged endpoints. This is currently unimplemented; the implementation
         * should be similar to the canMergeTo() mechanism. The segment constraint should have a function
         * collapseDoubledParent() that determines what to do in the event that a segment ends up with
         * a doubled parent -- that is, if both parents are the same point.
         * This same mechanism could turn a hexagon into a pentagon if two adjacent vertices are merged.
         */
        function checkGivenChildren(gobj) {
          // If two children of the merged gobj are "functionally identical", merge them.
          // "Functionally identical" is defined by the existing child's canMergeTo() function.
          // Can we relax the restriction that this applies only to children of points being merged?
          if (
            gobj.kind === 'Point' ||
            gobj.kind === 'Straight' ||
            gobj.genus.match(/Parameter/)
          ) {
            gobj.children.forEach(function(child1, ix) {
              var j, child2;
              for (j = ix + 1; j < gobj.children.length; j++) {
                child2 = gobj.children[j];
                if (
                  child1 !== child2 &&
                  child1.constraint === child2.constraint && // Consider only distinct gobjs with the same constraint
                  child1.canMergeTo &&
                  child1.canMergeTo(child2)
                ) {
                  // canMergeTo must exist and return true
                  list.mergeToGObj(child2, child1, option);
                  checkGivenChildren(child1); // This merge may enable the merging of two of child1's children
                }
              }
            });
          }
        }

        function listCommonChildren(gobj1, gobj2) {
          // If gobj1 and gobj2 are both parents of the same child, merging them may impact the common child.
          // Record them before merging, to take action later.
          gobj1.children.forEach(function(child1, ix) {
            gobj2.children.forEach(function(child2, iy) {
              if (child1 === child2) {
                // the merged gobj will be a double parent; can the child be collapsed?
                commonChildren.push(child1);
              }
            });
          });
        }

        function processCommonChildren() {
          // Each element is a common child of the two gobjs that were merged.
          commonChildren.forEach(function(child, ix) {
            if (child.collapseDoubledParent)
              // some children can collapse (segments, circles) if they have a double parent
              child.collapseDoubledParent(candidate);
          });
        }

        // Update the style of an existing gobject based
        // on the mergeGobj that has just been merged.
        // Generally the candidate style wins out,
        // but there are selected exceptions.
        function mergeGobjStyles(mergeGobj, candidate) {
          if (mergeGobj.style.traced) {
            candidate.style.traced = mergeGobj.style.traced;
          }
          if (mergeGobj.style.label && mergeGobj.style.label.showLabel) {
            candidate.style.label.showLabel = true;
          }
        }

        // Body of mergeGobjToCandidate()
        if (candidate.constraint === 'Pegged') {
          candidate = candidate.parents.text;
        }
        listCommonChildren(mergeGobj, candidate);
        list.mergeToGObj(mergeGobj, candidate, option);
        processCommonChildren();
        checkGivenChildren(candidate);

        // mergeToGObj() may have re-ordered the topologicalIndex values, so sort the constraint list
        // and reset the topologicalIndex values to match the list indices.
        list.constraintList.sort(function(a, b) {
          return a.topologicalIndex - b.topologicalIndex;
        });
        $.each(list.constraintList, function(key, gobj) {
          gobj.topologicalIndex = key;
        });

        //if we generated a label, we need to give it back.  The easiest way
        //of doing this is to just restore our label state, since labelPool
        //will automatically find and skip any other givens we generated labels for
        //along the way, at a minor cost of efficiency
        if (sketch.generatedLabels && sketch.generatedLabels[mergeGobj.id]) {
          session = sketch.labelPool.restoreSavedState();
          sketch.labelPool.saveState(session);
          sketch.generatedLabels[mergeGobj.id] = false;
        }
        list.mergeGObjsInList(mergeGobj.id, candidate.id); // let the list delete duplicated gobjs
        mergeGobjStyles(mergeGobj, candidate);

        //Existing doesn't actually need constraint, but all its children do
        //For simplicity, just invalidate itself.  Some objects actually do need
        //reconstraint if their child list changes (iterate map), though they
        //are not likely to be merged.
        candidate.invalidateGeom();
        return candidate;
      },

      _mergeGObjToSpecGObj: function(gobj, specGObjToCreate) {
        var gobjList = this.gobjList,
          specObjs = {},
          newId =
            '' + GSP.ObjectGraph.getNextFreeIdNumber(gobjList.constraintList),
          newGObj;
        specObjs[newId] = specGObjToCreate;
        this.constructGObjects(specObjs);
        newGObj = gobjList.gobjects[newId];
        this.mergeGobjToCandidate(gobj, newGObj /*, this.constructedObjects*/); // this.constructedObjects not needed
        return newGObj;
      },

      putGivenOnPath: function(givenGObj, path, value) {
        var newSpec = {
          kind: 'Point',
          genus: 'PointOnPath',
          parents: {
            path: path.id,
          },
          value: value,
          constraint: 'PointOnPath',
          label: givenGObj.label,
          style: givenGObj.style,
        };

        return this._mergeGObjToSpecGObj(givenGObj, newSpec);
      },

      findPotentialIntersection: function(path1, candidates, pos, hitSlop) {
        // When a tool given or drag merge is near several intersections,
        // we prefer intersections of like kinds (straight/straight or circle-arc/circle-arc)
        var thisIntersection, // current best choice
          returnedIntersectionInfo;

        function isSupportedIntersectionPath(gobj) {
          //The only currently supported intersection types are
          //Circle, Straight, and Arc
          return (
            gobj.isOfKind('Circle') || // are circle interiors ok?
            gobj.isOfKind('Straight') ||
            gobj.kind === 'Arc'
          ); // don't allow arc interiors
        }

        function checkForIntersectingPath(path2) {
          var path1IsStraightKind = path1.isOfKind('Straight');
          var path2IsStraightKind = path2.isOfKind('Straight');
          var path1GeomObj = path1IsStraightKind
            ? path1
            : path1.getGeometricArc();
          var path2GeomObj = path2IsStraightKind
            ? path2
            : path2.getGeometricArc();
          var path1IsStraight =
            path1IsStraightKind || path1GeomObj.orientation === 0;
          var path2IsStraight =
            path2IsStraightKind || path2GeomObj.orientation === 0;
          var location,
            locationArray,
            useSecondIntersection,
            swapPathParents,
            constraint,
            match; // if both are straights or both circles, prefer this match

          if (path1IsStraight) {
            if (path2IsStraight) {
              location = GSP.Geom.LineLineIntersection(
                path1GeomObj,
                path2GeomObj
              );
              match = true;
            } else {
              //path1 == straight, path2 == circle.  Switch them
              swapPathParents = true;
              locationArray = GSP.Geom.CircleStraightIntersection(
                path2GeomObj,
                path1GeomObj
              );
            }
          } else {
            //Path1 is circle or arc
            if (path2IsStraight) {
              locationArray = GSP.Geom.CircleStraightIntersection(
                path1GeomObj,
                path2GeomObj
              );
            } else {
              //Both are circles or arcs
              locationArray = GSP.Geom.CircleCircleIntersection(
                path1GeomObj,
                path2GeomObj
              );
              match = true; // Should we distinguish circle/circle from arc/arc? There's no demonstrated need just yet.
            }
          }

          if (locationArray) {
            if (locationArray[0] && pos.distance(locationArray[0]) <= hitSlop) {
              location = locationArray[0];
            } else if (
              locationArray[1] &&
              pos.distance(locationArray[1]) <= hitSlop
            ) {
              location = locationArray[1];
              useSecondIntersection = true;
            }
          }

          if (location && location.isFinite()) {
            //figure out the constraint to use
            if (path1IsStraightKind && path2IsStraightKind) {
              constraint = 'Intersection';
            } else {
              if (useSecondIntersection) {
                constraint = 'Intersection2';
              } else {
                constraint = 'Intersection1';
              }
            }
            thisIntersection = {
              //path1 is normalized to be the circle if its a circle/line intersection
              path1: swapPathParents ? path2 : path1,
              path2: swapPathParents ? path1 : path2,
              location: location,
              constraint: constraint,
            };
          }
          if (match && thisIntersection) {
            returnedIntersectionInfo = thisIntersection;
            return true; // we're done; we've found an intersection of matched kinds
          } else if (!returnedIntersectionInfo) {
            // if no matched kinds, return the first intersection with unmatched kinds
            returnedIntersectionInfo = thisIntersection;
          }
          // keep searching possible paths
        } // checkForIntersectingPath

        // body of findPotentialIntersection
        if (!isSupportedIntersectionPath(path1)) {
          return;
        }
        // Both paths are already close to pos, so allow doubled hitSlop for the intersection,
        // which isn't so easy to for the user to find if the paths are anywhere close to tangency
        hitSlop *= 2;

        var hitTest,
          options = {
            hotSpot: pos,
            assumeArrowSelectable: true,
            gobjArray: candidates.filter(function(gobj) {
              return gobj !== path1;
            }),
            filter: isSupportedIntersectionPath,
            postHitFilter: checkForIntersectingPath,
          };

        hitTest = this.hitGObj(
          {
            left: pos.x - hitSlop,
            top: pos.y - hitSlop,
            bottom: pos.y + hitSlop,
            right: pos.x + hitSlop,
          },
          options
        );

        // If multiple returned objects in hitArray, need to check for the preferred path
        if (
          returnedIntersectionInfo &&
          pos.distance(returnedIntersectionInfo.location) < hitSlop
        ) {
          return returnedIntersectionInfo;
        } // else return undefined
      }, // findPotentialIntersection

      findIntersections: function(candidates, pos, hitSlop) {
        // Returns an array of returnedIntersectionInfo elements
        // We assume caller has already filtered the candidates to make sure they're within hitSlop of pos
        var arr = candidates.slice(0),
          returnedInfo = [],
          gobj,
          intersection,
          ix;
        while (arr.length > 1) {
          // Need at least two candidates to define an intersection
          gobj = arr.shift();
          // Test gobj against each remaining candidate
          for (ix = 0; ix < arr.length; ix++) {
            intersection = this.findPotentialIntersection(
              gobj,
              [arr[ix]],
              pos,
              hitSlop
            );
            if (intersection) {
              returnedInfo.push(intersection);
            }
          }
        }
        if (returnedInfo.length) {
          return returnedInfo;
        }
      },

      putGivenOnIntersection: function(givenGObj, intersectionInfo) {
        //Constructs an intersection spec from an intersectionInfo object and a
        //given GObj that will be merged to it
        function infoToGObjSpec(info, givenGObj) {
          var newSpec = {
            kind: 'Point',
            constraint: info.constraint,
            genus: 'Intersection',
            label: givenGObj.label,
            style: givenGObj.style,
          };
          switch (info.constraint) {
            case 'Intersection':
              newSpec.parents = {
                line0: info.path1.id,
                line1: info.path2.id,
              };
              break;
            case 'Intersection1':
            case 'Intersection2':
              newSpec.parents = {
                circle: info.path1.id,
                obj: info.path2.id,
              };
              break;
            default:
              throw GSP.createError(
                'tool.putGivenOnIntersection() asked to create unsupported intersection constraint'
              );
          }
          return newSpec;
        }
        var newSpec = infoToGObjSpec(intersectionInfo, givenGObj);
        return this._mergeGObjToSpecGObj(givenGObj, newSpec);
      },

      /* Initializes a sketch.  Performs no View-related initializations
       *
       * @param {Document} document
       * @param {Object} spec
       * @param {Object} (Optional) options
       */
      init: function(document, spec, options) {
        var self = this;

        this.getWSPKeysObjectFromSpecs(spec.objects);

        self.document = document;
        // sketch state can be created, started, stopped
        self.state = 'created';
        self.Bap = new GSP.Bap(self);
        self.MotionManager = new GSP.MotionManager(self);
        self.labelPool = GSP.LabelPool.createInSketch(self);
        self.toolController = GSP.ToolController.createInSketch(self);

        self.Scroll = GSP.Scroll(self);
        self.options = $.extend(true, {}, options, spec.options);
        self.metadata = $.extend(true, {}, spec.metadata);
        self.preferences = $.extend(true, {}, GSP.Prefs, spec.preferences);

        // "composite-mode": default "src-over", unless "color" is white, then "destination"
        if (
          !self.preferences.colorableComponents.Background['composite-mode']
        ) {
          self.preferences.colorableComponents.Background['composite-mode'] =
            self.preferences.colorableComponents.Background.color === 'white'
              ? 'destination'
              : 'source-over';
        }

        self.config = {};
        if (spec.config) {
          $.extend(self.config, spec.config);
        }
        self.preferences.tracesEnabled = self.document.getAuthorPreference(
          'enabletracing',
          document.metadata['start-page']
        );

        self.sQuery = GSP.SQuery(self);
        self.gobjList = new GSP.GObjList();
        self.monitor = new GSP.PerfMonitor();
        self.spec = spec;
        self.jobScheduler = GSP.JobScheduler.create();
        self._deferredGObjCalls = {};

        GSP.log('Initializing gobjs');
        self.initGObjects(self.spec.objects);
        // constraint framecount. GObjects set their state.constraintFrame to this to signal need for reconstraint.
        self.constraintFrame = 0;
      },
      /* Attaches to node, and performs all required view configuration, event
       * handlers, etc.
       *
       * @param {type} node
       * @returns {undefined}
       */
      attachToNode: function(node) {
        var self = this,
          document = self.document,
          docWidth = document.docSpec.metadata.width,
          docHeight = document.docSpec.metadata.height,
          width,
          height,
          canvasNode,
          parentNode,
          initialCSS = {};
        //Private stack of touch regimes.  Clients should use push/pop/current methods
        //to work with touch regimes.  the touch regime array is defined here, and not in
        //the prototype so that each new sketch will not share the same touch regime scope
        self._touchRegimes = [];
        self.pushTouchRegime(GSP.DisplayRegime.createInSketch(self));

        parentNode = $('.wsp-sketch-container', node[0]);
        parentNode.empty();

        parentNode.append('<div class="wsp-clip-node"></div>');
        canvasNode = self.canvasNode = $('.wsp-clip-node', node[0]);
        canvasNode.css({ width: docWidth, height: docHeight });

        self.drawRefCon = {};
        self.anchorNode = node; // anchor node is the provided html node.
        self.baseNode = $('.wsp-base-node', node);

        initialCSS.clip = 'rect(auto, auto, auto, auto)';

        width = parseInt(node.css('width'), 10);
        height = parseInt(node.css('height'), 10);
        if (self.metadata.sketchRect === undefined) {
          self.metadata.sketchRect = {
            top: 0,
            left: 0,
            // bottom and right will be set below
          };
        } else {
          width =
            self.metadata.sketchRect.right - self.metadata.sketchRect.left;
          height =
            self.metadata.sketchRect.bottom - self.metadata.sketchRect.top;
        }
        self.metadata.sketchRect.bottom = self.metadata.sketchRect.top + height;
        self.metadata.sketchRect.right = self.metadata.sketchRect.left + width;

        if (
          self.preferences.colorableComponents.Background['composite-mode'] ===
          'source-over'
        ) {
          initialCSS['background-color'] =
            self.preferences.colorableComponents.Background.color;
        }

        canvasNode.css(initialCSS);

        self.draw = GSP.draw.create({
          rootNode: canvasNode,
          width: docWidth,
          height: docHeight,
        });

        canvasNode.append($('<div class="wsp-effects"></div>'));

        self.traces = {
          saturation: 1.0,
          // 1 -> there are non-fade traces, 0 -> there are no traces
          appliedAlpha: 1,
          // How much cummulative alpha have we faded the traces by since fadeStartTime
          fadeStartTime: 0, // epoch of fade calculation. Reset periodically if traces continue to be layed down.
        };

        self.renderRefCon = {
          gobj: {},
          label: {},
          dcForGObj: {}, // gObjID -> drawContext
          geomBounds: {}, // gObjID -> sketch
          renderBounds: {}, // gObjID -> geomBoundsRect
          labelBounds: {}, // gObjID -> labelBoundsRect
        }; // gObjID -> refcon

        self.isDirty = false;
        self.dirtyRect = null;

        // Create the eventHandlers object for current page if it doesn't already exist(from a previous
        // page load of this page).  This object will store the event handlers and the ids of the
        // emitters that they are handling.
        if (!document.gobjectEventHandlers[self.getPageId()]) {
          document.createSketchEventHandlersForPage(this);
        }

        self.isTouchScreenDevice = self.isTouchScreen();
        if (!self.isTouchScreenDevice) {
          // normalize mouse events to touch events.
          GSP.mouseTouch(self.canvasNode, {
            sketch: self,
          });
        }

        self.canvasNode.on('touchstart', function(e) {
          return self.handleTouchStart(e);
        });
        self.canvasNode.on('touchmove', function(e) {
          return self.handleTouchMove(e);
        });
        self.canvasNode.on('touchend touchcancel', function(e) {
          return self.handleTouchEnd(e);
        });

        self.renderPrepare();
      },

      // Save the trace layer in the session data, allowing it to be restored (e.g., after a page change)
      // session.traceData exists only during the time between saving traces and restoring them.
      saveTraces: function() {
        // Save traces only if there are existing traces and fading is off
        var traceNode,
          data,
          pageNum = this.metadata.id;
        if (this.traces.saturation === 0 || this.preferences.fadeTraces) return; // Don't save if no traces or fading is on
        traceNode = $(this.baseNode).find(
          '.wsp-clip-node canvas:first-child'
        )[0];
        data = traceNode.toDataURL();
        this.document.pageData[pageNum].session.traceData = data;
        return data;
      },

      restoreTraces: function() {
        var ctx,
          img,
          width,
          height,
          pageNum = this.metadata.id,
          traceNode = $(this.baseNode).find(
            '.wsp-clip-node canvas:first-child'
          )[0],
          session = this.document.pageData[pageNum].session,
          traceDataURI = session.traceData;
        if (traceDataURI) {
          ctx = traceNode.getContext('2d');
          width = traceNode.clientWidth;
          height = traceNode.clientHeight;
          img = new Image();
          img.onload = function() {
            ctx.drawImage(
              img,
              0,
              0,
              img.width,
              img.height,
              0,
              0,
              width,
              height
            ); // Or at whatever offset you like
          };
          img.src = traceDataURI;
          delete session.traceData;
        }
      },

      getWSPKeysObjectFromSpecs: function(objects) {
        this.wspSaysAndTabsObjects = {
          wspSaysExist: false,
          wspSaysGobjsId: [],
          wspTabsExist: false,
          wspTabsGobjsId: [],
          wspButtonUpSaysExist: false,
          wspButtonUpSaysGobjId: {},
          wspButtonDownSaysExist: false,
          wspButtonDownSaysGobjId: {},
        };

        for (var id in objects) {
          if (
            objects[id].constraint === 'ActionButtonShow' ||
            objects[id].constraint === 'ActionButtonHide' ||
            objects[id].constraint === 'ActionButtonToggleHideShow'
          ) {
            if (objects[id].label === 'WSP-SAYS') {
              this.wspSaysAndTabsObjects.wspSaysExist = true;
              for (var parentId in objects[id].parents) {
                this.wspSaysAndTabsObjects.wspSaysGobjsId.push(
                  objects[id].parents[parentId]
                );
              }
            }

            if (objects[id].label === 'WSP-TABS') {
              this.wspSaysAndTabsObjects.wspTabsExist = true;
              for (var tabParentId in objects[id].parents) {
                if (
                  this.wspSaysAndTabsObjects.wspTabsGobjsId.indexOf(
                    objects[id].parents[tabParentId]
                  ) === -1
                ) {
                  this.wspSaysAndTabsObjects.wspTabsGobjsId.push(
                    objects[id].parents[tabParentId]
                  );
                }
              }
            }

            if (objects[id].label === 'WSP-ON-BUTTON-DOWN-SAYS') {
              this.wspSaysAndTabsObjects.wspButtonDownSaysExist = true;
              $.extend(
                this.wspSaysAndTabsObjects.wspButtonDownSaysGobjId,
                this.getGobjForButtonEvents(objects, id)
              );
            }

            if (objects[id].label === 'WSP-ON-BUTTON-UP-SAYS') {
              this.wspSaysAndTabsObjects.wspButtonUpSaysExist = true;
              $.extend(
                this.wspSaysAndTabsObjects.wspButtonUpSaysGobjId,
                this.getGobjForButtonEvents(objects, id)
              );
            }
          }
        }
      },

      getGobjForButtonEvents: function(objects, id) {
        var buttons = {};
        var text = [];
        for (var parentId in objects[id].parents) {
          if (objects[objects[id].parents[parentId]].kind === 'Button') {
            buttons[objects[id].parents[parentId]] = [];
          } else {
            text.push(objects[id].parents[parentId]);
          }
        }

        for (var each in buttons) {
          buttons[each] = text;
        }

        return buttons;
      },
    };
    //SketchPrototype

    /**
     * Sketch constructor
     * @param {Object}        node: DOM node whose contents will be replaced by the sketch.
     * @param {Object|String} spec: The specification object for the sketch OR
     *                              a JSON string of the spec which will be parsed.
     * @param {Object}        options: Passed to Sketch.options
     * @returns {Object}      The new Sketch object or null in case of error
     *
     * Note that the WSP() API supports more options, e.g. the onLoad and onError
     * callbacks, a delta object to be applied immediately after loading, etc.
     */
    return function(document, spec, options) {
      var sketch = null;

      // If spec is passed as string, parse it as JSON
      if (typeof spec === 'string') {
        try {
          spec = JSON.parse(spec);
        } catch (e) {
          GSP.signalErrorWithCode('GSP.Error.invalidSketch');
          return null;
        }
      }

      sketch = Object.create(SketchPrototype);
      sketch.init(document, spec, options);

      return sketch;
    };
  })();

  /**
   * List all known constraints.
   * @return {array} Am array of strings
   */
  GSP.Sketch.allConstraints = function() {
    var k,
      c,
      constraints = [];
    for (k in GSP.gConstraints) {
      if (GSP.gConstraints.hasOwnProperty(k)) {
        c = GSP.gConstraints[k];
        if (c.doc && c.doc.usage && !c.doc.usage['abstract']) {
          constraints.push(k);
        }
      }
    }

    return constraints;
  };
  /**
   * Test the given JSON sketch spec for support.
   * @return {object} An object containing support diagnostics
   */
  GSP.Sketch.supportCheck = function(sketchSpec, args) {
    var ret = {
        count: 0,
        supportedCount: 0,
        unsupported: {},
        constraints: {},
        support: 'full',
        message: 'All Sketch Objects: <span class="expected">Supported</span>',
      },
      specObjs = sketchSpec.objects,
      id,
      unsupportInfo;

    for (id in specObjs) {
      if (specObjs.hasOwnProperty(id)) {
        var specObj = specObjs[id],
          kind = GSP.getKindObj(specObj.kind),
          constraint = GSP.getConstraintObj(specObj.constraint),
          supportedKind = kind && kind.kindSupportsSpecObj(specObj, specObjs),
          supportedConstraint =
            constraint &&
            constraint.constraintSupportsSpecObj(specObj, specObjs);

        ret.count++;

        if (!supportedKind || !supportedConstraint) {
          unsupportInfo = {};

          if (!supportedKind) {
            unsupportInfo.kind = specObj.kind;
          }
          if (!supportedConstraint) {
            unsupportInfo.constraint = specObj.constraint;
          }

          ret.unsupported[id] = unsupportInfo;
        } else {
          ret.constraints[specObj.constraint] =
            ret.constraints[specObj.constraint] || 0;
          ret.constraints[specObj.constraint]++;
          ret.supportedCount++;
        }
      }
    }

    if (ret.supportedCount !== ret.count) {
      ret.support = 'none';
      ret.message =
        'Some Sketch Objects: <span class="error">Not Supported</span>';
    }

    return ret;
  };

  /**
   * @fileOverview Utility routines for Control Lists.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
   *
   * A control list is  essentially a recipe for how to apply a transformation
   * to a set of objects - you'll have ones that are transformable directly (e.g.
   * free points) but also ones that want to adjust the transformation en passant.
   * More formally, you will have an ordered list of:
   *  {
   *   gobj: the gobj
   *   transform: current transform associated with this gobj.
   *   isController:
   *     true: seed with initial transform
   *     false: copy transform from controlIndex entry
   *   controlIndex: index in ControlList of element which governs this gobj's motion, or -1
   *   isTransformParent: true means apply reverse transform implied by controlIndex entry.
   *   isDragRoot: gobj should actually move - apply transform.
   *  }
   *
   * c.f. MoveDragRootsTo() and UserDrag_advance() in native code for how
   * to turn these into actual geometry changes.
   */
  /*global GSP:false, $:false*/
  /**
   * @namespace GSP.ControlList
   *
   */
  GSP.ControlList = (function() {
    // list of expect keys, and a canonical order thereof
    var order = [
      'gobj',
      'isController',
      'isDragRoot',
      'isTransformParent',
      'controlIndex',
    ];

    // Convert one element of the list toString
    function controlListItemToString(item) {
      var str = '{',
        i,
        val;
      for (i = 0; i < order.length; i++) {
        val = item[order[i]];
        if (order[i] === 'gobj') {
          if (typeof val === 'object') {
            val = val.id;
          }
        }

        if (i > 0) {
          str += ',';
        }

        str += '"' + order[i] + '":' + val;
      }

      str += '}';

      return str;
    }

    return {
      /**
       * Create a control list from an extern existing list.
       * "external" here means that the 'gobj' field is specified
       * not as a GObject, but rather a GObj id. This function
       * converts the id's to GObjects.
       *
       * @param {array} externalList An externally specified control list.
       * @param {Skech} sketch The sketch containing the gobjects in externalList.
       * @return {array} A control list.
       */
      fromExternalList: function(externalList, sketch) {
        var list = [],
          i,
          e;

        for (i = 0; i < externalList.length; i++) {
          e = $.extend(true, {}, externalList[i]);
          e.gobj = sketch.gobjList.gobjects[e.gobj];
          list.push(e);
        }

        return list;
      },
      /**
       * Convert a control list to a string form.
       *
       * @param {array} list A control list.
       * @return {string} Stringified version of list.
       */
      toString: function(list) {
        var i,
          str = '';
        for (i = 0; i < list.length; i++) {
          if (i > 0) {
            str += ',';
          }
          str += controlListItemToString(list[i]);
        }
        return str;
      },
    };
  })();

  /**
   * @fileOverview BapEdgeInfo.js
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
   *
   *
   *
   * BapEdgeInfo contains edge information extracted from desktop Sketchpad organized
   * by constraint.  For each constraint, there is a list of parents referred to by
   * name (as named by WSP Exporter), each of which has an edge type and a sort order.
   * Below is the documentation for edge types:
   *	dEdge - Parent directly affects child; child can't move w/o parent
   *	rEdge - Child is transformed image of parent
   *	iEdge - Parent affects position, but child can move w/o parent, e.g., point-on-path
   *	tEdge -  Must move if parent and image-child are both affected, e.g., mirror, center
   *	mEdge -  If one m-parent moves, there's no reason to add other m-parents
   *	zEdge -  Child motion does not immediately affect parents (e.g. child is measure of parents),
   *				 but a dragged child of the child that reverses up to that child can force geometric
   *				 motion of the first child's parents (i.e. the dragged child's grandparents)
   *	oEdge - Absolutely one-way propogataion: child >never< reverses to parent, e.g. colorization
   *	nEdge - Parental motion doesn't affect child (e.g., action button, table)
   *
   *
   * This file was autogenerated from the desktop Sketchpad Web Exporter on 2015/07/13
   *
   *    *****DO NOT HAND EDIT!*****
   */

  /*global GSP:false*/
  /**
   * @namespace GSP.BapEdgeInfo
   *
   */

  GSP.BapEdgeInfo = {
    Free: {
      Default: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PictureFree: {
      Default: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    Midpoint: {
      path: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    Segment: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    CircleFromTwoPoints: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    CircleByRadius: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      radius: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
    },
    Perpendicular: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      line: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
    },
    Parallel: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      line: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
    },
    AngleBisector: {
      A: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      B: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      C: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    PolygonFromPoints: {
      Default: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    Intersection: {
      line0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      line1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    CircleInterior: {
      circle: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    Intersection1: {
      obj: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      circle: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    Intersection2: {
      obj: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      circle: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PointOnPath: {
      path: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    PointOnPolygonEdge: {
      path: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    IterateMap: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    IterateMapByParametricDepth: {
      parameter: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      Default: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    IterateImage: {
      source: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      map: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PointTerminalIteration: {
      image: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    TranslateVector: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
      p1: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
    },
    TranslateFixXFixY: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
    },
    TranslateFixXMeasureY: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      measure: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    TranslateMeasureXFixY: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      measure: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    TranslateMeasureXMeasureY: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      measureX: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      measureY: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
    },
    TranslateFixDistFixAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
    },
    TranslateFixDist3PtAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      A: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
      B: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      C: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
    },
    TranslateFixDistMeasureAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      measure: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    TranslateFixDistAngleMarker: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      marker: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    TranslateMeasureDistFixAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      distance: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    TranslateMeasureDist3PtAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      A: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
      B: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      C: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
      distance: {
        edgeType: 'mEdge',
        sortIndex: 4,
      },
    },
    TranslateMeasureDistMeasureAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      angle: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      distance: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
    },
    TranslateMeasureDistAngleMarker: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      marker: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      distance: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
    },
    Rotate: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
    },
    Rotate3: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      A: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      B: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
      C: {
        edgeType: 'iEdge',
        sortIndex: 4,
      },
    },
    RotateMeasureAngle: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      angle: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
    },
    RotateAngleMarker: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      angle: {
        edgeType: 'tEdge',
        sortIndex: 2,
      },
    },
    DilateFixFactor: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
    },
    Dilate2SegRatio: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      seg0: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
      seg1: {
        edgeType: 'mEdge',
        sortIndex: 3,
      },
    },
    Dilate3PtRatio: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      A: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      B: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
      C: {
        edgeType: 'iEdge',
        sortIndex: 4,
      },
    },
    DilateMeasureFactor: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      center: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
      measure: {
        edgeType: 'mEdge',
        sortIndex: 2,
      },
    },
    Reflect: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      mirror: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
    },
    GlideReflect: {
      source: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
      vector: {
        edgeType: 'tEdge',
        sortIndex: 1,
      },
    },
    GeomLocus: {
      drivenObject: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      domainObject: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
      driverObject: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      Default: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
    },
    MeasurementLength: {
      path: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementDistance: {
      p0: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      obj0: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    MeasurementPerimeter: {
      shape: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementCircumference: {
      shape: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementAngle: {
      p0: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'zEdge',
        sortIndex: 2,
      },
    },
    MeasurementAngleMarker: {
      marker: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementArea: {
      shape: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementArcAngle: {
      arc: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementArcOnCircleAngle: {
      circle: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
      p1: {
        edgeType: 'zEdge',
        sortIndex: 2,
      },
      p2: {
        edgeType: 'zEdge',
        sortIndex: 3,
      },
    },
    MeasurementArcLength: {
      arc: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementArcOnCircleLength: {
      circle: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
      p1: {
        edgeType: 'zEdge',
        sortIndex: 2,
      },
      p2: {
        edgeType: 'zEdge',
        sortIndex: 3,
      },
    },
    GeometricSlope: {
      straight: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementRadius: {
      shape: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementRatio: {
      obj0: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      obj1: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
      obj2: {
        edgeType: 'zEdge',
        sortIndex: 2,
      },
    },
    Calculation: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementRectCoordinates: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    LinearEquation: {
      straight: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    QuadraticEquation: {
      circle: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    HorizontalUnitPoint: {
      origin: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    VerticalUnitPoint: {
      origin: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    UnitPointInternalSquare: {
      unitPoint: {
        edgeType: 'rEdge',
        sortIndex: 0,
      },
    },
    UnitPointInternalRectangle: {
      unitPoint: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    UnitPointExternalSquare: {
      axis: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    UnitPointExternalRectangle: {
      axis: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    AxisInternalDist: {
      origin: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      unitPoint: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    AxisExternalDist: {
      origin: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      unitDistance: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
    },
    AxisUnitCircle: {
      circle: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    CoordSys: {
      axisX: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      axisY: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    ActionButton: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonToggleHideShow: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonHide: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonShow: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonAnimate: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonMove: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonScroll: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonLinkPage: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonLinkURL: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonPresentSequentially: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonPresentSimultaneously: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    ActionButtonPresentCase: {
      Default: {
        edgeType: 'nEdge',
        sortIndex: 0,
      },
    },
    Line: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    Ray: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    MeasurementAbscissa: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    MeasurementOrdinate: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    MeasurementPolarDistance: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    MeasurementPolarDirection: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    PlotFixedXFixedY: {
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PlotFixedXMarkedY: {
      coordY: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PlotMarkedXFixedY: {
      coordX: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PlotMarkedXMarkedY: {
      coordX: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordY: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    PlotFixedRhoFixedTheta: {
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PlotFixedRhoMarkedTheta: {
      coordTheta: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PlotMarkedRhoFixedTheta: {
      coordRho: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PlotMarkedRhoMarkedTheta: {
      coordRho: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordTheta: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    Function: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    FunctionPlot: {
      function: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    CompositeText: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementPolarCoordinates: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    ColorizeUnivariate: {
      source: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      color: {
        edgeType: 'oEdge',
        sortIndex: 1,
      },
    },
    ColorizeTrivariate: {
      source: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      blue: {
        edgeType: 'oEdge',
        sortIndex: 1,
      },
      green: {
        edgeType: 'oEdge',
        sortIndex: 2,
      },
      red: {
        edgeType: 'oEdge',
        sortIndex: 3,
      },
    },
    Derivative_C: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    ArcOnCircle: {
      circle: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    ArcAroundPoint: {
      center: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    Arc3Points: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    ArcSector: {
      arc: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    ArcSegment: {
      arc: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PictureHungOnOnePoint: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PictureCenteredOnOnePoint: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    PictureBetweenTwoPoints: {
      p1: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p0: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PictureAcrossThreePoints: {
      p2: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p0: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    PictureCroppedByInterior: {
      source: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      cropInterior: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PictureFunction_C: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    MeasurementCoordinateDistance: {
      p0: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 2,
      },
    },
    MeasurementAnalyticSlope: {
      seg: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      coordSys: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    Pegged: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      text: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
    },
    UserTabulation: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    IteratedValuesTable: {
      Default: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
    },
    InterRayPolgon_C: {
      Default: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    ParametricLocus: {
      drivenObject: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      driverObject: {
        edgeType: 'iEdge',
        sortIndex: 1,
      },
      Default: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
    },
    MeasurementValueOfPointOnPath: {
      point: {
        edgeType: 'zEdge',
        sortIndex: 0,
      },
      path: {
        edgeType: 'zEdge',
        sortIndex: 1,
      },
    },
    PlotValueOnPath: {
      param: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      path: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
    },
    PlotFixedValueOnPath: {
      path: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    InterApproxPathStitchedPath_C: {
      Default: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    CustomTransformedPicture_C: {
      Default: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
    },
    CustomTransformedPoint: {
      drivenObject: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
      domainObject: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      driverObject: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      Default: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
    },
    CustomTransformedPath: {
      drivenObject: {
        edgeType: 'iEdge',
        sortIndex: 0,
      },
      domainObject: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      driverObject: {
        edgeType: 'iEdge',
        sortIndex: 2,
      },
      Default: {
        edgeType: 'iEdge',
        sortIndex: 3,
      },
    },
    AngleMarker_Simple: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    AngleMarker_Reflex: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    AngleMarker_CCW: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    AngleMarker_CW: {
      p0: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
      p1: {
        edgeType: 'dEdge',
        sortIndex: 1,
      },
      p2: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    PathMarker: {
      path: {
        edgeType: 'dEdge',
        sortIndex: 0,
      },
    },
    ParametricCartesianCurvePlot: {
      xFunction: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      function: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
    ParametricPolarCurvePlot: {
      function: {
        edgeType: 'mEdge',
        sortIndex: 0,
      },
      xFunction: {
        edgeType: 'mEdge',
        sortIndex: 1,
      },
      coordSys: {
        edgeType: 'dEdge',
        sortIndex: 2,
      },
    },
  };

  /**
   * @fileOverview BAP.
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
   *
   * BAP is a module ported from desktop Sketchpad that determines how objects 
   * should move during a drag.  BAP stands for Build Affect Pool.  The concept of
   * affect pool is dated, and is even unused in desktop Sketchpad v4-5.  Desktop
   * BAP build both an affect pool and a control list.  Modern code only cares 
   * about the control list, so our public API here is simply a single function:
   * 'createControlList', which given an object or set of objects, returns the 
   * control list for dragging that object.
   * 
   * The control list is a graph of objects that link 'controllers' (the object
   * being dragged) to 'drag roots' (the parent who must be moved).
   * The simplest example - dragging a free point - would generate a control list 
   * of 1 - simply that point marked as both the controller and the drag root.
   * Consider the example of dragging a point reflected across a mirror.  Here the
   * reflected point would be the controller, but we must move its parent when 
   * realizing the drag rather than the child.  So the pre-image point would 
   * become the drag root.  
   * 
   * In more complicated cases, there may be intermediate ancestors between the 
   * controller and the drag root (say the point pre-image in the previous example
   * wasn't a free point, but was instead a midpoint on a segment).  These are 
   * known as links.  Given the midpoint example, the midpoint pre-image would become
   * a link, its segment would become a link, and the segment's endpoints would 
   * become drag roots.
   * 
   * When the drag movement between a controller and a link or drag root is not 1-1
   * (I drag left, but the link needs to move right, like in the reflection example),
   * the parent is flagged as 'isTransformParent.'  This indicates that the original
   * motion of the controller must be transformed by the inverse of the transform
   * that describes the transformed child.  
   * 
   * The order of the control list starts with controllers and progresses up to drag
   * roots, making sure that any entry that has a controller (specified by 
   * controlIndex) comes later than its controller.
   *
   * This algorithm is currently a direct port of desktop's BAP algorithm, and 
   * inherits all of the bugs and complexities of the original implementation. 
   * C style in this module (slash-star) have a one-to-one correspondence with 
   * comments in the original desktop algorithm.  (slash-slash) style comments 
   * are specific to this implementation.
   * 
   * On Desktop Sketchpad, there are 3 different 'modes' of dragging - translation,
   * rotation, and dilation.  On WSP, we only support translation.  If we wanted
   * to support the others, all that would be needed would be to export the edge 
   * info for the other modes.  The algorithm, as a faithful port of desktop, should
   * behave properly.
   * 
   *
   * c.f. MoveDragRootsTo() and UserDrag_advance() in native code for how
   * to turn these into actual geometry changes.
    
   */
  /*global GSP:false*/
  /**
   * @namespace GSP.Bap
   *
   */
  GSP.Bap = (function() {
    //returns the edgeType for this gobjs specified parent - Currently unused
    //  function getEdgeForParentName(gobj, parentName) {
    //
    //    var constraintInfo = GSP.BapEdgeInfo[gobj.constraint],
    //        ret = constraintInfo && constraintInfo[parentName] && constraintInfo[parentName].edgeType;
    //
    //    if (!constraintInfo) {
    //      GSP.signalErrorWithMessage("BAP [getEdgeForParentName] No edge info for constraint: " + gobj.constraint);
    //      return; // undefined
    //    }
    //
    //    if (!ret) {
    //      ret = constraintInfo.Default && constraintInfo.Default.edgeType;
    //    }
    //
    //    return ret;
    //  }

    //equivalent to edgeTypeUtil on desktop
    function getEdgeForParentAtIndex(gobj, parentIndex) {
      var constraintInfo = GSP.BapEdgeInfo[gobj.constraint],
        key,
        ret;

      if (!constraintInfo) {
        GSP.signalErrorWithMessage(
          'BAP [getEdgeForParentAtIndex] No edge info for constraint: ' +
            gobj.constraint
        );
        return; // undefined
      }

      for (key in constraintInfo) {
        if (constraintInfo.hasOwnProperty(key)) {
          if (constraintInfo[key].sortIndex === parentIndex) {
            ret = constraintInfo[key].edgeType;
            break;
          }
        }
      }

      return ret || constraintInfo.Default.edgeType;
    }

    function buildControlList(gobjlist, sketch) {
      var queueMap = {},
        //queueMap contains all of the data needed to determine the role of a particular
        //  gobj.  Each entry has a key of gobject id, and contains the following properties:
        //    gobj - a ref to the gobj, for convenience
        //    transCode - (int) id of the particular transformation associated with this gobj
        //    isConstrained (bool)
        //    isLink (bool)
        //    isDragRoot (bool)
        //    isController (bool)
        //    isFollower (bool)
        //    completeFollower (bool)
        //    isSelectedZ (bool)
        //
        //    isTransformParent (bool)
        //    kidsAreConstrained (bool)
        //    addedToProcessed (bool)  used only when generating the processedList
        //    hasBeenAddedToOrderedList (bool) used only when building the final orderedList
        //If the gobj is in the pending queue, it also has an action property, indicating the
        //role it will try to take on when it's next processed.  If not in the queue, it's action
        //will be 'none' indicating that it has been processed and its boolean flags above are
        //appropriately set.
        //    action: (string) new action requested of the gobj, one of the following strings:
        //      'none'
        //      'constrained'
        //      'link'
        //      'controller'
        //      'follower'
        //      'selected'

        pendingQueue = [],
        //  pendingQueue is an array of gobjs that have been added to the queueMap.
        //  They are stored here to keep track of the order in which we need to
        //  process the items.
        //  pendingQueue is processed as a first in/first out queue

        processedQueue = [],
        //   processedQueue is queue of gobjs that have been processed from the
        //   pendingQueue, and ready to be consumed by buildControlList.  This
        //   is equivalent to the geomList in the desktop BAP algorighm.

        controlListToReturn = [],
        // The final, returned result
        anInputGObj;

      //Simply a convienence to parallel desktop.  This item is not yet in our queueMap,
      //so create an entry for it
      function attachData(gobj) {
        queueMap[gobj.id] = { gobj: gobj, action: 'none', transCode: 0 };
      }

      function addToPendingQueue(gobj, action, transCode, optParent) {
        var newAction = action,
          pendingAction,
          edgeOfFirstParent = getEdgeForParentAtIndex(gobj, 0);

        //GSP.log("adding " + gobj.label + " to queue as " + action + " with transCode:" + transCode);

        /* If the gobj doesn't yet have any bap data, attach the data */

        if (undefined === queueMap[gobj.id]) {
          attachData(gobj);

          /*If this is a selected object, figger out whut to do.
            If it's a z-child, mark it as such, but don't enqueue it.
            Otherwise, enqueue it to become a controller. */
          if (newAction === 'selected') {
            if (
              'zEdge' !== edgeOfFirstParent &&
              'nEdge' !== edgeOfFirstParent
            ) {
              newAction = 'controller';
            } else {
              queueMap[gobj.id].isSelectedZ = true;
            }
          }
        }

        pendingAction = queueMap[gobj.id].action;
        if (pendingAction === 'selected') {
          queueMap[gobj.id].action = newAction;
          queueMap[gobj.id].transCode = transCode;
          pendingAction = newAction;
        }

        if (
          newAction === pendingAction &&
          transCode === queueMap[gobj.id].transCode
        ) {
          //no change
          return;
        }

        if (newAction === 'controller' && queueMap[gobj.id].isController) {
          /*If the object is being added as a controller, and is already a
           * controller, do nothing. */
          return;
        }

        if (pendingAction && pendingAction !== 'none') {
          /* If the object is being constrained, and is already a link, */
          /* and the parent has the same transCode as the child to be queued, */
          /* add to the queue only if the parent is not already linked. */
          if (
            'constrain' === newAction /*if the new action is to constrain */ &&
            queueMap[gobj.id].isLink /*and the gobj is already a link */ &&
            optParent &&
              queueMap[gobj.id].transCode === queueMap[optParent.id].transCode
          ) {
            /*and the gobj and parent have the same transCode */
            if (queueMap[optParent.id].isLink) {
              return; /* parent is already linked, so don't add to queue */
            }
            /* Add this object using addAsLinkAction rather than addAsConstrainedAction. */
            /* This gives the child a chance to add the parent as a link rather than move the controllers */
            /* up in the drag graph. */
            /* But it can become a link only if it's not already a controller. */
            if (!queueMap[gobj.id].isController) {
              newAction = 'link';
            }
          }
          /* The gobj is already on the pending list, so decide which
           * of the possibly conflicting actions to take */
          var bothActions = {},
            kActionWeight = {
              none: 0,
              controller: 1,
              link: 2,
              constrained: 3,
              follower: 4,
              selected: 5,
            };
          //          kActionWeight = { 'none':0,
          //                            'constrained':1,
          //                            'link':2,
          //                            'controller':3,
          //                            'follower':4,
          //                            'selected':5};
          //Initially, this was improperly corresponding with the order of roles,
          //but when it was ordered this way, one particular bug was no longer
          //reproduced with WSP.  It's hard to believe that this was the only
          //instance of a difference, with such different weights, and I can't argue
          //why my clearly incorrect transcription behaved 'better.'  I suspect 'constrained'
          //receives too much weight here, but it is difficult to really know the ramifications
          //of such a change - JB 6/14/2013

          bothActions[pendingAction] = true;
          bothActions[newAction] = true;

          /* If we're constraining and linking with the same transCode, linking takes precedence */
          if (
            bothActions.hasOwnProperty('link') &&
            bothActions.hasOwnProperty('constrained') &&
            (-1 === transCode || transCode === queueMap[gobj.id].transCode)
          ) {
            newAction = 'link'; /* linking takes precedence */
          } else if (
            bothActions.hasOwnProperty('constrained') &&
            (bothActions.hasOwnProperty('link') ||
              bothActions.hasOwnProperty('controller'))
          ) {
            /* If we're constraining and controlling, or if we're constraining
             * and linking with != transCodes, */
            /* make it a follower */
            newAction = 'follower';
            transCode = 0;
          }

          /* Otherwise, possible actions are in order of increasing precedence */
          if (kActionWeight[newAction] < kActionWeight[pendingAction]) {
            return;
          }
        } else {
          /* not yet on pending list, so add it */
          pendingQueue.push(gobj);
        }

        queueMap[gobj.id].action = newAction;
        if (0 <= transCode) {
          queueMap[gobj.id].transCode = transCode;
        }
      }

      //equivalent to addParentsToPendingQueue from desktop
      //edgesToAdd is an object with each edge as key, and true as the value.
      //If an edge property doesn't exist, then it's treated as false
      //If edgesToAdd itself is undefined, then all edges are added
      function addParentsToPendingQueue(
        gobj,
        edgesToAdd,
        action,
        transCode,
        addAllMParents
      ) {
        var addOneParent = function(index, parent) {
          var parentEdge = getEdgeForParentAtIndex(gobj, index),
            doIt = true;

          if (!edgesToAdd || edgesToAdd[parentEdge]) {
            if (parentEdge === 'zEdge') {
              /*Never add a free or unaffected calculation z-parent. */
              if (
                (!queueMap[parent.id] || parent.constraint === 'Free') &&
                parent.kind === 'Expression'
              ) {
                doIt = false;
              } else {
                /*Adding z-parents is tricky. These should really be broken down into two distinct kinds of end points, 
                  because making a z child into a complete follower depends on the type of object.
                  (Recall that z children are those which can transmit geometric information without moving themselves:
                  measurements, calculations, functions, derivatives.)
                  To make a measurement (e.g., Length AB) into a complete follower, we must add both parents, 
                  A and B, as complete followers themselves. Otherwise the measurement may change, and children
                  which depend on the measurement's constancy to move correctly will fail to follow the mouse.
                  But calculations, functions and derivatives are different. If a calculation, for instance,
                  is the sum Length AB + Length CD, and Length AB is drag-affected but not Length CD,
                  the calculation will remain constant as long as Length AB is held constant; there's no 
                  need in this case to add the other parent.
                  In a real sense, the z characteristic is orthogonal to the other edge types, and we should
                  mark calculations, functions and derivatives as m-children (adding one m-parent to a 
                  follower child doesn't require adding the others), and we should mark other measurements
                  as i-children (adding one i-parent to a follower child requires adding all i-parents).
                  But for now we leave the edges as they are; more problems with this categorization
                  will require a more fundamental fix.
  
                  For z-children, then, the flag addAllMParents means that for measurements we should add all z-parents.
                  For expressions, we don't add unaffected z-parents, no matter what the flag says.
                */
                if (
                  !queueMap[parent.id] &&
                  (gobj.kind === 'Expression' || !addAllMParents)
                ) {
                  doIt = false;
                }
              }
            } else if (parentEdge === 'mEdge' && !addAllMParents) {
              doIt = queueMap[parent.id] ? true : false;
            }

            if (doIt) {
              if ('link' === action) {
                //It may not exist yet
                if (!queueMap[parent.id]) {
                  attachData(parent);
                }

                queueMap[parent.id].controller = gobj;
              }

              addToPendingQueue(parent, action, transCode);
            }
          }

          return true; //keep going
        };

        gobj.eachParent(addOneParent, true);
      }

      //returns an object detailing whether some, or all parents of each edge type
      //exist. Also may set a incompatibleParent flag.
      function checkParents(gobj) {
        var ret = {},
          checkOneParent = function(index, parent) {
            var parentInfo = queueMap[parent.id],
              edgeType = getEdgeForParentAtIndex(gobj, index);

            if (parentInfo && !parentInfo.isSelectedZ) {
              //affected parent
              switch (edgeType) {
                case 'rEdge':
                  //an rEdge parent must have this gobj as its controller or
                  //its incompatible - even if it has no controller
                  if (queueMap[parent.id].controller !== gobj) {
                    ret.incompatibleParent = true;
                  }
                  break;
                case 'dEdge':
                case 'iEdge':
                case 'tEdge':
                  if (parentInfo.transCode !== queueMap[gobj.id].transCode) {
                    ret.incompatibleParent = true;
                  }
                  break;
              }

              if (ret[edgeType] === undefined) {
                ret[edgeType] = 'allAffected';
              } else if (ret[edgeType] === 'noneAffected') {
                ret[edgeType] = 'someAffected';
              }
            } else {
              //unaffected parent
              if (ret[edgeType] === undefined) {
                ret[edgeType] = 'noneAffected';
              } else if (ret[edgeType] === 'allAffected') {
                ret[edgeType] = 'someAffected';
              }
            }

            return true; //keep going
          };

        gobj.eachParent(checkOneParent, true);

        return ret;
      }

      var transCodeArray = [];

      function getTransCode(gobj) {
        //getTransCode returns an index for each unique transformation
        //relationship starting at index 1.  Index 0 signals the original
        //drag transformation (on Desktop, getTransCode returning 0 signals
        //a memory error

        var i, testGObj;

        function transformedChildrenHaveIdenticalParents(childOne, childTwo) {
          //all parents other than 'source' are the same
          var parentsMatch = true;

          if (childOne.parents.length !== childTwo.parents.length) {
            return false;
          }

          //With a guarantee that they have the same number of parents, we check
          //each of childOne's parents and verify childTwo also has that parent
          childOne.eachParent(function(index, parent) {
            if ('rEdge' !== getEdgeForParentAtIndex(childOne, index)) {
              if (parent !== childTwo.parentsList[index]) {
                parentsMatch = false;
                return false; //stop the iteration
              }
            }
            return true; //keep going
          }, true);

          return parentsMatch;
        }

        function transformedChildrenHaveIdenticalData(childOne, childTwo) {
          var transformerOne,
            transformerTwo,
            affineTransformOne,
            affineTransformTwo;

          transformerOne = childOne.getTransformer();
          transformerTwo = childTwo.getTransformer();
          affineTransformOne = transformerOne.getAffineTransform();
          affineTransformTwo = transformerTwo.getAffineTransform();

          return affineTransformOne.isEqual(affineTransformTwo);
        }

        for (i = 0; i < transCodeArray.length; i++) {
          testGObj = transCodeArray[i];

          //efficiency not done (but could be done) by desktop:
          //If it's the exact object, it's a match of course:
          if (testGObj === gobj && queueMap[testGObj.id].isLink) {
            return i + 1;
          }

          if (
            queueMap[testGObj.id].transCode === queueMap[gobj.id].transCode &&
            /* The stored entry must still be a link or the match fails */
            queueMap[testGObj.id].isLink &&
            /*	Make sure the relations match. */
            testGObj.constraint === gobj.constraint &&
            /* Compare all but the first parent (which is the pre-image: */
            transformedChildrenHaveIdenticalParents(testGObj, gobj) &&
            /* Compare all the data in the data threads */
            transformedChildrenHaveIdenticalData(testGObj, gobj)
          ) {
            return i + 1;
          }
        }

        //Here with no match, add a new one:
        transCodeArray.push(gobj);
        return i + 1;
      }

      function checkCompleteFollower(gobj, parentSummary) {
        /*If the gobj currently being processed is affected in different incompatible ways, 
          it can't behave in several different ways at the same time. To resolve the conflict,
          theGObj is made into a follower. This function determines which parents such a
          follower needs to carry with it.
          If there are affected i-parents, all r, i and t-parents must move with it.
          If there are affected t-parents, all r and t-parents must move with it.
          If there are affected m-parents, all r and t-parents must move with it.
        */
        var edgesToAdd = { zEdge: true, dEdge: true },
          complete = true;

        /*If any i parents are affected, all r, i and t parents must be added. */
        if (parentSummary.iEdge && parentSummary.iEdge !== 'noneAffected') {
          edgesToAdd.iEdge = true;
          edgesToAdd.rEdge = true;
          edgesToAdd.tEdge = true;
        }

        if (
          parentSummary.iEdge === 'noneAffected' ||
          parentSummary.mEdge === 'noneAffected' ||
          parentSummary.mEdge === 'someAffected'
        ) {
          /* there are existing unaffected i or m-edges, so the gobj isn't complete */
          complete = false;
        }

        /* If I have affected r-parents which I do not control, both r-parents
         * and t-parents must be followers. */
        /* Similarly, if I have affected t-parents, both r and t-parents must
         * be followers. */
        if (
          (parentSummary.rEdge &&
            parentSummary.rEdge !== 'noneAffected' &&
            parentSummary.incompatibleParent) ||
          (parentSummary.tEdge && parentSummary.tEdge !== 'noneAffected')
        ) {
          edgesToAdd.tEdge = true;
          edgesToAdd.rEdge = true;
        }

        if (parentSummary.tEdge === 'noneAffected') {
          complete = false;
        }

        if (parentSummary.mEdge && parentSummary.mEdge !== 'noneAffected') {
          edgesToAdd.tEdge = true;
          edgesToAdd.mEdge = true;
          edgesToAdd.rEdge = true;
        }

        if (
          complete &&
          (!parentSummary.mEdge || parentSummary.mEdge === 'allAffected')
        ) {
          queueMap[gobj.id].completeFollower = true;
        }

        addParentsToPendingQueue(gobj, edgesToAdd, 'controller', -1, complete); //add all mEdges if complete
      }

      function addAsFollower(gobj, parentSummary) {
        /*If I was previously a link, my controlling child must become a follower */
        if (queueMap[gobj.id].isLink && queueMap[gobj.id].controller) {
          addToPendingQueue(queueMap[gobj.id].controller, 'follower', 0, gobj);
        }
        /* Start the object fresh */

        queueMap[gobj.id].transCode = 0;
        queueMap[gobj.id].controller = undefined;
        /* clear all other flags except for BAP_SELECTED_Z */
        queueMap[gobj.id].isConstrained = false;
        queueMap[gobj.id].isLink = false;
        queueMap[gobj.id].isDragRoot = false;
        queueMap[gobj.id].isController = false;
        queueMap[gobj.id].isFollower = true;

        /* Add my D-parents and Z-parents as controllers */
        addParentsToPendingQueue(
          gobj,
          { zEdge: true, dEdge: true },
          'controller',
          0
        );

        checkCompleteFollower(gobj, parentSummary);
      }

      function addAsConstrained(gobj, parentSummary) {
        /* 
    A link or controller can't undergo a transition to constrained, but only to follower.
    A link should become a follower if any one of the following is true:
    1. There are drag-affected T, M or I parents.
    2. There's a D-parent with a different transCode.
    3. There's an R-parent with a child-transCode which doesn't match theGObj's transCode.
  */

        if (queueMap[gobj.id].isLink) {
          /* It's a link, so check the parents */

          var mustFollow = function() {
            var ret =
              parentSummary.iEdge === 'someAffected' ||
              parentSummary.iEdge === 'allAffected' ||
              parentSummary.mEdge === 'someAffected' ||
              parentSummary.mEdge === 'allAffected' ||
              parentSummary.tEdge === 'someAffected' ||
              parentSummary.tEdge === 'allAffected';

            /* NEED TO TEST D EDGES AND R EDGES!! */
            if (!ret) {
              if (parentSummary.dEdge) {
                gobj.eachParent(function(index, theParent) {
                  if (
                    'dEdge' === getEdgeForParentAtIndex(gobj, index) &&
                    queueMap[theParent.id]
                  ) {
                    /*	If my d-parent has a different transCode than I do, it's
                          transformed differently than I am, and we must both become followers.
                          If my d-parent's not a link, neither can I be. I can check
                          the parent's flags, because they'll have been processed as
                          links before I've been re-processed as constrained.
                    */

                    if (
                      queueMap[theParent.id].transCode !==
                        queueMap[gobj.id].transCode ||
                      !queueMap[theParent.id].isLink
                    ) {
                      ret = true;
                      return false; //we can stop iterating on parents now
                    }
                  }
                  return true; //keep going
                }, true);
              } else if (parentSummary.rEdge) {
                var aTransCode = getTransCode(gobj),
                  sourceGobj = gobj.parentsList[0];

                ret =
                  aTransCode !== 0 &&
                  sourceGobj &&
                  aTransCode !== queueMap[sourceGobj.id].transCode;
              }
            }
            return ret;
          };

          if (mustFollow()) {
            addAsFollower(gobj, parentSummary);
          }
        } else if (
          queueMap[gobj.id].isFollower &&
          !queueMap[gobj.id].completeFollower
        ) {
          checkCompleteFollower(gobj, parentSummary);
        }

        /*If a selected z-child is being constrained for the first time,
         * it must reconstrain its kids */
        if (queueMap[gobj.id].isSelectedZ && !queueMap[gobj.id].isConstrained) {
          queueMap[gobj.id].kidsAreConstrained = false;
        }

        queueMap[gobj.id].isConstrained = true;
      }

      function addAsLink(gobj, parentSummary) {
        if (
          !parentSummary.incompatibleParent &&
          !parentSummary.dEdge &&
          !parentSummary.rEdge &&
          (!parentSummary.iEdge || parentSummary.iEdge === 'noneAffected') &&
          (!parentSummary.tEdge || parentSummary.tEdge === 'noneAffected') &&
          (!parentSummary.mEdge || parentSummary.mEdge === 'noneAffected')
        ) {
          queueMap[gobj.id].isLink = true;

          if ('zEdge' !== getEdgeForParentAtIndex(gobj, 0)) {
            queueMap[gobj.id].isDragRoot = true;
          } else {
            addParentsToPendingQueue(
              gobj,
              { zEdge: true },
              'link',
              queueMap[gobj.id].transCode
            );
          }
        } else if (
          (parentSummary.tEdge && parentSummary.tEdge !== 'noneAffected') ||
          (parentSummary.iEdge &&
            parentSummary.iEdge !== 'noneAffected' &&
            parentSummary.rEdge)
        ) {
          return addAsFollower(gobj, parentSummary);
        } else if (parentSummary.incompatibleParent) {
          return addAsFollower(gobj, parentSummary);
        } else {
          queueMap[gobj.id].isLink = true;
          if (!queueMap[gobj.id].transCode) {
            queueMap[gobj.id].isFollower = true;
          }

          /*Add d-parents with the same transCode as theGObj*/
          addParentsToPendingQueue(
            gobj,
            { dEdge: true },
            'link',
            queueMap[gobj.id].transCode
          );

          if (parentSummary.rEdge === 'noneAffected') {
            /*I have an unaffected r-parent, so increment the transCount and link it.*/
            addParentsToPendingQueue(
              gobj,
              { rEdge: true },
              'link',
              getTransCode(gobj)
            );
          }

          /*Affected i-parents cause all i- and t-parents to be added*/
          if (parentSummary.iEdge && parentSummary.iEdge !== 'noneAffected') {
            addParentsToPendingQueue(
              gobj,
              { tEdge: true, iEdge: true },
              'link',
              queueMap[gobj.id].transCode
            );
            if (
              0 === queueMap[gobj.id].transCode &&
              (!parentSummary.mEdge || parentSummary.mEdge === 'allAffected')
            ) {
              queueMap[gobj.id].completeFollower = true;
            }
          } else if (
            parentSummary.tEdge &&
            parentSummary.tEdge !== 'noneAffected'
          ) {
            addParentsToPendingQueue(
              gobj,
              { tEdge: true },
              'link',
              queueMap[gobj.id].transCode
            );
            if (
              0 === queueMap[gobj.id].transCode &&
              (!parentSummary.mEdge || parentSummary.mEdge === 'allAffected') &&
              !parentSummary.iEdge
            ) {
              queueMap[gobj.id].completeFollower = true;
            }
          } else if (
            !parentSummary.iEdge &&
            !parentSummary.tEdge &&
            (!parentSummary.mEdge || parentSummary.mEdge === 'allAffected') &&
            0 === queueMap[gobj.id].transCode
          ) {
            queueMap[gobj.id].completeFollower = true;
          }
          if (parentSummary.mEdge && parentSummary.mEdge !== 'noneAffected') {
            addParentsToPendingQueue(
              gobj,
              { mEdge: true },
              'link',
              queueMap[gobj.id].transCode
            );
          }
        }
      }

      function addAsController(gobj, parentSummary) {
        var validController = true,
          sourceParent;

        if ('zEdge' === getEdgeForParentAtIndex(gobj, 0)) {
          addParentsToPendingQueue(gobj, { zEdge: true }, 'controller', 0);
          validController = false;
        } else if (
          (parentSummary.iEdge && parentSummary.iEdge !== 'noneAffected') ||
          (parentSummary.tEdge && parentSummary.tEdge !== 'noneAffected') ||
          (parentSummary.mEdge && parentSummary.mEdge !== 'noneAffected')
        ) {
          /*at least some of i, t, or m are affected*/
          validController = false;
        } else if (parentSummary.dEdge) {
          /*turn my d-parents into controllers, shortening the control chain*/
          addParentsToPendingQueue(gobj, { dEdge: true }, 'controller', 0);
          validController = false;
        } else if (parentSummary.rEdge === 'allAffected') {
          /* no affected i, t or m parents, and no d-parents. Check the r-parent if there is one */
          sourceParent = gobj.parentsList[0];

          if (sourceParent && queueMap[sourceParent.id].controller !== gobj) {
            /*the rEdge has a different controller */
            validController = false;
          }
        }

        if (!validController) {
          return addAsFollower(gobj, parentSummary);
        }

        /*if I was previously a link, my controlling child must become a follower*/
        if (queueMap[gobj.id].controller) {
          addToPendingQueue(queueMap[gobj.id].controller, 'follower', 0, gobj);
          queueMap[gobj.id].controller = undefined;
        }

        /*now add me as a controller:*/
        queueMap[gobj.id].isController = true;
        queueMap[gobj.id].isLink = true;
        queueMap[gobj.id].isFollower = true;

        if (
          !(parentSummary.iEdge || parentSummary.tEdge || parentSummary.mEdge)
        ) {
          queueMap[gobj.id].completeFollower = true;
        }

        queueMap[gobj.id].isDragRoot =
          !parentSummary.rEdge || parentSummary.dEdge ? true : false;

        if (parentSummary.rEdge) {
          /*add the r-parent*/
          var newCode = getTransCode(gobj);

          sourceParent = gobj.parentsList[0];

          if (
            parentSummary.rEdge === 'noneAffected' &&
            (!queueMap[sourceParent.id] ||
              queueMap[sourceParent.id].transCode !== newCode)
          ) {
            if (!queueMap[sourceParent.id]) {
              attachData(sourceParent);
            }
            queueMap[sourceParent.id].transCode = newCode;
            queueMap[sourceParent.id].controller = gobj; //This seems to be redundant here
            addParentsToPendingQueue(gobj, { rEdge: true }, 'link', newCode);
          }
        }
      }

      function addChildrenToPendingQueue(gobj) {
        var ret;

        function edgeByChild(parent, child) {
          child.eachParent(function(index, aParent) {
            if (aParent === parent) {
              ret = getEdgeForParentAtIndex(child, index);
              return false; //stop iterating
            }
            return true; //keep going
          });

          return ret;
        }

        var i, thisEdge, theChild, newTransCode;

        //there's no good way to know if we're doing the children in the
        //same order as on Desktop, but we try, assuming the children
        //will have been added in the same order....
        for (i = gobj.children.length - 1; i >= 0; i--) {
          newTransCode = -1;

          theChild = gobj.children[i];
          thisEdge = edgeByChild(gobj, theChild);

          if ('nEdge' !== thisEdge) {
            if ('dEdge' === thisEdge) {
              newTransCode = queueMap[gobj.id].transCode;
            }
            addToPendingQueue(theChild, 'constrained', newTransCode, gobj);
          }
        }

        queueMap[gobj.id].kidsAreConstrained = true;
      }

      function processQueue() {
        var aGobj, queueMapItem, parentSummary, actionToPerform;

        aGobj = pendingQueue.shift();

        while (aGobj) {
          queueMapItem = queueMap[aGobj.id];

          if (!queueMapItem.addedToProcessed) {
            processedQueue.push(aGobj);
            queueMap[aGobj.id].addedToProcessed = true;

            if (queueMapItem.action !== 'selected') {
              queueMapItem.isConstrained = true;
            }
          }

          parentSummary = checkParents(aGobj);

          actionToPerform = queueMapItem.action;
          queueMapItem.action = 'none';

          switch (actionToPerform) {
            case 'constrained':
              addAsConstrained(aGobj, parentSummary);
              break;
            case 'link':
              addAsLink(aGobj, parentSummary);
              break;
            case 'controller':
              addAsController(aGobj, parentSummary);
              break;
            case 'follower':
              addAsFollower(aGobj, parentSummary);
              break;
            //Selected Z were flagged at the outset and
            //don't need anything else done to them
            //case 'selected':
            //  break;
          }

          /*if theGObj isn't a selected z-child playing no other role, 
            and its kids aren't already constrained, 
            and theGObj isn't a free calculation, constrain its kids now */
          if (
            !queueMapItem.isSelectedZ &&
            !queueMapItem.kidsAreConstrained &&
            (aGobj.constraint !== 'Free' || aGobj.kind !== 'Expression')
          ) {
            addChildrenToPendingQueue(aGobj);
          }

          aGobj = pendingQueue.shift();
        }
      }

      function buildControlListFromQueue() {
        var aGobj,
          controlList = [],
          orderedGeomList = [],
          i,
          gobjBapInfo,
          newItem;

        //functions like desktop's BuildReturnList(), sorting the geomList in its current
        //order, but making sure parents are added before their children are
        function createOrderedGeomList() {
          var curIndex = 0,
            currentGObj,
            canBeAdded;

          function perParentCanBeAdded(index, parent) {
            if (
              queueMap[parent.id] &&
              !queueMap[parent.id].hasBeenAddedToOrderedList &&
              !queueMap[parent.id].isSelectedZ
            ) {
              canBeAdded = false;
              return false;
            }
            return true;
          }

          while (processedQueue.length > 0) {
            canBeAdded = true;
            currentGObj = processedQueue[curIndex];
            currentGObj.eachParent(perParentCanBeAdded, true);

            if (canBeAdded) {
              orderedGeomList.push(currentGObj);
              processedQueue.splice(curIndex, 1);
              queueMap[currentGObj.id].hasBeenAddedToOrderedList = true;
            } else {
              curIndex++;
            }

            if (curIndex === processedQueue.length) {
              curIndex = 0;
            }
          }
        }

        function findControllerIndexInControlList(controllerGObj) {
          //Desktop tests and never returns a z parent - Is that necessary?
          //Why would a z parent be a link to begin with?

          /*If this node has multiple parents in the
            control list, the one returned is the last one added.*/
          var j, ret;

          /*follow links to find the control index of the controller*/
          for (j = 0; j < controlList.length; j++) {
            if (controlList[j].gobj === controllerGObj) {
              ret = j;
            }
          }

          return ret;
        }

        function pruneControlList() {
          var i, j, oldIndex, secondHalfOfList;

          for (i = 0; i < controlList.length; i++) {
            if (
              controlList[i].controlRefs === 0 &&
              !controlList[i].isDragRoot
            ) {
              /*Found a item to prune */
              oldIndex = controlList[i].controlIndex;
              /*adjust anyone who references an item after our soon to be pruned item
                (no one should ever index anyone later in the list) */
              for (j = i + 1; j < controlList.length; j++) {
                if (controlList[j].controlIndex > i) {
                  controlList[j].controlIndex--;
                }
              }
              secondHalfOfList = controlList.slice(i + 1);
              controlList.splice(i);
              controlList = controlList.concat(secondHalfOfList);

              if (oldIndex >= 0) {
                controlList[oldIndex].controlRefs--;
                i = oldIndex - 1; //-1 because it will get incremented in the next loop
              } else {
                i--; //decrement i so we can recheck the new item stored there
              }
            }
          }
        }

        createOrderedGeomList();

        for (i = orderedGeomList.length - 1; i >= 0; i--) {
          aGobj = orderedGeomList[i];
          gobjBapInfo = queueMap[aGobj.id];

          if (
            gobjBapInfo.isController ||
            gobjBapInfo.isLink ||
            gobjBapInfo.isDragRoot ||
            gobjBapInfo.isSelectedZ
          ) {
            /*preprocess selected Z's*/
            if (gobjBapInfo.isSelectedZ) {
              gobjBapInfo.isController = true;
              gobjBapInfo.isDragRoot = true;
            }

            newItem = {
              gobj: aGobj,
              isController: gobjBapInfo.isController ? true : false,
              isDragRoot: gobjBapInfo.isDragRoot ? true : false,
              controlRefs: 0,
            };

            if (newItem.isController) {
              newItem.controlIndex = -1;
              newItem.isTransformParent = false;
            } else {
              newItem.controlIndex = findControllerIndexInControlList(
                gobjBapInfo.controller
              );
              newItem.isTransformParent =
                queueMap[gobjBapInfo.controller.id].transCode !==
                gobjBapInfo.transCode;
              controlList[newItem.controlIndex].controlRefs++;
            }

            controlList.push(newItem);
          }
        }

        pruneControlList();

        return controlList;
      }

      //Remove the last parent from loci if it is the same as the first parent for
      //proper BAP processing.
      //
      //
      //Returns an array of objects/parent pairs where the parent has been popped
      //from the parentsList so that it may be pushed back on after bap processing
      //
      //NOTE: If Loci stop adding the duplicate SampleGObj at the end of the parent
      //list as well as the beginning, these two functions can be removed.
      function pruneDuplicateParentFromLoci() {
        var theParentsList,
          retArray = [];

        for (anInputGObj = 0; anInputGObj < gobjlist.length; anInputGObj++) {
          theParentsList = gobjlist[anInputGObj].parentsList;

          if (
            gobjlist[anInputGObj].constraint === 'GeomLocus' &&
            theParentsList[0] === theParentsList[theParentsList.length - 1]
          ) {
            retArray.push({
              gobj: gobjlist[anInputGObj],
              parent: gobjlist[anInputGObj].parentsList.pop(),
            });
          }
        }
        return retArray;
      }

      //Undoes the action by pruneDuplicateParentsFromLoci()
      function readdDuplicateParentToLoci(removedPairArray) {
        var i;

        if (removedPairArray) {
          for (i = 0; i < removedPairArray.length; i++) {
            removedPairArray[i].gobj.parentsList.push(
              removedPairArray[i].parent
            );
          }
        }
      }

      var locusParentCache = pruneDuplicateParentFromLoci();

      for (anInputGObj = 0; anInputGObj < gobjlist.length; anInputGObj++) {
        addToPendingQueue(gobjlist[anInputGObj], 'selected', 0);
      }
      processQueue();
      controlListToReturn = buildControlListFromQueue();

      readdDuplicateParentToLoci(locusParentCache);

      return controlListToReturn;
    }

    var BapPrototype = {
      /**
       * Given a list of gobjs, return an array of gobjs that are the controllers of the.
       * set of input gobjs.
       *
       * @param {Array} gobjlist The gobj(s) to build a control list for.
       * @return {Array} The computed control list of gobjs.
       */
      createControlList: function(gobjlist) {
        var controlList,
          gobj = gobjlist[0];

        if (
          this.sketch.getOption('bap-useDebugControlList') &&
          gobjlist.length === 1 &&
          gobj.debug &&
          gobj.debug.controlList
        ) {
          controlList = GSP.ControlList.fromExternalList(
            gobj.debug.controlList,
            this.sketch
          );
        } else {
          controlList = buildControlList(gobjlist, this.sketch);
        }

        return controlList;
      },
    };

    return function(/* @lends GSP.Bap */ sketch) {
      /** @private m */
      var b = Object.create(BapPrototype);
      b.sketch = sketch;

      return b;
    };
  })();

  // jshint ignore: start
  /**
   *
   *  Base64 encode / decode
   *  http://www.webtoolkit.info/
   *
   **/
  if (typeof window.btoa === 'undefined') {
    var Base64 = {
      // private property
      _keyStr:
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',

      // public method for encoding
      encode: function(input) {
        var output = '';
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = Base64._utf8_encode(input);

        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);

          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;

          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }

          output =
            output +
            this._keyStr.charAt(enc1) +
            this._keyStr.charAt(enc2) +
            this._keyStr.charAt(enc3) +
            this._keyStr.charAt(enc4);
        }

        return output;
      },

      // public method for decoding
      decode: function(input) {
        var output = '';
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

        while (i < input.length) {
          enc1 = this._keyStr.indexOf(input.charAt(i++));
          enc2 = this._keyStr.indexOf(input.charAt(i++));
          enc3 = this._keyStr.indexOf(input.charAt(i++));
          enc4 = this._keyStr.indexOf(input.charAt(i++));

          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;

          output = output + String.fromCharCode(chr1);

          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }
        }

        output = Base64._utf8_decode(output);

        return output;
      },

      // private method for UTF-8 encoding
      _utf8_encode: function(string) {
        string = string.replace(/\r\n/g, '\n');
        var utftext = '';

        for (var n = 0; n < string.length; n++) {
          var c = string.charCodeAt(n);

          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if (c > 127 && c < 2048) {
            utftext += String.fromCharCode((c >> 6) | 192);
            utftext += String.fromCharCode((c & 63) | 128);
          } else {
            utftext += String.fromCharCode((c >> 12) | 224);
            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
            utftext += String.fromCharCode((c & 63) | 128);
          }
        }

        return utftext;
      },

      // private method for UTF-8 decoding
      _utf8_decode: function(utftext) {
        var string = '';
        var i = 0;
        var c = (c1 = c2 = 0);

        while (i < utftext.length) {
          c = utftext.charCodeAt(i);

          if (c < 128) {
            string += String.fromCharCode(c);
            i++;
          } else if (c > 191 && c < 224) {
            c2 = utftext.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
          } else {
            c2 = utftext.charCodeAt(i + 1);
            c3 = utftext.charCodeAt(i + 2);
            string += String.fromCharCode(
              ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)
            );
            i += 3;
          }
        }

        return string;
      },
    };
    GSP.btoa = function(template) {
      return Base64.encode(template);
    };
  } else {
    GSP.btoa = function(template) {
      return window.btoa(template);
    };
  }
  // jshint ignore: end
  /**
   * @fileOverview Tools to manage scrolling the sketch.
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /*global GSP:false*/
  /**
   * @namespace GSP.Scroll
   * Manage scrolling the sketch
   */
  GSP.Scroll = function(/* @lends GSP.Scroll */ sketch) {
    var singletonTracker = GSP.makeClass(GSP.TouchTracker, {
      primalLoc: null,
      touchBegan: function(pos, touch) {
        sketch.event('StartScroll', {
          touch: touch,
          position: pos,
        });
        this.primalLoc = GSP.GeometricPoint(pos.x, pos.y);
      },
      touchMoved: function(pos, touch) {
        var curPoint = GSP.GeometricPoint(pos.x, pos.y),
          translationAmt = this.primalLoc.subtract(curPoint),
          viewLoc = this.primalLoc.copy();

        sketch.event('MoveScroll', {
          touch: touch,
          position: pos,
        });
        //to detect cases where translation couldn't fully be realized, we cache the
        //primal location in view coords, then transform that location in the view
        //back to primal for our new position.  If we eventually want to be able to
        //detect changes that happen via other events (such as scroll buttons) we
        //would need to stire the view location in our state, and also add api for
        //us to get notified (and update our primal snapshot based on our cached
        //view location).
        sketch.primalToViewTransform().transform(viewLoc);

        sketch.translate(translationAmt.x, translationAmt.y, true);

        //take a new snapshot of point in primal coords
        //If the translation failed to be realized (on the edge of the scrollable plane)
        //we should now aim to keep the new primal position under the finger as the
        //scrolling position
        this.primalLoc = viewLoc.subtract(translationAmt);
        sketch.viewToPrimalTransform().transform(this.primalLoc);
      },
      touchEnded: function(touch) {
        sketch.event('EndScroll', {
          touch: touch,
        });
        //reset singleton's state
        this.primalLoc = null;
      },
    });

    return {
      /**
       * Returns true if a scroll is underways
       */
      isScrolling: function() {
        return !!singletonTracker.primalLoc;
      },
      /**
       *  'Creates' the scrolling drag tracker.  Since it's a singleton object,
       *  it actually just returns that object unless it's already been claimed.
       *  If a scroll is already underway, this method returns undefined.
       */
      createTracker: function() {
        if (!this.isScrolling()) {
          return singletonTracker;
        }
      },
      /**
       * allows other clients to translate the sketch underneath any touch-
       * scrolls that may be in progress (eg. Scroll buttons).
       */
      translate: function(dx, dy) {
        var viewLoc,
          touchInProgress = this.isScrolling();

        if (touchInProgress) {
          viewLoc = singletonTracker.primalLoc.copy();
          sketch.primalToViewTransform().transform(viewLoc);
        }

        sketch.translate(dx, dy, false);

        if (touchInProgress) {
          sketch.viewToPrimalTransform().transform(viewLoc);
          singletonTracker.primalLoc = viewLoc;
        }
      },
    };
  };

  /**
   * @fileOverview Manage motions.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @preserve Copyright © 2013 KCP Technologies, Inc. All rights reserved.
   *
   * The motion manager encapsulates gobjecs in a sketch which are undergoing
   * movement. This can be from a user drag, or from the action of a button, or
   * some external source.
   *
   * To put a motion in, ahem, motion, you shoud.
   *   * Create the motion, which is (currently) an object with:
   *     functions:
   *     -  applyMotion(refCon) where refCon is the last refCon object
   *        suppled by UpdateRefCon(), q.v. This callback does the actual work of
   *        moving any free/semi-free gobjects.
   *     - completeMotion(). Cleanup callback called just before the motion ends.
   *     properties:
   *     - controlList: a control list object generated (typically) by bap.createControlList()
   *     - isValueChangingMotion: when true, this motion controls the value of the object
   *        rather than the position of the object.  Otherwise, leave undefined.
   *
   *   * Start your motion with GSP.MotionManager.StartMotion(motion), which will
   *     return a motion id which is used in later motion manager calls.
   *   * If necessary, update your motion with a new refCon UpdateRefCon(id, refCon).
   *     The refCon here is a caller defined object that will be passed back to the caller
   *     at the next applyMotion(refCon) call. A drag, for example, will want to update
   *     with an refCon that encapsulates the latest drag event.
   *   * When done, stop the motion with EndMotion(id). This schedules the motion for termination,
   *     and a callback to completeMotion(). Note that this is safe to call from within the
   *     applyMotion() callback.
   *
   */
  /*global GSP:false, $:false*/
  /**
   * @namespace GSP.MotionManager
   * Manage motions.
   */
  GSP.MotionManager = (function() {
    // returns true if two motions share the same drag root
    function motionsConflict(first, second) {
      var rootsOfFirst = [],
        i,
        j;

      //Are the motions the same kind re position vs. valueChanging?
      //If not, they don't conflict
      if (first.isValueChangingMotion !== second.isValueChangingMotion) {
        return false;
      }

      //If either one is missing a control list, they can't conflict
      if (!(first.controlList && second.controlList)) {
        GSP.signalErrorWithMessage(
          'motionsConflict finds motion without a control list'
        );
        return false;
      }

      //go backwards since dragRoots are at the end of the list
      for (i = first.controlList.length - 1; i >= 0; i--) {
        if (first.controlList[i].isDragRoot) {
          rootsOfFirst.push(first.controlList[i].gobj);
        }
      }

      for (i = second.controlList.length - 1; i >= 0; i--) {
        if (second.controlList[i].isDragRoot) {
          for (j = 0; j < rootsOfFirst.length; j++) {
            if (rootsOfFirst[j] === second.controlList[i].gobj) {
              return true;
            }
          }
        }
      }

      return false;
    }

    var MotionManagerPrototype = {
      _motionJob: null,
      /**
       * Schedules a motion.
       * @memberOf GSP.MotionManager
       * @param {Object} motion The motion to be scheduled.
       * @return {Number} id of motion
       */
      StartMotion: function(motion, refCon) {
        var id = this.motionID++,
          i,
          self = this;

        this.motionSet[id] = {
          motion: motion,
          state: 'active', // 'active', 'cancelled'
          refCon: refCon,
        };

        for (i = 0; i < this.motionList.length; i++) {
          if (
            motionsConflict(this.motionSet[this.motionList[i]].motion, motion)
          ) {
            GSP.log(
              'found conflicting motions, canceling ' +
                this.motionList[i] +
                ', keeping ' +
                id
            );
            this.EndMotion(this.motionList[i]);
          }
        }

        this.motionList.push(id);

        function motionJob() {
          return self.ApplyCurrent();
        }

        var jobOptions = {
          repeat: true,
          done: function() {
            self._motionJob = null;
          },
        };

        if (!GSP.JobScheduler.isActive(self._motionJob)) {
          self._motionJob = self.sketch.jobScheduler.addJob(
            motionJob,
            jobOptions
          );
        }

        return id;
      },
      /**
       * Updates a motion.
       * @memberOf GSP.MotionManager
       * @param {Number} id The id of the motion to update.
       * @param {Object} refCon The refCon to fed to future applyMotion() callbacks.
       * @return {undefined}
       */
      UpdateRefCon: function(id, refCon) {
        this.motionSet[id].refCon = refCon;
      },
      GetRefCon: function(id) {
        return this.motionSet[id].refCon;
      },
      /**
       * Ends a motion. Or more properly, queues the motion for ending.
       * @memberOf GSP.MotionManager
       * @param {Number} id The id of the motion to update.
       * @return {undefined}
       */
      EndMotion: function(id) {
        this.motionSet[id].state = 'cancelled';
      },
      /**
       * Stops all motions.
       * @memberOf GSP.MotionManager
       * @param {Number} id The id of the motion to update.
       * @return {undefined}
       */
      StopAllMotions: function() {
        var sketch = this.sketch;
        sketch.sQuery('Button').forEach(function(iGObj) {
          if (
            (iGObj.constraint === 'ActionButtonMove' ||
              iGObj.constraint === 'ActionButtonAnimate') &&
            iGObj.state.isActive
          ) {
            iGObj.press(sketch);
          }
        });
      },
      /**
       * Process current motions. Generally called by the sketch which owns
       * this motion manager.
       * @return {undefined}
       */
      ApplyCurrent: function() {
        var i,
          mot,
          that = this;

        // Process active motions. Note that the motion is allowed
        // to cancel itself during this process.
        for (i = 0; i < this.motionList.length; i++) {
          mot = this.motionSet[this.motionList[i]];
          if (mot.state === 'active') {
            try {
              mot.motion.applyMotion(mot.refCon);
            } catch (ex3) {
              //GSP.log(ex3);
            }
          }
        }

        // Reap the canceled motions.
        // First complete them and mark that by deleting them from the motionSet ...
        for (i in this.motionList) {
          mot = this.motionSet[this.motionList[i]];
          if (mot.state === 'cancelled') {
            try {
              mot.motion.completeMotion(mot.refCon);
            } catch (ex2) {
              //GSP.log(ex2);
            }
            delete this.motionSet[this.motionList[i]];
          }
        }
        // .. then remove from the list those motions that have gone away.
        this.motionList = $.grep(this.motionList, function(id) {
          return undefined !== that.motionSet[id];
        });

        if (this.motionList.length === 0) {
          return false;
        }
      },
      /**
       * Utility for applying a given transform to a given controlList, applying
       * the appropriate transforms to the appropriate drag roots.
       * properties:
       *   snapPoints: bool
       *   onPathTracksIdealLoc: bool
       *
       * @return {undefined}
       */
      ApplyTransformToControlList: function(
        sketch,
        transform,
        controlList,
        properties
      ) {
        var i,
          item,
          gobj,
          snapToGrid =
            properties &&
            properties.snapPoints &&
            sketch.preferences.snapToGrid,
          snapCoordSys,
          snapToGObj;

        if (snapToGrid) {
          snapCoordSys = sketch.findExistingCoordSys();
        }

        for (i = 0; i < controlList.length; i++) {
          item = controlList[i];
          gobj = item.gobj;

          snapToGObj = snapCoordSys;

          // obj.style.snapToGrid was gobject level property that
          // enabled individual gobjects to turn on snapping (v3.0.0)
          // We'll honor it as a minor backwards compatibility feature.
          if (snapToGrid && !snapToGObj && gobj.style.snapToGrid) {
            snapToGObj = gobj.getGObjRef(gobj.style.snapToGrid);
          }

          if (item.isController) {
            item.transform = transform;
          } else {
            item.transform = controlList[item.controlIndex].transform;
          }

          if (item.isTransformParent) {
            var control = controlList[item.controlIndex],
              transformer = control.gobj.getTransformer(),
              t = transformer.getAffineTransform(),
              tInv;

            tInv = t.inverse();
            if (null !== tInv) {
              item.transform = t.compose(control.transform).compose(tInv);
            }
          }

          if (item.isDragRoot && gobj.state.exists) {
            if (
              properties &&
              properties.onPathTracksIdealLoc &&
              item.gobj.kind === 'Point'
            ) {
              //The below strategy will only work for points, since we rely on
              //point-specific data in the geom property.  Fortunately, only points
              //will ever be on a path, so other objects can just use the
              //strategy for non "onPathTracksIdealLoc"

              if (!item.idealLocation) {
                item.idealLocation = { loc: item.gobj.geom.loc.copy() };
              }

              item.idealLocation.loc = item.transform.transform(
                item.idealLocation.loc
              );
              //short circuit the normal transform path by seeding the geom with the desired
              //location and passing an identity transform
              gobj.transform(sketch, {
                geom: item.idealLocation,
                affine: GSP.AffineTransform.Identity,
              });
            } else {
              gobj.transform(sketch, {
                geom: item.gobj.geom,
                affine: item.transform,
              });
            }

            // Snap "snappable" points to the appropriate coordinate system.
            if (gobj.kind === 'Point' && snapToGObj) {
              if (
                snapToGObj.snapPoint &&
                snapToGObj.state.exists &&
                !gobj.hasDescendant(snapToGObj)
              ) {
                snapToGObj.snapPoint(gobj.geom.loc);
              }
            }

            gobj.sQuery.sketch.invalidateGeom(gobj, 'drag'); // invalidated due to a drag
          }
        }
      },

      ApplyTransformToGobjUsingKeys: function(sketch, transform, controlList) {
        // var controlList = sketch.Bap.createControlList([gobj]);
        // var transformObject = {
        //   'm00': 1,
        //   'm11': 1,
        //   'm20': transform.dx,
        //   'm21': transform.dy
        // };

        var i, item;
        for (i = 0; i < controlList.length; i++) {
          item = controlList[i];
          // transform the path by seeding the geom with the desired location and passing an affine transform
          item.gobj.transform(sketch, {
            geom: item.gobj.geom,
            affine: transform,
          });

          sketch.invalidateGeom(item.gobj);
        }
      },
    };

    return function(/* @lends GSP.MotionManager */ sketch) {
      /** @private m */
      var m = Object.create(MotionManagerPrototype);

      m.motionList = []; // ordered list of motion id's

      m.sketch = sketch; // Keep a back-pointer to the sketch which owns us
      m.motionID = 0; // We'll keep unique id's for our motions

      m.motionSet = {}; // map id -> motion

      return m;
    };
  })();

  /**
   * @fileOverview A Geometric Point.
   * @author <a href="mailto:jsandoe@kcptech.com">Jonathan Sandoe</a>
   * @version 0.0
   *
   *
   * A GeometricPoint encapsulates an {x, y} position on the plane
   * In general, the routines acting on GeometricPoints create new GeometricPoints,
   * but where efficiency is a concern, can act directly on the x and y values
   * of passed in points.
   *
   *
   * @preserve (C) KCP Technologies, 2011.
   */

  /**
   * @class A Geometric Point.
   * Constructs a Geometric Point.
   * @param {number} x the horizontal coordinate of a GeometricPoint.
   * @param {number} y the vertical coordinate of a GeometricPoint.
   * @return {object} A Geometric Point.
   */
  GSP.GeometricPoint = (function(/* @lends GSP.GeometricPoint */) {
    var GeometricPointPrototype = /** @lends GSP.GeometricPoint */ {
      transformClass: 'GeometricPoint', // mark this as Geom Transformable.
      /**
       * Returns the x component of the GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {number} The x component of the GeometricPoint.
       */
      getX: function() {
        return this.x;
      },

      /**
       * Returns the y component of the GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {number} The y component of the GeometricPoint.
       */
      getY: function() {
        return this.y;
      },

      /**
       * Returns a string representation of the GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {string} a representation of the GeometricPoint.
       */
      toString: function() {
        return '{ x:' + this.x + ', y:' + this.y + '}';
      },

      /**
       * Returns whether this GeometricPoint equals the argument GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @param {GSP.GeometricPoint} v Another GeometricPoint.
       * @param {Number} epsilon An error tolerance. If v is within epsilon
       * of this GeometricPoint, they are considered equal.
       * @return {boolean} whether this GeometricPoint equals the argument GeometricPoint.
       */
      equals: function(v, epsilon) {
        if (typeof epsilon === 'undefined') {
          epsilon = 0;
        }
        if (v) {
          return (
            Math.abs(this.x - v.x) <= epsilon &&
            Math.abs(this.y - v.y) <= epsilon
          );
        } else {
          return false;
        }
      },

      /**
       * Returns a new GeometricPoint that is the negation of this GeometricPoint.
       * This is equivalent to scalar multiplication by -1.
       * @memberOf GSP.GeometricPoint
       * @return {GSP.GeometricPoint} A GeometricPoint.
       */
      negate: function() {
        return GSP.GeometricPoint(-this.x, -this.y);
      },

      /**
       * Returns a new GeometricPoint whose coordinates are rounded to int.
       * @memberOf GSP.GeometricPoint
       * @return {GSP.GeometricPoint} A GeometricPoint.
       */
      round: function() {
        return GSP.GeometricPoint(Math.round(this.x), Math.round(this.y));
      },

      /**
       * Returns a new GeometricPoint that is the sum of this GeometricPoint and the argument.
       * @memberOf GSP.GeometricPoint
       * @param {GSP.GeometricPoint} v A GeometricPoint to be added to this GeometricPoint.
       * @return {GSP.GeometricPoint} A GeometricPoint.
       */
      add: function(v) {
        return GSP.GeometricPoint(this.x + v.getX(), this.y + v.getY());
      },

      /**
       * Returns a new GeometricPoint that is the difference between this GeometricPoint
       * and the argument.
       * @memberOf GSP.GeometricPoint
       * @param {GSP.GeometricPoint} v A GeometricPoint to be subtracted from this GeometricPoint.
       * @return {GSP.GeometricPoint} A GeometricPoint.
       */
      subtract: function(v) {
        return GSP.GeometricPoint(this.x - v.getX(), this.y - v.getY());
      },

      /**
       * Returns a new GeometricPoint that is the scalar product of this GeometricPoint
       * and the argument.
       * @memberOf GSP.GeometricPoint
       * @param {number} s a scalar value.
       * @return {GSP.GeometricPoint} A GeometricPoint.
       */
      multiply: function(s) {
        return GSP.GeometricPoint(this.x * s, this.y * s);
      },

      /**
       * Returns a number that is the dot product of this GeometricPoint and the
       * argument.
       * @memberOf GSP.GeometricPoint
       * @param {GSP.GeometricPoint} v A GeometricPoint.
       * @return {number} the dot product.
       */
      dot: function(v) {
        return this.x * v.getX() + this.y * v.getY();
      },

      /**
       * Returns the length of this GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {number} the length of this GeometricPoint.
       */
      vLength: function() {
        return Math.sqrt(this.dot(this));
      },

      /**
       * Returns the distance of this pointfrom the passed in point.
       * @memberOf GSP.GeometricPoint
       * @return {number} the distance.
       */

      distance: function(p) {
        return this.subtract(p).vLength();
      },

      /**
       * Returns the length squared of this GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {number} the length of this GeometricPoint.
       */
      vLength2: function() {
        return this.dot(this);
      },

      /**
       * Returns the l1 norm / manhatten distance of this GeometricPoint.
       * @memberOf GSP.GeometricPoint
       * @return {number} the length of this GeometricPoint.
       */
      l1Norm: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      },

      /**
       * Returns whether this GeometricPoint is zero length.
       * @memberOf GSP.GeometricPoint
       * @return {boolean} whether this GeometricPoint is zero length.
       */
      isZeroLength: function() {
        return this.x === 0 && this.y === 0;
      },
      isFinite: function() {
        return isFinite(this.x) && isFinite(this.y);
      },
      isDefined: function() {
        return !isNaN(this.x) && !isNaN(this.y);
      },

      rotate: function(pivot, angle) {
        var tpoint = this.subtract(pivot);
        var cosA = Math.cos(angle);
        var sinA = Math.sin(angle);
        var newPoint = GSP.GeometricPoint(
          cosA * tpoint.x - sinA * tpoint.y,
          sinA * tpoint.x + cosA * tpoint.y
        );
        return newPoint.add(pivot);
      },

      /**
       * Returns the GeometricPoint in the same direction with magnitude 1 as this
       * GeometricPoint.
       */
      unit: function() {
        return this.multiply(1 / this.vLength());
      },

      /**
       * Scales a GeometricPoint from the pivot point to this point by a scale factor.
       */
      scale: function(pivot, scaleFactor) {
        return this.subtract(pivot)
          .multiply(scaleFactor)
          .add(pivot);
      },

      /**
       * Return a copy of the point.
       */
      copy: function() {
        return this.multiply(1);
      },
    };

    return function(x, y) {
      // Create a GeometricPoint from the x and y values, or from a single param with x and y attributes
      var GeometricPoint;
      if (x && x.x && x.y && y === undefined) {
        // single param has both x and y
        return GSP.GeometricPoint(x.x, x.y);
      }
      if (typeof x === 'string') {
        x = Number(x);
      } else if (typeof x !== 'number') {
        x = NaN;
      }
      if (typeof y === 'string') {
        y = Number(y);
      } else if (typeof y !== 'number') {
        y = NaN;
      }
      GeometricPoint = Object.create(GeometricPointPrototype);

      GeometricPoint.x = x;
      GeometricPoint.y = y;

      return GeometricPoint;
    };
  })();

  /**
   * A constant for the (0,0) position.
   */
  GSP.GeometricPoint.ORIGIN = GSP.GeometricPoint(0, 0);
  GSP.GeometricPoint.INFINITY = GSP.GeometricPoint(Infinity, Infinity);
  GSP.GeometricPoint.UNDEFINED = GSP.GeometricPoint(undefined, undefined);

  /**
   * Create a GeometricPoint from center, radius, and angle.
   * @param {GeometricPoint} center   Center point
   * @param {Number} radius   Radius
   * @param {GeometricPoint} angle   Angle in radians
   * @return {GeometricPoint}
   */
  GSP.GeometricPoint.FromCenterRadiusAngle = function(center, radius, theta) {
    return GSP.GeometricPoint(
      center.x + radius * Math.cos(theta),
      center.y + radius * Math.sin(theta)
    );
  };

  /**
   * Three point angle.
   * @param {GeometricPoint} a   First point
   * @param {GeometricPoint} b   Second point
   * @param {GeometricPoint} c   Third point
   * @return {Number} Three point angle in radians in the range (-pi,pi].
   */
  GSP.GeometricPoint.threePointAngle = function(a, b, c) {
    var aPrime, cPrime, temp, theta;
    aPrime = a.subtract(b);
    temp = c.subtract(b);

    // rotate a to the x-axis, and scale by the length of a.
    // No need to calculate a new A.y; we know it's zero.
    cPrime = new GSP.GeometricPoint(
      temp.dot(aPrime),
      temp.y * aPrime.x - temp.x * aPrime.y
    );
    aPrime = new GSP.GeometricPoint(aPrime.dot(aPrime), 0);

    // both the angle, ratio and collinearity are undefined if a == b
    if (Math.abs(aPrime.x) < 0.0004) {
      return undefined;
    }
    if (Math.abs(cPrime.x) < 0.0004) {
      if (Math.abs(cPrime.y) < 0.0004) {
        //  the angle is undefined if c == b
        return undefined;
      } else if (cPrime.y > 0) {
        theta = Math.PI / 2;
      } else {
        theta = -Math.PI / 2;
      }
    } else {
      if (Math.abs(cPrime.y) < 0.0004) {
        theta = cPrime.x >= 0 ? 0 : Math.PI;
      } else {
        theta = Math.atan(cPrime.y / cPrime.x);
        if (cPrime.x < 0) {
          if (cPrime.y >= 0) {
            theta += Math.PI;
          } else {
            theta -= Math.PI;
          }
        }
      }
    }
    return theta;
  };

  /**
   * threePointFlippedAngle should be used in place of threePointAngle() when the angle is
   * to be a user-facing angle measurement.  Generally, Sketchpad objects' positions are in primal
   * coordinates (and rendering is also in primal coordinates), where positive Y extends down from top
   * left.  Measurements should behave as if the coordinate system is a normal cartesian coordinate system
   * with positive Y incrementing from the bottom of the screen.  This means the angle needs to be flipped
   * except in the case of a straight angle (0 or 180 degrees).  This flipping logic lives in
   * ThreePointFlippedAngle_UTIL, whose arguments and return are equivalent to ThreePointAngle_UTIL()
   * @param {GeometricPoint} a   First point
   * @param {GeometricPoint} b   Second point
   * @param {GeometricPoint} c   Third point
   * @return {Number} Three point angle in radians in the range (-pi,pi].
   */

  GSP.GeometricPoint.threePointFlippedAngle = function(a, b, c) {
    var ret = GSP.GeometricPoint.threePointAngle(a, b, c);

    /* ThreePoint returns +pi (or +0) for straight angles, which we want to preserve
     in our measured output, which is vertically flipped.  So we cannot
     negate that double-pole, but all other angles need to be flipped. */

    if (Math.abs(ret) > 0.0 && Math.abs(ret) < Math.PI) {
      ret = -ret;
    }

    return ret;
  };

  /* GSP.math.expect close tolerance function for Geometric Point */

  GSP.GeometricPoint.expect = function(value, expected, tol) {
    if ((value === undefined) !== (expected === undefined)) {
      return false;
    }
    if ((value === null) !== (expected === null)) {
      return false;
    }
    return (
      GSP.math.expect(value.getX(), expected.getX(), tol, true) &&
      GSP.math.expect(value.getY(), expected.getY(), tol, true)
    );
  };

  /**
   * Find the closest point on a line from the given point.
   * @p0 {GeometricPoint} First control point
   * @p1 {GeometricPoint} Second control point
   * @p {GeometricPoint} The given point
   * @args {Object} Variant behavior. args.returnPoint(Boolean): return the 'point', args.clampP0(Boolean): don't go past p0, args.clampP1(Boolean): don't go past p1.
   * @return {{ point: GeometricPoint, param: Number}} p the closest point, and param its parameter value along p0 -> p1
   */
  GSP.GeometricPoint.mapPointToLine = function(p0, p1, p, args) {
    var normalizedPoint,
      normalizedEnd,
      normalizedValue, // if p0 and p1 coincide, this value
      // will apply
      ret = {};
    normalizedPoint = p.subtract(p0);
    normalizedEnd = p1.subtract(p0);
    // The following could result in a divide by zero,
    // which is fine in these circumstances. We do not want normalizedValue
    // to evaluate to a finite number, if the line p0-p1 is undefined.
    // See test page: Gobj-Dilate3PtRation-ScaleFactorInfinity
    normalizedValue =
      normalizedPoint.dot(normalizedEnd) / normalizedEnd.dot(normalizedEnd);

    if (args) {
      if (args.clampP0 && normalizedValue < 0) {
        normalizedValue = 0;
      }

      if (args.clampP1 && normalizedValue > 1) {
        normalizedValue = 1;
      }

      if (args.returnPoint) {
        ret.point = p0.add(normalizedEnd.multiply(normalizedValue));
      }
    }

    ret.param = normalizedValue;

    return ret;
  };

  /**
   * Create a function that returns a transformed GeometricPoint
   * @param {String} methodName  Name of method of GeometricPoint to invoke.
   * @param {...Object} var_args Optional list of arguments to pass to GeometricPointMethod
   * @return {function} A function that maps GeometricPoint -> GeometricPoint
   */
  GSP.GeometricPoint.curryFunction = function(methodName /*, ... */) {
    var args = Array.prototype.slice.call(arguments, 1);

    return function(vec) {
      return vec[methodName].apply(vec, args);
    };
  };

  /**
   * @fileOverview An AffineTransform class.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2011.
   */
  /*
    An AffineTransform represents the variable components of a 3x3 matrix in homogeneous
    coordinates.  Notationally, matrix components are labeled "mxy", where x and y are in
    (0, 1, 2).  Structually, such a matrix is set up for point transformations as follows:
  
                  +--         --+
    [ x' ]        | m00 m10 m20 |   [ x ]  The points m00, m01, m10, and m11 are frequently also called (a, b, c, d).
    | y' |  =     | m01 m11 m21 | * | y |  The point (m20, m21) is frequently also called (dx, dy).
    [ 1  ]        |  0   0   1  |   [ 1 ]
                  +--         --+
                        
    This column-vector / matrix form reduces to:
  
    x' = m00 * x + m10 * y + m20
    y' = m01 * x + m11 * y + m21
    
    If you prefer to think of your points as row-vectors rather than column-vectors, 
    and have a transform matrix with upper-left square A, B, C, D, and upper-right Tx, Ty,
    with lowest row 0, 0, 1, then A = m00, B = m01, C = m10, D = m11, Tx = m20, and Ty = m21
    is the correspondence.
  */

  /**
   * @class Affine Transformation class
   *  Throughout, we assume points are represented by GSP.GeometricPoint {GeometricPoint}
   *
   *  We also define (conceptually, not as a classes)
   *  {XYValue} - arguments conformant to:
   *    (x, y) - two {number} arguments
   *    {'x': x, 'y': y} - e.g. a GeometricPoint
   *    {'dx': x, 'dy': y}
   *  {PointList} - arguments conformant to:
   *    {GeometricPoint} one geometric point
   *    [GeometricPoint, ..., GeometricPoint] an array of geometric points
   */
  (function() {
    var AffineTransformPrototype,
      AffineTransform,
      keynames = ['m00', 'm10', 'm20', 'm01', 'm11', 'm21'],
      PACKED_SAMPLE_SIZE = 6;

    /* For a function that takes, conceptually, an (x,y)
      pair, we'll allow one of (x,y), ({'x': x, 'y': y}),  and ({'dx': x, 'dy': y}) 
      as valid arguments */
    function extractXYArgs(xValueOrObject, yValue) {
      var x = xValueOrObject,
        y = yValue;
      if (y === undefined) {
        x = xValueOrObject.hasOwnProperty('dx')
          ? xValueOrObject.dx
          : xValueOrObject.x;
        y = xValueOrObject.hasOwnProperty('dy')
          ? xValueOrObject.dy
          : xValueOrObject.y;
      }

      return { x: x, y: y };
    }

    AffineTransformPrototype = {
      transformClass: 'AffineTransform', // mark this as Geom Transformable.
      /* stringification */
      toString: function() {
        var str = '[';
        str +=
          '[m00: ' + this.m00 + ' m10: ' + this.m10 + ' m20: ' + this.m20 + ']';
        str +=
          '[m01: ' + this.m01 + ' m11: ' + this.m11 + ' m21: ' + this.m21 + ']';
        str += ']';

        return str;
      },
      toStringCSS: function() {
        return (
          'matrix(' +
          this.m00 +
          ',' +
          this.m01 +
          ',' +
          this.m10 +
          ',' +
          this.m11 +
          ',' +
          this.m20 +
          ',' +
          this.m21 +
          ')'
        );
      },

      /*
       * Apply this transform in place to points
       *
       * @param {PointList} points
       */
      transform: function(points) {
        var k, xp, yp;
        if (points.getX && points.getY) {
          xp = this.m00 * points.getX() + this.m10 * points.getY() + this.m20;
          yp = this.m01 * points.getX() + this.m11 * points.getY() + this.m21;
          points.x = xp;
          points.y = yp;

          return points;
        } else if (typeof points === 'object') {
          for (k in points) {
            this.transform(points[k]);
          }
        }
      },
      /**
       * Returns a new transform = t * this
       * @param {AffineTransform} t left multiplicand
       * @return {AffineTransform} Resulting transformation
       */

      compose: function(t) {
        return new AffineTransform({
          m00: t.m00 * this.m00 + t.m10 * this.m01,
          m10: t.m00 * this.m10 + t.m10 * this.m11,
          m20: t.m00 * this.m20 + t.m10 * this.m21 + t.m20,
          m01: t.m01 * this.m00 + t.m11 * this.m01,
          m11: t.m01 * this.m10 + t.m11 * this.m11,
          m21: t.m01 * this.m20 + t.m11 * this.m21 + t.m21,
        });
      },
      /**
       * Returns a new transform = translation * this
       * @param {XYValue} translation vector
       * @return {AffineTransform} Resulting transformation
       */

      translate: function(xValueOrObject, yValue) {
        var delta = extractXYArgs(xValueOrObject, yValue);

        return new AffineTransform({
          m00: this.m00,
          m10: this.m10,
          m20: this.m20 + delta.x,
          m01: this.m01,
          m11: this.m11,
          m21: this.m21 + delta.y,
        });
      },
      /**
       * Returns a new transform = scale * this
       * @param {XYValue} scale vector
       * @return {AffineTransform} Resulting transformation
       */

      scale: function(xValueOrObject, yValue) {
        var s = extractXYArgs(xValueOrObject, yValue);
        /*
          [x 0 0]  [m00 m10 m20]
          |0 y 0|  |m01 m11 m21|
          [0 0 1]  [0   0   1  ]
        */

        return new AffineTransform({
          m00: this.m00 * s.x,
          m10: this.m10 * s.x,
          m20: this.m20 * s.x,
          m01: this.m01 * s.y,
          m11: this.m11 * s.y,
          m21: this.m21 * s.y,
        });
      },
      /**
       * Returns a new transform = rotation * this
       * @param {number} angle Angle in radians
       * @return {AffineTransform} Resulting transformation
       */

      rotate: function(angle) {
        var cosA = Math.cos(angle),
          sinA = Math.sin(angle);

        /*
          [cosA -sinA 0]  [m00 m10 m20]
          |sinA  cosA 0|  |m01 m11 m21|
          [0     0    1]  [0   0   1  ]
        */
        return new AffineTransform({
          m00: cosA * this.m00 - sinA * this.m01,
          m10: cosA * this.m10 - sinA * this.m11,
          m20: cosA * this.m20 - sinA * this.m21,
          m01: sinA * this.m00 + cosA * this.m01,
          m11: sinA * this.m10 + cosA * this.m11,
          m21: sinA * this.m20 + cosA * this.m21,
        });
      },

      /**
       * Returns a new transform = (this)^-1
       * or null if there is no inverse.
       */

      inverse: function() {
        var det = this.m00 * this.m11 - this.m10 * this.m01;
        if (!det) {
          return null;
        }

        return new AffineTransform({
          m00: this.m11 / det,
          m10: -this.m10 / det,
          m20: (-this.m11 * this.m20 + this.m10 * this.m21) / det,
          m01: -this.m01 / det,
          m11: this.m00 / det,
          m21: (this.m01 * this.m20 - this.m00 * this.m21) / det,
        });
      },

      /*
       * Return new AffineTransform which is a copy of this one.
       */
      copy: function() {
        return new AffineTransform(this);
      },

      isEqual: function(iTransform) {
        return (
          this.m00 === iTransform.m00 &&
          this.m10 === iTransform.m10 &&
          this.m20 === iTransform.m20 &&
          this.m01 === iTransform.m01 &&
          this.m11 === iTransform.m11 &&
          this.m21 === iTransform.m21
        );
      },
      isTranslation: function() {
        return (
          this.m00 === 1 && this.m10 === 0 && this.m01 === 0 && this.m11 === 1
        );
      },
      packIntoSampleArray: function(samples, sampleIndex) {
        var base = PACKED_SAMPLE_SIZE * sampleIndex;

        samples[base] = this.m00;
        samples[base + 1] = this.m10;
        samples[base + 2] = this.m20;
        samples[base + 3] = this.m01;
        samples[base + 4] = this.m11;
        samples[base + 5] = this.m21;
      },
    };

    /**
     * @constructor
     */

    AffineTransform = function(values) {
      var aT = Object.create(AffineTransformPrototype),
        k,
        kn;
      for (k in keynames) {
        kn = keynames[k];
        aT[kn] = values.hasOwnProperty(kn) ? values[kn] : 0;
      }
      return aT;
    };

    /* Constants */
    AffineTransform.Identity = new AffineTransform({ m00: 1, m11: 1 });
    AffineTransform.KeyNames = keynames;

    /* Class functions */

    /**
     * Functor the returns a new AffineTransform which is, in matrix form,
     * the same as the pointTransform function, a javascript
     * function GeometricPoint -> GeometricPoint, which must be affine.
     * @param {array} pointTransform
     * @return {AffineTransform} An AffineTransform.
     */
    AffineTransform.fromPointTransform = function(pointTransform) {
      var z = pointTransform(GSP.GeometricPoint(0, 0)),
        a = pointTransform(GSP.GeometricPoint(1, 0)),
        b = pointTransform(GSP.GeometricPoint(0, 1)),
        dx = z.getX(),
        dy = z.getY();
      return new AffineTransform({
        m00: a.getX() - dx,
        m01: a.getY() - dy,
        m10: b.getX() - dx,
        m11: b.getY() - dy,
        m20: dx,
        m21: dy,
      });
    };

    /**
     * Returns a new Affine transform that maps the 3 source points in
     * array s to the 3 destination points in array d.
     * @param {array} s an array of 3 GeometricPoint's
     * @param {array} d an array of 3 GeometricPoint's
     * @return {AffineTransform} An AffineTransform.
     */
    AffineTransform.fromPointMapping = function(s, d) {
      var d21 = s[2].subtract(s[1]),
        d20 = s[2].subtract(s[0]),
        T = d21.getY() * d20.getX() + d21.getX() * -d20.getY(),
        pointTransform,
        ret = null;

      if (T !== 0) {
        pointTransform = function(point) {
          var r = point.subtract(s[2]),
            l0 = (-d21.getY() * r.getX() + d21.getX() * r.getY()) / T,
            l1 = (d20.getY() * r.getX() + -d20.getX() * r.getY()) / T,
            l2 = 1 - l0 - l1;

          return d[0]
            .multiply(l0)
            .add(d[1].multiply(l1))
            .add(d[2].multiply(l2));
        };

        ret = GSP.AffineTransform.fromPointTransform(pointTransform);
      }

      return ret;
    };

    AffineTransform.fromPackedSampleArray = function(samples, sampleIndex) {
      var base = sampleIndex * PACKED_SAMPLE_SIZE,
        values = {
          m00: samples[base],
          m10: samples[base + 1],
          m20: samples[base + 2],
          m01: samples[base + 3],
          m11: samples[base + 4],
          m21: samples[base + 5],
        };

      return new AffineTransform(values);
    };

    AffineTransform.packedSampleSize = PACKED_SAMPLE_SIZE;

    // export to GSP namespace
    GSP.AffineTransform = AffineTransform;
  })();
  /**
   * @fileOverview A GeomTransformer class.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   *  The GeomTransformer class is an object which knows how to transform Geometry
   *  as found in the GObject's "geom" object.
   *  It knows how to deal with scalars (which it takes to be a species of distance), GeometricPoint,
   *  and AffineTransform objects. It will also deal with arrays of such.
   *
   *
   * @preserve (C) KCP Technologies, 2011.
   */

  (function(namesp) {
    var G = namesp,
      GeomTransformerPrototype,
      GeomTransformer,
      copyGeom;

    GeomTransformerPrototype = {
      /*
       * @param {Object} geom Potentially transformable object.
       *
       * @return {string} Classification of transformable ("distance"|"GeometricPoint"|"AffineTransform"|undefined).
       */
      transformClass: function(value) {
        if (typeof value === 'number') {
          return 'distance';
        }

        return value.transformClass;
      },

      transformGeometricArc: function(transformable) {
        var transformer = this;

        function transformStraightArc() {
          var p0 = transformer.point
              ? transformer.point(transformable.initialPoint)
              : transformable.initialPoint,
            p1 = transformer.point
              ? transformer.point(transformable.finalPoint)
              : transformable.finalPoint;

          return GSP.GeometricArc.FromStraightEndpoints(p0, p1);
        }

        function transformThreePointArc() {
          var p0 = transformer.point
              ? transformer.point(transformable.initialPoint)
              : transformable.initialPoint,
            p1 = transformer.point
              ? transformer.point(transformable.middlePoint)
              : transformable.middlePoint,
            p2 = transformer.point
              ? transformer.point(transformable.finalPoint)
              : transformable.finalPoint,
            linTransformable = GSP.Geom.ThreePointCollinear(
              transformable.initialPoint,
              transformable.finalPoint,
              transformable.middlePoint
            ),
            arc = GSP.GeometricArc.FromThreePoints(p0, p1, p2);

          //If the original arc had a different orientation than linTransformable
          //recreated from its points, then the translated arc will have gotten its sign
          //wrong in the resulting orientation.  So we flip it here.
          if (transformable.orientation !== linTransformable.orientation) {
            arc.orientation *= -1;
          }
          return arc;
        }

        return transformable.orientation === 0
          ? transformStraightArc()
          : transformThreePointArc();
      },

      doOneTransform: function(transformable, transformClass) {
        if (transformClass === undefined) {
          transformClass = this.transformClass(transformable);
        }

        switch (transformClass) {
          case 'distance':
            return this.distance ? this.distance(transformable) : transformable;
          case 'GeometricPoint':
            return this.point
              ? this.point(transformable)
              : transformable.copy();
          case 'AffineTransform':
            return transformable.compose(this.getAffineTransform());
          case 'GeometricArc':
            return this.transformGeometricArc(transformable);
        }
      },
      getAffineTransform: function() {
        if (this.affineTransform) {
          return this.affineTransform;
        }
        if (this.point) {
          return GSP.AffineTransform.fromPointTransform(this.point);
        }
        return GSP.AffineTransform.Identity;
      },
      /*
       * @param {Object} sourceGeom Geometry to transform.
       * @param {Object} destGeom Geometry into which to inject transformed fields.
       *
       * @return {Object} newly created transformed object.
       */
      transformGeom: function(sourceGeom, destGeom) {
        var transformClass, key, ix, arr, value;
        for (key in sourceGeom) {
          if (sourceGeom.hasOwnProperty(key)) {
            value = sourceGeom[key];
            transformClass = this.transformClass(value);
            if (transformClass) {
              destGeom[key] = this.doOneTransform(value, transformClass);
            } else {
              if ($.isArray(value)) {
                arr = [];
                for (ix = 0; ix < value.length; ix += 1) {
                  arr.push(this.doOneTransform(value[ix]));
                }
                destGeom[key] = arr;
              } else {
                destGeom[key] = sourceGeom[key];
              }
            }
          }
        }
      },
    };

    /**
     * @constructor
     */

    GeomTransformer = function(init) {
      var aT = Object.create(GeomTransformerPrototype);

      aT.distance = null;
      aT.point = undefined;
      aT.affineTransform = undefined;

      if ('function' === typeof init) {
        aT.point = init; // init is a function - assume it's a point transformer.
      } else {
        $.extend(aT, init);
      }

      return aT;
    };

    copyGeom = new GeomTransformer({ distance: 0 });

    // Convenience function to just copy geometry.
    GeomTransformer.copyGeom = function(sourceGeom, destGeom) {
      copyGeom.transformGeom(sourceGeom, destGeom);
    };

    // export to global namespace
    G.GeomTransformer = GeomTransformer;
  })(GSP);
  /**
   * @fileOverview Fundamental geometric algorithms.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2011.
   */

  /**
   * @namespace Various fundamental geometry algorithms
   *  Throughout, we assume points are represented by GSP.GeometricPoint {GeometricPoint}
   *  Rectangles {Rect} are any object with numeric (top,left, bottom, right) properties.
   */
  (function() {
    // CommonJS compatibility - extract the global object ('window' on browsers).
    var Geom = {};

    /**
      A constant object representing an infinite rectangle.
     */
    Geom.kInfiniteRect = {
      left: Number.NEGATIVE_INFINITY,
      top: Number.NEGATIVE_INFINITY,
      right: Number.POSITIVE_INFINITY,
      bottom: Number.POSITIVE_INFINITY,
    };

    Geom.isFiniteRect = function(iRect) {
      return (
        iRect &&
        isFinite(iRect.top) &&
          isFinite(iRect.left) &&
          isFinite(iRect.bottom) &&
          isFinite(iRect.right)
      );
    };
    /**
      Returns true if the specified rectangle is valid, false otherwise.
      A rectangle is invalid if it is null/undefined, if any of its properties are
      null/undefined/NaN, or if it is geometrically impossible (e.g. left > right).
      @param  {Object} iRect -- a rectangle in { left, top, right, bottom } form
      @returns {Boolean}
     */
    Geom.isValidRect = function(iRect) {
      return (
        iRect &&
        iRect.left != null &&
        iRect.left === iRect.left &&
        iRect.top != null &&
        iRect.top === iRect.top &&
        iRect.right != null &&
        iRect.right === iRect.right &&
        iRect.bottom != null &&
        iRect.bottom === iRect.bottom &&
        iRect.left <= iRect.right &&
        iRect.top <= iRect.bottom
      );
    };

    /**
      Returns true if the specified rectangle is empty, false otherwise.
      Invalid rectangles are considered empty.
      @param  {Object} iRect -- a rectangle in { left, top, right, bottom } form
      @returns {Boolean}
     */
    Geom.isEmptyRect = function(iRect) {
      return (
        !Geom.isValidRect(iRect) ||
        iRect.left === iRect.right ||
        iRect.top === iRect.bottom
      );
    };

    /**
      Returns true if iRect2 is contained completely within iRect1, false otherwise.
      @param  {Object} iRect1 -- a rectangle in { left, top, right, bottom } form
      @param  {Object} iRect2 -- a rectangle in { left, top, right, bottom } form
      @returns {Boolean}
     */
    Geom.containsRect = function(iRect1, iRect2) {
      return (
        Geom.isValidRect(iRect1) &&
        Geom.isValidRect(iRect2) &&
        iRect1.left <= iRect2.left &&
        iRect1.top <= iRect2.top &&
        iRect1.right >= iRect2.right &&
        iRect1.bottom >= iRect2.bottom
      );
    };

    /**
      Returns true if rectangle iRect1 intersects rectangle iRect2, false otherwise.
      @param  {Object} iRect1 -- a rectangle in { left, top, right, bottom } form
      @param  {Object} iRect2 -- a rectangle in { left, top, right, bottom } form
      @returns {Boolean}
     */
    Geom.isIntersectRects = function(iRect1, iRect2) {
      return (
        Geom.isValidRect(iRect1) &&
        Geom.isValidRect(iRect2) &&
        iRect1.left <= iRect2.right &&
        iRect2.left <= iRect1.right &&
        iRect1.top <= iRect2.bottom &&
        iRect2.top <= iRect1.bottom
      );
    };

    /**
      Returns true if rectangle iRect1 intersects rectangle iRect2, false otherwise.
      @param  {Object} iRect1 -- a rectangle in { left, top, right, bottom } form
      @param  {Object} iRect2 -- a rectangle in { left, top, right, bottom } form
      @returns {Boolean}
     */
    Geom.isIntersectValidRects = function(iRect1, iRect2) {
      return (
        iRect1 &&
        iRect2 &&
        iRect1.left <= iRect2.right &&
        iRect2.left <= iRect1.right &&
        iRect1.top <= iRect2.bottom &&
        iRect2.top <= iRect1.bottom
      );
    };

    /**
      Returns a rectangle representing the intersection between iRect1 and iRect2.
      Returns null if the rectangles do not intersect.
      @param  {Object} iRect1 -- a rectangle in { left, top, right, bottom } form
      @param  {Object} iRect2 -- a rectangle in { left, top, right, bottom } form
      @returns {Object} a rectangle in { left, top, right, bottom } form
     */
    Geom.intersectRects = function(iRect1, iRect2) {
      if (!Geom.isValidRect(iRect1) || !Geom.isValidRect(iRect2)) return null;
      var intersection = {
        left: Math.max(iRect1.left, iRect2.left),
        top: Math.max(iRect1.top, iRect2.top),
        right: Math.min(iRect1.right, iRect2.right),
        bottom: Math.min(iRect1.bottom, iRect2.bottom),
      };
      return Geom.isValidRect(intersection) ? intersection : null;
    };

    /**
      Returns a rectangle representing the union between iRect1 and iRect2.
      @param  {Object} iRect1 -- a rectangle in { left, top, right, bottom } form
      @param  {Object} iRect2 -- a rectangle in { left, top, right, bottom } form
      @returns {Object} a rectangle in { left, top, right, bottom } form
     */
    Geom.unionRects = function(iRect1, iRect2) {
      var isRect1Valid = Geom.isValidRect(iRect1),
        isRect2Valid = Geom.isValidRect(iRect2);
      if (!isRect1Valid && isRect2Valid) return iRect2;
      if (isRect1Valid && !isRect2Valid) return iRect1;
      if (!isRect1Valid && !isRect2Valid) return null;

      return {
        left: Math.min(iRect1.left, iRect2.left),
        top: Math.min(iRect1.top, iRect2.top),
        right: Math.max(iRect1.right, iRect2.right),
        bottom: Math.max(iRect1.bottom, iRect2.bottom),
      };
    };

    /**
      Returns the rectangle which results from insetting the bounds of iRect
      by the amounts specified in iXInset and iYInset.
      @param  {Object} iRect -- a rectangle in { left, top, right, bottom } form
      @param  {Number} iXInset -- the amount to inset/adjust horizontally
                                  defaults to 1 if not specified
      @param  {Number} iYInset -- the amount to inset/adjust vertically
                                  defaults to iXInset if not specified
      @returns {Object} a rectangle in { left, top, right, bottom } form
     */
    Geom.insetRect = function(iRect, iXInset, iYInset) {
      var xInset = iXInset != null ? iXInset : 1,
        yInset = iYInset != null ? iYInset : xInset;
      return {
        left: iRect.left + xInset,
        top: iRect.top + yInset,
        right: iRect.right - xInset,
        bottom: iRect.bottom - yInset,
      };
    };

    /**
      Returns the rectangle which results from offsetting the bounds of iRect
      by the amounts specified in iXOffset and iYOffset.
      @param  {Object} iRect -- a rectangle in { left, top, right, bottom } form
      @param  {Number} iXOffset -- the amount to offset horizontally
                                  defaults to 1 if not specified
      @param  {Number} iYOffset -- the amount to offset vertically
                                  defaults to iXOffset if not specified
      @returns {Object} a rectangle in { left, top, right, bottom } form
     */
    Geom.offsetRect = function(iRect, iXOffset, iYOffset) {
      var xOffset = iXOffset || 0,
        yOffset = iYOffset || xOffset;
      return {
        left: iRect.left + xOffset,
        top: iRect.top + yOffset,
        right: iRect.right + xOffset,
        bottom: iRect.bottom + yOffset,
      };
    };

    /**
      Returns the rectangle which bounds the GSP.GeometricPoint's contained
      in either a single array argument or the arguments list.
  
      @param {Array | variable list of arguments}
      @returns {Object} a rectangle in { left, top, right, bottom } form
     */
    Geom.boundingRect = function() {
      var left, right, top, bottom, i, x, y, items;

      if (arguments.length === 1) {
        items = arguments[0];
      } else {
        items = arguments;
      }

      for (i = 0; i < items.length; i++) {
        x = items[i].x;
        y = items[i].y;

        if (x < left || left === undefined) {
          left = x;
        }
        if (x > right || right === undefined) {
          right = x;
        }
        if (y < top || top === undefined) {
          top = y;
        }
        if (y > bottom || bottom === undefined) {
          bottom = y;
        }
      }

      return { left: left, right: right, top: top, bottom: bottom };
    };

    /*
     * Test if point p is in rect r
     *
     * @param {GeometricPoint} p
     * @param {Rect} r
     * @return {boolean}
     */
    Geom.PointInRect = function(p, r) {
      return (
        p.getX() >= r.left &&
        p.getX() <= r.right &&
        p.getY() >= r.top &&
        p.getY() <= r.bottom
      );
    };

    /*
     * An octAngle is a fast direction calculation useful for comparisons, to determine
     * the relationship between two directions. Because it uses no trig calls, it's
     * a fast way to determine (for instance) whether or not a given point is within
     * an arc sector, by comparing the point's octAngle with the starting and ending
     * octAngles of the sector. This makes it particularly useful for hit-testing and
     * for determining existence of intersections.
     *
     * It returns an "angle" indicating the direction of anglePt relative to refPt.
     * The returned value is in the range [0, 8), with the result identifying
     * the octant in which the vector from refPt to anglePt lies.
     *
     * @param {GeometricPoint} rPt
     * @param {GeometricPoint} aPt
     * @return {Number}
     */

    Geom.OctAngleUtil = function(rPt, aPt) {
      var a = aPt.copy().subtract(rPt),
        temp = GSP.GeometricPoint(Math.abs(a.getX()), Math.abs(a.getY())),
        retAngle;

      if (a.getX() === 0.0 && a.getY() === 0.0) {
        return undefined;
      }

      if (temp.getX() > temp.getY()) {
        retAngle = temp.getY() / temp.getX();
      } else {
        retAngle = 2.0 - temp.getX() / temp.getY(); //now in the range of [0..2], ok for first quadrant
      }

      if (a.getX() < 0.0) {
        if (a.getY() <= 0.0) {
          retAngle += 4.0; //quadrant 3
        } else {
          retAngle = 4.0 - retAngle; //quadrant 2
        }
      } else if (a.getY() < 0.0) {
        retAngle = 8.0 - retAngle; //quadrant 4
      }

      return retAngle;
    };

    /*
     * Test if rect r intersects the circle defined by curveInfo.
     * Algorithm is superset of CircleOrCircleInteriorPrim_RectHit_UTIL()
     * and ArcOrArcInteriorPrim_RectHit_UTIL()
     * curveInfo:
     *  {
     *    type: {String} circle | circleInterior | arc | arcSector | arcSegment
     *    curve: {GeometricArc}
     *  }
     *
     * @param {Rect} r
     * @param {Object} curveInfo
     * @return {boolean}
     */
    Geom.RectIntersectsCurve = function(r, curveInfo) {
      var center = curveInfo.curve.center,
        radius = curveInfo.curve.radius,
        originRect = {
          top: r.top - center.getY(),
          bottom: r.bottom - center.getY(),
          left: r.left - center.getX(),
          right: r.right - center.getX(),
        },
        radiusSquared = radius * radius,
        leftSquared = originRect.left * originRect.left,
        rightSquared = originRect.right * originRect.right,
        topSquared = originRect.top * originRect.top,
        botSquared = originRect.bottom * originRect.bottom,
        intersects,
        //all of the following are defined only in the arc cases
        initialOctAngle,
        finalOctAngle,
        p,
        refPt = GSP.GeometricPoint(0, 0);

      var rectIntersectsCircle = function() {
        var isInterior = !(
            curveInfo.type === 'circle' || curveInfo.type === 'arc'
          ),
          ret;

        /* Check whether the rect intersects, wholly contains, or is wholly contained by the circle */
        if (originRect.right < 0.0) {
          /* R is to left of circle center */
          if (originRect.top > 0.0) {
            /* R is in lower left corner */

            ret = rightSquared + topSquared < radiusSquared;
          } else if (originRect.bottom < 0) {
            /* R is in upper left corner */
            ret = rightSquared + botSquared < radiusSquared;
          } else {
            /* R is due West of circle */
            ret = -originRect.right < radius;
          }
        } else if (originRect.left > 0) {
          /* R is to right of circle center */
          if (originRect.top > 0) {
            /* R is in lower right corner */
            ret = leftSquared + topSquared < radiusSquared;
          } else if (originRect.bottom < 0) {
            /* R is in upoper right corner */
            ret = leftSquared + botSquared < radiusSquared;
          } else {
            /* R is due East of circle */
            ret = originRect.left < radius;
          }
        } else {
          /* R is on circle vertical centerline */
          if (originRect.top > 0) {
            /* R due South of circle */
            ret = originRect.top < radius;
          } else if (originRect.bottom < 0) {
            /* R due North of circle */
            ret = -originRect.bottom < radius;
          } else {
            /* R contains circle centerpoint */
            ret = true;
          }
        }
        if (ret && !isInterior) {
          /* For circles/arcs, as opposed to interiors, we must guarantee as well that at least one corner of the rect lies 
             outside of the circle, so the rect intersects the circumference */
          ret =
            leftSquared + topSquared > radiusSquared ||
            leftSquared + botSquared > radiusSquared ||
            rightSquared + topSquared > radiusSquared ||
            rightSquared + botSquared > radiusSquared;
        }

        return ret;
      };

      var rectIntersectsArc = function() {
        var intersectionTest = function() {
          var octInt = Geom.OctAngleUtil(refPt, p);

          if (octInt < initialOctAngle) {
            octInt += 8.0;
          }

          if (octInt <= finalOctAngle) {
            return true;
          }

          return false;
        };

        //if either endpoint of the arc is in the rect, the arc is hit
        if (Geom.PointInRect(curveInfo.curve.initialPoint, r)) {
          return true;
        }
        if (Geom.PointInRect(curveInfo.curve.finalPoint, r)) {
          return true;
        }

        while (initialOctAngle < 0.0) {
          initialOctAngle += 8.0;
        }

        while (finalOctAngle < initialOctAngle) {
          finalOctAngle += 8.0;
        }

        if (topSquared <= radiusSquared) {
          //check top edge
          p = GSP.GeometricPoint(
            Math.sqrt(radiusSquared - topSquared),
            originRect.top
          );
          if (originRect.left <= p.getX() && originRect.right >= p.getX()) {
            if (intersectionTest()) {
              return true;
            }
          }

          p = GSP.GeometricPoint(p.getX() * -1.0, p.getY());
          if (originRect.left <= p.getX() && originRect.right >= p.getX()) {
            if (intersectionTest()) {
              return true;
            }
          }
        }

        if (botSquared <= radiusSquared) {
          //check the bottom edge
          p = GSP.GeometricPoint(
            Math.sqrt(radiusSquared - botSquared),
            originRect.bottom
          );
          if (originRect.left <= p.getX() && originRect.right >= p.getX()) {
            if (intersectionTest()) {
              return true;
            }
          }

          p = GSP.GeometricPoint(p.getX() * -1.0, p.getY());
          if (originRect.left <= p.getX() && originRect.right >= p.getX()) {
            if (intersectionTest()) {
              return true;
            }
          }
        }

        if (leftSquared <= radiusSquared) {
          //check the left edge
          p = GSP.GeometricPoint(
            originRect.left,
            Math.sqrt(radiusSquared - leftSquared)
          );
          if (originRect.top <= p.getY() && originRect.bottom >= p.getY()) {
            if (intersectionTest()) {
              return true;
            }
          }

          p = GSP.GeometricPoint(p.getX(), p.getY() * -1.0);
          if (originRect.top <= p.getY() && originRect.bottom >= p.getY()) {
            if (intersectionTest()) {
              return true;
            }
          }
        }

        if (rightSquared <= radiusSquared) {
          //check the right edge
          p = GSP.GeometricPoint(
            originRect.right,
            Math.sqrt(radiusSquared - rightSquared)
          );
          if (originRect.top <= p.getY() && originRect.bottom >= p.getY()) {
            if (intersectionTest()) {
              return true;
            }
          }

          p = GSP.GeometricPoint(p.getX(), p.getY() * -1.0);
          if (originRect.top <= p.getY() && originRect.bottom >= p.getY()) {
            if (intersectionTest()) {
              return true;
            }
          }
        }

        return false;
      };

      var rectIntersectsArcSector = function(perimeterOnly) {
        var edgeA,
          edgeB,
          center = curveInfo.curve.center,
          initialPt = curveInfo.curve.initialPoint,
          finalPt = curveInfo.curve.finalPoint,
          theta;

        //two segments to test, Center=>Initial and Center=>Final
        if (topSquared <= radiusSquared) {
          //check top edge

          edgeA = GSP.GeometricPoint(r.left, r.top);
          edgeB = GSP.GeometricPoint(r.right, r.top);
          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, initialPt)) {
            return true;
          }
          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, finalPt)) {
            return true;
          }
        }

        if (botSquared <= radiusSquared) {
          //check the bottom edge

          edgeA = GSP.GeometricPoint(r.left, r.bottom);
          edgeB = GSP.GeometricPoint(r.right, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, initialPt)) {
            return true;
          }
          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, finalPt)) {
            return true;
          }
        }

        if (leftSquared <= radiusSquared) {
          //check the left edge

          edgeA = GSP.GeometricPoint(r.left, r.top);
          edgeB = GSP.GeometricPoint(r.left, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, initialPt)) {
            return true;
          }
          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, finalPt)) {
            return true;
          }
        }

        if (rightSquared <= radiusSquared) {
          //check the right edge

          edgeA = GSP.GeometricPoint(r.right, r.top);
          edgeB = GSP.GeometricPoint(r.right, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, initialPt)) {
            return true;
          }
          if (Geom.SegmentSectsSegment(edgeA, edgeB, center, finalPt)) {
            return true;
          }
        }

        if (perimeterOnly) return false;

        //At this point, we've tested the edges of the arc, as well as the case where
        //the whole arc is inside the rect.  Now make sure the whole rect isn't inside
        //the arc.  Do this by testing an arbitrary point of the rect.  We choose top-left
        if (topSquared + leftSquared < radiusSquared) {
          p = GSP.GeometricPoint(originRect.left, originRect.top);
          theta = Geom.OctAngleUtil(refPt, p);

          if (theta < initialOctAngle) {
            theta += 8.0;
          }

          return theta <= finalOctAngle;
        }

        return false;
      };

      var rectIntersectsArcSegment = function(perimeterOnly) {
        var edgeA,
          edgeB,
          initialPt = curveInfo.curve.initialPoint,
          finalPt = curveInfo.curve.finalPoint;

        if (topSquared <= radiusSquared) {
          //check top edge

          edgeA = GSP.GeometricPoint(r.left, r.top);
          edgeB = GSP.GeometricPoint(r.right, r.top);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, initialPt, finalPt)) {
            return true;
          }
        }

        if (botSquared <= radiusSquared) {
          //check the bottom edge

          edgeA = GSP.GeometricPoint(r.left, r.bottom);
          edgeB = GSP.GeometricPoint(r.right, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, initialPt, finalPt)) {
            return true;
          }
        }

        if (leftSquared <= radiusSquared) {
          //check the left edge

          edgeA = GSP.GeometricPoint(r.left, r.top);
          edgeB = GSP.GeometricPoint(r.left, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, initialPt, finalPt)) {
            return true;
          }
        }

        if (rightSquared <= radiusSquared) {
          //check the right edge

          edgeA = GSP.GeometricPoint(r.right, r.top);
          edgeB = GSP.GeometricPoint(r.right, r.bottom);

          if (Geom.SegmentSectsSegment(edgeA, edgeB, initialPt, finalPt)) {
            return true;
          }
        }

        if (perimeterOnly) return false;

        //At this point, we've tested the edges of the arc, as well as the case where
        //the whole arc is inside the rect.  Now make sure the whole rect isn't inside
        //the arc.  Do this by testing an arbitrary point of the rect.  We choose top-left
        p = GSP.GeometricPoint(r.left, r.top);

        //GSP BUG! Ensure the top left itself is in the circle!!!
        var topLeftIsInCircle = topSquared + leftSquared <= radiusSquared;

        return (
          topLeftIsInCircle &&
          Geom.ThreePointCollinear(initialPt, finalPt, p).orientation > 0
        );
      };

      if (curveInfo.curve.orientation === 0) {
        return Geom.SegmentSectsRect(
          r,
          curveInfo.curve.initialPoint,
          curveInfo.curve.finalPoint
        );
      }

      intersects = rectIntersectsCircle();

      //if we don't intersect the encompassing circle, none of the arcs will intersect
      if (!intersects) {
        return false;
      }

      //for circles, we're done
      if (curveInfo.type === 'circle' || curveInfo.type === 'circleInterior') {
        return intersects;
      }

      //The remainder of this function is specific to arcs and arc interiors
      initialOctAngle = Geom.OctAngleUtil(
        curveInfo.curve.center,
        curveInfo.curve.initialPoint
      );
      finalOctAngle = Geom.OctAngleUtil(
        curveInfo.curve.center,
        curveInfo.curve.finalPoint
      );

      //if the rect intersect the arc edge, we're done
      if (rectIntersectsArc()) {
        return true;
      }

      switch (curveInfo.type) {
        case 'arc':
          //for arcs, we're done no matter what
          intersects = false;
          break;
        case 'arcSectorPerimeter':
          intersects = rectIntersectsArcSector(true);
          break;
        case 'arcSector':
          intersects = rectIntersectsArcSector(false);
          break;
        case 'arcSegmentPerimeter':
          intersects = rectIntersectsArcSegment(true);
          break;
        case 'arcSegment':
          intersects = rectIntersectsArcSegment(false);
          break;
        default:
          //should never get here
          GSP.signalErrorWithMessage(
            'Unexpected curve type: RectIntersectsCurve should only see arcs here.'
          );
      }

      return intersects;
    };

    /*
     * Test if rect r1 intersects r2
     *
     * @param {Rect} r1
     * @param {Rect} r2
     * @return {boolean}
     */

    Geom.RectsIntersect = function(r1, r2) {
      var rLeft, rRight, rBottom, rTop;

      rLeft = r1.left > r2.left ? r1.left : r2.left;
      rTop = r1.top > r2.top ? r1.top : r2.top;
      rRight = r1.right > r2.right ? r1.right : r2.right;
      rBottom = r1.bottom > r2.bottom ? r1.bottom : r2.bottom;

      return rLeft <= rRight && rTop <= rBottom;
    };

    /*
     * Test if segment AB intersects segment CD
     *
     * @param {GeometricPoint} A, B, C, D
     * @return {GeometricPoint} (if they intersect, otherwise null)
     */
    Geom.SegmentSectsSegment = function(A, B, C, D) {
      // Algorithm appropriated from Geom_IntersectStraights_UTIL()
      var ax = A.getX(),
        ay = A.getY(),
        bx = B.getX(),
        by = B.getY(),
        cx = C.getX(),
        cy = C.getY(),
        dx = D.getX(),
        dy = D.getY(),
        abDeltaX = bx - ax,
        abDeltaY = by - ay,
        cdDeltaY = dy - cy,
        p,
        q = ax * cdDeltaY,
        denom = q + bx * -cdDeltaY + cx * -abDeltaY + dx * abDeltaY;

      //Parallel lines don't intersect
      //Also, if any of the inputs were undefined or NaN, denom will be NaN
      if (0.0 === denom || isNaN(denom)) {
        return null;
      }

      //q compute parameter of intersection on directed line AB
      q = (q + cx * (ay - dy) + dx * (cy - ay)) / denom;

      if (q < 0.0 || q > 1.0) {
        //q is out of range, we can stop here
        return null;
      }

      p = -(ax * (cy - by) + bx * (ay - cy) + cx * abDeltaY) / denom;

      if (p < 0.0 || p > 1.0) {
        return null;
      }

      return GSP.GeometricPoint(ax + abDeltaX * q, ay + abDeltaY * q);
    };

    /*
     * Test if the segment AB intersects rect r
     *
     * @param {Rect} r
     * @param {GeometricPoint} A, B
     * @return {boolean}
     */
    Geom.SegmentSectsRect = function(r, A, B) {
      var ret = Geom.PointInRect(A, r) || Geom.PointInRect(B, r),
        topLeft,
        topRight,
        botLeft,
        botRight;

      //An efficiency that rules out some segments based on whether they are
      //entirely to the top, left, bottom or right of the segment.
      function hasAChance() {
        var aX = A.x,
          aY = A.y,
          bX = B.x,
          bY = B.y;

        if (aX < r.left && bX < r.left) {
          return false;
        }

        if (aX > r.right && bX > r.right) {
          return false;
        }

        if (aY < r.top && bY < r.top) {
          return false;
        }

        if (aY > r.bottom && bY > r.bottom) {
          return false;
        }

        return true;
      }

      if (!ret && hasAChance()) {
        topLeft = GSP.GeometricPoint(r.left, r.top);
        topRight = GSP.GeometricPoint(r.right, r.top);
        botLeft = GSP.GeometricPoint(r.left, r.bottom);
        botRight = GSP.GeometricPoint(r.right, r.bottom);

        ret =
          Geom.SegmentSectsSegment(A, B, topLeft, topRight) ||
          Geom.SegmentSectsSegment(A, B, topLeft, botLeft) ||
          Geom.SegmentSectsSegment(A, B, topRight, botRight) ||
          Geom.SegmentSectsSegment(A, B, botLeft, botRight);
      }
      return !!ret;
    };
    /*
     * Returns an array of intersections of the segment AB with rect r
     *
     * @param {Rect} r
     * @param {GeometricPoint} A, B
     * @return {Array} array of GeometricPoints
     */

    Geom.IntersectionsOfRectAndSegment = function(r, A, B) {
      var topLeft = GSP.GeometricPoint(r.left, r.top),
        topRight = GSP.GeometricPoint(r.right, r.top),
        botLeft = GSP.GeometricPoint(r.left, r.bottom),
        botRight = GSP.GeometricPoint(r.right, r.bottom),
        topIntersection = GSP.Geom.SegmentSectsSegment(A, B, topLeft, topRight),
        bottomIntersection = GSP.Geom.SegmentSectsSegment(
          A,
          B,
          botLeft,
          botRight
        ),
        leftIntersection = GSP.Geom.SegmentSectsSegment(A, B, topLeft, botLeft),
        rightIntersection = GSP.Geom.SegmentSectsSegment(
          A,
          B,
          topRight,
          botRight
        ),
        ret = [];

      if (topIntersection) {
        ret.push(topIntersection);
      }
      if (bottomIntersection) {
        ret.push(bottomIntersection);
      }
      if (leftIntersection) {
        ret.push(leftIntersection);
      }
      if (rightIntersection) {
        ret.push(rightIntersection);
      }

      return ret;
    };

    /*
     * Test if the point p is in the parallelogram with sides BA, BC
     *
     * @param {GeometricPoint} p
     * @param {GeometricPoint} A, B, C
     * @return {boolean}
     */
    Geom.PointInParallelogram = function(p, A, B, C) {
      //Algorithm from http://stackoverflow.com/questions/1217585/parallelogram-contains-point

      //given 2 normalized vectors represented as GeometricPoints, return
      //the determinant.
      function determinant(v1, v2) {
        return v1.getX() * v2.getY() - v1.getY() * v2.getX();
      }

      var normA = A.subtract(B),
        normC = C.subtract(B),
        normP = p.subtract(B),
        ACdeterm = determinant(normA, normC),
        testVal;

      if (ACdeterm === 0) {
        return false;
      }

      testVal = -determinant(normP, normA) / ACdeterm;

      if (testVal < 0 || 1 < testVal) {
        return false;
      }

      testVal = determinant(normP, normC) / ACdeterm;

      if (testVal < 0 || 1 < testVal) {
        return false;
      }

      return true;
    };

    /*
     * Test whether the Parallelogram defined by the sides BA, BC intersects rect r
     *
     * @param {Rect} r
     * @param {GeometricPoint} A, B, C
     * @return {boolean}
     */
    Geom.ParallelogramSectsRect = function(r, A, B, C) {
      var D;

      // Test whether r is contained in the parallelogram.
      if (
        Geom.PointInParallelogram(GSP.GeometricPoint(r.left, r.top), A, B, C)
      ) {
        return true;
      }

      // Test the four segments of the parallelogram for intersections with r.
      if (Geom.SegmentSectsRect(r, B, A)) {
        return true;
      }

      if (Geom.SegmentSectsRect(r, B, C)) {
        return true;
      }

      D = B.add(A.subtract(B)).add(C.subtract(B));

      if (Geom.SegmentSectsRect(r, A, D)) {
        return true;
      }

      if (Geom.SegmentSectsRect(r, C, D)) {
        return true;
      }

      return false;
    };

    Geom.ThreePointCollinear = function(a, b, c) {
      var A = a.subtract(b),
        temp = c.subtract(b),
        C = GSP.GeometricPoint(
          temp.x * A.x + temp.y * A.y,
          temp.y * A.x - temp.x * A.y
        ),
        Anorm = A.vLength(),
        orientation,
        isStraight;

      function isZero(x) {
        var tol = 0.0004;
        return x > -tol && x < tol;
      }

      orientation = isZero(C.y) ? 0 : GSP.math.sign(C.y);
      if (orientation === 0) {
        isStraight = A.dot(temp) > 0 ? 'fullCircle' : 'halfCircle';
      }
      return {
        exists: !isZero(Anorm),
        orientation: orientation,
        isStraight: isStraight,
      };
    };

    // atan2 of (x,y), normalized to -PI < theta <= PI
    Geom.AngleFromPoint = function(p) {
      var theta = Math.atan2(p.y, p.x);
      if (theta <= -Math.PI) {
        theta += 2 * Math.PI;
      }

      return theta;
    };

    // Joseph O'Rourke recipe for circle center (http://www.delphidabbler.com/tips/144)
    Geom.CenterFromThreePoints = function(p0, p1, p2) {
      var U = p1.subtract(p0),
        V = p2.subtract(p0),
        W = p2.subtract(p1),
        S = p0.add(p1),
        R = p0.add(p2);

      var E = U.dot(S),
        F = V.dot(R),
        G = 2 * (U.x * W.y - U.y * W.x),
        px = (V.y * E - U.y * F) / G,
        py = (U.x * F - V.x * E) / G;

      return GSP.GeometricPoint(px, py);
    };

    /**
     * Derives the constants of a normalize equation for a line:
     *    Ax + By = C
     */
    function makeNormalizedLine(p0, p1) {
      var a, b, c, toString;
      a = p1.y - p0.y;
      b = p0.x - p1.x;
      c = a * p1.x + b * p1.y;

      toString = function() {
        return '[' + this.a + 'x + ' + this.b + 'y = ' + c + ']';
      };
      return { a: a, b: b, c: c, p0: p0, p1: p1, toString: toString };
    }

    Geom.LineLineIntersection = function(ln0, ln1, epsilon) {
      var nln0 = makeNormalizedLine(ln0.getZeroPoint(), ln0.getUnitPoint());
      var nln1 = makeNormalizedLine(ln1.getZeroPoint(), ln1.getUnitPoint());
      var result = GSP.GeometricPoint(null, null),
        x,
        y;
      var determinant = nln0.a * nln1.b - nln1.a * nln0.b;

      if (undefined === epsilon) {
        epsilon = 1e-8;
      }

      if (Math.abs(determinant) > epsilon) {
        x = (nln1.b * nln0.c - nln0.b * nln1.c) / determinant;
        y = (nln0.a * nln1.c - nln1.a * nln0.c) / determinant;
        result = GSP.GeometricPoint(x, y);
      }

      if (
        result.isDefined() &&
        (!ln0.pointIsInBounds(result) || !ln1.pointIsInBounds(result))
      ) {
        result = GSP.GeometricPoint(NaN, NaN);
      }

      return result;
    };

    Geom.CircleStraightIntersection = function(circle, straight) {
      var p0Vector = straight.getP0();
      var p1Vector = straight.getP1();
      var ctrVector = circle.center;
      var radius = circle.radius;
      var result,
        deltaP,
        a,
        b,
        c,
        bb4ac,
        EPS = 0.001,
        intersectionVector1,
        intersectionVector2,
        tmp,
        RADIUS_TOLERANCE = 0.0002,
        ENDPOINT_TOLERANCE_SQ = 1.0e-9,
        minRadius = radius - RADIUS_TOLERANCE,
        maxRadius = radius + RADIUS_TOLERANCE,
        minC,
        maxC,
        b2;

      result = [];

      // find segment vector
      deltaP = p1Vector.subtract(p0Vector);
      // square of length of delta
      a = deltaP.dot(deltaP);
      if (Math.abs(a) < EPS) {
        return result;
      }

      b = 2 * deltaP.dot(p0Vector.subtract(ctrVector));
      b2 = b * b;

      //We'll calculate part of c and store it in tmp,
      //then calculate minDisc and maxDisc as calculations of
      //c with slightly smaller/bigger radii so we can detect
      //the tangent
      tmp =
        ctrVector.dot(ctrVector) +
        p0Vector.dot(p0Vector) -
        2 * ctrVector.dot(p0Vector);
      maxC = tmp - maxRadius * maxRadius;
      bb4ac = b2 - 4 * a * maxC;
      if (bb4ac < 0) {
        return result;
      }

      minC = tmp - minRadius * minRadius;
      bb4ac = b2 - 4 * a * minC;

      if (bb4ac < 0) {
        //line is tangent to circle (or close enough)
        bb4ac = 0;
      } else {
        c = tmp - radius * radius;
        bb4ac = b2 - 4 * a * c;
      }
      intersectionVector1 = p0Vector.add(
        deltaP.multiply((-b - Math.sqrt(bb4ac)) / (2 * a))
      );
      if (
        intersectionVector1.isDefined() &&
        straight.pointIsInBounds(intersectionVector1, ENDPOINT_TOLERANCE_SQ)
      ) {
        result.push(intersectionVector1);
      }
      intersectionVector2 = p0Vector.add(
        deltaP.multiply((-b + Math.sqrt(bb4ac)) / (2 * a))
      );
      if (
        intersectionVector2.isDefined() &&
        straight.pointIsInBounds(intersectionVector2, ENDPOINT_TOLERANCE_SQ)
      ) {
        result.push(intersectionVector2);
      }
      // replicate result if it is odd.
      if (result.length === 1) {
        result.push(result[0]);
      }

      return result;
    };

    Geom.CircleCircleIntersection = function(circle0, circle1) {
      /*  It's important that these intersections behave continuously during movement
       *  of the gobjs from which circle0 and circle1 are derived. For this reason,
       *  callers depend on the returned array being in the same order over multiple
       *  function calls with the parameters derived from the same two gobjs.
       *  If, on a later call, one of the two gobjs has switched its orientation,
       *  the returned array should be in reverse order.
       *  (Orientation switches should occur only for arcFromThreePoints gobjs.)
       *  The only known failure of this bugfix is the case of a three-point arc with
       *  its middle point on the opposite side of a mirror from its endpoints.
       *  The intersection points of the preimage arc and its image (which lie on the mirror)
       *  switch roles as the two circles pass through the discontinuity that occurs
       *  when the two imaginary circles on which the arcs live become superposed.
       *  FWIW, this behavior matches desktop GSP.
       */
      var c0Vector = circle0.center,
        radius0 = circle0.radius,
        c1Vector = circle1.center,
        radius1 = circle1.radius,
        resultArray,
        deltaVector,
        dCenters,
        a,
        midpointVector,
        h,
        r;

      resultArray = [];
      deltaVector = c1Vector.subtract(c0Vector);
      dCenters = deltaVector.vLength();

      // centers are too far, can be no result
      if (dCenters > radius0 + radius1) {
        return resultArray;
      }

      // one circle is contained in the other
      if (dCenters < Math.abs(radius0 - radius1)) {
        return resultArray;
      }

      // calculate midpoint of intersection points
      a =
        (radius0 * radius0 - radius1 * radius1 + dCenters * dCenters) /
        (2 * dCenters);
      midpointVector = c0Vector.add(deltaVector.multiply(a / dCenters));
      // determine the distance from midpointVector to c0Vector.
      h = Math.sqrt(radius0 * radius0 - a * a); /* 0 */
      // determine the offsets of the intersection point
      r = GSP.GeometricPoint(-deltaVector.y, deltaVector.x).multiply(
        h / dCenters
      );
      resultArray.push(midpointVector.add(r));
      resultArray.push(midpointVector.add(r.negate()));
      if (circle0.orientation * circle1.orientation === -1) {
        resultArray.reverse();
      }
      return resultArray;
    };

    Geom.RectSectsPolygon = function(rect, points) {
      function pointInPolygon(thePoint, vertexArray) {
        var x = thePoint.x,
          y = thePoint.y,
          c = -1,
          vi,
          vj,
          numVertices = vertexArray.length;

        vi = vertexArray[0];
        vj = vertexArray[vertexArray.length - 1];

        while (numVertices--) {
          if (
            ((vi.y <= y && y < vj.y) || (vj.y <= y && y < vi.y)) &&
            x - vi.x < ((vj.x - vi.x) * (y - vi.y)) / (vj.y - vi.y)
          ) {
            c *= -1;
          }
          vj = vi;
          vi = vertexArray[vertexArray.length - numVertices];
        }

        return 1 === c;
      }

      if (pointInPolygon(GSP.GeometricPoint(rect.left, rect.top), points)) {
        return true;
      }

      return GSP.Geom.RectSectsPolygonPerimeter(rect, points);
    };

    Geom.RectSectsPolygonPerimeter = function(rect, points) {
      var head, tail, ix;

      for (ix = 0; ix < points.length; ix += 1) {
        tail = points[ix];
        head = points[(ix + 1) % points.length];
        if (GSP.Geom.SegmentSectsRect(rect, head, tail)) {
          return true;
        }
      }

      return false;
    };

    /*
     * Returns the a rectangle that is the union of an axis aligned
     * rectangle and a point.
     * @param {{left, top, width, height}} rect
     * @param {{x, y}} point
     * @return {{left, top, width, height}}
     */
    Geom.unionRectPoint = function(rect, point) {
      var ret = {};

      if (!rect) {
        ret.left = ret.right = point.x;
        ret.top = ret.bottom = point.y;
      } else {
        //if (rect.right === undefined) { rect.right = rect.left + rect.width; }
        //if (rect.bottom === undefined) { rect.bottom = rect.top + rect.height; }
        ret.left = Math.min(rect.left, point.x);
        ret.right = Math.max(rect.right, point.x);
        //ret.width = ret.right - ret.left;
        ret.top = Math.min(rect.top, point.y);
        ret.bottom = Math.max(rect.bottom, point.y);
        //ret.height = ret.bottom - ret.top;
      }
      return ret;
    };

    // export to GSP namespace
    GSP.Geom = Geom;
  })();

  /**
   * @fileOverview Geometry for Arc and arc-like objects (circles, angle markers).
   * @author Matthew Litwin <mlitwin@kcptech.com>
   *
   *
   * The notion of a GeometricArc encapsulates a variety of arc and arc like geometric
   * forms: Arcs from 3 points (which can be straight), arcs on a circle, and even circles
   * as such.
   *
   * The geometry of the arc is overdetermined - there are a number of different ways
   * clients want to access the basic geometry of an arc.
   * The essential ones (e.g. center, radius, initialPoint, finalPoint) are available
   * as attributes of the GeometricArc.
   * Others, (e.g. arc initialParam) are computed Just-In-Time, and cached.
   *
   * GeometricArc's are construction via specialized construction functions, e.g.
   *  GSP.GeometricArc.FromThreePoints or GSP.GeometricArc.FromCenterAndEndpoints.
   * The GeometricArc construction is private - as it's intended to hide the messy
   * details of what constitutes a valid arc.
   * @preserve (C) KCP Technologies, 2011.
   */

  /**
   * Exported GeometricArc functions in namespace GSP.GeometricArc
   */
  GSP.GeometricArc = (function() {
    var MAX_ROUNDED_INT_COORD = 30000.0, // Sketchpad's "big" value for the plane
      PACKED_SAMPLE_SIZE = 7, //Size, in floats, of one arc stored in a packed sample array
      GeometricArcPrototype = /** @lends GeometricArc */ {
        transformClass: 'GeometricArc', // mark this as Geom Transformable.
        center: GSP.GeometricPoint.UNDEFINED,
        radius: undefined,
        // The arc goes from the initialPoint/Angle CW to the finalPoint/Angle
        initialAngle: undefined,
        finalAngle: undefined,
        initialPoint: GSP.GeometricPoint.UNDEFINED,
        middlePoint: GSP.GeometricPoint.UNDEFINED,
        finalPoint: GSP.GeometricPoint.UNDEFINED,
        orientation: undefined, // Parameterization orientation of the arc. +1 is CW.
        exists: false,
        arcAngle: undefined, // angle distance (i.e. positive measured in CCW from initialPoint to finalPoint)

        // Compatibility with straight kind API - getZeroPoint, getUnitPoint, getP0, getP1
        getZeroPoint: function() {
          return this.initialPoint;
        },
        getUnitPoint: function() {
          return this.finalPoint;
        },
        getP0: function() {
          return this.initialPoint;
        },
        getP1: function() {
          return this.finalPoint;
        },
        updateSecondaryGeometry: function() {
          var testValues = [], // We'll test some values for bounds.
            that = this;
          this.arcAngle = this.finalAngle - this.initialAngle;
          if (this.arcAngle < 0.0) {
            this.arcAngle += 2 * Math.PI;
          }
          if (0 === this.orientation) {
            this.arcLength = this.finalPoint
              .subtract(this.initialPoint)
              .vLength();
          } else {
            this.arcLength = this.radius * this.arcAngle;
          }
          testValues.push(
            this.initialPoint.x,
            this.initialPoint.y,
            this.finalPoint.x,
            this.finalPoint.y
          );
          if (this.orientation !== 0) {
            testValues.push(this.radius, this.center.x, this.center.y);
          }

          $.each(testValues, function(i, v) {
            if (Math.abs(v) > MAX_ROUNDED_INT_COORD) {
              that.exists = false;
              return false;
            }
          });
        },
        /*
         * Return values calculated from the fundamental geometry given the genus.
         * In theory, you can call this with different genera, though probably
         * you've got a particular genus you are interested in.
         * @param {String} genus The genus of the Arc: SimpleArc, ArcSector, ArcSegment.
         * @return {Object} array of calculated properties.
         */
        getCache: function(genus) {
          var ret;
          // vivify this.cache
          if (!this.cache) {
            this.cache = {};
          }

          // If we've calculated for this genus, return it.
          if (this.cache[genus]) {
            return this.cache[genus];
          }

          // Create the cached values
          ret = {
            halfChordLength: 0 /* for arc segments only; 0 for simple arcs, and equal to radius for sectors */,
            perimeterLength: 0 /* Arc: arc length. Segment: arc length + chord length. Sector: arc length + 2 * radius. */,
            /*  The parameter, in the range [0..1), tours the arc from the starting point of the arc and goes
            either ccw (orientation == 1) or cw (orientation == -1) around the perimeter. This means that
            arc sectors and arc segments tour the arc first, followed by the radii or chord.
          */
            /* When the orientation of an arc flips, its parameter must be switched also.
            Arc parameters are in the range of 0..1, with the starting point being the 
            initial point for a simple arc, the center point for a sector, and the chord
            midpoint for a segment.
          */
            initialParam: 0 /* parameter value at the initial arc endpoint (0 for a simple arc) */,
            finalParam: 0 /* parameter value at the final arc endpoint (1 for a simple arc) */,
          };

          if (0 === this.orientation) {
            ret.arcLength = this.finalPoint
              .subtract(this.initialPoint)
              .vLength();
            ret.perimeterLength = ret.arcLength;
          } else {
            if ('ArcSegment' === genus) {
              ret.halfChordLength =
                this.finalPoint.subtract(this.initialPoint).vLength() / 2;
            } else {
              if ('ArcSector' === genus) {
                ret.halfChordLength = this.radius;
              }
            }
            ret.perimeterLength = this.arcLength + 2.0 * ret.halfChordLength;
          }

          if (0 !== ret.perimeterLength) {
            ret.initialParam = ret.halfChordLength / ret.perimeterLength;
          }

          ret.finalParam = 1.0 - ret.initialParam;

          this.cache[genus] = ret;

          return ret;
        },
        /*
         * Test if point (assumed to be on the circle of the arc) is within the arc.
         * @param {GeometricPoint} point
         * @return {boolean}
         */
        pointIsInBounds: function(point) {
          var theta,
            EPSILON = 10e-8;

          // Straight arc special case
          if (this.orientation === 0) {
            var val = GSP.GeometricPoint.mapPointToLine(
              this.initialPoint,
              this.finalPoint,
              point
            ).param;
            return val >= -EPSILON && val <= 1 + EPSILON;
          }

          // Full Circle - we're in.
          if (this.arcAngle === 2 * Math.PI) {
            return true;
          }

          theta = GSP.Geom.AngleFromPoint(point.subtract(this.center));

          if (theta < this.initialAngle - EPSILON) {
            theta += 2 * Math.PI;
          }

          return (
            theta >= this.initialAngle - EPSILON &&
            theta <= this.initialAngle + this.arcAngle + EPSILON
          );
        },
        mapPointToArc: function(point, genus, args) {
          var cache = this.getCache(genus),
            theta = GSP.Geom.AngleFromPoint(point.subtract(this.center)),
            finalAngle =
              this.initialAngle +
              this.arcAngle /* make a finalAngle > initialAngle */,
            ret = {};

          if (theta < this.initialAngle) {
            theta += 2 * Math.PI;
          }

          // Default assumption
          ret.param = cache.initialParam;
          if (args.returnPoint) {
            ret.point = this.initialPoint;
          }

          if (theta <= finalAngle) {
            /* the ray hits the arc */
            ret.param =
              (theta - this.initialAngle) / (finalAngle - this.initialAngle);
            ret.param =
              cache.initialParam +
              ret.param * (cache.finalParam - cache.initialParam);
            if (args.returnPoint) {
              ret.point = GSP.GeometricPoint.FromCenterRadiusAngle(
                this.center,
                this.radius,
                theta
              );
            }
          } else if (
            theta - finalAngle <
            this.initialAngle - (theta - 2 * Math.PI)
          ) {
            /* closer to final point */
            ret.param = cache.finalParam;
            if (args.returnPoint) {
              ret.point = this.finalPoint;
            }
          }

          return ret;
        },
        mapPositionToPathValue: function(point, genus) {
          var l,
            cache,
            points = [],
            closest,
            center;

          function closestPoint(points, point) {
            var best,
              dist,
              bestDist = Infinity,
              i;
            if (points.length === 1) {
              return points[0];
            }
            for (i = 0; i < points.length; i++) {
              dist = points[i].point.subtract(point).vLength2();
              if (dist < bestDist) {
                bestDist = dist;
                best = points[i];
              }
            }

            return best;
          }

          if (0 === this.orientation) {
            l = GSP.GeometricPoint.mapPointToLine(
              this.initialPoint,
              this.finalPoint,
              point,
              { clampP0: true, clampP1: true }
            );

            return l.param;
          }

          points.push(
            this.mapPointToArc(point, genus, {
              returnPoint: genus !== 'SimpleArc',
            })
          );

          if ('SimpleArc' !== genus) {
            cache = this.getCache(genus);
            center =
              'ArcSector' === genus
                ? this.center
                : this.initialPoint.add(this.finalPoint).multiply(0.5);

            l = GSP.GeometricPoint.mapPointToLine(
              center,
              this.initialPoint,
              point,
              { clampP0: true, clampP1: true, returnPoint: true }
            );

            l.param *= cache.initialParam;
            points.push(l);

            l = GSP.GeometricPoint.mapPointToLine(
              center,
              this.finalPoint,
              point,
              { clampP0: true, clampP1: true, returnPoint: true }
            );

            l.param = 1.0 - l.param * cache.initialParam;
            points.push(l);
          }

          closest = closestPoint(points, point);

          return this.orientation === 1 ? closest.param : 1 - closest.param;
        },
        mapPathValueToPosition: function(value, genus, output) {
          var delta,
            tolerance = 1.0e-10,
            cache,
            centerPoint /* the center of the circle or chord, as appropriate */,
            pt /* other end point of the appropriate segment */,
            theta,
            orientation = this.orientation,
            segParamDistance,
            ret;

          if (0 === orientation) {
            delta = this.finalPoint.subtract(this.initialPoint);
            if (output) {
              output.derivative = GSP.GeometricPoint(delta.x, delta.y);
            }
            return this.initialPoint.add(delta.multiply(value));
          }

          if (-1 === orientation) {
            value = 1.0 - value;
          }

          cache = this.getCache(genus);

          if (
            value >= cache.initialParam - tolerance &&
            value <= cache.finalParam + tolerance
          ) {
            if (value <= cache.initialParam) {
              ret = this.initialPoint;
              delta = ret.subtract(this.center);
            } else if (value >= cache.finalParam) {
              ret = this.finalPoint;
              delta = ret.subtract(this.center);
            } else {
              /* Use trig to find some intermediate point on the arc. */
              theta =
                this.initialAngle +
                (this.arcAngle * (value - cache.initialParam)) /
                  (cache.finalParam - cache.initialParam);
              delta = GSP.GeometricPoint(
                this.radius * Math.cos(theta),
                this.radius * Math.sin(theta)
              );

              ret = GSP.GeometricPoint(
                this.center.x + delta.x,
                this.center.y + delta.y
              );
            }
            if (output) {
              output.derivative = GSP.GeometricPoint(
                -delta.y,
                delta.x
              ).multiply(
                (orientation * this.arcAngle) /
                  (cache.finalParam - cache.initialParam)
              );
            }
          } else {
            /* point is not on the arc, so it must be on a half-chord or radius */

            // Some 0, 1 value wrapping to get edge cases correct
            if (value === 1.0 && 1 === orientation) {
              value = 0.0;
            }
            if (value === 0.0 && -1 === orientation) {
              value = 1.0;
            }

            if ('ArcSector' === genus) {
              centerPoint = this.center;
            } else {
              centerPoint = this.initialPoint
                .add(this.finalPoint)
                .multiply(0.5);
            }
            if (value < cache.initialParam) {
              pt = this.initialPoint;
              segParamDistance = cache.initialParam;
            } else {
              pt = this.finalPoint;
              value = 1.0 - value;
              segParamDistance = 1.0 - cache.finalParam;
              orientation *= -1;
              segParamDistance = cache.initialParam;
            }

            /*  value is in the range from 0 to cache.initialParam; put it in the range from 0 to 1. */
            value /= cache.initialParam;
            ret = centerPoint.add(pt.subtract(centerPoint).multiply(value));
            if (output) {
              output.derivative = GSP.GeometricPoint(
                (orientation * (pt.x - centerPoint.x)) / segParamDistance,
                (orientation * (pt.y - centerPoint.y)) / segParamDistance
              );
            }
          }

          return ret;
        },
        packIntoSampleArray: function(samples, sampleIndex) {
          var base = PACKED_SAMPLE_SIZE * sampleIndex;

          samples[base] = this.orientation;
          samples[base + 1] = this.initialPoint.x;
          samples[base + 2] = this.initialPoint.y;
          samples[base + 3] = this.finalPoint.x;
          samples[base + 4] = this.finalPoint.y;
          samples[base + 5] = this.center.x;
          samples[base + 6] = this.center.y;
        },
      };

    function GeometricArc() {
      var arc = Object.create(GeometricArcPrototype);
      return arc;
    }

    return {
      /*
       * Construct a straight arc from p0 to p1
       * @param {GeometricPoint} p0
       * @param {GeometricPoint} p1
       * @return {GeometricArc}
       */
      FromStraightEndpoints: function(p0, p1) {
        var arc = new GeometricArc();

        arc.orientation = 0;
        arc.initialPoint = p0;
        arc.middlePoint = GSP.GeometricPoint(
          (p0.getX() + p1.getX()) / 2,
          (p0.getY() + p1.getY()) / 2
        );
        arc.finalPoint = p1;
        arc.exists = true;

        arc.updateSecondaryGeometry();
        return arc;
      },
      /*
       * Construct an arc from p0 through p1 to p2
       * @param {GeometricPoint} p0
       * @param {GeometricPoint} p1
       * @param {GeometricPoint} p2
       * @return {GeometricArc}
       */
      FromThreePoints: function(p0, p1, p2) {
        var arc,
          linearity = GSP.Geom.ThreePointCollinear(p0, p2, p1),
          z0,
          z2,
          swap;

        // Check for degeneracy. p1 must be strictly between p0 and p2
        if (!linearity.exists || p1.equals(p0) || p1.equals(p2)) {
          return new GeometricArc();
        }

        if (linearity.orientation === 0) {
          return GSP.GeometricArc.FromStraightEndpoints(p0, p2);
        }

        swap = linearity.orientation === -1;

        arc = new GeometricArc();
        arc.center = GSP.Geom.CenterFromThreePoints(p0, p1, p2);

        z0 = p0.subtract(arc.center);
        z2 = p2.subtract(arc.center);

        arc.radius = z0.vLength();
        arc.initialAngle = GSP.Geom.AngleFromPoint(swap ? z2 : z0);
        arc.finalAngle = GSP.Geom.AngleFromPoint(swap ? z0 : z2);
        arc.orientation = linearity.orientation;
        arc.initialPoint = swap ? p2 : p0;
        arc.middlePoint = p1;
        arc.finalPoint = swap ? p0 : p2;
        arc.exists = true;

        if (
          arc.radius > MAX_ROUNDED_INT_COORD ||
          Math.abs(arc.center.x) > MAX_ROUNDED_INT_COORD ||
          Math.abs(arc.center.y) > MAX_ROUNDED_INT_COORD
        ) {
          return GSP.GeometricArc.FromStraightEndpoints(p0, p2); // punt to a straight
        }
        arc.updateSecondaryGeometry();
        return arc;
      },
      /*
       * Construct an arc about center c from p0 to p1
       * p0 determines the radius, p1 the final direction.
       * Thus p0 is always on the resulting arc, but p1 will only be on
       * the arc if it's the same distance from c as p0.
       * @param {GeometricPoint} c The center of the arc
       * @param {GeometricPoint} p0
       * @param {GeometricPoint} p1
       * @return {GeometricArc}
       */
      FromCenterAndEndpoints: function(c, p0, p1, orientation) {
        var arc = new GeometricArc(),
          z0 = p0.subtract(c),
          z1 = p1.subtract(c),
          theta,
          swap,
          TOLERANCE = 0.0000001; /* Tolerance from GSP arc.c:ArcOnCircleConstraint() */

        if (
          p0.equals(p1, TOLERANCE) ||
          p0.equals(c, TOLERANCE) ||
          p1.equals(c, TOLERANCE)
        ) {
          arc.exists = false;
          return arc;
        }

        if (undefined === orientation) {
          orientation = 1;
        }

        swap = -1 === orientation;

        arc.center = c;
        arc.radius = z0.vLength();
        arc.initialAngle = GSP.Geom.AngleFromPoint(swap ? z1 : z0);
        arc.finalAngle = GSP.Geom.AngleFromPoint(swap ? z0 : z1);
        arc.orientation = orientation;
        arc.initialPoint = swap ? p1 : p0;
        theta = (arc.initialAngle + arc.finalAngle) / 2;
        if (arc.initialAngle > arc.finalAngle) {
          theta += Math.PI;
        }
        arc.middlePoint = GSP.GeometricPoint(Math.cos(theta), Math.sin(theta))
          .multiply(arc.radius)
          .add(arc.center);
        arc.finalPoint = swap ? p0 : p1;
        arc.exists = true;

        arc.updateSecondaryGeometry();
        return arc;
      },
      /*
       * Construct an full-circle arc about center c of radius
       * @param {GeometricPoint} c The center of the arc
       * @param {number} r The radius
       * @return {GeometricArc}
       */
      FromCenterAndRadius: function(c, r) {
        var arc = new GeometricArc(),
          z0 = c.add(GSP.GeometricPoint(c.x + r, c.y));

        arc.center = c;
        arc.radius = r;
        arc.initialAngle = 0;
        arc.finalAngle = 2 * Math.PI;
        // Isn't orientation based on the native (rendering) coord sys, in which what
        // appears as CCW on-screen has orientation -1?
        // arc.orientation = 1;
        arc.orientation = -1;
        arc.initialPoint = z0;
        arc.middlePoint = z0;
        arc.finalPoint = z0;
        arc.exists = true;

        arc.updateSecondaryGeometry();
        return arc;
      },
      FromPackedSampleArray: function(samples, sampleIndex) {
        var base = sampleIndex * PACKED_SAMPLE_SIZE,
          orientation = samples[base],
          initialPointX = samples[base + 1],
          initialPointY = samples[base + 2],
          finalPointX = samples[base + 3],
          finalPointY = samples[base + 4],
          centerX = samples[base + 5],
          centerY = samples[base + 6],
          p0 = GSP.GeometricPoint(initialPointX, initialPointY),
          p1 = GSP.GeometricPoint(finalPointX, finalPointY),
          c;

        if (orientation === 0) {
          return GSP.GeometricArc.FromStraightEndpoints(p0, p1);
        } else {
          c = GSP.GeometricPoint(centerX, centerY);
          //Arcs always store their initial and final points in the forward "1" orientation
          //Therefore, we create a new one here always in this orientation regardless
          //of the original passed-in orientation
          return GSP.GeometricArc.FromCenterAndEndpoints(c, p0, p1, 1);
        }
      },
      packedSampleSize: PACKED_SAMPLE_SIZE,
    };
  })();
  /**
   * @fileOverview Utilities for formatting labels.
   * @author <a href="mailto:jsandoe@kcptech.com">Jonathan Sandoe</a>
   * @version 0.0
   * Copyright © 2013 KCP Technologies, Inc.
   */
  /*global GSP:true */
  GSP.labels = {};

  /*
   * Parses a label expression and returns an MFS string.
   */
  GSP.labels.parseLabelExpression = function(expr, iMathItalicization) {
    // Math italicization defaults to true, so undefined --> true
    var mathItalicization =
      iMathItalicization || iMathItalicization === undefined;

    /*
     * returns an object containing 'before', 'inside', 'after', where
     * 'before' is the text before the bracketed substring, 'inside' is
     * the text within the bracketed substring and 'after' is the text
     * after. If the string does not contain a balanced bracketed substring
     * the original string will be entirely with before and inside and after
     * will be empty strings.
     */
    function splitSquareBrackets(str) {
      var leftIx = 0,
        rightIx = str.length,
        ix = rightIx,
        level,
        obj = {
          before: '',
          inside: '',
          after: '',
        };

      // look for left bracket
      while (leftIx < str.length) {
        if (str[leftIx] === '[') {
          break;
        }
        leftIx += 1;
      }

      // look for right bracket
      ix = leftIx + 1;
      level = 1;
      while (ix < rightIx) {
        if (str[ix] === ']') {
          level -= 1;
        } else if (str[ix] === '[') {
          level += 1;
        }
        if (level === 0) {
          break;
        }
        ix += 1;
      }
      // if we did not find the right bracket (ix === rightIx),
      // or the brackets enclose nothing (ix - leftIx === 1),
      // or the brackets enclose everything, then do not split
      if (
        ix === rightIx ||
        ix - leftIx === 1 ||
        (leftIx === 0 && ix + 1 === rightIx)
      ) {
        leftIx = rightIx;
      } else {
        rightIx = ix;
      }

      obj.before = str.substr(0, leftIx);
      obj.inside = str.substr(leftIx + 1, rightIx - leftIx - 1);
      obj.after = str.substr(rightIx + 1);
      return obj;
    }

    /**
     * Applies MFS formatting to a text region in the following way:
     *  (a) splits the text at bracketing boundaries (whitespace,
     *      paren open/close, angle symbol (\u2220), ...)
     *  (b) for each split element, if the element begins with an alphabetic
     *      character, it is formatting using italic characters, otherwise
     *      formatting follows the default, presumably straight, character
     *      style.
     */
    function formatText(text) {
      if (!text) {
        text = '';
      }
      var re = /([()\[\]|<>{},\u2220\s.\/\-]+)/,
        splArray = text.split(re),
        ix,
        buf = [];
      for (ix = 0; ix < splArray.length; ix += 1) {
        var textTerm = splArray[ix];
        buf.push(
          GSP.mfs.makeTextMFS(
            textTerm,
            mathItalicization && /[a-zA-Zα-ω]/.test(textTerm[0])
          )
        );
      }
      if (splArray.length > 1)
        // variadic call
        return GSP.mfs.makeHorizontalMFS.apply(this, buf);
      else {
        return buf[0];
      }
    }
    /*
     * Returns a mfs expression formatting the expression.
     */
    function parseToMFS(expr) {
      var rslt = [],
        parts;
      if (expr) {
        parts = splitSquareBrackets(expr);
        if (parts.inside) {
          rslt.push({
            type: 'sub',
            value: [parseToMFS(parts.before), parseToMFS(parts.inside)],
          });
          if (parts.after) {
            rslt.push(parseToMFS(parts.after));
          }
        } else {
          rslt.push(formatText(parts.before));
        }
      }
      return rslt.length === 1
        ? rslt[0]
        : // variadic call
          GSP.mfs.makeHorizontalMFS.apply(this, rslt);
    }
    try {
      return parseToMFS(expr);
    } catch (ex) {
      throw GSP.createError('Error parsing label "' + expr + '": ' + ex);
    }
  };

  /*
   * Returns all legal nameOrigins, or legal nameOrigins for a gobj.
   */
  GSP.labels.legalNameOrigins = function(gobj) {
    var nameOrigins;
    if (!gobj) {
      // No gobj, so return all legal values
      nameOrigins = [
        'namedFromLabel',
        'namedByPrime',
        'namedByShortFn',
        'namedByFullFn',
        'namedFromTemplate',
      ];
    } else {
      nameOrigins = [];
      if (gobj.hasLabel) {
        nameOrigins.push('namedFromLabel');
      }
      if (gobj.isTransformationConstraint) {
        nameOrigins.push('namedByPrime', 'namedByShortFn', 'namedByFullFn');
      }
      if (gobj.kind === 'Expression') {
        nameOrigins.push('namedFromTemplate');
      }
    }
    return nameOrigins;
  };

  /**
   * @fileOverview Utilities for generating default labels in a sketch.
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   *
   * Copyright © 2015 KCP Technologies, Inc.
   */
  /*global GSP:true */
  (function() {
    //These could/should be localized, and moved into resources
    var labelPoolInfo = {
      //The two expression special cases determined by genus
      Parameter: 't',
      Function: 'fghqrstuvw',

      //The rest are determined by kind
      Point: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      Straight: 'jklmnopqrstuvwxyzabcdefghi',
      Circle: 'c',
      Polygon: 'P',
      CircleInterior: 'C',
      Sampler: 'L',
      Measure: 'm',
      CoordSys: 'S',
      Axis: 'xy',
      Button: '',
      Arc: 'a',
      ArcInterior: 'A',
      Map: '',
      IterateImage: '',
      Picture: '',
      Table: '',
      AngleMarker: '',
      Kind: '',
    };

    function poolKindForKindInstance(instance, genus) {
      //A few expression kinds need disambiguation using genus
      if (instance.kind === 'Expression') {
        if (genus === 'Function') {
          return 'Function';
        }

        if (genus === 'ScalarParameter') {
          return 'Parameter';
        }
      }

      //Otherwise, we look up based on kind
      var kind = instance.kind;
      var kindList = instance.baseKinds.slice();

      while (kind) {
        if (labelPoolInfo.hasOwnProperty(kind)) {
          return kind;
        }
        kind = kindList.pop();
      }
    }

    var labelGeneratorProto = {
      generate: function(kind, genus) {
        var curCounter = this.counters[kind];
        var sequence = labelPoolInfo[kind];

        if (!curCounter) {
          this.counters[kind] = {
            index: 0,
            subscript: 0,
          };
          curCounter = this.counters[kind];

          //For sequences of 0 or 1, we want to start with a subscript of 1
          //eg. Parameters start with "t[1]" rather than "t"
          if (sequence.length <= 1) {
            curCounter.subscript = 1;
          }
        } else if (sequence.length) {
          //it exists.  Increment the sequence index,
          //incrementing subscript if we wrap around
          curCounter.index += 1;
          if (curCounter.index >= sequence.length) {
            curCounter.index = 0;
            curCounter.subscript += 1;
          }
        } else {
          //there is no sequence, just increment the subscript
          curCounter.subscript += 1;
        }

        //Now generate a label:
        var label = '';

        if (sequence.length) {
          label += sequence[curCounter.index];

          if (curCounter.subscript > 0) {
            label += '[';
            label += curCounter.subscript;
            label += ']';
          }
        } else {
          // Use the subscript for 'no sequence' labels
          label += curCounter.subscript;
        }

        return label;
      },
      copy: function() {
        var ret = Object.create(labelGeneratorProto);

        ret.counters = $.extend(true, {}, this.counters);

        return ret;
      },
    };

    function createGenerator() {
      var ret = Object.create(labelGeneratorProto);

      ret.counters = {};

      return ret;
    }

    var labelPoolProto = {
      curGenerator: function() {
        return this.generators[this.generators.length - 1];
      },
      /**
       * generates a new default label based on kind and genus
       *
       * @param kind - String
       * @param genus - String, optional - required for parameter and functions, which are
       *    Expression kinds that would otherwise be classified as Measure
       * @returns {string} - the generated label
       */
      generateLabel: function(kind, genus, id) {
        var label;
        var kindClass = GSP.gObjects[kind];
        var poolKind = poolKindForKindInstance(kindClass, genus);
        var foundAMatch = true;

        function searchForMatch(index, searchGobj) {
          if (
            poolKind ===
              poolKindForKindInstance(searchGobj, searchGobj.genus) &&
            label === searchGobj.label
          ) {
            foundAMatch = true;
            return false; //stop searching
          }
        }

        while (foundAMatch) {
          foundAMatch = false;
          label = this.curGenerator().generate(poolKind);

          this.sketch.eachGObj(searchForMatch);
        }
        if (this.session) {
          if (!id)
            throw GSP.createError(
              'generateLabel called with a toolplay session but no id.'
            );
          if (!this.session.generatedLabels) {
            this.session.generatedLabels = {};
          }
          this.session.generatedLabels[id] = true;
        }
        return label;
      },
      saveState: function(session) {
        this.generators.push(this.curGenerator().copy());
        this.session = session; // While session is set, id's of newly generated labels are stored in session.generatedLabels
      },
      restoreSavedState: function() {
        var retVal;
        if (this.generators.length < 2) {
          throw GSP.createError(
            'LabelPool.restoreSavedState() called without calling saveState()'
          );
        }

        this.generators.pop();
        retVal = this.session;
        this.session = null;
        return retVal;
      },
      forgetSavedState: function() {
        if (this.generators.length < 2) {
          throw GSP.createError(
            'LabelPool.forgetSavedState() called without calling saveState()'
          );
        }
        //Here we just want to delete the second to last one, keeping the last one
        //on the top of the stack
        this.generators.splice(this.generators.length - 2, 1);
        this.session = null;
      },
    };

    GSP.LabelPool = {
      createInSketch: function(sketch) {
        var ret = Object.create(labelPoolProto);
        ret.sketch = sketch;
        ret.generators = [];
        ret.generators.push(createGenerator());

        return ret;
      },
    };
  })();

  (function() {
    var expressionCache = {}; // cache for infix parsing

    GSP.mfs = {};

    GSP.mfs.binaryOperatorPrecedence = {
      '^': 3,
      '*': 2,
      '/': 2,
      '+': 1,
      '-': 1,
    };

    /*
     * This table translates the "symbol" character set to UTF.
     * Symbol characters are referenced in MFS symbol elements.
     */
    GSP.mfs.symMap = {
      '20': '\u0020', // space ('&#x00A0;')
      '21': '\u0021', // exclam
      '22': '\u2200', // universal
      '23': '\u0023', // numbersign
      '24': '\u2203', // existential
      '25': '\u0025', // percent
      '26': '\u0026', // ampersand
      '27': '\u220B', // suchthat
      '28': '\u0028', // parenleft
      '29': '\u0029', // parenright
      '2A': '\u2217', // asteriskmath
      '2B': '\u002B', // plus
      '2C': '\u002C', // comma
      '2D': '\u2212', // minus
      '2E': '\u002E', // period
      '2F': '\u002F', // slash
      '30': '\u0030', // zero
      '31': '\u0031', // one
      '32': '\u0032', // two
      '33': '\u0033', // three
      '34': '\u0034', // four
      '35': '\u0035', // five
      '36': '\u0036', // six
      '37': '\u0037', // seven
      '38': '\u0038', // eight
      '39': '\u0039', // nine
      '3A': '\u003A', // colon
      '3B': '\u003B', // semicolon
      '3C': '\u003C', // less
      '3D': '\u003D', // equal
      '3E': '\u003E', // greater
      '3F': '\u003F', // question
      '40': '\u2245', // congruent
      '41': '\u0391', // Alpha
      '42': '\u0392', // Beta
      '43': '\u03A7', // Chi
      '44': '\u0394', // Delta ('&#x2206;')
      '45': '\u0395', // Epsilon
      '46': '\u03A6', // Phi
      '47': '\u0393', // Gamma
      '48': '\u0397', // Eta
      '49': '\u0399', // Iota
      '4A': '\u03D1', // theta1
      '4B': '\u039A', // Kappa
      '4C': '\u039B', // Lambda
      '4D': '\u039C', // Mu
      '4E': '\u039D', // Nu
      '4F': '\u039F', // Omicron
      '50': '\u03A0', // Pi
      '51': '\u0398', // Theta
      '52': '\u03A1', // Rho
      '53': '\u03A3', // Sigma
      '54': '\u03A4', // Tau
      '55': '\u03A5', // Upsilon
      '56': '\u03C2', // sigma1
      '57': '\u03A9', // Omega ('&#x2126;')
      '58': '\u039E', // Xi
      '59': '\u03A8', // Psi
      '5A': '\u0396', // Zeta
      '5B': '\u005B', // bracketleft
      '5C': '\u2234', // therefore
      '5D': '\u005D', // bracketright
      '5E': '\u22A5', // perpendicular
      '5F': '\u005F', // underscore
      '61': '\u03B1', // alpha
      '62': '\u03B2', // beta
      '63': '\u03C7', // chi
      '64': '\u03B4', // delta
      '65': '\u03B5', // epsilon
      '66': '\u03C6', // phi
      '67': '\u03B3', // gamma
      '68': '\u03B7', // eta
      '69': '\u03B9', // iota
      '6A': '\u03D5', // phi1
      '6B': '\u03BA', // kappa
      '6C': '\u03BB', // lambda
      '6D': '\u00B5', // mu ('&#x03BC;')
      '6E': '\u03BD', // nu
      '6F': '\u03BF', // omicron
      '70': '\u03C0', // pi
      '71': '\u03B8', // theta
      '72': '\u03C1', // rho
      '73': '\u03C3', // sigma
      '74': '\u03C4', // tau
      '75': '\u03C5', // upsilon
      '76': '\u03D6', // omega1
      '77': '\u03C9', // omega
      '78': '\u03BE', // xi
      '79': '\u03C8', // psi
      '7A': '\u03B6', // zeta
      '7B': '\u007B', // braceleft
      '7C': '\u007C', // bar
      '7D': '\u007D', // braceright
      '7E': '\u223C', // similar
      A0: '\u20AC', // Euro
      A1: '\u03D2', // Upsilon1
      A2: '\u2032', // minute
      A3: '\u2264', // lessequal
      A4: '\u2044', // fraction ('&#x2215;')
      A5: '\u221E', // infinity
      A6: '\u0192', // florin
      A7: '\u2663', // club
      A8: '\u2666', // diamond
      A9: '\u2665', // heart
      AA: '\u2660', // spade
      AB: '\u2194', // arrowboth
      AC: '\u2190', // arrowleft
      AD: '\u2191', // arrowup
      AE: '\u2192', // arrowright
      AF: '\u2193', // arrowdown
      B0: '\u00B0', // degree
      B1: '\u00B1', // plusminus
      B2: '\u2033', // second
      B3: '\u2265', // greaterequal
      B4: '\u00D7', // multiply
      B5: '\u221D', // proportional
      B6: '\u2202', // partialdiff
      B7: '\u2022', // bullet
      B8: '\u00F7', // divide
      B9: '\u2260', // notequal
      BA: '\u2261', // equivalence
      BB: '\u2248', // approxequal
      BC: '\u2026', // ellipsis
      BF: '\u21B5', // carriagereturn
      C0: '\u2135', // aleph
      C1: '\u2111', // Ifraktur
      C2: '\u211C', // Rfraktur
      C3: '\u2118', // weierstrass
      C4: '\u2297', // circlemultiply
      C5: '\u2295', // circleplus
      C6: '\u2205', // emptyset
      C7: '\u2229', // intersection
      C8: '\u222A', // union
      C9: '\u2283', // propersuperset
      CA: '\u2287', // reflexsuperset
      CB: '\u2284', // notsubset
      CC: '\u2282', // propersubset
      CD: '\u2286', // reflexsubset
      CE: '\u2208', // element
      CF: '\u2209', // notelement
      D0: '\u2220', // angle
      D1: '\u2207', // gradient
      D5: '\u220F', // product
      D6: '\u221A', // radical
      D7: '\u22C5', // dotmath
      D8: '\u00AC', // logicalnot
      D9: '\u2227', // logicaland
      DA: '\u2228', // logicalor
      DB: '\u21D4', // arrowdblboth
      DC: '\u21D0', // arrowdblleft
      DD: '\u21D1', // arrowdblup
      DE: '\u21D2', // arrowdblright
      DF: '\u21D3', // arrowdbldown
      E0: '\u25CA', // lozenge
      E1: '\u2329', // angleleft
      E5: '\u2211', // summation
      F1: '\u232A', // angleright
      F2: '\u222B', // integral
      F3: '\u2320', // integraltp
      F5: '\u2321', // integralbt
      /*
       * The standard adobe symbol character set is an 8-bit set.
       * Documentation refers to these additional characters.
       */
      '100': '\u2299', // circle
      '101': '\u2225', // parallel
      '102': '\u25B3', // triangle
      '103': '\u2212', // minus sign
      '176': '\u00B0', // degree sign
      '177': '\u00B1', // plus-minus
    };

    GSP.mfs.makeFunctionFromParsedInfix = function(node) {
      var typeMap,
        f,
        body,
        memoize = {};

      function visit(node) {
        var key = '' + node.index,
          fn = typeMap[node.type],
          memo;

        // Just a one time thing? Just do it.
        if (node.refCount === 1) {
          return fn(node);
        }

        // Otherwise for memoized result
        if (memoize[key]) {
          return memoize[key];
        }

        // Otherwise, evaluate and cache

        memo = 'm[' + key + ']';
        memoize[key] = memo; // later calls remeber the cached value

        return '(' + memo + '=' + fn(node) + ')'; // first call stashed value as side-effect
      }

      var stdConstantMap = {
        pi: 'Math.PI',
        e: 'Math.E',
      };

      var stdFunctionMap = {
        sin: 'GSP.math.sin',
        cos: 'GSP.math.cos',
        tan: 'GSP.math.tan',
        Arcsin: 'GSP.math.asin',
        Arccos: 'GSP.math.acos',
        Arctan: 'GSP.math.atan',
        abs: 'GSP.math.abs',
        sqrt: 'GSP.math.sqrt',
        ln: 'GSP.math.ln',
        log: 'GSP.math.log',
        sgn: 'GSP.math.sign',
        round: 'GSP.math.round',
        trunc: 'GSP.math.trunc',
        isDefined: 'GSP.math.isDefined',
      };

      function visitBinary(node) {
        var left = visit(node.children.left);
        if (node.children.left.type === 'binary-expr') {
          left = '(' + left + ')';
        }
        var right = visit(node.children.right);
        if (node.operator === '^') {
          return 'GSP.math.pow(' + left + ',' + right + ')';
        } else {
          if (node.children.right.type === 'binary-expr') {
            right = '(' + right + ')';
          }
          return left + node.operator + right;
        }
      }

      function visitUnary(node) {
        var child = visit(node.children.child);
        if (
          node.children.child.type === 'unary-expr' ||
          node.children.child.type === 'binary-expr'
        ) {
          child = '(' + child + ')';
        }
        // Put a parenthesis around the whole thing, to disambiguate
        // 1--2 to mean 1 - (-2)
        return '(' + node.operator + child + ')';
      }

      function visitFunction(node) {
        var fn;
        if (node.subtype === 'sys') {
          fn = stdFunctionMap[node.name];
          return fn + '(' + visit(node.children.arg) + ', unitMap)';
        } else {
          return (
            visit(node.children.name) + '(' + visit(node.children.arg) + ')'
          );
        }
      }
      function visitPrimary(node) {
        var value = node.children.value,
          unit = node.children.unit;
        if (typeof unit !== 'undefined') {
          return (
            'GSP.units.convertToDocUnits(unitMap, ' +
            visit(value) +
            ', ' +
            visit(unit) +
            ')'
          );
        } else {
          return visit(value);
        }
      }

      function visitConstant(node) {
        var val = node.value;
        if (node.subtype === 'numeric') {
          // Remove leading 0's to prevent octal interpretation
          return val.replace(/^0+(?=[^0])/, '');
        } else {
          return stdConstantMap[val];
        }
      }

      function visitUnit(node) {
        return '"' + node.name + '"';
      }

      function visitReference(node) {
        return 'parentArray["' + node.name + '"].uValue';
      }

      function visitVariable(node) {
        return 'parentArray["' + node.name + '"]';
      }

      function visitEquation(node) {
        return visit(node.children.expr);
      }

      function visitBlank(node) {
        return NaN;
      }

      typeMap = {
        blank: visitBlank,
        equation: visitEquation,
        'binary-expr': visitBinary,
        'unary-expr': visitUnary,
        function: visitFunction,
        constant: visitConstant,
        primary: visitPrimary,
        unit: visitUnit,
        variable: visitVariable,
        reference: visitReference,
      };

      f = '';
      body = visit(node); // grab the meat of the function
      // If there was memoization, the function needs a memoize cache called 'm'
      if (!$.isEmptyObject(memoize)) {
        f += 'var m={};';
      }
      f += 'return ' + body + ';';
      // console.log(f);
      /*jslint evil:true*/
      return new Function('parentArray', 'unitMap', f);
    };

    // Return a struct with derived data from the expression:
    // parsedInfix: the syntax tree
    // func: an evaluatable function
    GSP.mfs.getParsedInfixAndFunction = function getParsedInfixAndFunction(
      expression
    ) {
      var expr = expressionCache[expression] || {};

      if (!expr.parsedInfix) {
        expr.parsedInfix = GSP.infixExpressionParser.parse(expression);
        expr.func = GSP.mfs.makeFunctionFromParsedInfix(expr.parsedInfix);
        expressionCache[expression] = expr;
      }

      return expr;
    };

    // Some clients are just interested in the parsed infix
    GSP.mfs.getParsedInfix = function getParsedInfix(expression) {
      var expr = expressionCache[expression] || {};

      if (!expr.parsedInfix) {
        expr.parsedInfix = GSP.infixExpressionParser.parse(this.expression);
        expressionCache[expression] = expr;
      }

      return expr.parsedInfix;
    };

    GSP.mfs.makeMathMLFromParseTree = function(node) {
      var operatorMap = {
        '+': '+',
        '-': '&#x02212;',
        '*': '&#x22c5;',
      };

      var stdConstantMap = {
        pi: '&#x003C0;',
        e: 'e',
      };

      var stdFunctionMap, typeMap;

      function visit(node) {
        var fn = typeMap[node.type];
        return fn(node);
      }

      function visitBinary(node) {
        var left = visit(node.children.left);
        if (node.children.left.type === 'binary-expr') {
          left = '<mfenced separators="">' + left + '</mfenced>';
        } else if (
          node.children.left.type === 'unary-expr' ||
          node.children.left.type === 'function'
        ) {
          left = '<mrow>' + left + '</mrow>';
        }
        var right = visit(node.children.right);
        if (node.children.right.type === 'binary-expr') {
          right = '<mfenced separators="">' + right + '</mfenced>';
        } else if (
          node.children.right.type === 'unary-expr' ||
          node.children.right.type === 'function'
        ) {
          right = '<mrow>' + right + '</mrow>';
        }
        if (node.operator === '^') {
          return '<msup>' + left + right + '</msup>';
        }
        if (node.operator === '/') {
          return '<mfrac>' + left + right + '</mfrac>';
        } else {
          return left + '<mo>' + operatorMap[node.operator] + '</mo>' + right;
        }
      }

      function visitUnary(node) {
        var child = visit(node.children.child);
        if (node.children.child.type === 'binary-expr') {
          child = '<mrow>' + child + '</mrow>';
        }
        return '<mo>' + operatorMap[node.operator] + '</mo>' + child;
      }

      function functionBuilder(fnname, arg) {
        return (
          '<mi>' +
          fnname +
          '</mi>' +
          '<mfenced><mrow>' +
          arg +
          '</mrow></mfenced>'
        );
      }

      function absBuilder(fnname, arg) {
        return (
          '<mfenced open="|" close="|" separators=""><mrow>' +
          arg +
          '</mrow></mfenced>'
        );
      }
      function sqrtBuilder(fnname, arg) {
        return '<msqrt><mrow>' + arg + '</mrow></msqrt>';
      }

      function visitFunction(node) {
        var helper = stdFunctionMap[node.name];
        if (helper === undefined) {
          helper = functionBuilder;
        }
        if (node.subtype === 'sys') {
          return helper(node.name, visit(node.children.arg));
        } else {
          return helper(visit(node.children.name), visit(node.children.arg));
        }
      }

      function visitPrimary(node) {
        return visit(node.children.value);
      }

      function visitConstant(node) {
        var value;
        if (node.subtype === 'numeric') {
          value = node.value;
        } else {
          value = stdConstantMap[node.value];
        }
        return '<mn>' + value + '</mn>';
      }

      function visitUnit(node) {
        return '<mi>' + node.name + '</mi>';
      }

      function visitReference(node) {
        return '<mi>' + node.name + '</mi>';
      }

      function visitVariable(node) {
        return '<mi>' + node.name + '</mi>';
      }

      function visitEquation(node) {
        if (node.children.expr) {
          return visit(node.children.expr);
        } else {
          return visit(node.children.expr);
        }
      }

      stdFunctionMap = {
        sin: functionBuilder,
        cos: functionBuilder,
        tan: functionBuilder,
        Arcsin: functionBuilder,
        Arccos: functionBuilder,
        Arctan: functionBuilder,
        abs: absBuilder,
        sqrt: sqrtBuilder,
        ln: functionBuilder,
        log: functionBuilder,
        sgn: functionBuilder,
        round: functionBuilder,
        trunc: functionBuilder,
      };

      typeMap = {
        equation: visitEquation,
        'binary-expr': visitBinary,
        'unary-expr': visitUnary,
        function: visitFunction,
        constant: visitConstant,
        primary: visitPrimary,
        unit: visitUnit,
        variable: visitVariable,
        reference: visitReference,
      };

      function visitRoot(node) {
        return '<math>' + visit(node) + '</math>';
      }
      return visitRoot(node);
    };

    /*********** Utility Functions for Infix Expressions ***************/

    /*
     * The tasks of translating infix to mfs and rendering infix as
     * mathquill are similar. Below are the functions that are shared by
     * both. Further refactoring may be possible, but most of the
     * low-hanging fruit has been picked. The main structural difference
     * between the routines is that while the mfs generator is a
     * translator/compiler from one encoding to another, the mathquill
     * renderer is more imperative: it issues rendering commands to
     * mathquill as it walks the infix tree. Because Mathquill understands
     * latex, we could potentially generate a latex expression instead of
     * issuing commands. However, we need a fairly intimate connection
     * to the rendered mathquill tree for keeping track of references to parents, as
     * well as independent variables. Hence, the current design.
     */

    /******************************************************************/

    /*
     * Identify strings which require parentheses, e.g. strings with spaces
     * or other "suspicious" characters unless the entire string is wrapped
     * in parentheses.
     */
    function isCompoundString(iString) {
      var i,
        len = iString.length,
        tChar,
        nestingLevel = 0,
        suspiciousChars = ' +-*/()\u2212\u22c5',
        hasSuspiciousChars = false,
        hasUnparenthesizedChars = false;
      for (i = 0; i < len; ++i) {
        tChar = iString[i];
        hasSuspiciousChars =
          hasSuspiciousChars || suspiciousChars.indexOf(tChar) >= 0;
        if (tChar === '(') {
          ++nestingLevel;
        } else if (nestingLevel && tChar === ')') {
          --nestingLevel;
        } else if (!nestingLevel) {
          hasUnparenthesizedChars = true;
        }
        // If there are suspicious chars then _any_ unparenthesized chars
        // require parenthesization (e.g. "(a+b)c" ^ 2 should be parenthesized).
        // Note that this is an improvement over the heuristic GSP uses, which
        // itself is not implemented correctly in GSP 5.06.
        if (hasSuspiciousChars && hasUnparenthesizedChars) return true;
      }
      // If parentheses are unbalanced, then we should parenthesize
      return nestingLevel > 0;
    }

    function isParameter(gobj) {
      return gobj.kind === 'Expression' && gobj.genus === 'ScalarParameter';
    }

    function isLabeledExpressionOrMeasure(gobj) {
      return gobj.style.nameOrigin === 'namedFromLabel';
    }

    /*
     * Identify those references which should be parenthesized in power
     * expressions. This function does not examine infix expression tree
     * structure, only superficial things like labels and measurements.
     */
    function isTextuallyComplexReference(node, fnReferences) {
      var gobj;
      if (node.type !== 'reference') return false;
      if (!fnReferences) {
        throw GSP.createError('reference without parents!');
      }
      gobj = fnReferences[node.name];
      // Scalar parameters are not parenthesized unless their labels require it.
      if (isParameter(gobj) || isLabeledExpressionOrMeasure(gobj)) {
        return gobj.label ? isCompoundString(gobj.label) : false;
      }

      // Leave blanks blank.
      if (gobj.parsedInfix && gobj.parsedInfix.type === 'blank') {
        return false;
      }

      if (gobj.parsedInfix) {
        throw GSP.createError(
          'non-blank parsed infix not expected in isTextuallyComplexReference'
        );
      }
      // All other references are parenthesized
      return true;
    }

    function isReference(node) {
      return node.type === 'reference';
    }

    /*
   * Keep dereferencing until enough structure is revealed that we can
   * make decisions about parenthesizing. The return value is called a
   * "denoted."
   *
   * We need to handle references to references to references...  We
   * stop when we reach a non-reference, or a reference to something
   * simple like a parameter or a non-infix measurement.
   *
   * NOTE: This function may still return a reference, but only to a simple
   * one that can be handled by isTextuallyComplexReference.
   *
   * @param {Object} node - the infix expr to dereference
   * @param {Object} fnReferences - the reference mapping (parents) of node
   * @returns { expr: the dereferenced infix expression,
                fnReferences: the reference mapping (parents) of the dereferenced expr }
   *
   */
    function dereference(node, fnReferences) {
      var unchanged = { expr: node, fnReferences: fnReferences };

      if (!isReference(node)) {
        return unchanged;
      }

      var gobj = fnReferences[node.name];

      if (
        isParameter(gobj) ||
        !gobj.parsedInfix || // Measures lack parsedInfix
        gobj.parsedInfix.type === 'blank' ||
        isLabeledExpressionOrMeasure(gobj)
      ) {
        return unchanged;
      }

      if (!gobj.parsedInfix || !gobj.parsedInfix.children) {
        throw GSP.createError('expected parsedInfix with children');
      }
      return dereference(gobj.parsedInfix.children.expr, gobj.parentsList);
    }

    /*
     * Identify compound values or textually complex references, which
     * should be parenthesized on the left side of power expressions.
     */
    function isCompoundPowerLeft(node, fnReferences) {
      // unary expressions and values with units should be parenthesized
      // in power expressions.
      var isCompound =
        node.type === 'unary-expr' ||
        (node.type === 'primary' && node.children.unit);

      return isCompound || isTextuallyComplexReference(node, fnReferences);
    }

    function isCompoundPowerExpression(node, leftDenoted) {
      if (node.operator !== '^') {
        return false;
      }
      // If leftDenoted.expr is a reference, it is to something "simple"
      // in terms of tree structure, but possibly complex textually.
      return isCompoundPowerLeft(leftDenoted.expr, leftDenoted.fnReferences);
    }

    function isNonFractionAndLeftIsBinary(node, leftDenoted) {
      var isFraction = node.operator === '/';
      return !isFraction && leftDenoted.expr.type === 'binary-expr';
    }

    function isNonFractionAndRightIsBinary(node, rightDenoted) {
      var isFraction = node.operator === '/';
      return !isFraction && rightDenoted.expr.type === 'binary-expr';
    }

    function isNonFractionAndRightIsUnary(node, rightDenoted) {
      var isFraction = node.operator === '/';
      return !isFraction && rightDenoted.expr.type === 'unary-expr';
    }

    function isFractionAndDenominatorIsFraction(node, rightDenoted) {
      var isFraction = node.operator === '/';
      return isFraction && rightDenoted.expr.operator === '/';
    }

    function shouldParenthesizeBinaryLeft(node, leftDenoted) {
      var parentPrecedence = GSP.mfs.binaryOperatorPrecedence[node.operator],
        childPrecedence =
          GSP.mfs.binaryOperatorPrecedence[leftDenoted.expr.operator];
      // If the precedence of the parent operator is higher than that of
      // the child operator OR if the left child is grouped in a way that
      // is not expected for a right-associative operator (of which '^' is
      // currently the only one supported) then add parentheses.
      return (
        childPrecedence < parentPrecedence ||
        (childPrecedence === parentPrecedence && node.operator === '^')
      );
    }

    // associative property
    // (a+b)+c = a+(b+c)
    var associativeOperators = { '+': true, '*': true };

    function shouldParenthesizeBinaryRight(node, rightDenoted) {
      var parentPrecedence = GSP.mfs.binaryOperatorPrecedence[node.operator],
        childPrecedence =
          GSP.mfs.binaryOperatorPrecedence[rightDenoted.expr.operator];
      // Don't add redundant parentheses to right child of associative operators
      if (
        node.operator === rightDenoted.expr.operator &&
        associativeOperators[node.operator]
      ) {
        return false;
      }
      // If the precedence of the parent operator is higher than that of
      // the child operator OR if the right child is grouped in a way that
      // is not expected for a left-associative operator (all except '^' and '/')
      // then add parentheses.
      return (
        childPrecedence <= parentPrecedence &&
        node.operator !== '^' &&
        rightDenoted.expr.operator !== '/'
      );
    }

    function shouldParenthesizeUnaryRight(node, rightDenoted) {
      // do not parenthesize negative exponents
      return node.operator !== '^';
    }

    var stdConstantMapForInfix = {
      pi: '\u03C0', // pi
      e: 'e',
    };

    function visitInfixConstant(node, func) {
      var value;

      if (node.subtype === 'numeric') {
        value = node.value;
      } else {
        value = stdConstantMapForInfix[node.value];
      }
      return func(value);
    }

    function visitInfixEquation(node, visit, ignoreDecl) {
      if (node.children.declaration && !ignoreDecl) {
        return visit(node.children.declaration);
      } else {
        return visit(node.children.expr);
      }
    }

    function visitInfixUnit(node, func) {
      var unitName = GSP.units.findUnit(node.name);
      return func(unitName.symbol);
    }

    GSP.mfs.makeMFSFromParsedInfix = function(
      node,
      fnReferences,
      ignoreDecl,
      italicize
    ) {
      var operatorMap = {
        '+': '+', // plus sign
        '-': '\u2212', // minus sign
        '*': '\u22c5', // dot
      };

      var stdFunctionMap, typeMap;

      function visit(node) {
        var fn = typeMap[node.type];
        return fn(node);
      }

      function visitFraction(node) {
        var left = visit(node.children.left),
          right = visit(node.children.right),
          rightDenoted = dereference(node.children.right, fnReferences);

        if (rightDenoted.expr.operator === '/') {
          right = GSP.mfs.makeParenthesisMFS(right);
        }

        // Denominators are only parenthesized if they are themselves fractions.
        return { type: 'fraction', value: [left, right] };
      }

      function visitBinary(node) {
        var left, leftDenoted;

        // Nibble off the fraction case to simplify code-flow.
        if (node.operator === '/') {
          return visitFraction(node);
        }

        left = visit(node.children.left);
        leftDenoted = dereference(node.children.left, fnReferences);

        // Power expressions of compound children are parenthesized
        if (isCompoundPowerExpression(node, leftDenoted)) {
          left = GSP.mfs.makeParenthesisMFS(left);
        }
        // Nested binary expressions are parenthesized based on precedence, but
        // numerators should never be parenthesized.
        else if (isNonFractionAndLeftIsBinary(node, leftDenoted)) {
          left = shouldParenthesizeBinaryLeft(node, leftDenoted)
            ? GSP.mfs.makeParenthesisMFS(left)
            : GSP.mfs.makeHorizontalMFS(left);
        } else if (
          node.children.left.type === 'unary-expr' ||
          node.children.left.type === 'function'
        ) {
          left = GSP.mfs.makeHorizontalMFS(left);
        }

        var right = visit(node.children.right);
        var rightDenoted = dereference(node.children.right, fnReferences);

        if (isNonFractionAndRightIsBinary(node, rightDenoted)) {
          right = shouldParenthesizeBinaryRight(node, rightDenoted)
            ? GSP.mfs.makeParenthesisMFS(right)
            : GSP.mfs.makeHorizontalMFS(right);
        } else if (isNonFractionAndRightIsUnary(node, rightDenoted)) {
          right = shouldParenthesizeUnaryRight(node, rightDenoted)
            ? GSP.mfs.makeParenthesisMFS(right)
            : GSP.mfs.makeHorizontalMFS(right);
        } else if (node.children.right.type === 'function') {
          right = GSP.mfs.makeHorizontalMFS(right);
        }
        if (node.operator === '^') {
          return { type: 'super', value: [left, right] };
        } else if (node.operator === '*') {
          //no space for multiply?
          return GSP.mfs.makeHorizontalMFS(
            left,
            GSP.mfs.makeTextMFS(operatorMap[node.operator]),
            right
          );
        } else {
          // + or -
          return GSP.mfs.makeHorizontalMFS(
            left,
            GSP.mfs.makeTextMFS(' ' + operatorMap[node.operator] + ' '),
            right
          );
        }
      }

      function visitUnary(node) {
        var child = visit(node.children.child),
          childDenoted = dereference(node.children.child, fnReferences);

        if (
          childDenoted.expr.type === 'unary-expr' ||
          childDenoted.expr.type === 'binary-expr' ||
          isTextuallyComplexReference(
            childDenoted.expr,
            childDenoted.fnReferences
          )
        ) {
          child =
            childDenoted.expr.operator === '^'
              ? GSP.mfs.makeHorizontalMFS(child)
              : { type: 'paren', value: [child] };
        }
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS(operatorMap[node.operator]),
          child
        );
      }

      function functionBuilder(nameMFS, argMFS) {
        return GSP.mfs.makeHorizontalMFS(nameMFS, {
          type: 'paren',
          value: [argMFS],
        });
      }

      function absBuilder(nameMFS, arg) {
        return { type: 'abs', value: [arg] };
      }
      function sqrtBuilder(nameMFS, arg) {
        return { type: 'root', value: [arg] };
      }

      function visitFunction(node) {
        var helper = stdFunctionMap[node.name];
        if (helper === undefined) {
          helper = functionBuilder;
        }

        var nameMFS =
          node.subtype === 'sys'
            ? GSP.mfs.makeTextMFS(node.name)
            : visit(node.children.name);

        return helper(nameMFS, visit(node.children.arg));
      }

      function visitPrimary(node) {
        var sequence = [visit(node.children.value)];
        if (node.children.unit) {
          sequence.push(visit(node.children.unit));
        }
        // variadic call
        return GSP.mfs.makeHorizontalMFS.apply(this, sequence);
      }

      function visitReference(node) {
        var gobj, option, retVal;
        if (fnReferences) {
          gobj = fnReferences[node.name];
          if (gobj.kind === 'Expression' && gobj.isFunction()) {
            retVal = GSP.mfs.makeTextMFS(
              gobj.label,
              gobj.getMathItalicization()
            );
          } else {
            if (gobj.style.nameOrigin === 'noVisibleName') {
              option = { force: true }; // use MFS-formatted labels for node with no visible name
            }
            retVal = gobj.getNameMFS(option);
          }
        } else {
          retVal = GSP.mfs.makeTextMFS(node.name);
        }
        return retVal;
      }

      function visitVariable(node) {
        return GSP.mfs.makeTextMFS(node.name, italicize);
      }

      function visitDeclaration(node) {
        var arg = GSP.mfs.makeTextMFS(node.argument, true);
        if (node.name) {
          return functionBuilder(GSP.mfs.makeTextMFS(node.name, true), arg);
        } else {
          return arg;
        }
      }

      function visitBlank(/*node*/) {
        return GSP.mfs.makeTextMFS(' ');
      }

      stdFunctionMap = {
        abs: absBuilder,
        sqrt: sqrtBuilder,
      };

      typeMap = {
        blank: visitBlank,
        equation: function(node) {
          return visitInfixEquation(node, visit, ignoreDecl);
        },
        declaration: visitDeclaration,
        'binary-expr': visitBinary,
        'unary-expr': visitUnary,
        function: visitFunction,
        constant: function(node) {
          return visitInfixConstant(node, GSP.mfs.makeTextMFS);
        },
        primary: visitPrimary,
        unit: function(node) {
          return visitInfixUnit(node, GSP.mfs.makeTextMFS);
        },
        variable: visitVariable,
        reference: visitReference,
      };

      return visit(node);
    };

    /*
     * This function is the mirror image of
     * CalculatorEditor.translateMathQuillToInfix. That one reads
     * mathquill, this one writes Mathquill.
     */
    GSP.mfs.renderMathquillFromParsedInfix = function(
      node,
      editor,
      fnReferences,
      ignoreDecl
    ) {
      function parenthesize(expr) {
        emit('(');
        visit(expr);
        editor.ascendTwo();
        emit(')');
      }

      var stdFunctionMap, typeMap;

      function visit(node) {
        var fn = typeMap[node.type];
        return fn(node);
      }

      function emit(ch) {
        editor.insertAtCursor(ch, true);
      }

      function emitPiecemeal(str) {
        for (var i = 0; i < str.length; i++) {
          editor.insertAtCursor(str.charAt(i), true);
        }
      }

      function visitBinary(node) {
        var leftDenoted = dereference(node.children.left, fnReferences),
          rightDenoted;

        // Power expressions of compound children are parenthesized
        if (isCompoundPowerExpression(node, leftDenoted)) {
          parenthesize(node.children.left);
        }
        // Nested binary expressions are parenthesized based on precedence, but
        // numerators should never be parenthesized.
        else if (isNonFractionAndLeftIsBinary(node, leftDenoted)) {
          if (shouldParenthesizeBinaryLeft(node, leftDenoted)) {
            parenthesize(node.children.left);
          } else {
            visit(node.children.left);
          }
        } else if (node.operator === '/') {
          // Ensure the entire numerator is above the line. Emitting the
          // "/" operator will then properly size the line.
          editor.renderAndSelect(function() {
            visit(node.children.left);
          });
        } else {
          visit(node.children.left);
        }
        emit(node.operator);

        rightDenoted = dereference(node.children.right, fnReferences);

        // Denominators are only parenthesized if they are themselves fractions.
        if (isFractionAndDenominatorIsFraction(node, rightDenoted)) {
          parenthesize(node.children.right);
        } else if (isNonFractionAndRightIsBinary(node, rightDenoted)) {
          if (shouldParenthesizeBinaryRight(node, rightDenoted)) {
            parenthesize(node.children.right);
          } else {
            visit(node.children.right);
          }
        } else if (isNonFractionAndRightIsUnary(node, rightDenoted)) {
          if (shouldParenthesizeUnaryRight(node, rightDenoted)) {
            parenthesize(node.children.right);
          } else {
            visit(node.children.right);
          }
        } else {
          visit(node.children.right);
        }

        if (node.operator === '^' || node.operator === '/') {
          editor.ascendTwo();
        }
      }

      function visitUnary(node) {
        var childDenoted = dereference(node.children.child, fnReferences),
          isComplicated =
            childDenoted.expr.type === 'unary-expr' ||
            childDenoted.expr.type === 'binary-expr' ||
            isTextuallyComplexReference(
              childDenoted.expr,
              childDenoted.fnReferences
            );
        emit(node.operator);
        if (isComplicated && childDenoted.expr.operator !== '^') {
          parenthesize(node.children.child);
        } else {
          visit(node.children.child);
        }
      }

      function absBuilder(arg) {
        editor.renderOnLeft(function() {
          editor.renderAndSelect(function() {
            visit(arg);
          });
          emit('|');
        });
      }

      function sqrtBuilder(arg) {
        emit('\\sqrt');
        visit(arg);
        editor.ascendTwo();
      }

      function visitFunction(node) {
        var helper = stdFunctionMap[node.name];
        if (helper === undefined) {
          helper = parenthesize;
          if (node.name) {
            editor.writeLiteral(node.name);
          }
        }

        if (node.subtype !== 'sys') {
          visit(node.children.name);
        }

        helper(node.children.arg);
      }

      function visitPrimary(node) {
        visit(node.children.value);
        if (node.children.unit) {
          visit(node.children.unit);
        }
      }

      /*
       * Emit a fully expanded reference as an opaque HTML blob.
       *
       * This transforms the reference into its expanded HTML representation,
       * via MFS. Then it asks mathquill to insert the HTML as a blob
       * annotated with the referenced parent id as an html attribute.
       *
       * @arg {Object} node - the infix node, a reference
       */
      function visitReference(node) {
        var gobj,
          mfs,
          $elt = $('<span></span>')
            .addClass('wsp-ref')
            .attr('wsp-ref', node.name)
            .attr('wsp-sessionID', editor.getSessionID());

        function emitReferenceBlob() {
          // support parameters named "\endBlob" :-)
          var quoted = $elt[0].outerHTML.replace(/\\/g, '\\\\');

          editor.writeLatex('\\blob' + quoted + '\\endBlob');
        }

        if (fnReferences) {
          gobj = fnReferences[node.name];
          if (gobj.kind === 'Expression' && gobj.isFunction()) {
            $elt.text(gobj.label); // performs HTML escaping
          } else {
            mfs = gobj.getNameMFS({ force: true }); // don't use an empty string for noVisibleName gobjs
            if (mfs.type === 'text' && mfs.value === '' && gobj.label) {
              mfs.value = gobj.label;
            }
            GSP.mfs.makeHTMLFromMFSParseTree(mfs, $elt, {}, {});
          }
          emitReferenceBlob();
        } else {
          emit(node.name);
        }
      }

      function visitVariable(node) {
        emit(node.name);
        // This may be changed by selecting from the equation menu, so
        // we need to remember it.
        editor.registerIndependentVariable();
      }

      function visitDeclaration(node) {
        var arg = node.argument;
        if (node.name) {
          emit(node.name);
          parenthesize(arg);
        } else {
          emit(arg);
        }
      }

      function visitBlank(node) {}

      stdFunctionMap = {
        abs: absBuilder,
        sqrt: sqrtBuilder,
      };

      typeMap = {
        blank: visitBlank,
        equation: function(node) {
          return visitInfixEquation(node, visit, ignoreDecl);
        },
        declaration: visitDeclaration,
        'binary-expr': visitBinary,
        'unary-expr': visitUnary,
        function: visitFunction,
        constant: function(node) {
          return visitInfixConstant(node, emitPiecemeal);
        },
        primary: visitPrimary,
        unit: function(node) {
          return visitInfixUnit(node, emit);
        },
        variable: visitVariable,
        reference: visitReference,
      };

      return visit(node);
    };

    /*
     * Given an mfs tree, italicize it.
     * @param {Object} - the mfs tree to italicize
     * @returns {Object} - the italicized mfs tree
     */
    GSP.mfs.makeItalicMFS = function makeItalicMFS(mfsInner) {
      return {
        type: 'style',
        value: [{ code: 'fontStyle', value: '2' }, mfsInner],
      };
    };

    /*
     * Given an mfs tree, ensure it is not italicized.
     *
     * @param {Object} - the mfs tree to de-italicize
     * @returns {Object} - the de-italicized mfs tree
     */
    GSP.mfs.makeNonItalicMFS = function makeNonItalicMFS(mfsInner) {
      return {
        type: 'style',
        value: [{ code: 'fontStyle', value: '1' }, mfsInner],
      };
    };

    /*
     * Given a text string, turn it into an mfs tree, optionally italicizing.
     * @param {string} text
     * @param {bool} italicize
     * @returns {Object} - the mfs tree
     */
    GSP.mfs.makeTextMFS = function makeTextMFS(text, italicize) {
      if (typeof text === 'object') {
        throw GSP.createError("Can't make text from objects");
      }
      var ret = { type: 'text', value: String(text) };
      return italicize ? GSP.mfs.makeItalicMFS(ret) : ret;
    };

    GSP.mfs.makeFractionMFS = function makeFractionMFS(numer, denom) {
      return { type: 'fraction', value: [numer, denom] };
    };

    /*
     * Given an mfs tree, return whether it is an empty text tree.
     * @param {Object} the MFS tree.
     * @returns {Boolean}
     */
    GSP.mfs.isEmptyTextMFS = function isEmptyTextMFS(mfsTree) {
      return mfsTree.type === 'text' && mfsTree.value === '';
    };

    /*
     * Given an mfs tree, wrap it in a parenthesis.
     * @param {Object} the MFS tree.
     * @returns {Object}
     */
    GSP.mfs.makeParenthesisMFS = function(node) {
      return { type: 'paren', value: [node] };
    };

    /*
     * variadic function to construct a horizontal mfs object. Arguments
     * are MFS trees.
     *
     */
    GSP.mfs.makeHorizontalMFS = function makeHorizontalMFS() {
      return {
        type: 'horizontal',
        value: Array.prototype.slice.call(arguments, 0),
      };
    };

    /*
     * Returns a horizontal overbar MFS tree for the given parents of
     * 'gObj.'
     * @param {Object} gObj
     * @param {string list} parentNames
     */
    GSP.mfs.parentsHorizontalOverbar = function(gObj, parentNames) {
      var names = [];
      $.each(parentNames, function(i, v) {
        var parent = gObj.getParent(v);
        if (parent) {
          names.push(parent.getNameMFS());
        }
      });
      return {
        type: 'overbar',
        variant: 5,
        value: GSP.mfs.makeHorizontalNamesMFS(names),
      };
    };

    GSP.mfs.makeNonvisibleSpokenWordSeparator = function() {
      // NJS2_IMHWSAR-168:
      // Provides a non-visible separator unit for adding a spoken break between
      // MFS objects that do not have a visible word-break between them in their
      // preferred graphical / symbolic layout.

      // As of the introduction of this idea, 7-Jul-2020 in Magic's Accessibility work,
      // we believe that browser-support of Unicode provides sufficient that we can
      // deploy a Unicode ZERO-WIDTH SPACE here and (a) browsers will
      // correctly voice terms separated by it separately; and (b) browsers JavaScript
      // engines will correctly convert this character to NO visible character when
      // either displaying textNodes that may come to contain it or exporting them
      // as "plainText" in any future circumstances involving non-Unicode export (none foreseen).
      // Those are the semantics of the Unicode character, which was introduced in Unicode 3.2,
      // and Mac Voiceover (Sierra) and Safari (13.1) comply, although we have yet to test
      // across devices etc.
      //
      // If our assumption is NOT correct, and the Unicode character either (a) fails to
      // separate words on some screen readers, or (b) appears inappropriately in downstream
      // text contexts, we can filter it there, either promoting it to a visible space-separator
      // (in makeSpeakableTextFromMfs) or demoting it into an empty string (in any future
      // MFSnode-to-plaintext export).

      // As it happens (later than the above paragraph), certain Mac VoiceOver voices
      // like Veena (English India) do NOT separate words on ZERO WIDTH SPACE or INVISIBLE
      // SEPARATOR. So we do indeed currently promote these to regular spaces in our
      // makeSpeakableText post-processing stage (search NJS2_IMHWSAR-168).

      return GSP.mfs.makeTextMFS('\u200B'); // UNICODE: Zero Width Space
    };

    /*
     * Given a list of names and an optional prefix node, this function
     * returns a horizontal node containing each of the names. If any of
     * the names is multicharacter, a "|" separator character is inserted
     * between each pair of names.
     *
     * Any given prefix is inserted before the first name, and no
     * separator character goes between it and the first name.
     *
     * Note that this function modifies the horizontals array given as
     * argument.
     */

    GSP.mfs.makeHorizontalNamesMFS = function(horizontals, optPrefix) {
      function distinguishCompoundNames(names) {
        function intersperse(array, separator) {
          if (array.length === 0) return [];
          var result = [],
            i;
          for (i = 0; i < array.length - 1; i++) {
            result.push(array[i]);
            result.push(separator);
          }
          result.push(array[i]);
          return result;
        }

        var multiCharacterName = false;

        function checkForMultiCharacter(node) {
          if (node.value.length > 1 && node.value[1] !== "'") {
            multiCharacterName = true;
          }
        }

        for (var i = 0; i < names.length; i++) {
          GSP.mfs.walkNode(names[i], 'text', checkForMultiCharacter);
        }

        return intersperse(
          names,
          multiCharacterName
            ? // ensure the visible "|" separator is not italicized.
              GSP.mfs.makeNonItalicMFS(GSP.mfs.makeTextMFS('|'))
            : // or that we have an invisible separator, for makeSpeakableText to verbally undo this visual concatenation
              // (cf https://magicsw.jira.com/browse/IMHWSAR-168)
              GSP.mfs.makeNonvisibleSpokenWordSeparator()
        );
      }

      horizontals = distinguishCompoundNames(horizontals);
      if (optPrefix) {
        horizontals.unshift(optPrefix);
      }
      return GSP.mfs.makeHorizontalMFS.apply(this, horizontals);
    };

    /*
     * Walks an infix expression parse tree to determine if the
     * expression is 'simple'. A simple expression has a simple
     * constant term with, possibly, a unit.
     */
    GSP.mfs.isSimpleExpression = function(node) {
      var typeMap = {};
      function visit(node) {
        var res = typeMap[node.type],
          resType = $.type(res);

        if (resType === 'boolean') {
          return res;
        } else if (resType === 'function') {
          return res(node);
        } else {
          return false;
        }
      }
      typeMap.equation = function(node) {
        return (
          typeof node.children.declaration !== 'undefined' ||
          visit(node.children.expr)
        );
      };
      typeMap['unary-expr'] = function(node) {
        return visit(node.children.child);
      };
      typeMap.primary = function(node) {
        return visit(node.children.value);
      };
      typeMap.constant = true;
      typeMap.blank = true;

      return visit(node);
    };

    /**
     * Determines the units of an expression.
     * Returns an object with properties named for unit families and
     * integer values representing the powers of each unit.
     *
     * @param {object} node - root node of the expression parse tree
     * @param {object} sQuery
     * @param {object} variableUnits (optional) - units of the independent variable, if this is a function evaluation
     * @returns {object} unit map containing powers of each unit family
     */
    GSP.mfs.determineUnit = function(node, fnReferences, variableUnits) {
      var typeMap = {},
        units = GSP.units,
        memoize = {};

      function visit(node) {
        var key = node.index,
          fn = typeMap[node.type];
        if (fn) {
          if (!memoize[key]) {
            memoize[key] = fn(node);
          }

          return memoize[key];
        } else {
          GSP.signalErrorWithMessage(
            'GSP.mfs.determineUnit: missing typeMap: ' + node.type
          );
        }
      }
      function agree(n1, n2) {
        var ret = true;

        GSP.units.eachUnitDimension(n1, function(family, power) {
          if (power !== n2[family]) {
            ret = false;
            return false;
          }
        });

        GSP.units.eachUnitDimension(n2, function(family, power) {
          if (power !== n1[family]) {
            ret = false;
            return false;
          }
        });

        return ret;
      }
      function getSqrtUnits(node) {
        var umap = visit(node);

        GSP.units.eachUnitDimension(umap, function(family, power) {
          if (power % 2 === 0) {
            umap[family] *= 0.5;
          } else {
            umap = {};
            return false;
          }
        });

        return umap;
      }
      typeMap.equation = function(node) {
        return visit(node.children.expr);
      };
      typeMap['binary-expr'] = function(node) {
        var lnode = visit(node.children.left),
          rnode = visit(node.children.right),
          factor,
          key,
          u,
          v,
          unitSpec = {};
        if (node.subtype === 'power') {
          lnode = visit(node.children.left);
          if (node.children.right.type === 'primary') {
            v = Number(node.children.right.children.value.value);
            if (v % 1 === 0) {
              for (key in lnode) {
                if (lnode.hasOwnProperty(key)) {
                  unitSpec[key] = lnode[key] * v;
                }
              }
            }
          }
          return unitSpec;
        } else if (node.subtype === 'multiplicative') {
          factor = 1;
          if (node.operator === '/') {
            factor = -1;
          }
          lnode = $.extend({}, lnode); // copy for output
          for (key in rnode) {
            if (rnode.hasOwnProperty(key)) {
              u = lnode[key];
              if (u === undefined) {
                lnode[key] = 0;
              }
              lnode[key] += factor * rnode[key];
            }
          }
          return lnode;
        } else if (node.subtype === 'additive') {
          if (agree(lnode, rnode)) {
            return lnode;
          } else {
            return {};
          }
        }
      };
      typeMap['unary-expr'] = function(node) {
        return visit(node.children.child);
      };
      typeMap['function'] = function(node) {
        // inverse trig functions return an angle, abs, round, and trunc
        // return the units of their argument. Otherwise we return
        // no unit.
        if (
          node.name === 'Arcsin' ||
          node.name === 'Arccos' ||
          node.name === 'Arctan'
        ) {
          return { angle: 1 };
        } else if (
          node.name === 'abs' ||
          node.name === 'round' ||
          node.name === 'trunc'
        ) {
          return visit(node.children.arg);
        } else if (node.name === 'sqrt') {
          return getSqrtUnits(node.children.arg);
        } else if (node.subtype === 'custom') {
          var functionGObj = fnReferences[node.children.name.name];
          return functionGObj.getUnitPowers(visit(node.children.arg));
        } else {
          return {};
        }
      };
      typeMap.primary = function(node) {
        if (node.children.unit) {
          return visit(node.children.unit);
        } else {
          return {};
        }
      };
      typeMap.constant = function(node) {
        return {};
      };
      typeMap.unit = function(node) {
        var umap = {};
        var unitFamily = units.getUnitFamily(node.name);
        if (unitFamily && unitFamily !== 'scalar') {
          umap[units.getUnitFamily(node.name)] = 1;
        }
        return umap;
      };
      typeMap.reference = function(node) {
        var gobj, rtn;
        if (fnReferences) {
          gobj = fnReferences[node.name];
          if (gobj) {
            rtn = $.extend(true, {}, gobj.unitPowers);
          }
        }

        return rtn;
      };
      typeMap.variable = function(node) {
        var rtn = variableUnits ? variableUnits : {};
        return rtn;
      };
      typeMap.blank = function(node) {
        return {};
      };

      return visit(node);
    };

    GSP.mfs.findByType = function(node, typeName) {
      function walk(node, typeName, results) {
        var key;
        if (node.children) {
          for (key in node.children) {
            if (node.children.hasOwnProperty(key)) {
              walk(node.children[key], typeName, results);
            }
          }
        }
        if (node.type === typeName) {
          results.push(node);
        }
      }
      var results = [];
      walk(node, typeName, results);
      return results;
    };

    /**
     *
     * Given an mfs parseTree node, recursively walk the tree, and replace
     * any nodes of the given type by the result of calling callback on
     * the existing child node. If the callback-returned node has children, these
     * are included in the walk.
     *
     * @param {Object} node
     * @param {Object} type
     * @param {Function} callback
     *
     * @return {Object} the new node
     */
    GSP.mfs.replaceNodes = function replaceNodes(node, type, callback) {
      var i,
        child,
        ret = node.type === type ? callback(node) : node,
        count = $.isArray(ret.value) ? ret.value.length : 0;

      for (i = 0; i < count; ++i) {
        child = ret.value[i];
        ret.value[i] = replaceNodes(child, type, callback);
      }

      return ret;
    };

    /**
     * Given a root node, and a map of key-value pairs of mfs to substitute,
     * iterates the param nodes in a mfs tree and replaces them with the mfs in the
     * map.
     *
     * @param {type} rootNode
     * @param {type} mapOfValues
     * @returns {undefined}
     */
    GSP.mfs.realizeParamNodes = function(rootNode, mapOfValues) {
      GSP.mfs.replaceNodes(rootNode, 'parameter', function(node) {
        return mapOfValues[node.value];
      });
    };
    /**
     * Performs a depth-first walk of all nodes descending from node,
     * calling callback with each node of type "type" it encounters. This
     * function is useful on all kinds of MFS elements.
     *
     * @param {Object} node
     * @param {String} type
     * @param {Function} callback
     */
    GSP.mfs.walkNode = function walkNode(node, type, callback) {
      // Walk the children, but don't "replace" them.
      GSP.mfs.replaceNodes(node, type, function(node) {
        callback(node);
        return node;
      });
    };

    /*
     * Performs an in-place flattening of the passed in vertical node, adding spaces
     * between the children when appropriate. (For convenience, the node is also returned.)
     *
     * NOTE: Desktop behavior differs here in that it only adds space nodes when then
     * children are 'simple' (having no children).  This appears to be a bug in the
     * algorithm rather than desired behavior - eg. word wrapped text where such as this:
     * <VL<T'hello'><S[boldStyle]<T'hello'>><T'hello'>> will put a space node between
     * the first and second hello, but omit the space between the second and 3rd since
     * the second node (a style node) has a child.  Note the logic preceeding line
     * 240 and absent from line 273 in MFS_StreamOut() to see the bug in desktop code.
     *
     * Logs an error if node is not the proper type.
     *
     * @param {Object} node
     * @returns {Object} the node
     */
    GSP.mfs.flattenVerticalNode = function flattenVerticalNode(node) {
      if (node.type !== 'vertical') {
        GSP.signalErrorWithMessage(
          'GSP.mfs.flattenVerticalNode should only be called on vertical nodes'
        );
        return node;
      }

      node.type = 'horizontal';

      var children = node.value;
      var spaceNode;

      //Adds a space node in between every child node
      for (var i = children.length - 1; i > 0; --i) {
        spaceNode = GSP.mfs.makeTextMFS(' ');
        children.splice(i, 0, spaceNode);
      }

      return node;
    };

    var lineHeightSpecs = {
      Times: {
        default: '1',
      },
      'Times New Roman': {
        '16px': '1.1',
        '24px': '1.1',
        '36px': '1.1',
        default: 'normal',
      },
      Arial: {
        '16px': '1.1',
        '24px': '1.1',
        '36px': '1.1',
        default: 'normal',
      },
      Geneva: {
        '16px': '1.3',
        '24px': '1.35',
        '36px': '1.35',
        default: 'normal',
      },
      'ReportSchoolRg-Regular': {
        '16px': '1.15',
        '24px': '1.15',
        '36px': '1.15',
        default: 'normal',
      },
      'Report School': {
        '16px': '1.15',
        '24px': '1.15',
        '36px': '1.15',
        default: 'normal',
      },
      'Proxima Nova': {
        '16px': '1.2',
        '24px': '1.2',
        '36px': '1.2',
        default: 'normal',
      },
    };

    /*
   * Given a string containing a css font-family value, return the first
   * named font it contains, without quotes.
   * For example:
  
     extractFirstFontFamily("a")
     "a"
     extractFirstFontFamily("a,b")
     "a"
     extractFirstFontFamily('"a",b')
     "a"
     extractFirstFontFamily('"a b"')
     "a b"
     extractFirstFontFamily("'a b'")
     "a b"
   */
    GSP.mfs.extractFirstFontFamily = function(fontName) {
      var name = fontName || '';
      name = name.split(',')[0];
      name = name.replace(/'/g, '"');
      return name.replace(/^"(.*)"$/, '$1');
    };

    GSP.mfs.getLineHeight = function(fontFamily, fontSize) {
      var name = GSP.mfs.extractFirstFontFamily(fontFamily);
      var spec = lineHeightSpecs[name];
      if (spec) {
        return spec[fontSize] || spec[fontSize + 'px'] || spec['default'];
      } else {
        return null;
      }
    };

    // This table describes cross-platform fallbacks for system fonts. It
    // is keyed by the family name we find in the JSON document. Since
    // these names are platform specific, we add fallback names, separated
    // by commas, to the css font-family. Sometimes we also need to set
    // other font properties such as style and weight in order to get
    // proper cross-platform behavior.

    var fontFallbackSpecs = {
      'Proxima Nova Bold': {
        fallbackFamilies: ['Proxima Nova'],
        // We actually need to set the font weight, beacuse we can't just
        // fall back to vanilla Proxima Nova and expect to get a bold
        // face. Similarly for others below.
        sets: { 'font-weight': 'bold' },
      },
      'Proxima Nova Italic': {
        fallbackFamilies: ['Proxima Nova'],
        sets: { 'font-style': 'italic' },
      },
      'Proxima Nova Bold It': {
        fallbackFamilies: ['Proxima Nova'],
        sets: {
          'font-weight': 'bold',
          'font-style': 'italic',
        },
      },

      'ReportSchoolRg-Bold': {
        fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
        sets: { 'font-weight': 'bold' },
      },
      'ReportSchoolRg-Italic': {
        fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
        sets: { 'font-style': 'italic' },
      },
      'ReportSchoolRg-BoldItalic': {
        fallbackFamilies: ['Report School Rg', 'ReportSchoolRg-Regular'],
        sets: {
          'font-weight': 'bold',
          'font-style': 'italic',
        },
      },

      'Report School Rg': {
        fallbackFamilies: ['ReportSchoolRg-Regular'],
      },
      'ReportSchoolRg-Regular': {
        fallbackFamilies: ['Report School Rg'],
      },

      /*
       * Mac GSP exports this as "SRA Sans 1.0 Book", while Win GSP
       * exports as "SRA Sans 1.0." However, browsers on BOTH platforms
       * natively expect "SRA Sans 1.0."
       */
      'SRA Sans 1.0 Book': {
        fallbackFamilies: ['SRA Sans 1.0'],
      },

      'SRA Sans 1.0 Bold': {
        fallbackFamilies: ['SRA Sans 1.0'],

        sets: { 'font-weight': 'bold' },
      },

      'SRA Sans 1.0 Italic': {
        fallbackFamilies: ['SRA Sans 1.0'],

        sets: { 'font-style': 'italic' },
      },

      'SRA Sans 1.0 Bold Italic': {
        fallbackFamilies: ['SRA Sans 1.0'],

        sets: {
          'font-weight': 'bold',
          'font-style': 'italic',
        },
      },

      /*
       * Mac GSP exports this as "SRA Sans 3.0 Book", while Win GSP
       * exports as "SRA Sans 3.0." However, browsers on BOTH platforms
       * natively expect "SRA Sans 3.0."
       */
      'SRA Sans 3.0 Book': {
        fallbackFamilies: ['SRA Sans 3.0'],
      },

      'SRA Sans 3.0 Bold': {
        fallbackFamilies: ['SRA Sans 3.0'],

        sets: { 'font-weight': 'bold' },
      },

      'SRA Sans 3.0 Italic': {
        fallbackFamilies: ['SRA Sans 3.0'],

        sets: { 'font-style': 'italic' },
      },

      'SRA Sans 3.0 Bold Italic': {
        fallbackFamilies: ['SRA Sans 3.0'],

        sets: {
          'font-weight': 'bold',
          'font-style': 'italic',
        },
      },

      'MHEelemsans Regular': {
        fallbackFamilies: ['MHEelemsans'],
      },

      'MHEelemsans Bold': {
        fallbackFamilies: ['MHEelemsans'],
        sets: {
          'font-weight': 'bold',
        },
      },

      'MHEelemsans Italic': {
        fallbackFamilies: ['MHEelemsans'],
        sets: {
          'font-style': 'italic',
        },
      },

      'MHEelemsans Bold Italic': {
        fallbackFamilies: ['MHEelemsans'],
        sets: {
          'font-weight': 'bold',
          'font-style': 'italic',
        },
      },

      'UniMath2 A': {
        fallbackFamilies: ['UniMath2-Regular', 'UniMath2'],
      },

      'UniMath2-Regular': {
        fallbackFamilies: ['UniMath2 A', 'UniMath2'],
      },

      'UniMath2-BoldItalic': {
        fallbackFamilies: ['UniMath2 A', 'UniMath2'],
        sets: {
          'font-style': 'italic',
          'font-weight': 'bold',
        },
      },

      'UniMath2-Italic': {
        fallbackFamilies: ['UniMath2 A', 'UniMath2'],
        sets: {
          'font-style': 'italic',
        },
      },

      'UniMath2-Bold': {
        fallbackFamilies: ['UniMath2 A', 'UniMath2'],
        sets: {
          'font-weight': 'bold',
        },
      },

      'UniMath2 B': {
        fallbackFamilies: ['UniMath2-SemiBold', 'UniMath2'],
      },

      'UniMath2-SemiBold': {
        fallbackFamilies: ['UniMath2 B', 'UniMath2'],
      },

      'UniMath2-SemiBoldItalic': {
        fallbackFamilies: ['UniMath2 B', 'UniMath2'],
        sets: {
          'font-style': 'italic',
        },
      },

      'UniMath2-ExtraBoldItalic': {
        fallbackFamilies: ['UniMath2 B', 'UniMath2'],
        sets: {
          'font-style': 'italic',
          'font-weight': 'bold',
        },
      },

      'UniMath2-ExtraBold': {
        fallbackFamilies: ['UniMath2 B', 'UniMath2'],
        sets: {
          'font-weight': 'bold',
        },
      },
    };

    $.extend(fontFallbackSpecs, GSP.getConfigValue('Fonts.fallbacks'));

    /*
     * Sets the right styles to aid cross-platform font rendering of
     * system fonts. Employs the fontFallbackSpecs table. May set the
     * following styles: font family, font weight, font style.
     *
     * @param {string} fontFamily. The initially given font family,
     * possibly not available cross platform.
     * @param {function(key, value)} setter: Knows how to set font
     * properties in the calling context.
     * @returns {undefined}
     */

    GSP.mfs.normalizeFont = function(fontFamily, setter) {
      var firstFamily = GSP.mfs.extractFirstFontFamily(fontFamily);
      var spec = fontFallbackSpecs[firstFamily];
      if (!spec) {
        return;
      }
      var fallbackFamilies = spec.fallbackFamilies,
        key,
        fam,
        quotedFallbackFamilies = [];

      var sets = spec.sets;
      if (sets) {
        for (key in sets) {
          if (sets.hasOwnProperty(key)) {
            setter(key, sets[key]);
          }
        }
      }

      // Interpolate the fallback family into comma-separated list.
      var all = fontFamily.split(',');

      /*
       * "To avoid mistakes in escaping, it is recommended to quote font
       * family names that contain white space, digits, or punctuation
       * characters other than hyphens."
       *
       * http://stackoverflow.com/questions/7638775/do-i-need-to-wrap-quotes-around-font-family-names-in-css
       */
      for (var i = 0; i < fallbackFamilies.length; i++) {
        fam = fallbackFamilies[i];
        fam = fam.match(/\s|\d|[?:;!@#$%^&*()<>/+{}]/) ? '"' + fam + '"' : fam;
        quotedFallbackFamilies.push(fam);
      }
      all.splice(1, 0, quotedFallbackFamilies.join(','));
      setter('font-family', all.join(','));
    };

    // The following array specifies how to create and style overbars of
    // different types.  Indexed by overbar type, it contains objects
    // specifying 1) The css class of the element containing a specific
    // type of overbar 2) An SVG code template, parameterized by color,
    // for drawing a specific type of overbar. 3 (Added below)) An SVG
    // Factory: a function which takes a color as a string and returns a
    // "data:image" url encoding an svg element of that color.

    var overbarSpecs = [
      // 0: unused
      { type: '', cssClass: '', template: '' },
      // 1: unused
      { type: '', cssClass: '', template: '' },

      // 2: line segment
      {
        type: 'segment',
        cssClass: 'mfs-overbar-seg',
        template:
          '<svg version="1.1" viewBox="0 0 128 50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">' +
          '<path d="M 0 7 ' +
          'L 128 7 " ' +
          'stroke="@@color@@" fill="@@color@@" stroke-width="3"/>' +
          '</svg>',
      },

      // 3: ray
      {
        type: 'ray',
        cssClass: 'mfs-overbar-ray',
        template:
          '<svg version="1.1" viewBox="0 0 128 40" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">' +
          '<path d="M 7 20 ' +
          'l 114 0' +
          'M 121 20' +
          'l -21 -20' +
          'L 121 20' +
          'l -21 20' +
          '" ' +
          'stroke="@@color@@" fill="none" stroke-width="10"/>' +
          '</svg>',
      },

      // 4: line
      {
        type: 'line',
        cssClass: 'mfs-overbar-line',
        template:
          '<svg version="1.1" viewBox="0 0 128 40" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">' +
          '<path d="M 7 20 ' +
          'l 21 -20 ' +
          'L 7 20 ' +
          'l 21 20 ' +
          'M 7 20 ' +
          'l 114 0' +
          'M 121 20' +
          'l -21 -20' +
          'L 121 20' +
          'l -21 20' +
          '" ' +
          'stroke="@@color@@" fill="none" stroke-width="8"/>' +
          '</svg>',
      },

      // 5: arc
      {
        type: 'arc',
        cssClass: 'mfs-overbar-arc',
        template:
          '<svg version="1.1" viewBox="0 0 128 50" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">' +
          '<path d="M 12 50 ' +
          'Q 70 0 128 50 ' +
          'M 128 50 ' +
          'Q 70 9 12 50 " ' +
          'stroke="@@color@@" fill="@@color@@" stroke-width="1"/>' +
          '</svg>',
      },
    ];

    // Accessor for overbar creation
    // Finds the spec given an index, or a type (String)
    function getOverbarSpec(overbar) {
      if (typeof overbar === 'number') {
        return overbarSpecs[overbar];
      }

      var i;
      for (i = 0; i < overbarSpecs.length; i++) {
        if (overbar === overbarSpecs[i].type) {
          return overbarSpecs[i];
        }
      }
      return null;
    }

    GSP.mfs.createOverbarDOM = function(overbarType, color) {
      var overbarSpec = getOverbarSpec(overbarType),
        newEl;
      newEl = $('<div>');
      newEl.addClass('mfs-overbar');
      if (overbarSpec.cssClass) {
        newEl.addClass(overbarSpec.cssClass);
      }
      if (overbarSpec.factory) {
        newEl.css('background-image', overbarSpec.factory(color));
      }
      return newEl;
    };

    GSP.mfs.getNodeText = function(node) {
      var s = node.value,
        kNBSP = '\xA0';
      // extract the symbol from symbol nodes
      if (node.type === 'symbol') return GSP.mfs.symMap[s.toUpperCase()] || 'x';
      // Replace trailing spaces with non-breaking spaces
      if (node.type === 'text' && s.match(/ $/))
        s = s.substring(0, s.length - 1) + kNBSP;
      return s;
    };

    GSP.mfs.isTextOrSymbolNode = function(node) {
      return node.type === 'text' || node.type === 'symbol';
    };

    GSP.mfs.mergeTextEls = function(nodeArray) {
      var last,
        newArray = [];
      $.each(nodeArray, function(ix, node) {
        if (
          last &&
          GSP.mfs.isTextOrSymbolNode(last) &&
          GSP.mfs.isTextOrSymbolNode(node)
        ) {
          // combine text and symbol nodes into text nodes
          last.value += GSP.mfs.getNodeText(node);
        } else {
          if (node.type === 'symbol') {
            // convert symbol nodes to text node
            node.value = GSP.mfs.getNodeText(node);
            node.type = 'text';
          }
          newArray.push(node);
          last = node;
        }
      });
      return newArray;
    };

    /**
     * Appends to the provided html element, 'el', an appropriately styled
     * rendering of the parse tree provided by 'node'. The font table, 'fontTable',
     * is used to resolve font references.
     */
    GSP.mfs.makeHTMLFromMFSParseTree = (function() {
      /**
       * Creates an SVG Factory.
       *
       * Given an SVG Code template, returns a function taking a color
       * string, and returning an encoded image of that color.
       *
       */
      function makeSVGFactory(template) {
        return function(color) {
          var base64 = GSP.btoa(template.replace(/@@color@@/g, color));
          return 'url("data:image/svg+xml;base64,' + base64 + '")';
        };
      }

      // Build SVG factories.
      for (var i = 0; i < overbarSpecs.length; i++) {
        var template = overbarSpecs[i].template;
        overbarSpecs[i].factory = template ? makeSVGFactory(template) : null;
      }

      // Creates an SVG template given the steps of a path to draw.
      function makeSVGTemplate(width, height, steps) {
        var stepStr = '',
          label,
          step,
          nums;

        for (var i = 0; i < steps.length; i++) {
          step = steps[i];
          label = step[0];
          nums = step[1];
          stepStr += label + ' ';
          for (var j = 0; j < nums.length; j++) {
            stepStr += Math.round(nums[j] * 10) / 10 + ' ';
          }
        }
        var code =
          '<svg version="1.1" viewBox="0 0 ' +
          width +
          ' ' +
          height +
          '" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">' +
          '<path d="' +
          stepStr +
          '" stroke="@@color@@" fill="@@color@@" stroke-width="1"/>' +
          '</svg>';
        return code;
      }

      // Parens are drawn using SVG too, so we'll need an svg code template
      // and an SVG Factory for left parens, as well as right parens.

      var parenSVGFactories = (function() {
        var width = 40,
          height = 70;

        var bottom = height * 0.9;
        var top = height - bottom;
        var midY = top + (bottom - top) / 2;

        // Control points for drawing the near and far edges of the parenthesis.
        // These are in the x dimension and near or far relative to startX.
        var farFactor = 0.5;
        var nearFactor = 0.2;

        var parenWidth = width * 0.17;

        // Returns an SVG template for drawing a right paren.
        function makeRightTemplate() {
          var startX = 0;
          var jogRight = startX + parenWidth;
          var nearRight = width * (1 + nearFactor);
          var farRight = width * (1 + farFactor);

          return makeSVGTemplate(width, height, [
            ['M', [startX, top]],
            ['L', [jogRight, top]],
            // Draw the far edge.
            ['Q', [farRight, midY, jogRight, bottom]],
            ['M', [jogRight, bottom]],
            ['L', [startX, bottom]],
            // Draw the near edge.
            ['Q', [nearRight, midY, startX, top]],
          ]);
        }

        // Returns an SVG template for drawing a left paren.
        function makeLeftTemplate() {
          var startX = width;
          var jogLeft = startX - parenWidth;
          var nearLeft = -(width * nearFactor);
          var farLeft = -(width * farFactor);

          return makeSVGTemplate(width, height, [
            ['M', [startX, top]],
            ['L', [jogLeft, top]],
            // Draw the far edge.
            ['Q', [farLeft, midY, jogLeft, bottom]],
            ['M', [jogLeft, bottom]],
            ['L', [startX, bottom]],
            // Draw the near edge.
            ['Q', [nearLeft, midY, startX, top]],
          ]);
        }

        return {
          left: makeSVGFactory(makeLeftTemplate()),
          right: makeSVGFactory(makeRightTemplate()),
        };
      })();

      var rootSVGFactories = (function() {
        var width = 40,
          height = 70;

        function makeRightTemplate() {
          var startX = 0,
            top = 0;
          var right = width,
            bottom = height * 0.03;

          return makeSVGTemplate(width, height, [
            ['M', [startX, top]],
            ['L', [right, top]],
            ['L', [right, bottom]],
            ['L', [startX, bottom]],
            ['L', [startX, top]],
          ]);
        }

        function makeLeftTemplate() {
          var left = 0;
          var lineThicknessY = height * 0.06;
          var lineThicknessX = width * 0.05;
          var middleY = height * 0.55;
          var belowMiddleY = middleY + lineThicknessY / 3;
          var rightOfLeft = width * 0.25;
          var leftOfRight = rightOfLeft + width * 0.2;
          var bottom = height * 0.87;
          var right = width - lineThicknessX * 3;
          var farRight = width;
          var top = 0;
          var belowTop = top + lineThicknessY / 2;
          var belowBottom = bottom + lineThicknessY;

          return makeSVGTemplate(width, height, [
            ['M', [left, middleY]],
            ['L', [rightOfLeft, middleY]],
            ['L', [leftOfRight, bottom]],
            ['L', [right, top]],
            ['L', [farRight, top]],
            ['L', [farRight, belowTop]],
            ['L', [right + lineThicknessX / 2, belowTop]],
            ['L', [leftOfRight, belowBottom]],
            ['L', [rightOfLeft - lineThicknessX, belowMiddleY]],
            ['L', [left, belowMiddleY]],
            ['L', [left, middleY]],
          ]);
        }

        return {
          left: makeSVGFactory(makeLeftTemplate()),
          right: makeSVGFactory(makeRightTemplate()),
        };
      })();

      var absoluteValueSVGFactory = (function() {
        var width = 20,
          height = 70;

        function makeTemplate() {
          var startX = 8,
            top = 4;
          var right = 12,
            bottom = height - 4;

          return makeSVGTemplate(width, height, [
            ['M', [startX, top]],
            ['L', [right, top]],
            ['L', [right, bottom]],
            ['L', [startX, bottom]],
            ['L', [startX, top]],
          ]);
        }

        return makeSVGFactory(makeTemplate());
      })();

      return function(node, el, fontTable, baseCSS) {
        var replaceableParameterMap = {}, // maps names to html elements,
          // the contents of which are replaceable.
          visitMap = {},
          styleList = [];

        $.each(baseCSS, function(key, value) {
          if (key !== 'font-size' && key !== 'fontSize') {
            pushStyle(key, value);
          }
        });

        function pushMarker() {
          styleList.push({ type: 'marker' });
        }
        function pushStyle(name, value) {
          styleList.push({ type: 'style', name: name, value: value });
        }
        //    function pushClass(name) {
        //        styleList.push({type: 'class', name: name});
        //    }
        function popMarker() {
          var item = styleList.pop();
          while (item.type !== 'marker') {
            item = styleList.pop();
          }
        }
        /* returns a style object from the current styleList */
        function assembleStyles(el) {
          var styles = {};
          $.each(styleList, function(k, v) {
            if (v.type === 'style') {
              styles[v.name] = v.value;
            }
          });
          var lineHeight = GSP.mfs.getLineHeight(
            styles.fontFamily || el.css('font-family'),
            styles.fontSize || el.css('font-size')
          );
          if (lineHeight) {
            styles.lineHeight = lineHeight;
          }
          return styles;
        }
        function assembleClasses() {
          var classes = [];
          $.each(styleList, function(k, v) {
            if (v.type === 'class') {
              classes.push(v.name);
            }
          });
          return classes.join(' ');
        }
        /*
         * Appends a new child to the given html node and returns the a jquery
         * link to the new child.
         */
        function appendEl(el, inner) {
          el.append(inner);
          var newEl = el[0].lastChild;
          return $(newEl);
        }

        function visit(node, el) {
          var newEl, fn;
          fn = visitMap[node.type];
          if (fn) {
            newEl = fn(node, el);
            return newEl;
          } else {
            GSP.signalErrorWithMessage(
              'GSP.mfs.makeHTMLFromMFSParseTree: ' +
                'No handler for node:' +
                node.type
            );
            return el;
          }
        }

        /*
         * Replace special characters with HTML escape codes. See
         * http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html and
         * https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet
         * #RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
         * for details.
         */
        function htmlEscape(str) {
          return String(str)
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\//g, '&#47;');
        }

        function appendText(el, iText) {
          var styles = assembleStyles(el),
            classes = assembleClasses();

          // Add an mfs-text-{font-style} class, for any needed css tweaking.
          if (styles['font-style']) {
            classes += ' mfs-text-' + styles['font-style'];
          }
          return (
            appendEl(el, '<div class="mfs-text"/>')
              .css(styles)
              .addClass(classes)
              // HTML escaping should happen last
              .append(htmlEscape(iText))
          );
        }

        function aggregator(el, node) {
          var ix;
          if (node.value.length > 0) {
            node.value = GSP.mfs.mergeTextEls(node.value);
          }
          for (ix = 0; ix < node.value.length; ix += 1) {
            visit(node.value[ix], el);
          }
        }
        function createAggregateElement(className, node, el) {
          var newEl = appendEl(el, '<div class="' + className + '"></div>');
          aggregator(newEl, node);
          return newEl;
        }
        function getColor(el) {
          return assembleStyles(el).color || el.css('color') || 'black';
        }

        /*
       * Creation of HTML table elements for rendering Parens, Absolute
       * Values, and Square roots.
       *
       * @param {Object} node - the node to render
       * @param {Object} el - the jquery elt we are rendering into
       * @param {Object} properties - an object specifying how to render
       * the table (which has one row with a left td, an optional middle
       * td, and an optional right td) as html/css/SVG. Here is an
       * example "properties" object for square roots:
  
         { tableClass: 'mfs-root',
           leftClass: 'mfs-left-root',
           leftSVGFactory: rootSVGFactories.left,
           middleClass: 'mfs-right-root',
           middleSVGFactory: rootSVGFactories.right }
  
      */
        function addSVGTable(node, el, properties) {
          var leftHTML = GSP.Strings.format('<td class="%@"></td>', [
              properties.leftClass,
            ]),
            // Dummy span to fix chrome issue; see comment in wsp.css
            left = $(leftHTML).append('<span></span>'),
            tableHTML = GSP.Strings.format(
              '<table class="%@"><tbody><tr><td></td></tr></tbody></table>',
              [properties.tableClass]
            ),
            table = appendEl(el, $(tableHTML)),
            tr = $('>tbody >tr', table),
            middle = $('>tbody >tr >td', table),
            right;

          if (properties.middleClass) {
            middle.addClass(properties.middleClass);
          }

          // Note: The middle element is now in the DOM.
          aggregator(middle, node);

          // Make sure we get a color. If the style node doesn't
          // specify, check the element.
          var color = getColor(el);

          left.css('background-image', properties.leftSVGFactory(color));
          tr.prepend(left);

          if (properties.middleClass) {
            middle.css('background-image', properties.middleSVGFactory(color));
          }

          if (properties.rightClass) {
            right = $(
              GSP.Strings.format('<td class="%@"></td>', [
                properties.rightClass,
              ])
            ).append('<span></span>');
            right.css('background-image', properties.rightSVGFactory(color));
            tr.append(right);
          }
          return table;
        }

        visitMap.abs = function(node, el) {
          return addSVGTable(node, el, {
            tableClass: 'mfs-abs',
            leftClass: 'mfs-abs-bar',
            rightClass: 'mfs-abs-bar',
            leftSVGFactory: absoluteValueSVGFactory,
            rightSVGFactory: absoluteValueSVGFactory,
          });
        };
        visitMap.bracket = function(node, el) {
          return createAggregateElement('mfs-bracket', node, el);
        };
        visitMap.curly = function(node, el) {
          return createAggregateElement('mfs-curly', node, el);
        };
        visitMap.fraction = function(node, el) {
          var newEl = appendEl(el, '<div class="mfs-frac"/>'),
            numerator = visit(node.value[0], newEl);
          numerator.addClass('mfs-numr mfs-responsive-borderwidth');
          numerator.css(
            'border-bottom',
            GSP.Strings.format('thin %@ solid', [getColor(numerator)])
          );
          visit(node.value[1], newEl).addClass('mfs-denm');
          return newEl;
        };
        visitMap.horizontal = function(node, el) {
          if (node.value.length > 0) {
            node.value = GSP.mfs.mergeTextEls(node.value);
          }
          if (node.value.length === 1) {
            return visit(node.value[0], el);
          }
          return createAggregateElement('mfs-horizontal', node, el);
        };
        visitMap.input = function(node, el) {
          // I found that on iOS, the following combination of input propertie
          // caused the device to reliably display a numeric keyboard. The
          // keyboard could be changed to alpha keyboard in the usual way, and
          // the character string is not required to conform to the pattern.
          // -- jms, 1/2014.
          var newEl = $('<button tabindex="0"></button>').addClass(
              'mfs-input mfs-responsive-borderwidth'
            ),
            bucket;
          newEl.append('%' + node.value);
          el.append(newEl);
          bucket = replaceableParameterMap[node.value];
          if (!bucket) {
            bucket = [];
            replaceableParameterMap[node.value] = bucket;
          }
          bucket.push(newEl);
          var registerElementFunc = GSP.getConfigValue(
            'NumberpadManager.delegates.registerElement'
          );
          registerElementFunc(newEl);
          return newEl;
        };
        visitMap.parameter = function(node, el) {
          var newEl, bucket;
          newEl = appendEl(el, '<div class="mfs-param"></div>');
          newEl.css(assembleStyles(el));
          newEl.append('%' + node.value);
          bucket = replaceableParameterMap[node.value];
          if (!bucket) {
            bucket = [];
            replaceableParameterMap[node.value] = bucket;
          }
          bucket.push(newEl);
          return newEl;
        };
        visitMap.paren = function(node, el) {
          return addSVGTable(node, el, {
            tableClass: 'mfs-paren',
            leftClass: 'mfs-left-paren',
            rightClass: 'mfs-right-paren',
            leftSVGFactory: parenSVGFactories.left,
            rightSVGFactory: parenSVGFactories.right,
          });
        };
        visitMap.root = function(node, el) {
          return addSVGTable(node, el, {
            tableClass: 'mfs-root',
            leftClass: 'mfs-left-root',
            leftSVGFactory: rootSVGFactories.left,
            middleClass: 'mfs-right-root',
            middleSVGFactory: rootSVGFactories.right,
          });
        };
        visitMap.style = function(node, el) {
          var ix,
            newEl = el,
            r,
            g,
            b,
            ff,
            styles = {},
            nodes = [];

          for (ix = 0; ix < node.value.length; ix += 1) {
            if (node.value[ix].code) {
              styles[node.value[ix].code] = node.value[ix].value;
            } else if (node.value[ix].type) {
              nodes.push(node.value[ix]);
            }
          }
          pushMarker();
          if (styles.fontFamily) {
            if (fontTable) {
              ff = fontTable[parseInt(styles.fontFamily, 16)];

              // Tells normalizeFont how to set font styles.
              var setFontProperty = function(key, val) {
                switch (key) {
                  case 'font-family':
                    ff = val;
                    break;
                  case 'font-weight':
                    var weights = { normal: 1, bold: 2 };
                    styles.fontWeight = weights[val];
                    break;
                  case 'font-style':
                    var fstyles = { normal: 1, italic: 2 };
                    styles.fontStyle = fstyles[val];
                    break;
                  default:
                    break;
                }
              };

              GSP.mfs.normalizeFont(ff, setFontProperty);

              if (ff) {
                pushStyle('font-family', ff);
              }
            }
          }
          if (Number(styles.fontWeight) === 1) {
            pushStyle('font-weight', 'normal');
          }
          if (Number(styles.fontWeight) === 2) {
            pushStyle('font-weight', 'bold');
          }
          if (Number(styles.fontStyle) === 1) {
            pushStyle('font-style', 'normal');
          }
          if (Number(styles.fontStyle) === 2) {
            pushStyle('font-style', 'italic');
          }
          if (styles.red || styles.green || styles.blue) {
            r = styles.red ? parseInt(styles.red, 16) - 1 : 0;
            g = styles.green ? parseInt(styles.green, 16) - 1 : 0;
            b = styles.blue ? parseInt(styles.blue, 16) - 1 : 0;
            pushStyle('color', 'rgb(' + r + ',' + g + ',' + b + ')');
          }
          if (Number(styles.underbar) === 1) {
            pushStyle('text-decoration', 'none');
          }
          if (Number(styles.underbar) === 2) {
            pushStyle('text-decoration', 'underline');
          }
          if (Number(styles.tightness) === 1) {
            pushStyle('letter-spacing', 'normal');
          }
          if (Number(styles.tightness) === 2) {
            pushStyle('letter-spacing', '-1px');
          }
          if (Number(styles.tightness) === 3) {
            pushStyle('letter-spacing', '1px');
          }

          if (nodes.length === 1) {
            newEl = visit(nodes[0], newEl);
            if (styles.fontSize) {
              newEl.css('fontSize', parseInt(styles.fontSize, 16) + 'px');
            }
          } else {
            throw GSP.createError('Malformed Style Node: Too many children');
          }
          popMarker();
          return newEl;
        };
        visitMap.sub = function(node, el) {
          var newEl = appendEl(el, '<div class="mfs-sub-group"/>');
          visit(node.value[0], newEl);
          visit(node.value[1], newEl).addClass('mfs-subscript');
          return newEl;
        };
        visitMap['super'] = function(node, el) {
          var newEl = appendEl(el, '<div class="mfs-super-group"/>');
          visit(node.value[0], newEl);
          visit(node.value[1], newEl).addClass('mfs-exponent');
          return newEl;
        };
        visitMap.symbol = function(node, el) {
          return appendText(el, GSP.mfs.getNodeText(node));
        };
        visitMap['switch'] = function(node, el) {
          var oneBasedNodeIndex = node.visibleNode;

          //if 0 or undefined, the node has no visible representation
          if (oneBasedNodeIndex && oneBasedNodeIndex > 0) {
            return visit(node.value[oneBasedNodeIndex - 1], el);
          }
        };
        visitMap.text = function(node, el) {
          return appendText(el, GSP.mfs.getNodeText(node));
        };
        visitMap.vertical = function(node, el) {
          var ix,
            groupEl,
            alignMap = { L: 'left', C: 'center', R: 'right' },
            alignment = node.alignment && alignMap[node.alignment],
            alignStyle = alignment
              ? 'style="text-align:' + alignment + ';"'
              : '';
          if (node.value.length > 1) {
            groupEl = appendEl(
              el,
              '<div class="mfs-vertical-group" ' + alignStyle + '/>'
            );
            for (ix = 0; ix < node.value.length; ix += 1) {
              if (node.value[ix].type !== 'future') {
                // If the text of the line is empty, insert a '<br>' tag instead,
                // because browsers ignore empty text nodes.
                if (GSP.mfs.isEmptyTextMFS(node.value[ix])) {
                  appendEl(groupEl, '<br />');
                } else {
                  visit(node.value[ix], groupEl);
                }
              }
            }
            return groupEl;
          } else {
            return visit(node.value[0], el);
          }
        };
        visitMap.future = function(node, el) {
          return el;
        };
        visitMap.overbar = function(node, el) {
          var color = getColor(el);

          var newEl = appendEl(
            el,
            GSP.mfs.createOverbarDOM(Number(node.variant), color)
          );
          visit(node.value, newEl);
          return newEl;
        };
        visit(node, el);
        return replaceableParameterMap;
      };
    })();

    GSP.mfs.makeMFSFromMFSParseTree = function(node) {
      var visitMap = {};

      function visit(node) {
        var fn;
        fn = visitMap[node.type];
        if (fn) {
          return fn(node);
        } else {
          GSP.signalErrorWithMessage(
            'GSP.mfs.makeMFSFromMFSParseTree: ' +
              'No handler for node:' +
              node.type
          );
          return '';
        }
      }

      function concatNodes(nodes) {
        var i,
          count = nodes.length,
          ret = '';

        for (i = 0; i < count; i++) {
          ret += visit(nodes[i]);
        }

        return ret;
      }

      visitMap.future = function(node) {};

      visitMap.abs = function(node) {
        return '<|' + visit(node.value[0]) + '>';
      };
      visitMap.bracket = function(node) {
        return '<[' + visit(node.value[0]) + '>';
      };
      visitMap.curly = function(node) {
        return '<{' + visit(node.value[0]) + '>';
      };
      visitMap.fraction = function(node) {
        return '</' + visit(node.value[0]) + visit(node.value[1]) + '>';
      };
      visitMap.horizontal = function(node) {
        return '<H' + concatNodes(node.value) + '>';
      };
      //    visitMap.input = function(node) {
      //    };
      visitMap.parameter = function(node) {
        return '<%' + node.value + '>';
      };
      visitMap.paren = function(node) {
        return '<(' + visit(node.value[0]) + '>';
      };
      visitMap.root = function(node) {
        return '<R' + visit(node.value[0]) + '>';
      };
      visitMap.style = function(node) {
        var styleString = '',
          curSpec,
          //Keep in sync with codeMap in mfs.pegjs
          keyToCodeMap = {
            green: 'G',
            blue: 'L',
            fontFamily: 'P',
            red: 'R',
            fontStyle: 'S',
            tightness: 'T',
            underbar: 'U',
            fontWeight: 'W',
            fontSize: '#',
            'diminish-size': '+',
          };

        //Iterate up to n-1 items in the value array
        //Last item in the array is the actual node to style
        for (var i = 0, length = node.value.length - 1; i < length; ++i) {
          curSpec = node.value[i];
          styleString += keyToCodeMap[curSpec.code];
          styleString += curSpec.value;
        }

        //..Then output the style plus the contents of the n-1 node
        return (
          '<S' + styleString + visit(node.value[node.value.length - 1]) + '>'
        );
      };
      visitMap.sub = function(node) {
        return '<-' + visit(node.value[0]) + visit(node.value[1]) + '>';
      };
      visitMap['super'] = function(node) {
        return '<+' + visit(node.value[0]) + visit(node.value[1]) + '>';
      };
      visitMap.symbol = function(node) {
        return '<!' + node.value + '>';
      };
      visitMap['switch'] = function(node) {
        var visibleNodeString = node.visibleNode
          ? node.visibleNode.toString(16)
          : '';

        return (
          '<?' +
          visibleNodeString +
          (node.refCon ? 'x' + node.refCon : '') +
          concatNodes(node.value) +
          '>'
        );
      };
      visitMap.text = function(node) {
        //escape any \ chars and then escape any ' chars
        return (
          "<T'" + node.value.replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "'>"
        );
      };
      visitMap.vertical = function(node) {
        var alignment = node.alignment ? node.alignment : '';
        return '<V' + alignment + concatNodes(node.value) + '>';
      };
      visitMap.future = function(node) {
        return '<F' + node.value + '>';
      };

      visitMap.overbar = function(node, el) {
        return '<O' + node.variant + visit(node.value) + '>';
      };

      return visit(node);
    };

    GSP.mfs.makeSpeakableTextFromMFSParseTree = function(node) {
      if (!node) return '';

      var visitMap = {};

      function visit(node) {
        var fn;
        fn = visitMap[node.type];
        if (fn) {
          return fn(node);
        } else {
          GSP.signalErrorWithMessage(
            'GSP.mfs.makeSpeakableTextFromMFSParseTree: ' +
              'No handler for node:' +
              node.type
          );
          return '';
        }
      }

      function concatNodesWithOptionalWordBreaks(nodes, addBreaksBetween) {
        var i,
          count = nodes.length,
          ret = '';
        var addSpace = false;

        for (i = 0; i < count; i++) {
          if (addSpace) ret += ' ';
          else addSpace = addBreaksBetween;
          ret += visit(nodes[i]);
        }

        return ret;
      }

      function isVocallySelfParenthesized(node) {
        // Returns T if the node is any of our vocally self-parenthesizing types; in which
        // case it does not need to be surrounded by extra parentheses when appearing as
        // a potentially rich child of some other vocalizable layout

        switch (node.type) {
          case 'paren':
          case 'curly':
          case 'bracket':
          case 'root':
          case 'abs':
            return true;
          case 'switch': {
            var oneBasedNodeIndex = node.visibleNode;
            return oneBasedNodeIndex > 0
              ? isVocallySelfParenthesized(node.value[oneBasedNodeIndex - 1])
              : false;
          }
          case 'style':
            return isVocallySelfParenthesized(
              node.value[node.value.length - 1]
            );

          default:
          // fall out
        }

        return false;
      }

      function isVocallyAtomic(aString) {
        // Returns T for "single speechable terms" of atomic mathematical priority;
        // i.e. things that cannot be confused under any circumstances for operations.

        if (!isNaN(aString)) return true; // numbers are atomic
        if (1 === aString.length)
          // single characters of any form are atomic
          return true;

        // Parameters that expand to numbers do not need parenthesization. //
        if (
          '<%cX>' === aString ||
          '<%cY>' === aString ||
          '<%rX>' === aString ||
          '<%rY>' === aString
        ) {
          return true;
        }

        // but everything else is considered possibly non-atomic; e.g. 2π is not
        // atomic, and even though "hi" sounds like a single symbol, "ab" could
        // be the product of a*b.

        return false;
      }

      function vocallyParenthesizeIfNecessary(node) {
        // Returns node's string, possibly bracketed in "the quantity ... end quantity"
        // if the node's string is not an atomic element (a number or single character)
        // or does not contain self-parenthesizing language already.

        var speakableNode = visit(node);
        if (
          isVocallyAtomic(speakableNode) ||
          isVocallySelfParenthesized(node)
        ) {
          return speakableNode;
        } else {
          return 'the quantity ' + speakableNode + ' end quantity';
        }
      }

      var coordinatePairFinder = new RegExp(
        '^\\s*([-−–0-9.]+)\\s*,\\s*([-−–0-9.]+\\s*(?:°|radians)?)\\s*$'
      );
      // (N.B. The "-−–" pattern appearing twice in this RegExp is: ASCII DASH, UNICODE MINUS, UNICODE EN-DASH.
      // The first is a negative sign coming out of sprintf(), which we don't expect in WSP but add for safety;
      // the second is the standard WSP negation symbol; and the third is the unary minus symbol coming from GSP5
      // exports of MFS that encodes negative numbers (e.g. static table rows pre-converted to MFS in json).

      // RegExp we hav
      // NJS2_5. Improve Coordinate Pairs. Without NJS2_5, coordinate
      // pairs such as "(3, 4)" are read as "the quantity three four end quantity"
      // since the comma is not explicitly vocalized. We try to improve
      // these to "coordinates three comma four" as a more conventional
      // speakable form. Subcases involve NJS2_5a, rectCoord measurements;
      // NJS2_5b, polarCoord measurements; and NJS2_5c, any sort of
      // coordinate pair appearing in a hot-text or plain-typed caption
      // within formal MFS "math parentheses" (rather than just within
      // plain-typed ASCII parentheses).

      // NJS2_5c. CoordinatePairFinder is a regular expression for detecting
      // coordinate pairs within a pair of parentheses. The expression
      // has the following logic:
      // 		Begin String + Optional Whitespace +
      //		Real# (in first capture group)
      //		whitespace + comma + whitespace
      //		2nd Real# which may have angle units (in 2nd capture group) +
      //		whitespace + end of string
      //
      //	This RegExp could be held as static or global across all
      //  makeSpeakableTextFromMFSParseTree if we ever need to optimize
      // performance evaluation of performing repeated regExp searches
      // on changing MFS test.

      visitMap.bracket = visitMap.curly = visitMap.paren = function(node) {
        var subQuantity = visit(node.value[0]);

        if (node.type === 'paren') {
          // NJS2_5a. Improve rectCoord parameters straight from measurementRectCoordinates
          if ('<%xValue>, <%yValue>' === subQuantity) {
            return 'coordinates <%xValue> comma <%yValue> ';
          }

          // NJS2_5b. Improve polarCoord parameters straight from measurementPolarCoordinates. We check only for left-hand matches
          // because polarCoordinates may come with a variety of instantiated
          // angle measurements.

          var leftPart = '<%rValue>, <%thetaValue>';
          if (subQuantity.startsWith(leftPart)) {
            return (
              'coordinates <%rValue> comma <%thetaValue> ' +
              subQuantity.substring(leftPart.length)
            );
          }

          // NJS2_5c. Improve non-symbolic coordinate parameters if they have coordinateSyntax (cf. CoordinatePairFinder above)
          var foundCoords = coordinatePairFinder.exec(subQuantity);
          if (foundCoords !== null) {
            return (
              'coordinates ' + foundCoords[1] + ' comma ' + foundCoords[2] + ' '
            );
          }

          // console.log("<"+subQuantity+"> not diagnosed as coordinate pair");

          // Otherwise: it's not a recognizable coordinate pair,
          //  fall through to default bracket/curly/paren vocalization
        }

        return 'the quantity ' + subQuantity + ' end quantity';
      };

      visitMap.root = function(node) {
        return (
          'the square root of ' + vocallyParenthesizeIfNecessary(node.value[0])
        );
      };

      visitMap.abs = function(node) {
        return (
          'the absolute value of ' +
          vocallyParenthesizeIfNecessary(node.value[0])
        );
      };

      visitMap.future = function(node) {
        return ''; // Future nodes should only exist in streams; they are unspeakable if encountered here
        // but we include the test case to avoid DEBUGLog failure on a missing test case (WSP3/IMHWSAR-41)
      };

      visitMap.fraction = function(node) {
        var numer = visit(node.value[0]);
        var denom = visit(node.value[1]);

        if (numer === '1') {
          // NJS2_6a. Improve fractions for simple common fractions with a "common name"

          if (denom === '2') return 'one half ';
          if (denom === '3') return 'one third ';
          if (denom === '4') return 'one quarter ';
        }

        // NJS2_6b. Improve fractions to reduce verbal parentheses ("the quantity ... end-quantity") where unnecessary

        return (
          vocallyParenthesizeIfNecessary(node.value[0]) +
          ' divided by ' +
          vocallyParenthesizeIfNecessary(node.value[1])
        );
      };

      visitMap.horizontal = function(node) {
        //  Horizontal nodes simply combine all of their children,
        //  without spaces, into a single "flattened" speakable string,
        //  with the exception of INLINE FUNCTION NOTATION, where we
        //  diagnose a math-parenthesized term (which we will call an "argument")
        //  horizontally following a non-whitespace string with no intermediate
        //  whitespace (which we will call a "functionName"). When we detect this,
        //  we produce a speakable phrase of the format
        //			functionName of argument
        //  or
        //			functionName of the quantity argument endQuantity
        //  depending on whether the argument appears to require parenthesization.
        //
        // Thus:
        //	 tan(x) => "tan of x"
        //	 tan(x+1) ==> "tan of the quantity x+1"
        // etc.

        var children = node.value;
        var i,
          count = children.length,
          ret = '';

        for (i = 0; i < count; i++) {
          var appendChild = true;

          if (i > 0 && children[i].type === 'paren' && ret.length > 0) {
            if (ret.charAt(ret.length - 1) !== ' ') {
              var argument = children[i].value[0];
              ret += ' of ' + vocallyParenthesizeIfNecessary(argument);
              appendChild = false;
            }
          }

          if (appendChild) ret += visit(children[i]);
        }

        return ret;
      };

      visitMap.vertical = function(node) {
        return concatNodesWithOptionalWordBreaks(node.value, true);
      };

      visitMap.parameter = function(node) {
        // GSP.signalErrorWithMessage("GSP.mfs.makeSpeakableTextFromMFSParseTree: Not expect uninstantiated parameters in speakables, unless WSP treatment is different from GSP's -- rnj 8-May-20 ");
        return '<%' + node.value + '>';
      };

      visitMap.input = function(node) {
        return '<%' + node.value + '>';
      };

      visitMap.style = function(node) {
        // node.value is an array of items which are all style attributes
        // except for the last one, which is the child-node to style.

        //..Then output the contents of the n-1 node, which is the "contents" to style
        return visit(node.value[node.value.length - 1]);
      };

      visitMap.sub = function(node) {
        return visit(node.value[0]) + ' sub ' + visit(node.value[1]);
      };

      visitMap['super'] = function(node) {
        var base = visit(node.value[0]);
        var exp = visit(node.value[1]);
        if ('2' === exp) {
          if ('cm' === base || ' cm' === base) return ' square centimeters ';
          // NJS2_3. Improve Square Unit Lengths
          else if ('in.' === base || ' in.' === base) return ' square inches ';
          // NJS2_3. Improve Square Unit Lengths
          else {
            // Even though in most expressions compound bases are already
            // self parenthesized, e.g. (1+2)^2, we must vocally parenthesize
            // them if necessary (which will of course skip self-parenthesized
            // bases unnecessary) to capture the case of function notations,
            // and distinguish f(x)^2 from f(x^2).  Only with added vocal
            // parenthesization of base can the first become "the quantity f of
            // x endquantity squared" rather than "f of x squared" (which is
            // how the second might vocalize).

            return vocallyParenthesizeIfNecessary(node.value[0]) + ' squared '; // NJS2_2. Improve Square and Cubed Terms.
          }
        } else if ('3' === exp) {
          if ('cm' === base || ' cm' === base) return ' cubed centimeters ';
          // NJS2_3. Improve Square Unit Lengths
          else if ('in.' === base || ' in.' === base) return ' cubed inches ';
          // NJS2_3. Improve Square Unit Lengths
          else {
            return vocallyParenthesizeIfNecessary(node.value[0]) + ' cubed '; // NJS2_3. Improve Square and Cubed Terms.
          }
        } else
          return (
            vocallyParenthesizeIfNecessary(node.value[0]) +
            ' raised to the power ' +
            vocallyParenthesizeIfNecessary(node.value[1])
          );
      };

      visitMap.symbol = function(node) {
        // For now, just return the Unicode symbol itself,
        // or a few possible surrogates if we encounter them as standalone "symbol nodes"
        if (node.value === 'B4') {
          return 'times'; // preferred to Unicode's "Dot Operator"
        }

        /*
            Removed 29-Jun-20. The Circle Operator can be entirely handled by NJS2_1 regex
            on assembled total expression; see NJS2_1 handler, later in this file.
            
         else if(node.value === "100")
          return 'circle ';	// NJS2_1. preferred to Unicode's "Circle Operator"
    */

        // Return Unicode equivalent or numeric value, which sure looks dumb but is better than nothing
        // cf. https://magicsw.jira.com/browse/IMHWSAR-148: MFS Vocalizes Theta symbol as "71"

        return GSP.mfs.symMap[node.value.toUpperCase()] || node.value;
      };

      visitMap.text = function(node) {
        var ret = node.value;
        var trimmed = ret.trim();
        //if(trimmed === '-') {
        // Nick 10-Jul-20. Prior to today, this code converted single dash + whitespaces
        // to minus signs, which in old code upgraded some ambiguous dashes in Linear and Quadratic
        // equations to proper minus. However, it didn't do that consistently (since HotText-quoted
        // versions of such equations reintegrated their MFS differently, meaning the dash was now
        // buried in a larger text node with other contents and therefore escaped this detection)
        // AND it does so at the cost of throwing out potentially meaningful spaces around the
        // dash (e.g. difference between "a - b"  and "ls  -a"), and could apply in MFS cases where
        // DASH was actually the right character (e.g. a labeled GObj named "dash", as quoted in
        // any measurement that sticks that label into its own text node). So we both fix the
        // DASH to MINUS translation earlier in the process -- in this case, MFS-generation improvements
        // in Linear and Quadratic Equation measurements -- and we also REMOVE this text-node translator.
        // BUT (and now to the point of things) we keep a console warning for the time being to help flush
        // any other POSITIVE cases that this now=removed converter used to detect; hopefully these
        // will be fixable upstream as well since blind-translation of dash-to-minus and trimming are
        // both inherently risky this far downstream.
        //console.log("FYI detecting a trimmed DASH we no longer speakably translate to unicode minus");

        // and then FALL THROUGH rather than execute old code:

        //  return '\u2201';	// convert LOW-ASCII DASH to UNICODE MINUS
        //} else
        if (trimmed === '⋅') {
          // Nick 10-Jul-20.  I'm not touching this similarly "old" code when fixing the above,
          // for lack of a known defect with it, but I suspect the conversion from dot-operator
          // to speakable times would be better done by regexp postprocessing of the generated whole speakable
          // output, rather than at the moment of text-node translation, for the same reason
          // as above: reintegration of MFS expressions e.g. in hot-text copying, can break down
          // the "standalone" integrity of text nodes originally generated in isolation. If a
          // defect around "failed dot-to-times conversion" ever surfaces, try fixing it by
          // removing this logic and instead adopting a post-gen approach like for ⊙->circle or △->
          // triangle conversion, below.

          return ' times ';
        } else {
          return ret;
        }
      };

      visitMap['switch'] = function(node) {
        // Speak only the one or none of the switch's various children which is currently
        // visible.
        var oneBasedNodeIndex = node.visibleNode;
        return oneBasedNodeIndex > 0
          ? visit(node.value[oneBasedNodeIndex - 1])
          : '';
      };

      visitMap.overbar = function(node) {
        var ret = '';

        switch (node.variant) {
          //	cf. mfs.js#overbarSpecs for possible values
          case 2:
            ret += 'Segment ';
            break;
          case 3:
            ret += 'Ray ';
            break;
          case 4:
            ret += 'Line ';
            break;
          case 5:
            ret += 'Arc ';
            break;
          default:
          // including 0 & 1, which are undefined: ignore
        }

        return ret + visit(node.value);
      };

      var speakableText = visit(node);

      // Apply improvements that may span multiple nodes
      // and therefore are best conducted in the "total text"
      // rather than during its node-by-node composition.

      speakableText = speakableText.replace(
        /\bm ?(Segment|Arc|∠|∠)/g,
        'measure of $1'
      );

      /* NSJ2_4.  Improve "m " Prefix in Measurements 
  
        We use a regular expression to expand "m " into "measure of "
        in cases where "m" starts a new word (\b) and where it is followed
        by "segment", "arc", or angle angle symbol (with or without space).
        
          There are many separate places where this prefix appears in the
          Original Name of a measurement or other default appearance:
            
        a. Segment Length Measurements
        b. Three-Point Angle Measurements
        c. Angle-Marker Measurements
        d. Arc Angle (3-Point Arc) Measurements
        e. Arc Angle (Arc on Circle By 2 Points) Measurements
        f. Arc Angle (Arc on Circle By 3 Points) Measurements
        g. Ratio of Segment Length Measurements
        h. All of the Above in ExpressionGObjs (Calculations or Functions)
        i. All of the Above when quoted as Hot Text in Captions
        j. All of the Above when handtyped as Styled Text in Captions
  
        N.B. J is potentially controversial as a vocalization improvement (since
        we are re-interpreting actual characters typed by a human author, rather
        than intrinsic mathematical meanings produced by Sketchpad itself); all the others are not. If we want to outlaw (j), we should restrict the fix to situations where we are dealing with an MeasurementGObj (a-g), an ExpressionGObj (h), or a Hot Text Fragment of a textGObj (i) rather than leave it unrestricted.
      */

      speakableText = speakableText.replace(/⊙/g, 'circle '); // NJS2_1. replace Unicode's "Circle Operator" char (promoted from MFS_Symbol #100 to plainText by earlier processing, e.g. mergeTextEls) with preferred pronunciation

      speakableText = speakableText.replace(/△/g, 'triangle '); // NJS2_IMHWSAR-131. replace Unicode's "Triangle" char with English pronunciation. Too bad: Voice Over gets this right, but NVDA apparently doesn't know what a triangle is

      speakableText = speakableText.replace(/→/g, 'toward '); // NJS2_IMHWSAR-180. replace Move button's "forward arrow" with an English pronunciation matching movement buttons. This is almost always better than "right arrow" or "right arrow operator" which is what screen readers like

      speakableText = speakableText.replace(/\u200B/g, ' '); // NJS2_IMHWSAR-168. replace Unicode's "Zero-Width Space" with a real since not all screen readers (e.g. VoiceOver's Neena) treat zero-width space as a word separator, despite its documented purpose!!
      // We would prefer to ONLY use zero-width space, so as not to visually corrupt the visual "spelling" of the screen-read equivalent that most screen readers display, but doing so with a space (or a dash) is better than widely misvocalizing them.
      // It is a toss up as to whether "Angle C A B" is a preferred visualization to Angle C-A-B, which all known screen readers also read as "C, A, B" rather than "Cab".

      speakableText = speakableText.replace(/>\s?in./g, '> inches'); // NJS22_IMHHSAR-249. Catch "<%value> inches" and
      speakableText = speakableText.replace(/(\d)\s?in./g, '$1 inches'); // NJS2_IMHWSAR-249. Replace "in." with
      // inches where it follows a digit. We are trying to catch common cases like "length AB = 2.3 in."
      // but avoid falling into traps like "I took it out and put it in." This RegExp will miss some
      // compound units, like "length AB^3 = 12.2 the quantity in. end quantity raised to the power 3",
      // but these are very rare in natural Sketchpad (no built-in measurements produce them). The
      // case of "square inches"---which result e.g. from area measurements--- is handled separately and
      // correctly (see handler in 'super' node for superscripts).

      return speakableText;
    };

    GSP.mfs.plurals = {
      Object: 'Objects',
      Text: 'Texts',
      Action: 'Actions',
      IterateMap: 'IterateMaps',
      ImportedObject: 'ImportedObjects',
      Table: 'Tables',
      OrnamentalMarker: 'OrnamentalMarkers',
      TransformableNonPath: 'TransformableNonPaths',
      Path: 'Paths',
      CoordSys: 'CoordSys',
      Envelope: 'Envelopes',
      IterateImage: 'IterateImages',
      CustomTransformedPictureImage: 'CustomTransformedPictureImages',
      Point: 'Points',
      Midpoint: 'Midpoints',
      OriginPoint: 'OriginPoints',
      Intersection: 'Intersections',
      PlottedPoint: 'PlottedPoints',
      CustomTransformedPointImage: 'CustomTransformedPointImages',
      AbstractTransformableGeometry: 'AbstractTransformableGeometrys',
      PointOnPath: 'PointOnPaths',
      UnitPoint: 'UnitPoints',
      TransformablePath: 'TransformablePaths',
      PointLocus: 'PointLoci',
      CustomTransformedPathImage: 'CustomTransformedPathImages',
      ParametricPlot: 'ParametricPlots',
      FunctionPlot: 'FunctionPlots',
      Straight: 'Straights',
      Curved: 'Curveds',
      Interior: 'Interiors',
      Line: 'Lines',
      Parallel: 'Parallels',
      Perpendicular: 'Perpendiculars',
      Ray: 'Rays',
      Bisector: 'Bisectors',
      Segment: 'Segments',
      AbstractSimplePath: 'AbstractSimplePaths',
      Circle: 'Circles',
      MetaArc: 'MetaArcs',
      Polygon: 'Polygons',
      Triangle: 'Triangles',
      Quadrilateral: 'Quadrilaterals',
      Pentagon: 'Pentagons',
      Hexagon: 'Hexagons',
      CircleInt: 'CircleInts',
      AbstractArea1: 'AbstractArea1s',
      Axis: 'Axis',
      AbstractRayOrSegment: 'AbstractRayOrSegments',
      AbstractDistance: 'AbstractDistances',
      AbstractPerimeter: 'AbstractPerimeters',
      AbstractCircle: 'AbstractCircles',
      Measure: 'Measures',
      Caption: 'Captions',
      MultiMeasure: 'MultiMeasures',
      UniMeasure: 'UniMeasures',
      CompositeText: 'CompositeTexts',
      Coordinate: 'Coordinates',
      Equation: 'Equations',
      AbstractCircleOrSimpleArc: 'AbstractCircleOrSimpleArcs',
      SimpleArc: 'SimpleArcs',
      ArcInterior: 'ArcInteriors',
      AbstractRadius: 'AbstractRadiuss',
      ArcSector: 'ArcSectors',
      ArcSegment: 'ArcSegments',
      AbstractArea2: 'AbstractArea2',
      DistanceMeasure: 'DistanceMeasures',
      AngleMeasure: 'AngleMeasures',
      AreaMeasure: 'AreaMeasures',
      ScalarMeasure: 'ScalarMeasures',
      LinearEquation: 'LinearEquations',
      QuadraticEquation: 'QuadraticEquations',
      Function: 'Functions',
      MetaDerivative: 'MetaDerivatives',
      ExactDerivative: 'ExactDerivatives',
      ApproximateDerivative: 'ApproximateDerivatives',
      DataFunction: 'DataFunctions',
      AbstractPlottedPath: 'AbstractPlottedPaths',
      DistanceParameter: 'DistanceParameters',
      AngleParameter: 'AngleParameters',
      ScalarParameter: 'ScalarParameters',
      ImportedPicture: 'ImportedPictures',
      Drawing: 'Drawings',
      AbstractTransformableGeometryAndPictures:
        'AbstractTransformableGeometryAndPictures',
      UserEditableTable: 'UserEditableTables',
      FixedEntryTable: 'FixedEntryTables',
      AngleMarker: 'AngleMarkers',
      PathMarker: 'PathMarkers',
      AbstractSimpleOrPlottedPath: 'AbstractSimpleOrPlottedPaths',
    };

    GSP.mfs.updatedGenus = {
      Object: 'Object',
      Text: 'Text',
      Action: 'Action',
      IterateMap: 'Iterate Map',
      ImportedObject: 'Imported Object',
      Table: 'Table',
      OrnamentalMarker: 'Ornamental Marker',
      TransformableNonPath: 'Transformable NonPath',
      Path: 'Path',
      CoordSys: 'Coordinate System',
      Envelope: 'Envelope',
      IterateImage: 'Iterate Image',
      CustomTransformedPictureImage: 'Custom Transformed Picture Image',
      Point: 'Point',
      Midpoint: 'Mid point',
      OriginPoint: 'Origin Point',
      Intersection: 'Inter section',
      PlottedPoint: 'Plotted Point',
      CustomTransformedPointImage: 'Custom Transformed Point Image',
      AbstractTransformableGeometry: 'Abstract Transformable Geometry',
      PointOnPath: 'Point On Path',
      UnitPoint: 'Unit Point',
      TransformablePath: 'Transformable Path',
      PointLocus: 'Point Locus',
      CustomTransformedPathImage: 'Custom Transformed Path Image',
      ParametricPlot: 'Parametric Plot',
      FunctionPlot: 'Function Plot',
      Straight: 'Straight',
      Curved: 'Curved',
      Interior: 'Interior',
      Line: 'Line',
      Parallel: 'Parallel',
      Perpendicular: 'Perpendicular',
      Ray: 'Ray',
      Bisector: 'Bisector',
      Segment: 'Segment',
      AbstractSimplePath: 'Abstract Simple Path',
      Circle: 'Circle',
      MetaArc: 'Meta Arc',
      Polygon: 'Polygon',
      Triangle: 'Triangle',
      Quadrilateral: 'Quadrilateral',
      Pentagon: 'Pentagon',
      Hexagon: 'Hexagon',
      CircleInt: 'Circle Interior',
      AbstractArea1: 'Abstract Area 1',
      Axis: 'Axis',
      AbstractRayOrSegment: 'Abstract Ray Or Segment',
      AbstractDistance: 'Abstract Distance',
      AbstractPerimeter: 'Abstract Perimeter',
      AbstractCircle: 'Abstract Circle',
      Measure: 'Measure',
      Caption: 'Caption',
      MultiMeasure: 'Multi Measure',
      UniMeasure: 'UniMeasure',
      CompositeText: 'Composite Text',
      Coordinate: 'Coordinate',
      Equation: 'Equation',
      AbstractCircleOrSimpleArc: 'Abstract Circle Or Simple Arc',
      SimpleArc: 'Simple Arc',
      ArcInterior: 'Arc Interior',
      AbstractRadius: 'Abstract Radius',
      ArcSector: 'Arc Sector',
      ArcSegment: 'Arc Segment',
      AbstractArea2: 'Abstract Area',
      DistanceMeasure: 'Distance Measure',
      AngleMeasure: 'Angle Measure',
      AreaMeasure: 'Area Measure',
      ScalarMeasure: 'Scalar Measure',
      LinearEquation: 'Linear Equation',
      QuadraticEquation: 'Quadratic Equation',
      Function: 'Function',
      MetaDerivative: 'Meta Derivative',
      ExactDerivative: 'Exact Derivative',
      ApproximateDerivative: 'Approximate Derivative',
      DataFunction: 'Data Function',
      AbstractPlottedPath: 'Abstract Plotted Path',
      DistanceParameter: 'Distance Parameter',
      AngleParameter: 'Angle Parameter',
      ScalarParameter: 'Scalar Parameter',
      ImportedPicture: 'Imported Picture',
      Drawing: 'Drawing',
      AbstractTransformableGeometryAndPictures:
        'Abstract Transformable Geometry And Picture',
      UserEditableTable: 'User Editable',
      FixedEntryTable: 'Fixed Entry',
      AngleMarker: 'Angle Marker',
      PathMarker: 'Path Marker',
      AbstractSimpleOrPlottedPath: 'Abstract Simple Or Plotted Path',
    };

    GSP.mfs.collectiveGeneraDescription = function(gobj, gobjList) {
      var gobjParentGenusList = {};
      var text = '';
      gobj.eachParent(function(index, parent) {
        if (parent.genus in gobjParentGenusList) {
          gobjParentGenusList[parent.genus] += 1;
        } else {
          gobjParentGenusList[parent.genus] = 1;
        }
      });

      for (var key in gobjParentGenusList) {
        if (gobjParentGenusList[key] > 1) {
          text += gobjParentGenusList[key] + ' ' + GSP.mfs.plurals[key] + ', ';
        } else {
          text += key + ', ';
        }
      }

      text = text.substring(0, text.length - 2);
      return text;
    };
  })();

  /*
   * Copyright © 2013 KCP Technologies, Inc.
   */
  /**
   * Utilities and standard symbols relating to units
   */
  GSP.units = {};

  GSP.units.unitFamilies = {
    length: {
      baseUnit: 'pixels',
    },
    angle: {
      baseUnit: 'radians',
    },
    scalar: {
      baseUnit: 'scalar',
    },
  };
  GSP.units.units = [
    {
      unitFamily: 'scalar',
      conversionFromBase: 1,
      pluralName: '',
      singularName: '',
      symbol: '',
    },
    {
      unitFamily: 'length',
      conversionFromBase: 1,
      pluralName: 'pixels',
      singularName: 'pixel',
      shortName: 'pix',
      digraph: 'px',
      symbol: ' pixels',
    },
    {
      unitFamily: 'length',
      conversionFromBase: 1 / 72,
      pluralName: 'inches',
      singularName: 'inch',
      shortName: 'in.',
      digraph: 'in',
      symbol: ' in.',
    },
    {
      unitFamily: 'length',
      conversionFromBase: 1 / (72 * 0.393700787401575),
      pluralName: 'centimeter',
      singularName: 'centimeter',
      shortName: 'cm',
      digraph: 'cm',
      symbol: ' cm',
    },
    {
      unitFamily: 'angle',
      conversionFromBase: 1,
      pluralName: 'radians',
      singularName: 'radian',
      shortName: 'rad',
      digraph: 'rd',
      symbol: ' radians',
    },
    {
      unitFamily: 'angle',
      conversionFromBase: 180 / Math.PI,
      pluralName: 'degrees',
      singularName: 'degree',
      shortName: 'deg',
      digraph: 'dg',
      symbol: '\u00B0',
    },
    {
      unitFamily: 'angle',
      conversionFromBase: 180 / Math.PI,
      pluralName: 'degrees',
      singularName: 'degree',
      shortName: 'signed deg',
      digraph: 'dg',
      symbol: '\u00B0',
    },
  ];

  /*
   * Makes a concordance map of unit symbols.
   * Desktop sketchpad uses many types of symbols for the same sets of units.
   * This makes them all findable.
   */
  GSP.units.makeUnitMap = function(units) {
    var ix,
      unit,
      unitMap = {};
    for (ix = 0; ix < units.length; ix += 1) {
      unit = units[ix];
      if (unit.pluralName !== undefined) {
        unitMap[unit.pluralName] = unit;
      }
      if (unit.singularName !== undefined) {
        unitMap[unit.singularName] = unit;
      }
      if (unit.shortName !== undefined) {
        unitMap[unit.shortName] = unit;
      }
      if (unit.digraph !== undefined) {
        unitMap[unit.digraph] = unit;
      }
      if (unit.symbol !== undefined) {
        unitMap[unit.symbol] = unit;
      }

      if (unit.unitFamily === 'scalar') {
        unitMap.scalar = unit;
      }
    }
    return unitMap;
  };
  GSP.units.unitMap = GSP.units.makeUnitMap(GSP.units.units);

  /*
   * Locates a unit definition by some name.
   */
  GSP.units.findUnit = function(name, nameType) {
    if (typeof name === 'undefined') {
      name = 'scalar';
    }
    return this.unitMap[name];
  };

  /*
   * Converts a value from one unit to another unit in the same unit
   * family.
   */
  GSP.units.convert = function(value, fromUnitName, toUnitName, power) {
    var fromUnit = this.findUnit(fromUnitName),
      toUnit = this.findUnit(toUnitName),
      unitFamily = fromUnit.unitFamily,
      baseValue;
    if (power === undefined) {
      power = 1;
    }
    if (!fromUnit) {
      GSP.signalErrorWithMessage(
        'GSP.units.convert: unknown fromUnit: ' + fromUnitName
      );
      return value;
    }
    if (!toUnit) {
      GSP.signalErrorWithMessage(
        'GSP.units.convert: unknown toUnit: ' + toUnitName
      );
      return value;
    }
    unitFamily = fromUnit.unitFamily;
    if (toUnit.unitFamily !== unitFamily) {
      GSP.signalErrorWithMessage(
        'GSP.units.convert: ' +
          "can't convert between unit families: " +
          fromUnitName +
          '/' +
          toUnitName
      );
      return value;
    }
    baseValue =
      fromUnit.pluralName === unitFamily.baseUnit
        ? value
        : value / Math.pow(fromUnit.conversionFromBase, power);
    return baseValue * Math.pow(toUnit.conversionFromBase, power);
  };

  /**
   * Iterates over each meaningful unit dimension in a given object that has unit
   * families as keys.  It can be used either with powersMap objects or unitObjects,
   * both of which match this criteria.  It skips scalar, and skips unit families
   * with a falsy value.  (But note: While powersMap objects will skip familes with
   * a power of 0, unitObjects are still likely to be called since each family key
   * points to an object of {unit, power})
   *
   * @param {type} powersMap - object specifying powers for each unit family
   * @param {type} func - user-supplied callback that takes 2 arguments (unitFamily, value)
   *               Return false to stop iteration.
   */
  GSP.units.eachUnitDimension = function(powersMap, func) {
    var key;

    for (key in powersMap) {
      if (
        powersMap.hasOwnProperty(key) &&
        powersMap[key] && //We don't want 0 powers, or any other falsy values
        key !== 'scalar'
      ) {
        if (false === func(key, powersMap[key])) {
          return;
        }
      }
    }
  };

  /**
   * Creates a single UnitsObject based on the given unitsMap and powersMap
   *
   * @param {Object} unitsMap - object specifying units for each unit family
   * @param {Object} powersMap - object specifying powers for each unit family
   * @returns {Object} single object containing both unit and power info for each unit family
   */
  GSP.units.makeUnitObjectFromUnitsAndPowers = function(unitsMap, powersMap) {
    var ret = {};

    GSP.units.eachUnitDimension(powersMap, function(family, power) {
      ret[family] = {
        unit: unitsMap[family],
        power: power,
      };
    });

    return ret;
  };

  /**
   * Converts a value from the base units (pix, rad) to the units specified in unitObject
   *
   * @param {Number} value
   * @param {Object} unitObject created by makeUnitObjectFromUnitsAndPowers
   * @returns {Number} converted value
   */
  GSP.units.convertFromBaseToUnitObject = function(value, unitObject) {
    var retValue = value;

    GSP.units.eachUnitDimension(unitObject, function(family, entry) {
      retValue = GSP.units.convertFromBaseValue(
        retValue,
        entry.unit,
        entry.power
      );
    });

    return retValue;
  };

  /**
   * Converts a value from the units specified in unitObject to the base units (pix, rad)
   *
   * @param {Number} value
   * @param {Object} unitObject created by makeUnitObjectFromUnitsAndPowers
   * @returns {Number} converted value
   */
  GSP.units.convertToBaseFromUnitObject = function(value, unitObject) {
    var retValue = value;

    GSP.units.eachUnitDimension(unitObject, function(family, entry) {
      retValue = GSP.units.convertToBaseValue(
        retValue,
        entry.unit,
        entry.power
      );
    });

    return retValue;
  };

  GSP.units.convertFromBaseValue = function(value, toUnitName, power) {
    var toUnit = this.findUnit(toUnitName),
      unitFamily;
    if (toUnit === undefined) {
      GSP.signalErrorWithMessage(
        'GSP.units.convert: unknown toUnit: ' + toUnitName
      );
      return value;
    }
    unitFamily = toUnit.unitFamily;
    return this.convert(
      value,
      this.unitFamilies[unitFamily].baseUnit,
      toUnitName,
      power
    );
  };

  GSP.units.convertToBaseValue = function(value, fromUnitName, power) {
    var fromUnit = this.findUnit(fromUnitName),
      unitFamily;
    if (fromUnit === undefined) {
      GSP.signalErrorWithMessage(
        'GSP.units.convert: unknown toUnit: ' + fromUnit
      );
      return value;
    }
    unitFamily = fromUnit.unitFamily;
    return this.convert(
      value,
      fromUnitName,
      this.unitFamilies[unitFamily].baseUnit,
      power
    );
  };

  /**
   * Generates an MFS Tree based on the givin unitsObject
   * Like desktop, we abort on any mixed unit value.
   *
   * @param {Object} unitsObject
   * @returns {String} MFS specifying the full unit expression
   */
  GSP.units.getMFSForUnitObject = function(unitsObject) {
    var retTree = null;

    GSP.units.eachUnitDimension(unitsObject, function(family, entry) {
      if (entry.power !== 0) {
        if (retTree) {
          //Here with mixed units - abort with no units
          //TODO - we should support some mixed units here!
          return null;
        } else if (entry.power === 1) {
          retTree = GSP.mfs.makeTextMFS(GSP.units.findUnit(entry.unit).symbol);
        } else {
          retTree = {
            type: 'super',
            value: [
              GSP.mfs.makeTextMFS(GSP.units.findUnit(entry.unit).symbol),
              GSP.mfs.makeTextMFS(entry.power),
            ],
          };
        }
      }
    });

    return retTree;
  };

  /*
   * Returns the unit family for a given unit. Unit families are: length,
   * angle, or scalar.
   */
  GSP.units.getUnitFamily = function(unitName) {
    var unit = this.findUnit(unitName);
    if (unit === undefined) {
      unit = this.findUnit('scalar');
    }
    return unit.unitFamily;
  };

  /*
   * Convert a value from a value to the document unit for the unit family.
   */
  GSP.units.convertToDocUnits = function(unitMap, value, currentUnit) {
    if (typeof currentUnit === 'undefined') {
      return value;
    }
    var unitObj = this.findUnit(currentUnit);
    var docUnit = unitMap[unitObj.unitFamily];
    return this.convert(value, currentUnit, docUnit, 1);
  };

  /*
   * Copyright © 2013 KCP Technologies, Inc.
   */
  /**
   * Utilities and standard symbols relating to units
   */
  GSP.math = {
    angleToRadians: function(unitName, value) {
      return GSP.units.convert(value, unitName, 'radians', 1);
    },
    sin: function(value, unitMap) {
      return Math.sin(this.angleToRadians(unitMap.angle, value));
    },
    cos: function(value, unitMap) {
      return Math.cos(this.angleToRadians(unitMap.angle, value));
    },
    tan: function(value, unitMap) {
      return Math.tan(this.angleToRadians(unitMap.angle, value));
    },
    asin: function(value, unitMap) {
      return GSP.units.convertToDocUnits(unitMap, Math.asin(value), 'radians');
    },
    acos: function(value, unitMap) {
      return GSP.units.convertToDocUnits(unitMap, Math.acos(value), 'radians');
    },
    atan: function(value, unitMap) {
      return GSP.units.convertToDocUnits(unitMap, Math.atan(value), 'radians');
    },
    abs: Math.abs,
    sqrt: Math.sqrt,
    ln: Math.log,
    log: function(value) {
      // Multiplying by 10 gives better stability for 0.1, 0.01, etc.
      // Note: At one time we were preferentially calling the proposed
      // Math.log10() if it were available, but Chrome's Math.log10()
      // handled these cases less well than our implementation (probably
      // because Math.log10(x) was simply returning Math.log(x)-Math.LOG10E),
      // and so we no longer test for or call Math.log10().
      return value >= 1
        ? Math.log(value) * Math.LOG10E
        : Math.log(10 * value) * Math.LOG10E - 1;
    },
    pow: function(base, exponent) {
      return base < 0
        ? GSP.math.powerOfNegativeBase(base, exponent)
        : Math.pow(base, exponent);
    },
    sign: function(value) {
      return value === value // isNaN()
        ? value === 0
          ? 0
          : value < 0
          ? -1
          : 1
        : NaN;
    },
    isDefined: function(value) {
      return isNaN(value) ? 0 : 1; // everything but a NaN is defined
    },
    round: Math.round,
    trunc: function(value) {
      return Math[value > 0 ? 'floor' : 'ceil'](value);
    },
    // A modulus function divendend % divisor
    // When both values are positive, this is just a remainer.
    // When negative values are involved, the question becomes vexed.
    // See http://en.wikipedia.org/wiki/Modulo_operation for the full story
    // We'll choose a convention where r = mod(a,n) means r is between 0 (inclusive)
    // and n (exclusive). I.e. r can be negative when n is negative
    mod: function(dividend, divisor) {
      return ((dividend % divisor) + divisor) % divisor;
    },

    /* 
        Returns the quantity iBase^iExpr, where iBase is assumed to be negative, if
        iExp appears to be the quotient of some odd fraction of relatively low-denominator
        (e. g. 1/3, 2/3, etc.), or NaN (or whatever Math.pow() returns) if no reasonable 
        real interpretation of the result can be assumed.
       */
    powerOfNegativeBase: function(iBase, iExponent) {
      var kTolerance = 0.0000000000001,
        trialDenom = 3,
        numerator,
        intNumerator,
        trial,
        sign;

      for (trial = 0; trial < 5; ++trial) {
        numerator = iExponent * trialDenom;
        intNumerator = Math.round(numerator);
        if (Math.abs(numerator - intNumerator) <= 2 * kTolerance) {
          sign = intNumerator % 2 !== 0 ? -1 : 1;
          return sign * Math.pow(-iBase, iExponent);
        }

        trialDenom += 2;
      }

      // No special case -- let Math.pow() handle it normally.
      // This will probably result in a NaN, but just in case...
      return Math.pow(iBase, iExponent);
    },

    /** Check for tolerance of value vs expected according to tol
     * see http://www.boost.org/doc/libs/1_35_0/libs/test/doc/components/test_tools/floating_point_comparison.html#tolerance
     *
     * @param {Number} value
     * @param {Number} expected
     * @param {Number} tol - (Optional) allowed tolerance, default is 0.00001
     * @param {Boolean} absolute - (Optional) test with absolute tolerance rather than relative
     */
    expect: function(value, expected, tol, absolute) {
      // numerically speaking, NaN is the same as undefined,
      // and math operators on undefined convert to NaN
      var valueNotDefined = isNaN(value) || value === undefined,
        expectedNotDefined = isNaN(expected) || expected === undefined,
        valueIsInfinity =
          !isFinite(value) &&
          !isNaN(value) &&
          (value > 0 ? 'posInfinity' : 'negInfinity'),
        expectedIsInfinity =
          (expected === 'inf' && 'posInfinity') ||
          (expected === '-inf' && 'negInfinity'),
        distance;

      if (undefined === tol) {
        tol = 0.00001;
      }

      if (value === expected) {
        return true;
      }

      if (valueIsInfinity || expectedIsInfinity) {
        return valueIsInfinity === expectedIsInfinity;
      }

      if (valueNotDefined || expectedNotDefined) {
        return valueNotDefined === expectedNotDefined;
      }

      distance = Math.abs(value - expected);

      if (absolute && value + tol !== value) {
        //test absolute distance:
        //Note - we override the request for absolute on numbers that are too
        //large to represent the tolerance.  Our test fails for tol=0, but If
        //tol was 0, we would have already returned true if they were equal above.
        return distance < tol;
      }

      //test relative distance:
      // Near zero, rounding issues get more complicated (e.g.
      // Desktop uses a non full accuracy value of PI, so sin(PI)
      // diverges from our sin(Math.PI). We'll bag out near zero -
      // if you want to test that, you'll need to use a more specific
      // test.
      if (Math.abs(value) + Math.abs(expected) < 2 * 1.0e-12) {
        return true;
      }

      return (
        distance <= tol * Math.abs(value) &&
        distance <= tol * Math.abs(expected)
      );
    },
    isFiniteScalar: function(value) {
      /*jslint eqeq:true */
      // more compact and more robust than testing for undefined independently
      return value != null && isFinite(value);
    },

    /**
     * Compute the greatest common divisor of two numbers
     * cf. gcd_UTIL() in geometry.c
     * @param {Number} a
     * @param {Number} b
     * @returns {Number} the greatest common divisor of the two arguments
     */
    gcd: function(a, b) {
      // Use ~~ to efficiently truncate to integer
      // (cf. http://stackoverflow.com/questions/4055633/what-does-do-in-javascript)
      /*jslint bitwise:true */
      if (a !== ~~a || b !== ~~b) return 0;
      if (0 === a || 0 === b) return 0;

      var tmp;
      while (b) {
        tmp = a % b;
        a = b;
        b = tmp;
      }
      return a;
    },

    /**
     * Reduce a fraction by the GCD.
     * @param {Number} iNumerator
     *        {Number} iDenominator
     * @returns {Object} fraction object
     *            {Number} fraction.numerator
     *            {Number} fraction.denominator
     */
    reduceFraction: function(iNumerator, iDenominator) {
      var gcd = this.gcd(iNumerator, iDenominator);
      if (gcd > 1) {
        return { numerator: iNumerator / gcd, denominator: iDenominator / gcd };
      }
      return { numerator: iNumerator, denominator: iDenominator };
    },

    /**
      Given a real numeric value, determines whether that value can
      be represented as a simple (denominator <= 12) fraction of pi.
      Returns the fraction as an object { numerator, denominator },
      if so, or false otherwise.
      @param  {Number}  iValue -- the numeric value to be considered
      @returns  {Object|Boolean}  { numerator: , denominator: } or false
     */
    getSimplePiFraction: function(iValue) {
      if (iValue === Math.floor(iValue)) return false;

      var t = (12 * iValue) / Math.PI,
        piTwelfthsMultipler = Math.round(t),
        diff = Math.abs(t - piTwelfthsMultipler);

      if (0 !== piTwelfthsMultipler && diff < 0.001) {
        var result = GSP.math.reduceFraction(Math.abs(piTwelfthsMultipler), 12);
        if (piTwelfthsMultipler < 0) result.numerator = -result.numerator;
        return result;
      }
      return false;
    },
    /*
      Given a value, and a point f(value), find a decent delta for the value
      to use in secant approximation.
      
      The method followed here is that of "Numerical Recipes in C" 2nd E.d. Sec. 5.7.4 p.p. 186.
    */
    parameterDeltaForSecant: function(iDomainValue, point) {
      var kSqrtMachinePrecision = 1.05367121e-8,
        rangeMagnitude,
        tEpsilon,
        tExactDifference;

      rangeMagnitude = Math.abs(point.x);
      if (Math.abs(point.y) > rangeMagnitude) {
        rangeMagnitude = Math.abs(point.y);
      }

      tEpsilon = kSqrtMachinePrecision * rangeMagnitude;

      /* We want (iDomainValue + tEpsilon) - iDomainValue == tEpsilon *exactly* in floating point. */
      tExactDifference = iDomainValue + tEpsilon;
      tEpsilon = tExactDifference - iDomainValue;

      return tEpsilon > 0.0 ? tEpsilon : kSqrtMachinePrecision;
    },
    secantApproximationToDerivative: function(value, location, pathFunction) {
      var testPosition,
        tSecantDelta = GSP.math.parameterDeltaForSecant(value, location);

      testPosition = pathFunction(value + tSecantDelta);

      if (testPosition.isDefined()) {
        return GSP.GeometricPoint(
          (testPosition.x - location.x) / tSecantDelta,
          (testPosition.y - location.y) / tSecantDelta
        );
      }

      testPosition = pathFunction(value - tSecantDelta);
      if (testPosition.isDefined()) {
        return GSP.GeometricPoint(
          (testPosition.x - location.x) / -tSecantDelta,
          (testPosition.y - location.y) / -tSecantDelta
        );
      }
      return GSP.GeometricPoint.UNDEFINED;
    },
  };

  GSP.math.PI = Math.PI;

  GSP.math.TWO_PI = 2 * Math.PI;

  GSP.math.SIMPLE_PI_THRESHOLD = Math.PI * 0.9999999999;
  /* We use a value consistently less than PI for our "cutover" threshold
     between Simple and Reflex regimes, so as to guarantee that an open-angle
     constructed on one side of a straight remains on that side for all orientations,
     rather than flip sides randomly based on whether our floating-point trig
     returns (initialAngle, terminalAngle) as (pi+e, pi-e) or as (pi-e, pi+e).
     Our chosen cross-over value is within 1x10^(-10) units of pi radians, which
     is "off" from an open-angle by less than half a pixel per million kilometers. */

  GSP.infixExpressionParser = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;

      this.name = 'SyntaxError';
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
      var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction = peg$parsestart,
        peg$c0 = [],
        peg$c1 = function() {
          return calcRefCounts(
            cse({
              kind: 'blank',
              type: 'blank',
              children: {},
            })
          );
        },
        peg$c2 = peg$FAILED,
        peg$c3 = null,
        peg$c4 = '=',
        peg$c5 = { type: 'literal', value: '=', description: '"="' },
        peg$c6 = function(declaration, expr) {
          var result = {
            kind: 'equation',
            type: 'equation',
            children: {
              expr: expr,
            },
          };
          if (declaration) {
            result.children.declaration = declaration[1];
          }
          return calcRefCounts(cse(result));
        },
        peg$c7 = /^[a-z]/,
        peg$c8 = { type: 'class', value: '[a-z]', description: '[a-z]' },
        peg$c9 = '(',
        peg$c10 = { type: 'literal', value: '(', description: '"("' },
        peg$c11 = /^[xyr\u03B8]/,
        peg$c12 = {
          type: 'class',
          value: '[xyr\\u03B8]',
          description: '[xyr\\u03B8]',
        },
        peg$c13 = ')',
        peg$c14 = { type: 'literal', value: ')', description: '")"' },
        peg$c15 = function(functionName, functionVar) {
          var name = functionName.join(''),
            result = {
              kind: 'declaration:' + name,
              type: 'declaration',
              children: {},
              name: name,
              argument: functionVar,
            };
          return cse(result);
        },
        peg$c16 = function(functionVar) {
          var result = {
            kind: 'declaration:' + functionVar,
            type: 'declaration',
            children: {},
            argument: functionVar,
          };
          return cse(result);
        },
        peg$c17 = '+',
        peg$c18 = { type: 'literal', value: '+', description: '"+"' },
        peg$c19 = '-',
        peg$c20 = { type: 'literal', value: '-', description: '"-"' },
        peg$c21 = function(head, tail) {
          var result, i, op;
          result = head;
          for (i = 0; i < tail.length; i++) {
            op = tail[i][0];
            result = cse({
              kind: 'binary-expr:' + op,
              type: 'binary-expr',
              children: {
                left: result,
                right: tail[i][2],
              },
              subtype: 'additive',
              operator: op,
            });
          }
          return result;
        },
        peg$c22 = '/',
        peg$c23 = { type: 'literal', value: '/', description: '"/"' },
        peg$c24 = '*',
        peg$c25 = { type: 'literal', value: '*', description: '"*"' },
        peg$c26 = function(head, tail) {
          var result, i, op;
          result = head;
          for (i = 0; i < tail.length; i++) {
            op = tail[i][0];
            result = cse({
              kind: 'binary-expr:' + op,
              type: 'binary-expr',
              children: {
                left: result,
                right: tail[i][2],
              },
              subtype: 'multiplicative',
              operator: op,
            });
          }
          return result;
        },
        peg$c27 = '^',
        peg$c28 = { type: 'literal', value: '^', description: '"^"' },
        peg$c29 = function(left, rightSide) {
          if (rightSide) {
            var right = rightSide[2];
            var result;
            result = {
              kind: 'binary-expr:^',
              type: 'binary-expr',
              children: {
                left: left,
                right: right,
              },
              subtype: 'power',
              operator: '^',
            };
            return cse(result);
          } else {
            return left;
          }
        },
        peg$c30 = function(expr) {
          return expr;
        },
        peg$c31 = function(unaryExpr) {
          return cse({
            kind: 'unary-expr:-',
            type: 'unary-expr',
            children: {
              child: unaryExpr,
            },
            operator: '-',
          });
        },
        peg$c32 = function(powerExpr) {
          return cse({
            kind: 'unary-expr:-',
            type: 'unary-expr',
            children: {
              child: powerExpr,
            },
            operator: '-',
          });
        },
        peg$c33 = function(funcname, expr) {
          return cse({
            kind: 'function:' + funcname,
            type: 'function',
            children: {
              arg: expr,
            },
            subtype: 'sys',
            name: funcname,
          });
        },
        peg$c34 = function(ref, expr) {
          return cse({
            kind: 'function:custom',
            type: 'function',
            children: {
              name: ref,
              arg: expr,
            },
            subtype: 'custom',
          });
        },
        peg$c35 = 'sin',
        peg$c36 = { type: 'literal', value: 'sin', description: '"sin"' },
        peg$c37 = 'cos',
        peg$c38 = { type: 'literal', value: 'cos', description: '"cos"' },
        peg$c39 = 'tan',
        peg$c40 = { type: 'literal', value: 'tan', description: '"tan"' },
        peg$c41 = 'Arcsin',
        peg$c42 = { type: 'literal', value: 'Arcsin', description: '"Arcsin"' },
        peg$c43 = 'Arccos',
        peg$c44 = { type: 'literal', value: 'Arccos', description: '"Arccos"' },
        peg$c45 = 'Arctan',
        peg$c46 = { type: 'literal', value: 'Arctan', description: '"Arctan"' },
        peg$c47 = 'abs',
        peg$c48 = { type: 'literal', value: 'abs', description: '"abs"' },
        peg$c49 = 'sqrt',
        peg$c50 = { type: 'literal', value: 'sqrt', description: '"sqrt"' },
        peg$c51 = 'ln',
        peg$c52 = { type: 'literal', value: 'ln', description: '"ln"' },
        peg$c53 = 'log',
        peg$c54 = { type: 'literal', value: 'log', description: '"log"' },
        peg$c55 = 'sgn',
        peg$c56 = { type: 'literal', value: 'sgn', description: '"sgn"' },
        peg$c57 = 'round',
        peg$c58 = { type: 'literal', value: 'round', description: '"round"' },
        peg$c59 = 'trunc',
        peg$c60 = { type: 'literal', value: 'trunc', description: '"trunc"' },
        peg$c61 = 'isDefined',
        peg$c62 = {
          type: 'literal',
          value: 'isDefined',
          description: '"isDefined"',
        },
        peg$c63 = function(const1, unit) {
          return cse({
            kind: 'primary',
            type: 'primary',
            children: {
              value: const1,
              unit: unit,
            },
          });
        },
        peg$c64 = function(const1) {
          return cse({
            kind: 'primary',
            type: 'primary',
            children: {
              value: const1,
            },
            unit: undefined,
          });
        },
        peg$c65 = '.',
        peg$c66 = { type: 'literal', value: '.', description: '"."' },
        peg$c67 = 'e',
        peg$c68 = { type: 'literal', value: 'e', description: '"e"' },
        peg$c69 = function(digits) {
          var value = digits.join('');
          return cse({
            kind: 'constant:numeric:' + value,
            type: 'constant',
            children: {},
            subtype: 'numeric',
            value: value,
          });
        },
        peg$c70 = 'pi',
        peg$c71 = { type: 'literal', value: 'pi', description: '"pi"' },
        peg$c72 = '\u03C0',
        peg$c73 = {
          type: 'literal',
          value: '\u03C0',
          description: '"\\u03C0"',
        },
        peg$c74 = function(symbol) {
          var symbolMap = { pi: 'pi', π: 'pi', e: 'e' },
            value = symbolMap[symbol] ? symbolMap[symbol] : symbol;
          return cse({
            kind: 'constant:symbolic:' + value,
            type: 'constant',
            children: {},
            subtype: 'symbolic',
            value: value,
          });
        },
        peg$c75 = /^[0-9]/,
        peg$c76 = { type: 'class', value: '[0-9]', description: '[0-9]' },
        peg$c77 = function(digits) {
          return digits.join('');
        },
        peg$c78 = 'pixels',
        peg$c79 = { type: 'literal', value: 'pixels', description: '"pixels"' },
        peg$c80 = 'pixel',
        peg$c81 = { type: 'literal', value: 'pixel', description: '"pixel"' },
        peg$c82 = 'px',
        peg$c83 = { type: 'literal', value: 'px', description: '"px"' },
        peg$c84 = 'pix',
        peg$c85 = { type: 'literal', value: 'pix', description: '"pix"' },
        peg$c86 = 'cm',
        peg$c87 = { type: 'literal', value: 'cm', description: '"cm"' },
        peg$c88 = 'centimeter',
        peg$c89 = {
          type: 'literal',
          value: 'centimeter',
          description: '"centimeter"',
        },
        peg$c90 = 'inches',
        peg$c91 = { type: 'literal', value: 'inches', description: '"inches"' },
        peg$c92 = 'inch',
        peg$c93 = { type: 'literal', value: 'inch', description: '"inch"' },
        peg$c94 = 'in.',
        peg$c95 = { type: 'literal', value: 'in.', description: '"in."' },
        peg$c96 = 'in',
        peg$c97 = { type: 'literal', value: 'in', description: '"in"' },
        peg$c98 = function(name) {
          return cse({
            kind: 'unit:' + name,
            type: 'unit',
            children: {},
            subtype: 'distance',
            name: name,
          });
        },
        peg$c99 = 'radians',
        peg$c100 = {
          type: 'literal',
          value: 'radians',
          description: '"radians"',
        },
        peg$c101 = 'radian',
        peg$c102 = {
          type: 'literal',
          value: 'radian',
          description: '"radian"',
        },
        peg$c103 = 'rad',
        peg$c104 = { type: 'literal', value: 'rad', description: '"rad"' },
        peg$c105 = 'rd',
        peg$c106 = { type: 'literal', value: 'rd', description: '"rd"' },
        peg$c107 = 'degrees',
        peg$c108 = {
          type: 'literal',
          value: 'degrees',
          description: '"degrees"',
        },
        peg$c109 = 'deg',
        peg$c110 = { type: 'literal', value: 'deg', description: '"deg"' },
        peg$c111 = '\xB0',
        peg$c112 = { type: 'literal', value: '\xB0', description: '"\\xB0"' },
        peg$c113 = 'signed deg',
        peg$c114 = {
          type: 'literal',
          value: 'signed deg',
          description: '"signed deg"',
        },
        peg$c115 = function(name) {
          return cse({
            kind: 'unit:' + name,
            type: 'unit',
            children: {},
            subtype: 'angle',
            name: name,
          });
        },
        peg$c116 = '@',
        peg$c117 = { type: 'literal', value: '@', description: '"@"' },
        peg$c118 = /^[0-9a-zA-Z_]/,
        peg$c119 = {
          type: 'class',
          value: '[0-9a-zA-Z_]',
          description: '[0-9a-zA-Z_]',
        },
        peg$c120 = function(name) {
          var nameString = name.join('');

          return cse({
            kind: 'reference:' + nameString,
            type: 'reference',
            children: {},
            name: nameString,
          });
        },
        peg$c121 = 'x',
        peg$c122 = { type: 'literal', value: 'x', description: '"x"' },
        peg$c123 = 'y',
        peg$c124 = { type: 'literal', value: 'y', description: '"y"' },
        peg$c125 = '\u03B8',
        peg$c126 = {
          type: 'literal',
          value: '\u03B8',
          description: '"\\u03B8"',
        },
        peg$c127 = 'r',
        peg$c128 = { type: 'literal', value: 'r', description: '"r"' },
        peg$c129 = 't',
        peg$c130 = { type: 'literal', value: 't', description: '"t"' },
        peg$c131 = function(name) {
          return cse({
            kind: 'variable:' + name,
            type: 'variable',
            children: {},
            name: name,
          });
        },
        peg$c132 = { type: 'other', description: 'whitespace' },
        peg$c133 = /^[ \t\n\r]/,
        peg$c134 = {
          type: 'class',
          value: '[ \\t\\n\\r]',
          description: '[ \\t\\n\\r]',
        },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          );
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }

      function offset() {
        return peg$reportedPos;
      }

      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }

      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }

      function expected(description) {
        throw peg$buildException(
          null,
          [{ type: 'other', description: description }],
          peg$reportedPos
        );
      }

      function error(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }

      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;

          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === '\n') {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }

        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }

        return peg$cachedPosDetails;
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected) {
          var i = 1;

          expected.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });

          while (i < expected.length) {
            if (expected[i - 1] === expected[i]) {
              expected.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        function buildMessage(expected, found) {
          function stringEscape(s) {
            function hex(ch) {
              return ch
                .charCodeAt(0)
                .toString(16)
                .toUpperCase();
            }

            return s
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\x08/g, '\\b')
              .replace(/\t/g, '\\t')
              .replace(/\n/g, '\\n')
              .replace(/\f/g, '\\f')
              .replace(/\r/g, '\\r')
              .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              })
              .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              })
              .replace(/[\u0180-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              })
              .replace(/[\u1080-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
          }

          var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

          for (i = 0; i < expected.length; i++) {
            expectedDescs[i] = expected[i].description;
          }

          expectedDesc =
            expected.length > 1
              ? expectedDescs.slice(0, -1).join(', ') +
                ' or ' +
                expectedDescs[expected.length - 1]
              : expectedDescs[0];

          foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input';

          return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';
        }

        var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

        if (expected !== null) {
          cleanupExpected(expected);
        }

        return new SyntaxError(
          message !== null ? message : buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column
        );
      }

      function peg$parsestart() {
        var s0;

        s0 = peg$parseequation();
        if (s0 === peg$FAILED) {
          s0 = peg$parseblank();
        }

        return s0;
      }

      function peg$parseblank() {
        var s0, s1;

        s0 = peg$currPos;
        s1 = [];
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;

        return s0;
      }

      function peg$parseequation() {
        var s0, s1, s2, s3, s4, s5, s6;

        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedeclaration();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s5 = peg$c4;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c5);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5, s6];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c3;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c6(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }

        return s0;
      }

      function peg$parsedeclaration() {
        var s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        s1 = [];
        if (peg$c7.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c7.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (peg$c11.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c12);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c13;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c14);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (peg$c11.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c12);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c16(s1);
          }
          s0 = s1;
        }

        return s0;
      }

      function peg$parseexpr() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;

        s0 = peg$currPos;
        s1 = peg$parseterm();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c17;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c18);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c19;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c20);
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseterm();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c2;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 43) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c18);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s5 = peg$c19;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c20);
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseterm();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s5 = [s5, s6, s7, s8];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c2;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c2;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c21(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }

        return s0;
      }

      function peg$parseterm() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;

        s0 = peg$currPos;
        s1 = peg$parsepowerExpr();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c22;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c23);
              }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 42) {
                s5 = peg$c24;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c25);
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsepowerExpr();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c2;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c22;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c23);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                  s5 = peg$c24;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c25);
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsepowerExpr();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s5 = [s5, s6, s7, s8];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c2;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c2;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c26(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }

        return s0;
      }

      function peg$parsepowerExpr() {
        var s0, s1, s2, s3, s4, s5, s6;

        s0 = peg$currPos;
        s1 = peg$parsefactor();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 94) {
              s4 = peg$c27;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepowerExpr();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c2;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$c3;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c29(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }

        return s0;
      }

      function peg$parsefactor() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$parseunaryExpr();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c9;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c10);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseexpr();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c13;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c14);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c30(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseprimary();
          }
        }

        return s0;
      }

      function peg$parseunaryExpr() {
        var s0, s1, s2, s3;

        s0 = peg$parsefunction();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c19;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseunaryExpr();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c31(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c19;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c20);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parsepowerExpr();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c32(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }

        return s0;
      }

      function peg$parsefunction() {
        var s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        s1 = peg$parsefuncname();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c9;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c10);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseexpr();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c13;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c14);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c33(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsereference();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c9;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseexpr();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c13;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c14);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c34(s1, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        }

        return s0;
      }

      function peg$parsefuncname() {
        var s0;

        if (input.substr(peg$currPos, 3) === peg$c35) {
          s0 = peg$c35;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c36);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c37) {
            s0 = peg$c37;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c38);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c39) {
              s0 = peg$c39;
              peg$currPos += 3;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c40);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 6) === peg$c41) {
                s0 = peg$c41;
                peg$currPos += 6;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c42);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c43) {
                  s0 = peg$c43;
                  peg$currPos += 6;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c44);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c45) {
                    s0 = peg$c45;
                    peg$currPos += 6;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c46);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c47) {
                      s0 = peg$c47;
                      peg$currPos += 3;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c48);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c49) {
                        s0 = peg$c49;
                        peg$currPos += 4;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c50);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c51) {
                          s0 = peg$c51;
                          peg$currPos += 2;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c52);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 3) === peg$c53) {
                            s0 = peg$c53;
                            peg$currPos += 3;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c54);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c55) {
                              s0 = peg$c55;
                              peg$currPos += 3;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c56);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 5) === peg$c57) {
                                s0 = peg$c57;
                                peg$currPos += 5;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c58);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c59) {
                                  s0 = peg$c59;
                                  peg$currPos += 5;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c60);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (
                                    input.substr(peg$currPos, 9) === peg$c61
                                  ) {
                                    s0 = peg$c61;
                                    peg$currPos += 9;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c62);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parseprimary() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        s1 = peg$parseconstant();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseunitname();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c63(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseconstant();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c64(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parsereference();
            if (s0 === peg$FAILED) {
              s0 = peg$parsevariable();
            }
          }
        }

        return s0;
      }

      function peg$parseconstant() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;

        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c19;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c3;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsedigits();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c65;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c66);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedigits();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 101) {
                  s6 = peg$c67;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c68);
                  }
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s7 = peg$c19;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c20);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$c3;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsedigits();
                    if (s8 !== peg$FAILED) {
                      s2 = [s2, s3, s4, s5, s6, s7, s8];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c2;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c19;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s2 === peg$FAILED) {
            s2 = peg$c3;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsedigits();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c65;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c66);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsedigits();
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s2 = peg$c19;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c20);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = peg$c3;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsedigits();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c65;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c66);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s2 = peg$c19;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c20);
                }
              }
              if (s2 === peg$FAILED) {
                s2 = peg$c3;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s3 = peg$c65;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c66);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsedigits();
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                  s2 = peg$c19;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c20);
                  }
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$c3;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsedigits();
                  if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c69(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c70) {
            s1 = peg$c70;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c71);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 960) {
              s1 = peg$c72;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c73);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 101) {
                s1 = peg$c67;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c68);
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
        }

        return s0;
      }

      function peg$parsedigits() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        if (peg$c75.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c76);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c75.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
          }
        } else {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c77(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parseunitname() {
        var s0;

        s0 = peg$parsedistanceunitname();
        if (s0 === peg$FAILED) {
          s0 = peg$parseangleunitname();
        }

        return s0;
      }

      function peg$parsedistanceunitname() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c78) {
          s1 = peg$c78;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c79);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c80) {
            s1 = peg$c80;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c81);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c82) {
              s1 = peg$c82;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c83);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c84) {
                s1 = peg$c84;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c85);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c86) {
                  s1 = peg$c86;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c87);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c88) {
                    s1 = peg$c88;
                    peg$currPos += 10;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c89);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c90) {
                      s1 = peg$c90;
                      peg$currPos += 6;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c91);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c92) {
                        s1 = peg$c92;
                        peg$currPos += 4;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c93);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c94) {
                          s1 = peg$c94;
                          peg$currPos += 3;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c95);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c96) {
                            s1 = peg$c96;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c97);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c98(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parseangleunitname() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c99) {
          s1 = peg$c99;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c100);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c103) {
              s1 = peg$c103;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c104);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c105) {
                s1 = peg$c105;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c106);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c107) {
                  s1 = peg$c107;
                  peg$currPos += 7;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c108);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 176) {
                      s1 = peg$c111;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c112);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 10) === peg$c113) {
                        s1 = peg$c113;
                        peg$currPos += 10;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c114);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c115(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parsereference() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s1 = peg$c116;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c118.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c118.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c119);
                }
              }
            }
          } else {
            s2 = peg$c2;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c120(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }

        return s0;
      }

      function peg$parsevariable() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 120) {
          s1 = peg$c121;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c122);
          }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 121) {
            s1 = peg$c123;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 952) {
              s1 = peg$c125;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c126);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 114) {
                s1 = peg$c127;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c128);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 116) {
                  s1 = peg$c129;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c130);
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c131(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parse_() {
        var s0, s1;

        peg$silentFails++;
        s0 = [];
        s1 = peg$parsewhitespace();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsewhitespace();
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c132);
          }
        }

        return s0;
      }

      function peg$parsewhitespace() {
        var s0;

        if (peg$c133.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c134);
          }
        }

        return s0;
      }

      var index = 0,
        nametable = {};

      /* We'll do Common Subexpression Elimination, where nodes of the same .kind,
            and the same children, will actually be the same object in the tree.
            It is thus required that the .kind be sufficient to determine the effect
            of the node when evaluated with given children.
            Each node will have a .index that can be used to identify it.
            While there, we compute a .refCount, which shows the number of times
            that the node would have occured in the non-CSE'd expression.
  
            See the Dragon Book (a.k.a Compilers: Principles, Techniques, and Tools)
            6.1.2 'The Value-Number Method for Constructing DAGs'
        */

      // Given a new node, see if it's already known, and if not,
      // augment it with an index, and remeber it.
      function cse(node) {
        var exprKey = node.kind,
          memoNode;

        // key is node.kind with child node indexes.
        for (var key in node.children) {
          if (node.children.hasOwnProperty(key)) {
            exprKey += ':' + key + ':' + node.children[key].index;
          }
        }

        // Have we seen this node - just return it?
        memoNode = nametable[exprKey];
        if (memoNode) {
          return memoNode;
        }

        // Otherwise, set up this node with index, init refCount, and rememeber it
        node.index = index;
        node.refCount = 0; // We'll calculate this as a final step.
        nametable[exprKey] = node;

        // Increment index for next node, and then we are done.
        index++;
        return node;
      }

      // DFS caclulation of refCount for nodes
      // Returns input node for syntactic sugar purposes.
      function calcRefCounts(root) {
        var k;
        for (k in root.children) {
          calcRefCounts(root.children[k]);
        }
        root.refCount++;
        return root;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: 'end', description: 'end of input' });
        }

        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }

    return {
      SyntaxError: SyntaxError,
      parse: parse,
    };
  })();

  GSP.jskParser = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;

      this.name = 'SyntaxError';
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
      var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction = peg$parsestart,
        peg$c0 = [],
        peg$c1 = peg$FAILED,
        peg$c2 = null,
        peg$c3 = ';',
        peg$c4 = { type: 'literal', value: ';', description: '";"' },
        peg$c5 = function(type, args, of) {
          var id = ++objCount;
          return { id: id, type: type, argGroups: args, opts: of ? of : [] };
        },
        peg$c6 = function(name) {
          return name;
        },
        peg$c7 = '[',
        peg$c8 = { type: 'literal', value: '[', description: '"["' },
        peg$c9 = ',',
        peg$c10 = { type: 'literal', value: ',', description: '","' },
        peg$c11 = ']',
        peg$c12 = { type: 'literal', value: ']', description: '"]"' },
        peg$c13 = function(of0, ofn) {
          var ix,
            r = [];
          r.push(of0);
          for (ix = 0; ix < ofn.length; ix += 1) {
            r.push(ofn[ix][3]);
          }
          return r;
        },
        peg$c14 = '(',
        peg$c15 = { type: 'literal', value: '(', description: '"("' },
        peg$c16 = ')',
        peg$c17 = { type: 'literal', value: ')', description: '")"' },
        peg$c18 = function() {
          return [];
        },
        peg$c19 = function(a, b) {
          var ix,
            r = [];
          r.push(a);
          for (ix = 0; ix < b.length; ix += 1) {
            r.push(b[ix][3]);
          }
          return r;
        },
        peg$c20 = 'Point on object',
        peg$c21 = {
          type: 'literal',
          value: 'Point on object',
          description: '"Point on object"',
        },
        peg$c22 = 'Point',
        peg$c23 = { type: 'literal', value: 'Point', description: '"Point"' },
        peg$c24 = 'FixedPoint',
        peg$c25 = {
          type: 'literal',
          value: 'FixedPoint',
          description: '"FixedPoint"',
        },
        peg$c26 = 'Midpoint',
        peg$c27 = {
          type: 'literal',
          value: 'Midpoint',
          description: '"Midpoint"',
        },
        peg$c28 = 'Intersect1',
        peg$c29 = {
          type: 'literal',
          value: 'Intersect1',
          description: '"Intersect1"',
        },
        peg$c30 = 'Intersect2',
        peg$c31 = {
          type: 'literal',
          value: 'Intersect2',
          description: '"Intersect2"',
        },
        peg$c32 = 'Intersect',
        peg$c33 = {
          type: 'literal',
          value: 'Intersect',
          description: '"Intersect"',
        },
        peg$c34 = 'PlotXY',
        peg$c35 = { type: 'literal', value: 'PlotXY', description: '"PlotXY"' },
        peg$c36 = 'PlotFixedXY',
        peg$c37 = {
          type: 'literal',
          value: 'PlotFixedXY',
          description: '"PlotFixedXY"',
        },
        peg$c38 = 'UnitPoint',
        peg$c39 = {
          type: 'literal',
          value: 'UnitPoint',
          description: '"UnitPoint"',
        },
        peg$c40 = 'SquareUnitPoint',
        peg$c41 = {
          type: 'literal',
          value: 'SquareUnitPoint',
          description: '"SquareUnitPoint"',
        },
        peg$c42 = 'RectangularUnitPoint',
        peg$c43 = {
          type: 'literal',
          value: 'RectangularUnitPoint',
          description: '"RectangularUnitPoint"',
        },
        peg$c44 = 'DriverPoint',
        peg$c45 = {
          type: 'literal',
          value: 'DriverPoint',
          description: '"DriverPoint"',
        },
        peg$c46 = 'Segment',
        peg$c47 = {
          type: 'literal',
          value: 'Segment',
          description: '"Segment"',
        },
        peg$c48 = 'Ray',
        peg$c49 = { type: 'literal', value: 'Ray', description: '"Ray"' },
        peg$c50 = 'Line',
        peg$c51 = { type: 'literal', value: 'Line', description: '"Line"' },
        peg$c52 = 'Perpendicular',
        peg$c53 = {
          type: 'literal',
          value: 'Perpendicular',
          description: '"Perpendicular"',
        },
        peg$c54 = 'Parallel',
        peg$c55 = {
          type: 'literal',
          value: 'Parallel',
          description: '"Parallel"',
        },
        peg$c56 = 'AxisX',
        peg$c57 = { type: 'literal', value: 'AxisX', description: '"AxisX"' },
        peg$c58 = 'AxisY',
        peg$c59 = { type: 'literal', value: 'AxisY', description: '"AxisY"' },
        peg$c60 = 'Bisector',
        peg$c61 = {
          type: 'literal',
          value: 'Bisector',
          description: '"Bisector"',
        },
        peg$c62 = 'HorizontalAxis',
        peg$c63 = {
          type: 'literal',
          value: 'HorizontalAxis',
          description: '"HorizontalAxis"',
        },
        peg$c64 = 'VerticalAxis',
        peg$c65 = {
          type: 'literal',
          value: 'VerticalAxis',
          description: '"VerticalAxis"',
        },
        peg$c66 = 'Polygon',
        peg$c67 = {
          type: 'literal',
          value: 'Polygon',
          description: '"Polygon"',
        },
        peg$c68 = 'Circle interior',
        peg$c69 = {
          type: 'literal',
          value: 'Circle interior',
          description: '"Circle interior"',
        },
        peg$c70 = 'Circle by radius',
        peg$c71 = {
          type: 'literal',
          value: 'Circle by radius',
          description: '"Circle by radius"',
        },
        peg$c72 = 'Circle',
        peg$c73 = { type: 'literal', value: 'Circle', description: '"Circle"' },
        peg$c74 = 'Reflection',
        peg$c75 = {
          type: 'literal',
          value: 'Reflection',
          description: '"Reflection"',
        },
        peg$c76 = 'Dilation/SegmentRatio',
        peg$c77 = {
          type: 'literal',
          value: 'Dilation/SegmentRatio',
          description: '"Dilation/SegmentRatio"',
        },
        peg$c78 = 'Dilation/3PtRatio',
        peg$c79 = {
          type: 'literal',
          value: 'Dilation/3PtRatio',
          description: '"Dilation/3PtRatio"',
        },
        peg$c80 = 'Dilation/MarkedRatio',
        peg$c81 = {
          type: 'literal',
          value: 'Dilation/MarkedRatio',
          description: '"Dilation/MarkedRatio"',
        },
        peg$c82 = 'Dilation',
        peg$c83 = {
          type: 'literal',
          value: 'Dilation',
          description: '"Dilation"',
        },
        peg$c84 = 'Rotation/MarkedAngle',
        peg$c85 = {
          type: 'literal',
          value: 'Rotation/MarkedAngle',
          description: '"Rotation/MarkedAngle"',
        },
        peg$c86 = 'Rotation/MeasuredAngle',
        peg$c87 = {
          type: 'literal',
          value: 'Rotation/MeasuredAngle',
          description: '"Rotation/MeasuredAngle"',
        },
        peg$c88 = 'Rotation',
        peg$c89 = {
          type: 'literal',
          value: 'Rotation',
          description: '"Rotation"',
        },
        peg$c90 = 'VectorTranslation',
        peg$c91 = {
          type: 'literal',
          value: 'VectorTranslation',
          description: '"VectorTranslation"',
        },
        peg$c92 = 'Translation/FixedAngle/MarkedDistance',
        peg$c93 = {
          type: 'literal',
          value: 'Translation/FixedAngle/MarkedDistance',
          description: '"Translation/FixedAngle/MarkedDistance"',
        },
        peg$c94 = 'PolarTranslation',
        peg$c95 = {
          type: 'literal',
          value: 'PolarTranslation',
          description: '"PolarTranslation"',
        },
        peg$c96 = 'Translation/MarkedAngle/FixedDistance',
        peg$c97 = {
          type: 'literal',
          value: 'Translation/MarkedAngle/FixedDistance',
          description: '"Translation/MarkedAngle/FixedDistance"',
        },
        peg$c98 = 'Translation/MarkedAngle/MarkedDistance',
        peg$c99 = {
          type: 'literal',
          value: 'Translation/MarkedAngle/MarkedDistance',
          description: '"Translation/MarkedAngle/MarkedDistance"',
        },
        peg$c100 = 'Translation',
        peg$c101 = {
          type: 'literal',
          value: 'Translation',
          description: '"Translation"',
        },
        peg$c102 = 'Colorized_Spectrum',
        peg$c103 = {
          type: 'literal',
          value: 'Colorized_Spectrum',
          description: '"Colorized_Spectrum"',
        },
        peg$c104 = 'Colorized_Grayscale',
        peg$c105 = {
          type: 'literal',
          value: 'Colorized_Grayscale',
          description: '"Colorized_Grayscale"',
        },
        peg$c106 = 'Colorized_RGB',
        peg$c107 = {
          type: 'literal',
          value: 'Colorized_RGB',
          description: '"Colorized_RGB"',
        },
        peg$c108 = 'Colorized_HSV',
        peg$c109 = {
          type: 'literal',
          value: 'Colorized_HSV',
          description: '"Colorized_HSV"',
        },
        peg$c110 = 'Image',
        peg$c111 = { type: 'literal', value: 'Image', description: '"Image"' },
        peg$c112 = 'ImageOnPoint',
        peg$c113 = {
          type: 'literal',
          value: 'ImageOnPoint',
          description: '"ImageOnPoint"',
        },
        peg$c114 = 'ImageBetweenPoints',
        peg$c115 = {
          type: 'literal',
          value: 'ImageBetweenPoints',
          description: '"ImageBetweenPoints"',
        },
        peg$c116 = 'Length',
        peg$c117 = {
          type: 'literal',
          value: 'Length',
          description: '"Length"',
        },
        peg$c118 = 'Angle',
        peg$c119 = { type: 'literal', value: 'Angle', description: '"Angle"' },
        peg$c120 = 'Perimeter',
        peg$c121 = {
          type: 'literal',
          value: 'Perimeter',
          description: '"Perimeter"',
        },
        peg$c122 = 'Circumference',
        peg$c123 = {
          type: 'literal',
          value: 'Circumference',
          description: '"Circumference"',
        },
        peg$c124 = 'Radius',
        peg$c125 = {
          type: 'literal',
          value: 'Radius',
          description: '"Radius"',
        },
        peg$c126 = 'Area',
        peg$c127 = { type: 'literal', value: 'Area', description: '"Area"' },
        peg$c128 = 'Slope',
        peg$c129 = { type: 'literal', value: 'Slope', description: '"Slope"' },
        peg$c130 = 'Distance',
        peg$c131 = {
          type: 'literal',
          value: 'Distance',
          description: '"Distance"',
        },
        peg$c132 = 'Ratio/Segments',
        peg$c133 = {
          type: 'literal',
          value: 'Ratio/Segments',
          description: '"Ratio/Segments"',
        },
        peg$c134 = 'Ratio/Points',
        peg$c135 = {
          type: 'literal',
          value: 'Ratio/Points',
          description: '"Ratio/Points"',
        },
        peg$c136 = 'Coordinates',
        peg$c137 = {
          type: 'literal',
          value: 'Coordinates',
          description: '"Coordinates"',
        },
        peg$c138 = 'Abscissa',
        peg$c139 = {
          type: 'literal',
          value: 'Abscissa',
          description: '"Abscissa"',
        },
        peg$c140 = 'Ordinate',
        peg$c141 = {
          type: 'literal',
          value: 'Ordinate',
          description: '"Ordinate"',
        },
        peg$c142 = 'CoordinateDistance',
        peg$c143 = {
          type: 'literal',
          value: 'CoordinateDistance',
          description: '"CoordinateDistance"',
        },
        peg$c144 = 'Calculate',
        peg$c145 = {
          type: 'literal',
          value: 'Calculate',
          description: '"Calculate"',
        },
        peg$c146 = 'Parameter',
        peg$c147 = {
          type: 'literal',
          value: 'Parameter',
          description: '"Parameter"',
        },
        peg$c148 = 'ToggleVisibilityButton',
        peg$c149 = {
          type: 'literal',
          value: 'ToggleVisibilityButton',
          description: '"ToggleVisibilityButton"',
        },
        peg$c150 = 'ShowButton',
        peg$c151 = {
          type: 'literal',
          value: 'ShowButton',
          description: '"ShowButton"',
        },
        peg$c152 = 'HideButton',
        peg$c153 = {
          type: 'literal',
          value: 'HideButton',
          description: '"HideButton"',
        },
        peg$c154 = 'MoveButton',
        peg$c155 = {
          type: 'literal',
          value: 'MoveButton',
          description: '"MoveButton"',
        },
        peg$c156 = 'AnimateButton',
        peg$c157 = {
          type: 'literal',
          value: 'AnimateButton',
          description: '"AnimateButton"',
        },
        peg$c158 = 'SimultaneousButton',
        peg$c159 = {
          type: 'literal',
          value: 'SimultaneousButton',
          description: '"SimultaneousButton"',
        },
        peg$c160 = 'CoordSysByAxes',
        peg$c161 = {
          type: 'literal',
          value: 'CoordSysByAxes',
          description: '"CoordSysByAxes"',
        },
        peg$c162 = 'Origin&Unit',
        peg$c163 = {
          type: 'literal',
          value: 'Origin&Unit',
          description: '"Origin&Unit"',
        },
        peg$c164 = 'UnitCircle',
        peg$c165 = {
          type: 'literal',
          value: 'UnitCircle',
          description: '"UnitCircle"',
        },
        peg$c166 = 'Locus',
        peg$c167 = { type: 'literal', value: 'Locus', description: '"Locus"' },
        peg$c168 = 'FunctionPlot',
        peg$c169 = {
          type: 'literal',
          value: 'FunctionPlot',
          description: '"FunctionPlot"',
        },
        peg$c170 = 'Function',
        peg$c171 = {
          type: 'literal',
          value: 'Function',
          description: '"Function"',
        },
        peg$c172 = 'FixedText',
        peg$c173 = {
          type: 'literal',
          value: 'FixedText',
          description: '"FixedText"',
        },
        peg$c174 = 'PeggedText',
        peg$c175 = {
          type: 'literal',
          value: 'PeggedText',
          description: '"PeggedText"',
        },
        peg$c176 = 'ConcatText',
        peg$c177 = {
          type: 'literal',
          value: 'ConcatText',
          description: '"ConcatText"',
        },
        peg$c178 = 'red',
        peg$c179 = { type: 'literal', value: 'red', description: '"red"' },
        peg$c180 = 'green',
        peg$c181 = { type: 'literal', value: 'green', description: '"green"' },
        peg$c182 = 'blue',
        peg$c183 = { type: 'literal', value: 'blue', description: '"blue"' },
        peg$c184 = 'black',
        peg$c185 = { type: 'literal', value: 'black', description: '"black"' },
        peg$c186 = 'magenta',
        peg$c187 = {
          type: 'literal',
          value: 'magenta',
          description: '"magenta"',
        },
        peg$c188 = 'white',
        peg$c189 = { type: 'literal', value: 'white', description: '"white"' },
        peg$c190 = 'cyan',
        peg$c191 = { type: 'literal', value: 'cyan', description: '"cyan"' },
        peg$c192 = 'yellow',
        peg$c193 = {
          type: 'literal',
          value: 'yellow',
          description: '"yellow"',
        },
        peg$c194 = 'color(',
        peg$c195 = {
          type: 'literal',
          value: 'color(',
          description: '"color("',
        },
        peg$c196 = function(red, green, blue) {
          return 'color(' + [red, green, blue].join() + ')';
        },
        peg$c197 = 'hairline',
        peg$c198 = {
          type: 'literal',
          value: 'hairline',
          description: '"hairline"',
        },
        peg$c199 = 'thin',
        peg$c200 = { type: 'literal', value: 'thin', description: '"thin"' },
        peg$c201 = 'mediumLine',
        peg$c202 = {
          type: 'literal',
          value: 'mediumLine',
          description: '"mediumLine"',
        },
        peg$c203 = 'thick',
        peg$c204 = { type: 'literal', value: 'thick', description: '"thick"' },
        peg$c205 = 'dashed',
        peg$c206 = {
          type: 'literal',
          value: 'dashed',
          description: '"dashed"',
        },
        peg$c207 = 'dotted',
        peg$c208 = {
          type: 'literal',
          value: 'dotted',
          description: '"dotted"',
        },
        peg$c209 = 'solid',
        peg$c210 = { type: 'literal', value: 'solid', description: '"solid"' },
        peg$c211 = 'dot',
        peg$c212 = { type: 'literal', value: 'dot', description: '"dot"' },
        peg$c213 = 'small',
        peg$c214 = { type: 'literal', value: 'small', description: '"small"' },
        peg$c215 = 'mediumPoint',
        peg$c216 = {
          type: 'literal',
          value: 'mediumPoint',
          description: '"mediumPoint"',
        },
        peg$c217 = 'large',
        peg$c218 = { type: 'literal', value: 'large', description: '"large"' },
        peg$c219 = 'hidden',
        peg$c220 = {
          type: 'literal',
          value: 'hidden',
          description: '"hidden"',
        },
        peg$c221 = 'suffix(',
        peg$c222 = {
          type: 'literal',
          value: 'suffix(',
          description: '"suffix("',
        },
        peg$c223 = function(s) {
          return "suffix('" + s + "')";
        },
        peg$c224 = 'auto',
        peg$c225 = { type: 'literal', value: 'auto', description: '"auto"' },
        peg$c226 = 'label(',
        peg$c227 = {
          type: 'literal',
          value: 'label(',
          description: '"label("',
        },
        peg$c228 = function(s) {
          return "label('" + s + "')";
        },
        peg$c229 = 'layer(',
        peg$c230 = {
          type: 'literal',
          value: 'layer(',
          description: '"layer("',
        },
        peg$c231 = function(d) {
          return 'layer(' + d + ')';
        },
        peg$c232 = 'traced',
        peg$c233 = {
          type: 'literal',
          value: 'traced',
          description: '"traced"',
        },
        peg$c234 = 'image(',
        peg$c235 = {
          type: 'literal',
          value: 'image(',
          description: '"image("',
        },
        peg$c236 = function(s) {
          return "image('" + s + "')";
        },
        peg$c237 = 'bold',
        peg$c238 = { type: 'literal', value: 'bold', description: '"bold"' },
        peg$c239 = 'italic',
        peg$c240 = {
          type: 'literal',
          value: 'italic',
          description: '"italic"',
        },
        peg$c241 = 'plain',
        peg$c242 = { type: 'literal', value: 'plain', description: '"plain"' },
        peg$c243 = 'justifyLeft',
        peg$c244 = {
          type: 'literal',
          value: 'justifyLeft',
          description: '"justifyLeft"',
        },
        peg$c245 = 'justifyRight',
        peg$c246 = {
          type: 'literal',
          value: 'justifyRight',
          description: '"justifyRight"',
        },
        peg$c247 = 'justifyCenter',
        peg$c248 = {
          type: 'literal',
          value: 'justifyCenter',
          description: '"justifyCenter"',
        },
        peg$c249 = 'font(',
        peg$c250 = { type: 'literal', value: 'font(', description: '"font("' },
        peg$c251 = function(s) {
          return "font('" + s + "')";
        },
        peg$c252 = 'size(',
        peg$c253 = { type: 'literal', value: 'size(', description: '"size("' },
        peg$c254 = function(n) {
          return 'size(' + n + ')';
        },
        peg$c255 = 'digits(',
        peg$c256 = {
          type: 'literal',
          value: 'digits(',
          description: '"digits("',
        },
        peg$c257 = function(n) {
          return "digits('" + n + "')";
        },
        peg$c258 = 'medium',
        peg$c259 = {
          type: 'literal',
          value: 'medium',
          description: '"medium"',
        },
        peg$c260 = '-',
        peg$c261 = { type: 'literal', value: '-', description: '"-"' },
        peg$c262 = '.',
        peg$c263 = { type: 'literal', value: '.', description: '"."' },
        peg$c264 = 'e',
        peg$c265 = { type: 'literal', value: 'e', description: '"e"' },
        peg$c266 = function(s, w, f, e) {
          var estr = '',
            fstr = '';
          if (e) {
            estr = e.join('');
          }
          if (f) {
            fstr = '.' + (f[1] ? f[1] : '');
          }
          s = s ? s : '';
          return s + w + fstr + estr;
        },
        peg$c267 = function(s, f, e) {
          var estr = '',
            fstr = '';
          if (e) {
            estr = e.join('');
          }
          fstr = '.' + f[1];
          s = s ? s : '';
          return s + fstr + estr;
        },
        peg$c268 = "'",
        peg$c269 = { type: 'literal', value: "'", description: '"\'"' },
        peg$c270 = function(s) {
          return s[1].join('');
        },
        peg$c271 = /^[^']/,
        peg$c272 = { type: 'class', value: "[^']", description: "[^']" },
        peg$c273 = "''",
        peg$c274 = { type: 'literal', value: "''", description: '"\'\'"' },
        peg$c275 = function() {
          return '&apos;';
        },
        peg$c276 = function() {
          return '';
        },
        peg$c277 = '{',
        peg$c278 = { type: 'literal', value: '{', description: '"{"' },
        peg$c279 = /^[^}]/,
        peg$c280 = { type: 'class', value: '[^}]', description: '[^}]' },
        peg$c281 = '}',
        peg$c282 = { type: 'literal', value: '}', description: '"}"' },
        peg$c283 = ' ',
        peg$c284 = { type: 'literal', value: ' ', description: '" "' },
        peg$c285 = '\t',
        peg$c286 = { type: 'literal', value: '\t', description: '"\\t"' },
        peg$c287 = '\n',
        peg$c288 = { type: 'literal', value: '\n', description: '"\\n"' },
        peg$c289 = /^[0-9]/,
        peg$c290 = { type: 'class', value: '[0-9]', description: '[0-9]' },
        peg$c291 = function(d) {
          return d.join('');
        },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          );
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }

      function offset() {
        return peg$reportedPos;
      }

      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }

      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }

      function expected(description) {
        throw peg$buildException(
          null,
          [{ type: 'other', description: description }],
          peg$reportedPos
        );
      }

      function error(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }

      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;

          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === '\n') {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }

        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }

        return peg$cachedPosDetails;
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected) {
          var i = 1;

          expected.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });

          while (i < expected.length) {
            if (expected[i - 1] === expected[i]) {
              expected.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        function buildMessage(expected, found) {
          function stringEscape(s) {
            function hex(ch) {
              return ch
                .charCodeAt(0)
                .toString(16)
                .toUpperCase();
            }

            return s
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\x08/g, '\\b')
              .replace(/\t/g, '\\t')
              .replace(/\n/g, '\\n')
              .replace(/\f/g, '\\f')
              .replace(/\r/g, '\\r')
              .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              })
              .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              })
              .replace(/[\u0180-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              })
              .replace(/[\u1080-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
          }

          var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

          for (i = 0; i < expected.length; i++) {
            expectedDescs[i] = expected[i].description;
          }

          expectedDesc =
            expected.length > 1
              ? expectedDescs.slice(0, -1).join(', ') +
                ' or ' +
                expectedDescs[expected.length - 1]
              : expectedDescs[0];

          foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input';

          return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';
        }

        var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

        if (expected !== null) {
          cleanupExpected(expected);
        }

        return new SyntaxError(
          message !== null ? message : buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column
        );
      }

      function peg$parsestart() {
        var s0;

        s0 = peg$parsesketch();

        return s0;
      }

      function peg$parsesketch() {
        var s0, s1;

        s0 = [];
        s1 = peg$parseline();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parseline();
        }

        return s0;
      }

      function peg$parseline() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;

        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseobjectName();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseobjectArgumentList();
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseoptionalFormats();
                  if (s6 === peg$FAILED) {
                    s6 = peg$c2;
                  }
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s7 = peg$c3;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c4);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c5(s2, s4, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseobjectName() {
        var s0, s1;

        s0 = peg$currPos;
        s1 = peg$parsepointObject();
        if (s1 === peg$FAILED) {
          s1 = peg$parsestraightObject();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteriorObject();
            if (s1 === peg$FAILED) {
              s1 = peg$parsecircleObject();
              if (s1 === peg$FAILED) {
                s1 = peg$parsetransformObject();
                if (s1 === peg$FAILED) {
                  s1 = peg$parsecolorObject();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parsepictureObject();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parsemeasurementObject();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parsebuttonObject();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parsecoordinateSystemObject();
                          if (s1 === peg$FAILED) {
                            s1 = peg$parselociObject();
                            if (s1 === peg$FAILED) {
                              s1 = peg$parsefunctionObject();
                              if (s1 === peg$FAILED) {
                                s1 = peg$parsecaptionObject();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parseobjectArgumentList() {
        var s0, s1;

        s0 = [];
        s1 = peg$parseobjectArguments();
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = peg$parseobjectArguments();
          }
        } else {
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseoptionalFormats() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseoptionalFormat();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s8 = peg$c9;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseoptionalFormat();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c1;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c1;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c1;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c1;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s8 = peg$c9;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseoptionalFormat();
                        if (s10 !== peg$FAILED) {
                          s7 = [s7, s8, s9, s10];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$c1;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c1;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c1;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c1;
                  }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s6 = peg$c11;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c12);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13(s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseobjectArguments() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c16;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c18();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c14;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c15);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseargument();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c9;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseargument();
                    if (s8 !== peg$FAILED) {
                      s5 = [s5, s6, s7, s8];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c1;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c1;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c1;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c9;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseargument();
                      if (s8 !== peg$FAILED) {
                        s5 = [s5, s6, s7, s8];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$c1;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c1;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c1;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c19(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        }

        return s0;
      }

      function peg$parseargument() {
        var s0;

        s0 = peg$parsenumber();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring();
        }

        return s0;
      }

      function peg$parsepointObject() {
        var s0;

        if (input.substr(peg$currPos, 15) === peg$c20) {
          s0 = peg$c20;
          peg$currPos += 15;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c22) {
            s0 = peg$c22;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c23);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c24) {
              s0 = peg$c24;
              peg$currPos += 10;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c25);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c26) {
                s0 = peg$c26;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c27);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c28) {
                  s0 = peg$c28;
                  peg$currPos += 10;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c29);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c30) {
                    s0 = peg$c30;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c31);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c32) {
                      s0 = peg$c32;
                      peg$currPos += 9;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c33);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c34) {
                        s0 = peg$c34;
                        peg$currPos += 6;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c35);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 11) === peg$c36) {
                          s0 = peg$c36;
                          peg$currPos += 11;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c37);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 9) === peg$c38) {
                            s0 = peg$c38;
                            peg$currPos += 9;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c39);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 15) === peg$c40) {
                              s0 = peg$c40;
                              peg$currPos += 15;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c41);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 20) === peg$c42) {
                                s0 = peg$c42;
                                peg$currPos += 20;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c43);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 11) === peg$c44) {
                                  s0 = peg$c44;
                                  peg$currPos += 11;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c45);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsestraightObject() {
        var s0;

        if (input.substr(peg$currPos, 7) === peg$c46) {
          s0 = peg$c46;
          peg$currPos += 7;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c47);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c48) {
            s0 = peg$c48;
            peg$currPos += 3;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c49);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c50) {
              s0 = peg$c50;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c51);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 13) === peg$c52) {
                s0 = peg$c52;
                peg$currPos += 13;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c53);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c54) {
                  s0 = peg$c54;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c55);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c56) {
                    s0 = peg$c56;
                    peg$currPos += 5;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c57);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c58) {
                      s0 = peg$c58;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c59);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 8) === peg$c60) {
                        s0 = peg$c60;
                        peg$currPos += 8;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c61);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 14) === peg$c62) {
                          s0 = peg$c62;
                          peg$currPos += 14;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 12) === peg$c64) {
                            s0 = peg$c64;
                            peg$currPos += 12;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c65);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parseinteriorObject() {
        var s0;

        if (input.substr(peg$currPos, 7) === peg$c66) {
          s0 = peg$c66;
          peg$currPos += 7;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c67);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 15) === peg$c68) {
            s0 = peg$c68;
            peg$currPos += 15;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c69);
            }
          }
        }

        return s0;
      }

      function peg$parsecircleObject() {
        var s0;

        if (input.substr(peg$currPos, 16) === peg$c70) {
          s0 = peg$c70;
          peg$currPos += 16;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c71);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c72) {
            s0 = peg$c72;
            peg$currPos += 6;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
        }

        return s0;
      }

      function peg$parsetransformObject() {
        var s0;

        if (input.substr(peg$currPos, 10) === peg$c74) {
          s0 = peg$c74;
          peg$currPos += 10;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 21) === peg$c76) {
            s0 = peg$c76;
            peg$currPos += 21;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 17) === peg$c78) {
              s0 = peg$c78;
              peg$currPos += 17;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c79);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 20) === peg$c80) {
                s0 = peg$c80;
                peg$currPos += 20;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c81);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c82) {
                  s0 = peg$c82;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c83);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 20) === peg$c84) {
                    s0 = peg$c84;
                    peg$currPos += 20;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c85);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 22) === peg$c86) {
                      s0 = peg$c86;
                      peg$currPos += 22;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c87);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 8) === peg$c88) {
                        s0 = peg$c88;
                        peg$currPos += 8;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c89);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 17) === peg$c90) {
                          s0 = peg$c90;
                          peg$currPos += 17;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c91);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 37) === peg$c92) {
                            s0 = peg$c92;
                            peg$currPos += 37;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c93);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 16) === peg$c94) {
                              s0 = peg$c94;
                              peg$currPos += 16;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c95);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 37) === peg$c96) {
                                s0 = peg$c96;
                                peg$currPos += 37;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c97);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 38) === peg$c98) {
                                  s0 = peg$c98;
                                  peg$currPos += 38;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c99);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (
                                    input.substr(peg$currPos, 11) === peg$c100
                                  ) {
                                    s0 = peg$c100;
                                    peg$currPos += 11;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c101);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsecolorObject() {
        var s0;

        if (input.substr(peg$currPos, 18) === peg$c102) {
          s0 = peg$c102;
          peg$currPos += 18;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c103);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 19) === peg$c104) {
            s0 = peg$c104;
            peg$currPos += 19;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c105);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c106) {
              s0 = peg$c106;
              peg$currPos += 13;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c107);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 13) === peg$c108) {
                s0 = peg$c108;
                peg$currPos += 13;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c109);
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsepictureObject() {
        var s0;

        if (input.substr(peg$currPos, 5) === peg$c110) {
          s0 = peg$c110;
          peg$currPos += 5;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 12) === peg$c112) {
            s0 = peg$c112;
            peg$currPos += 12;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c113);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 18) === peg$c114) {
              s0 = peg$c114;
              peg$currPos += 18;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c115);
              }
            }
          }
        }

        return s0;
      }

      function peg$parsemeasurementObject() {
        var s0;

        if (input.substr(peg$currPos, 6) === peg$c116) {
          s0 = peg$c116;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c117);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c118) {
            s0 = peg$c118;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 9) === peg$c120) {
              s0 = peg$c120;
              peg$currPos += 9;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c121);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 13) === peg$c122) {
                s0 = peg$c122;
                peg$currPos += 13;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c123);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c124) {
                  s0 = peg$c124;
                  peg$currPos += 6;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c125);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c126) {
                    s0 = peg$c126;
                    peg$currPos += 4;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c127);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c128) {
                      s0 = peg$c128;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c129);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 8) === peg$c130) {
                        s0 = peg$c130;
                        peg$currPos += 8;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c131);
                        }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 14) === peg$c132) {
                          s0 = peg$c132;
                          peg$currPos += 14;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c133);
                          }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.substr(peg$currPos, 12) === peg$c134) {
                            s0 = peg$c134;
                            peg$currPos += 12;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c135);
                            }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 11) === peg$c136) {
                              s0 = peg$c136;
                              peg$currPos += 11;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c137);
                              }
                            }
                            if (s0 === peg$FAILED) {
                              if (input.substr(peg$currPos, 8) === peg$c138) {
                                s0 = peg$c138;
                                peg$currPos += 8;
                              } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c139);
                                }
                              }
                              if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c140) {
                                  s0 = peg$c140;
                                  peg$currPos += 8;
                                } else {
                                  s0 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c141);
                                  }
                                }
                                if (s0 === peg$FAILED) {
                                  if (
                                    input.substr(peg$currPos, 18) === peg$c142
                                  ) {
                                    s0 = peg$c142;
                                    peg$currPos += 18;
                                  } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c143);
                                    }
                                  }
                                  if (s0 === peg$FAILED) {
                                    if (
                                      input.substr(peg$currPos, 9) === peg$c144
                                    ) {
                                      s0 = peg$c144;
                                      peg$currPos += 9;
                                    } else {
                                      s0 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c145);
                                      }
                                    }
                                    if (s0 === peg$FAILED) {
                                      if (
                                        input.substr(peg$currPos, 9) ===
                                        peg$c146
                                      ) {
                                        s0 = peg$c146;
                                        peg$currPos += 9;
                                      } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c147);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsebuttonObject() {
        var s0;

        if (input.substr(peg$currPos, 22) === peg$c148) {
          s0 = peg$c148;
          peg$currPos += 22;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c149);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 10) === peg$c150) {
            s0 = peg$c150;
            peg$currPos += 10;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c151);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c152) {
              s0 = peg$c152;
              peg$currPos += 10;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c153);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 10) === peg$c154) {
                s0 = peg$c154;
                peg$currPos += 10;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c155);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 13) === peg$c156) {
                  s0 = peg$c156;
                  peg$currPos += 13;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c157);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 18) === peg$c158) {
                    s0 = peg$c158;
                    peg$currPos += 18;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c159);
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsecoordinateSystemObject() {
        var s0;

        if (input.substr(peg$currPos, 14) === peg$c160) {
          s0 = peg$c160;
          peg$currPos += 14;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c161);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 11) === peg$c162) {
            s0 = peg$c162;
            peg$currPos += 11;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c163);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c164) {
              s0 = peg$c164;
              peg$currPos += 10;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c165);
              }
            }
          }
        }

        return s0;
      }

      function peg$parselociObject() {
        var s0;

        if (input.substr(peg$currPos, 5) === peg$c166) {
          s0 = peg$c166;
          peg$currPos += 5;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c167);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 12) === peg$c168) {
            s0 = peg$c168;
            peg$currPos += 12;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c169);
            }
          }
        }

        return s0;
      }

      function peg$parsefunctionObject() {
        var s0;

        if (input.substr(peg$currPos, 8) === peg$c170) {
          s0 = peg$c170;
          peg$currPos += 8;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c171);
          }
        }

        return s0;
      }

      function peg$parsecaptionObject() {
        var s0;

        if (input.substr(peg$currPos, 9) === peg$c172) {
          s0 = peg$c172;
          peg$currPos += 9;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c173);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 10) === peg$c174) {
            s0 = peg$c174;
            peg$currPos += 10;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c175);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c176) {
              s0 = peg$c176;
              peg$currPos += 10;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c177);
              }
            }
          }
        }

        return s0;
      }

      function peg$parseoptionalFormat() {
        var s0;

        s0 = peg$parsenamedColor();
        if (s0 === peg$FAILED) {
          s0 = peg$parsergbColor();
          if (s0 === peg$FAILED) {
            s0 = peg$parselineFormat();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepointFormat();
              if (s0 === peg$FAILED) {
                s0 = peg$parsevisibilityFormat();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesuffixFormat();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseautoStartFormat();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parselabelFormat();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parselayerFormat();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsetracedFormat();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseimageFormat();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsetextFormat();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseprecisionFormat();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parselegacyFormat();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsenamedColor() {
        var s0;

        if (input.substr(peg$currPos, 3) === peg$c178) {
          s0 = peg$c178;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c179);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c180) {
            s0 = peg$c180;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c181);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c182) {
              s0 = peg$c182;
              peg$currPos += 4;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c183);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c184) {
                s0 = peg$c184;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c185);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c186) {
                  s0 = peg$c186;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c187);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c188) {
                    s0 = peg$c188;
                    peg$currPos += 5;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c189);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c190) {
                      s0 = peg$c190;
                      peg$currPos += 4;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c191);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c192) {
                        s0 = peg$c192;
                        peg$currPos += 6;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c193);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsergbColor() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c194) {
          s1 = peg$c194;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c195);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c9;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsenumber();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s9 = peg$c9;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parsenumber();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parse_();
                              if (s12 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s13 = peg$c16;
                                  peg$currPos++;
                                } else {
                                  s13 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c17);
                                  }
                                }
                                if (s13 !== peg$FAILED) {
                                  peg$reportedPos = s0;
                                  s1 = peg$c196(s3, s7, s11);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c1;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c1;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c1;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c1;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parselineFormat() {
        var s0;

        if (input.substr(peg$currPos, 8) === peg$c197) {
          s0 = peg$c197;
          peg$currPos += 8;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c198);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c199) {
            s0 = peg$c199;
            peg$currPos += 4;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c200);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c201) {
              s0 = peg$c201;
              peg$currPos += 10;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c202);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c203) {
                s0 = peg$c203;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c204);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c205) {
                  s0 = peg$c205;
                  peg$currPos += 6;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c206);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c207) {
                    s0 = peg$c207;
                    peg$currPos += 6;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c208);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c209) {
                      s0 = peg$c209;
                      peg$currPos += 5;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c210);
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsepointFormat() {
        var s0;

        if (input.substr(peg$currPos, 3) === peg$c211) {
          s0 = peg$c211;
          peg$currPos += 3;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c212);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c213) {
            s0 = peg$c213;
            peg$currPos += 5;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c214);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 11) === peg$c215) {
              s0 = peg$c215;
              peg$currPos += 11;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c216);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c217) {
                s0 = peg$c217;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c218);
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsevisibilityFormat() {
        var s0;

        if (input.substr(peg$currPos, 6) === peg$c219) {
          s0 = peg$c219;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c220);
          }
        }

        return s0;
      }

      function peg$parsesuffixFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c221) {
          s1 = peg$c221;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c222);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsestring();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c223(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseautoStartFormat() {
        var s0;

        if (input.substr(peg$currPos, 4) === peg$c224) {
          s0 = peg$c224;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c225);
          }
        }

        return s0;
      }

      function peg$parselabelFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c226) {
          s1 = peg$c226;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c227);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsestring();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c228(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parselayerFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c229) {
          s1 = peg$c229;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c230);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsedigits();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c231(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsetracedFormat() {
        var s0;

        if (input.substr(peg$currPos, 6) === peg$c232) {
          s0 = peg$c232;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c233);
          }
        }

        return s0;
      }

      function peg$parseimageFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c234) {
          s1 = peg$c234;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c235);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsestring();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c236(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsetextFormat() {
        var s0;

        if (input.substr(peg$currPos, 4) === peg$c237) {
          s0 = peg$c237;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c238);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c239) {
            s0 = peg$c239;
            peg$currPos += 6;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c240);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c241) {
              s0 = peg$c241;
              peg$currPos += 5;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c242);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parsesizeTextFormat();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefontTextFormat();
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 11) === peg$c243) {
                    s0 = peg$c243;
                    peg$currPos += 11;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c244);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 12) === peg$c245) {
                      s0 = peg$c245;
                      peg$currPos += 12;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c246);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 13) === peg$c247) {
                        s0 = peg$c247;
                        peg$currPos += 13;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c248);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parsefontTextFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c249) {
          s1 = peg$c249;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c250);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsestring();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c251(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsesizeTextFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c252) {
          s1 = peg$c252;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c253);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c254(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseprecisionFormat() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c255) {
          s1 = peg$c255;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c256);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenumber();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c16;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c257(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parselegacyFormat() {
        var s0;

        if (input.substr(peg$currPos, 6) === peg$c258) {
          s0 = peg$c258;
          peg$currPos += 6;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c259);
          }
        }

        return s0;
      }

      function peg$parsenumber() {
        var s0;

        s0 = peg$parsedigitsLeftOfDot();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedigitsRightOfDot();
        }

        return s0;
      }

      function peg$parsedigitsLeftOfDot() {
        var s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c260;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c261);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c262;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c263);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedigits();
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 101) {
                s5 = peg$c264;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c265);
                }
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s6 = peg$c260;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c261);
                  }
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$c2;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsedigits();
                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c1;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c1;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c1;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c266(s1, s2, s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsedigitsRightOfDot() {
        var s0, s1, s2, s3, s4, s5, s6;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c260;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c261);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c262;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c263);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsedigits();
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c1;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 101) {
              s4 = peg$c264;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c265);
              }
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c260;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c261);
                }
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsedigits();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c1;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c1;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c1;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c267(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsestring() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s2 = peg$c268;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c269);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsechar();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsechar();
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s4 = peg$c268;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c269);
              }
            }
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$c1;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c1;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c270(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parsechar() {
        var s0, s1;

        if (peg$c271.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c272);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c273) {
            s1 = peg$c273;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c274);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c275();
          }
          s0 = s1;
        }

        return s0;
      }

      function peg$parse_() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsecomment();
        if (s2 === peg$FAILED) {
          s2 = peg$parsewhite();
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsecomment();
          if (s2 === peg$FAILED) {
            s2 = peg$parsewhite();
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c276();
        }
        s0 = s1;

        return s0;
      }

      function peg$parsecomment() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c277;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c278);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c279.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c280);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c279.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c280);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c281;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c282);
              }
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsewhite() {
        var s0;

        if (input.charCodeAt(peg$currPos) === 32) {
          s0 = peg$c283;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c284);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 9) {
            s0 = peg$c285;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c286);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c287;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c288);
              }
            }
          }
        }

        return s0;
      }

      function peg$parsedigits() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        if (peg$c289.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c290);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c289.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c290);
              }
            }
          }
        } else {
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c291(s1);
        }
        s0 = s1;

        return s0;
      }

      var objCount = 0;

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: 'end', description: 'end of input' });
        }

        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }

    return {
      SyntaxError: SyntaxError,
      parse: parse,
    };
  })();

  GSP.mfsParser = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;

      this.name = 'SyntaxError';
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
      var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction = peg$parsestart,
        peg$c0 = function(expr) {
          return expr;
        },
        peg$c1 = peg$FAILED,
        peg$c2 = '<|',
        peg$c3 = { type: 'literal', value: '<|', description: '"<|"' },
        peg$c4 = [],
        peg$c5 = '>',
        peg$c6 = { type: 'literal', value: '>', description: '">"' },
        peg$c7 = function(expr) {
          return { type: 'abs', value: expr };
        },
        peg$c8 = '<[',
        peg$c9 = { type: 'literal', value: '<[', description: '"<["' },
        peg$c10 = function(expr) {
          return { type: 'bracket', value: expr };
        },
        peg$c11 = '<{',
        peg$c12 = { type: 'literal', value: '<{', description: '"<{"' },
        peg$c13 = function(expr) {
          return { type: 'curly', value: expr };
        },
        peg$c14 = '</',
        peg$c15 = { type: 'literal', value: '</', description: '"</"' },
        peg$c16 = function(expr1, expr2) {
          return { type: 'fraction', value: [expr1, expr2] };
        },
        peg$c17 = '<H',
        peg$c18 = { type: 'literal', value: '<H', description: '"<H"' },
        peg$c19 = function(msg) {
          return { type: 'horizontal', value: msg };
        },
        peg$c20 = '<%',
        peg$c21 = { type: 'literal', value: '<%', description: '"<%"' },
        peg$c22 = /^[a-zA-Z0-9_\-]/,
        peg$c23 = {
          type: 'class',
          value: '[a-zA-Z0-9_\\-]',
          description: '[a-zA-Z0-9_\\-]',
        },
        peg$c24 = function(name) {
          return { type: 'parameter', value: name.join('') };
        },
        peg$c25 = '<I',
        peg$c26 = { type: 'literal', value: '<I', description: '"<I"' },
        peg$c27 = function(name) {
          return { type: 'input', value: name.join('') };
        },
        peg$c28 = '<(',
        peg$c29 = { type: 'literal', value: '<(', description: '"<("' },
        peg$c30 = function(expr) {
          return { type: 'paren', value: expr };
        },
        peg$c31 = '<R',
        peg$c32 = { type: 'literal', value: '<R', description: '"<R"' },
        peg$c33 = function(expr) {
          return { type: 'root', value: expr };
        },
        peg$c34 = '<S',
        peg$c35 = { type: 'literal', value: '<S', description: '"<S"' },
        peg$c36 = function(format, expr) {
          var processedFormat = format,
            i;
          if (format) {
            processedFormat = []; // make a copy of format removing legacy formats
            for (i = 0; i < format.length; i++) {
              if (format[i].code !== 'legacyOverbar') {
                processedFormat.push(format[i]);
              } else {
                // legacy 'O' overbar format becomes overbar node
                expr = {
                  type: 'overbar',
                  variant: parseInt(format[i].value, 16),
                  value: expr,
                };
              }
            }
            processedFormat.push(expr);
          }
          return { type: 'style', value: processedFormat };
        },
        peg$c37 = /^[OGLPRSTUW#+]/,
        peg$c38 = {
          type: 'class',
          value: '[OGLPRSTUW#+]',
          description: '[OGLPRSTUW#+]',
        },
        peg$c39 = /^[0-9a-fA-F]/,
        peg$c40 = {
          type: 'class',
          value: '[0-9a-fA-F]',
          description: '[0-9a-fA-F]',
        },
        peg$c41 = function(code, num) {
          var codeMap = {
            O: 'legacyOverbar',
            G: 'green',
            L: 'blue',
            P: 'fontFamily',
            R: 'red',
            S: 'fontStyle',
            T: 'tightness',
            U: 'underbar',
            W: 'fontWeight',
            '#': 'fontSize',
            '+': 'diminish-size',
          };
          if (!num || num.length === 0) {
            return { code: codeMap[code], value: '0' };
          } else {
            return {
              code: codeMap[code],
              value: num.length === 1 ? num[0] : num.join(''),
            };
          }
        },
        peg$c42 = '<-',
        peg$c43 = { type: 'literal', value: '<-', description: '"<-"' },
        peg$c44 = function(expr1, expr2) {
          return { type: 'sub', value: [expr1, expr2] };
        },
        peg$c45 = '<+',
        peg$c46 = { type: 'literal', value: '<+', description: '"<+"' },
        peg$c47 = function(expr1, expr2) {
          return { type: 'super', value: [expr1, expr2] };
        },
        peg$c48 = '<!',
        peg$c49 = { type: 'literal', value: '<!', description: '"<!"' },
        peg$c50 = /^[0-9A-Fa-f]/,
        peg$c51 = {
          type: 'class',
          value: '[0-9A-Fa-f]',
          description: '[0-9A-Fa-f]',
        },
        peg$c52 = function(code) {
          return { type: 'symbol', value: code.join('') };
        },
        peg$c53 = '<?',
        peg$c54 = { type: 'literal', value: '<?', description: '"<?"' },
        peg$c55 = 'x',
        peg$c56 = { type: 'literal', value: 'x', description: '"x"' },
        peg$c57 = function(code, refcon, exprs) {
          return {
            type: 'switch',
            visibleNode: parseInt(code, 16),
            value: exprs,
            refCon: refcon.join(''),
          };
        },
        peg$c58 = function(code, exprs) {
          return {
            type: 'switch',
            visibleNode: parseInt(code, 16),
            value: exprs,
            refCon: '',
          };
        },
        peg$c59 = "<T''>",
        peg$c60 = { type: 'literal', value: "<T''>", description: '"<T\'\'>"' },
        peg$c61 = function() {
          return { type: 'text', value: '' };
        },
        peg$c62 = '<T"">',
        peg$c63 = {
          type: 'literal',
          value: '<T"">',
          description: '"<T\\"\\">"',
        },
        peg$c64 = "<T'",
        peg$c65 = { type: 'literal', value: "<T'", description: '"<T\'"' },
        peg$c66 = "'>",
        peg$c67 = { type: 'literal', value: "'>", description: '"\'>"' },
        peg$c68 = function(msg) {
          return { type: 'text', value: msg };
        },
        peg$c69 = '<T"',
        peg$c70 = { type: 'literal', value: '<T"', description: '"<T\\""' },
        peg$c71 = '">',
        peg$c72 = { type: 'literal', value: '">', description: '"\\">"' },
        peg$c73 = function(chars) {
          return chars.join('');
        },
        peg$c74 = /^[^'\\]/,
        peg$c75 = { type: 'class', value: "[^'\\\\]", description: "[^'\\\\]" },
        peg$c76 = '\\\\',
        peg$c77 = { type: 'literal', value: '\\\\', description: '"\\\\\\\\"' },
        peg$c78 = function() {
          return '\\';
        },
        peg$c79 = "\\'",
        peg$c80 = { type: 'literal', value: "\\'", description: '"\\\\\'"' },
        peg$c81 = function() {
          return "'";
        },
        peg$c82 = '\\"',
        peg$c83 = { type: 'literal', value: '\\"', description: '"\\\\\\""' },
        peg$c84 = function() {
          return '"';
        },
        peg$c85 = /^[^"\\]/,
        peg$c86 = { type: 'class', value: '[^"\\\\]', description: '[^"\\\\]' },
        peg$c87 = '<V',
        peg$c88 = { type: 'literal', value: '<V', description: '"<V"' },
        peg$c89 = null,
        peg$c90 = 'L',
        peg$c91 = { type: 'literal', value: 'L', description: '"L"' },
        peg$c92 = 'R',
        peg$c93 = { type: 'literal', value: 'R', description: '"R"' },
        peg$c94 = 'C',
        peg$c95 = { type: 'literal', value: 'C', description: '"C"' },
        peg$c96 = function(align, expr) {
          return { type: 'vertical', alignment: align, value: expr };
        },
        peg$c97 = '<0>',
        peg$c98 = { type: 'literal', value: '<0>', description: '"<0>"' },
        peg$c99 = function() {
          return { type: 'text', value: '' };
        },
        peg$c100 = '<F',
        peg$c101 = { type: 'literal', value: '<F', description: '"<F"' },
        peg$c102 = /^[^>]/,
        peg$c103 = { type: 'class', value: '[^>]', description: '[^>]' },
        peg$c104 = function(codes) {
          return { type: 'future', value: codes.join('') };
        },
        peg$c105 = '<O',
        peg$c106 = { type: 'literal', value: '<O', description: '"<O"' },
        peg$c107 = function(code, expr) {
          return {
            type: 'overbar',
            variant: parseInt(code.join(''), 16),
            value: expr,
          };
        },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          );
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }

      function offset() {
        return peg$reportedPos;
      }

      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }

      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }

      function expected(description) {
        throw peg$buildException(
          null,
          [{ type: 'other', description: description }],
          peg$reportedPos
        );
      }

      function error(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }

      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;

          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === '\n') {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }

        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }

        return peg$cachedPosDetails;
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected) {
          var i = 1;

          expected.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });

          while (i < expected.length) {
            if (expected[i - 1] === expected[i]) {
              expected.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        function buildMessage(expected, found) {
          function stringEscape(s) {
            function hex(ch) {
              return ch
                .charCodeAt(0)
                .toString(16)
                .toUpperCase();
            }

            return s
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\x08/g, '\\b')
              .replace(/\t/g, '\\t')
              .replace(/\n/g, '\\n')
              .replace(/\f/g, '\\f')
              .replace(/\r/g, '\\r')
              .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              })
              .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              })
              .replace(/[\u0180-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              })
              .replace(/[\u1080-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
          }

          var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

          for (i = 0; i < expected.length; i++) {
            expectedDescs[i] = expected[i].description;
          }

          expectedDesc =
            expected.length > 1
              ? expectedDescs.slice(0, -1).join(', ') +
                ' or ' +
                expectedDescs[expected.length - 1]
              : expectedDescs[0];

          foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input';

          return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';
        }

        var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

        if (expected !== null) {
          cleanupExpected(expected);
        }

        return new SyntaxError(
          message !== null ? message : buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column
        );
      }

      function peg$parsestart() {
        var s0, s1;

        s0 = peg$currPos;
        s1 = peg$parseexpr();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c0(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parseexpr() {
        var s0;

        s0 = peg$parsetext();
        if (s0 === peg$FAILED) {
          s0 = peg$parsehorizontal();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestyle();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesub();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesuper();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseparen();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseparameter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseabs();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseblankline();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsebracket();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsecurly();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsefraction();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsefuture();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseinput();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseroot();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsesymbol();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseswitch();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parsevertical();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseoverbar();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parseabs() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c2) {
          s1 = peg$c2;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c7(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsebracket() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c8) {
          s1 = peg$c8;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c10(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsecurly() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c11) {
          s1 = peg$c11;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsefraction() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c14) {
          s1 = peg$c14;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpr();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c16(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsehorizontal() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c17) {
          s1 = peg$c17;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c19(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseparameter() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c20) {
          s1 = peg$c20;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c21);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c22.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c23);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c22.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c23);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c24(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseinput() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c25) {
          s1 = peg$c25;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c26);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c22.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c23);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c22.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c23);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c27(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseparen() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c28) {
          s1 = peg$c28;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c29);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c30(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseroot() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c31) {
          s1 = peg$c31;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c32);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseexpr();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseexpr();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsestyle() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c34) {
          s1 = peg$c34;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestylespec();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestylespec();
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c36(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsestylespec() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c39.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c40);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c39.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c40);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c41(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsesub() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c42) {
          s1 = peg$c42;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpr();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c44(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsesuper() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c45) {
          s1 = peg$c45;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpr();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c47(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parsesymbol() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c48) {
          s1 = peg$c48;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c49);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c51);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c50.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }
            }
          } else {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c52(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseswitch() {
        var s0, s1, s2, s3, s4, s5, s6;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c53) {
          s1 = peg$c53;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c54);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c51);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c50.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c51);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 120) {
              s3 = peg$c55;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c56);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c50.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c50.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c51);
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseexpr();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseexpr();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s6 = peg$c5;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c57(s2, s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c53) {
            s1 = peg$c53;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c50.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c51);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c50.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseexpr();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseexpr();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s4 = peg$c5;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        }

        return s0;
      }

      function peg$parsetext() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c59) {
          s1 = peg$c59;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c60);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c61();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c62) {
            s1 = peg$c62;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c63);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c61();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c64) {
              s1 = peg$c64;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsesqchars();
              if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c66) {
                  s3 = peg$c66;
                  peg$currPos += 2;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c67);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c68(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c69) {
                s1 = peg$c69;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c70);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsedqchars();
                if (s2 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c71) {
                    s3 = peg$c71;
                    peg$currPos += 2;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c72);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c1;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c1;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            }
          }
        }

        return s0;
      }

      function peg$parsesqchars() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsesqchar();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsesqchar();
          }
        } else {
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c73(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parsesqchar() {
        var s0, s1;

        if (peg$c74.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c75);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c76) {
            s1 = peg$c76;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c78();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c79) {
              s1 = peg$c79;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c80);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c81();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c82) {
                s1 = peg$c82;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c83);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c84();
              }
              s0 = s1;
            }
          }
        }

        return s0;
      }

      function peg$parsedqchars() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedqchar();
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsedqchar();
          }
        } else {
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c73(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parsedqchar() {
        var s0, s1;

        if (peg$c85.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c86);
          }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c76) {
            s1 = peg$c76;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c78();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c82) {
              s1 = peg$c82;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c83);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c84();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c79) {
                s1 = peg$c79;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c80);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c81();
              }
              s0 = s1;
            }
          }
        }

        return s0;
      }

      function peg$parsevertical() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c87) {
          s1 = peg$c87;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c88);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 76) {
            s2 = peg$c90;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c91);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 82) {
              s2 = peg$c92;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c93);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 67) {
                s2 = peg$c94;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c95);
                }
              }
            }
          }
          if (s2 === peg$FAILED) {
            s2 = peg$c89;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseexpr();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseexpr();
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c96(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseblankline() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c98);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c99();
        }
        s0 = s1;

        return s0;
      }

      function peg$parsefuture() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c100) {
          s1 = peg$c100;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c101);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c102.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c103);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c102.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c103);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c104(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      function peg$parseoverbar() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c105) {
          s1 = peg$c105;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c106);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c50.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c51);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c50.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c51);
                }
              }
            }
          } else {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpr();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s4 = peg$c5;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c107(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c1;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c1;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c1;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c1;
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: 'end', description: 'end of input' });
        }

        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }

    return {
      SyntaxError: SyntaxError,
      parse: parse,
    };
  })();

  GSP.sQueryParser = (function() {
    /*
     * Generated by PEG.js 0.8.0.
     *
     * http://pegjs.majda.cz/
     */

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function SyntaxError(message, expected, found, offset, line, column) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.offset = offset;
      this.line = line;
      this.column = column;

      this.name = 'SyntaxError';
    }

    peg$subclass(SyntaxError, Error);

    function parse(input) {
      var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction = peg$parsestart,
        peg$c0 = peg$FAILED,
        peg$c1 = [],
        peg$c2 = ',',
        peg$c3 = { type: 'literal', value: ',', description: '","' },
        peg$c4 = function(first, more) {
          var parts = [],
            ix;
          if (first) {
            parts.push(first);
          }
          for (ix = 0; ix < more.length; ix += 1) {
            parts.push(more[ix][1]);
          }
          return parts;
        },
        peg$c5 = null,
        peg$c6 = function(base, mods) {
          var rslt = { type: 'selectorAnd' },
            parts = [];
          if (base) {
            parts.push(base);
          }
          parts = parts.concat(mods);
          if (parts.length === 1) {
            return parts[0];
          } else {
            rslt.parts = parts;
            return rslt;
          }
        },
        peg$c7 = '*',
        peg$c8 = { type: 'literal', value: '*', description: '"*"' },
        peg$c9 = function() {
          return { type: 'global' };
        },
        peg$c10 = function(name) {
          return { type: 'kind', name: name };
        },
        peg$c11 = '#',
        peg$c12 = { type: 'literal', value: '#', description: '"#"' },
        peg$c13 = function(name) {
          return { type: 'id', name: name };
        },
        peg$c14 = '.',
        peg$c15 = { type: 'literal', value: '.', description: '"."' },
        peg$c16 = function(name) {
          return { type: 'class', name: name };
        },
        peg$c17 = '[',
        peg$c18 = { type: 'literal', value: '[', description: '"["' },
        peg$c19 = ']',
        peg$c20 = { type: 'literal', value: ']', description: '"]"' },
        peg$c21 = function(name, oper, value) {
          return { type: 'attr', name: name, oper: oper, value: value };
        },
        peg$c22 = '=',
        peg$c23 = { type: 'literal', value: '=', description: '"="' },
        peg$c24 = 'true',
        peg$c25 = { type: 'literal', value: 'true', description: '"true"' },
        peg$c26 = function() {
          return true;
        },
        peg$c27 = 'false',
        peg$c28 = { type: 'literal', value: 'false', description: '"false"' },
        peg$c29 = function() {
          return false;
        },
        peg$c30 = /^[0-9a-zA-Z_]/,
        peg$c31 = {
          type: 'class',
          value: '[0-9a-zA-Z_]',
          description: '[0-9a-zA-Z_]',
        },
        peg$c32 = function(chars) {
          return chars.join('');
        },
        peg$c33 = '"',
        peg$c34 = { type: 'literal', value: '"', description: '"\\""' },
        peg$c35 = /^[^\n\r\f\\"]/,
        peg$c36 = {
          type: 'class',
          value: '[^\\n\\r\\f\\\\"]',
          description: '[^\\n\\r\\f\\\\"]',
        },
        peg$c37 = '\\',
        peg$c38 = { type: 'literal', value: '\\', description: '"\\\\"' },
        peg$c39 = function(nl) {
          return nl;
        },
        peg$c40 = function(chars) {
          return chars.join('');
        },
        peg$c41 = "'",
        peg$c42 = { type: 'literal', value: "'", description: '"\'"' },
        peg$c43 = /^[^\n\r\f\\']/,
        peg$c44 = {
          type: 'class',
          value: "[^\\n\\r\\f\\\\']",
          description: "[^\\n\\r\\f\\\\']",
        },
        peg$c45 = '\n',
        peg$c46 = { type: 'literal', value: '\n', description: '"\\n"' },
        peg$c47 = '\r\n',
        peg$c48 = { type: 'literal', value: '\r\n', description: '"\\r\\n"' },
        peg$c49 = '\r',
        peg$c50 = { type: 'literal', value: '\r', description: '"\\r"' },
        peg$c51 = '\f',
        peg$c52 = { type: 'literal', value: '\f', description: '"\\f"' },
        peg$c53 = /^[^\r\n\f0-9a-fA-F]/,
        peg$c54 = {
          type: 'class',
          value: '[^\\r\\n\\f0-9a-fA-F]',
          description: '[^\\r\\n\\f0-9a-fA-F]',
        },
        peg$c55 = function(char_) {
          return char_;
        },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          );
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$reportedPos, peg$currPos);
      }

      function offset() {
        return peg$reportedPos;
      }

      function line() {
        return peg$computePosDetails(peg$reportedPos).line;
      }

      function column() {
        return peg$computePosDetails(peg$reportedPos).column;
      }

      function expected(description) {
        throw peg$buildException(
          null,
          [{ type: 'other', description: description }],
          peg$reportedPos
        );
      }

      function error(message) {
        throw peg$buildException(message, null, peg$reportedPos);
      }

      function peg$computePosDetails(pos) {
        function advance(details, startPos, endPos) {
          var p, ch;

          for (p = startPos; p < endPos; p++) {
            ch = input.charAt(p);
            if (ch === '\n') {
              if (!details.seenCR) {
                details.line++;
              }
              details.column = 1;
              details.seenCR = false;
            } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
              details.line++;
              details.column = 1;
              details.seenCR = true;
            } else {
              details.column++;
              details.seenCR = false;
            }
          }
        }

        if (peg$cachedPos !== pos) {
          if (peg$cachedPos > pos) {
            peg$cachedPos = 0;
            peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advance(peg$cachedPosDetails, peg$cachedPos, pos);
          peg$cachedPos = pos;
        }

        return peg$cachedPosDetails;
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildException(message, expected, pos) {
        function cleanupExpected(expected) {
          var i = 1;

          expected.sort(function(a, b) {
            if (a.description < b.description) {
              return -1;
            } else if (a.description > b.description) {
              return 1;
            } else {
              return 0;
            }
          });

          while (i < expected.length) {
            if (expected[i - 1] === expected[i]) {
              expected.splice(i, 1);
            } else {
              i++;
            }
          }
        }

        function buildMessage(expected, found) {
          function stringEscape(s) {
            function hex(ch) {
              return ch
                .charCodeAt(0)
                .toString(16)
                .toUpperCase();
            }

            return s
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\x08/g, '\\b')
              .replace(/\t/g, '\\t')
              .replace(/\n/g, '\\n')
              .replace(/\f/g, '\\f')
              .replace(/\r/g, '\\r')
              .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              })
              .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              })
              .replace(/[\u0180-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              })
              .replace(/[\u1080-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
          }

          var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

          for (i = 0; i < expected.length; i++) {
            expectedDescs[i] = expected[i].description;
          }

          expectedDesc =
            expected.length > 1
              ? expectedDescs.slice(0, -1).join(', ') +
                ' or ' +
                expectedDescs[expected.length - 1]
              : expectedDescs[0];

          foundDesc = found ? '"' + stringEscape(found) + '"' : 'end of input';

          return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';
        }

        var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

        if (expected !== null) {
          cleanupExpected(expected);
        }

        return new SyntaxError(
          message !== null ? message : buildMessage(expected, found),
          expected,
          found,
          pos,
          posDetails.line,
          posDetails.column
        );
      }

      function peg$parsestart() {
        var s0;

        s0 = peg$parseselector();

        return s0;
      }

      function peg$parseselector() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        s1 = peg$parseselectorComponent();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c2;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c3);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseselectorComponent();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c2;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c3);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseselectorComponent();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c4(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parseselectorComponent() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        s1 = peg$parseselGlobal();
        if (s1 === peg$FAILED) {
          s1 = peg$parseselKind();
        }
        if (s1 === peg$FAILED) {
          s1 = peg$c5;
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseselAttr();
          if (s3 === peg$FAILED) {
            s3 = peg$parseselId();
            if (s3 === peg$FAILED) {
              s3 = peg$parseselClass();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseselAttr();
            if (s3 === peg$FAILED) {
              s3 = peg$parseselId();
              if (s3 === peg$FAILED) {
                s3 = peg$parseselClass();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c6(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parseselGlobal() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 42) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c9();
        }
        s0 = s1;

        return s0;
      }

      function peg$parseselKind() {
        var s0, s1;

        s0 = peg$currPos;
        s1 = peg$parsename();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c10(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parseselId() {
        var s0, s1, s2;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c12);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parseselClass() {
        var s0, s1, s2;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c14;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c15);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c16(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parseselAttr() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c18);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsename();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseoper();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsevalue();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c19;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c20);
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c21(s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parseoper() {
        var s0;

        if (input.charCodeAt(peg$currPos) === 61) {
          s0 = peg$c22;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }

        return s0;
      }

      function peg$parsevalue() {
        var s0;

        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsetrueValue();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefalseValue();
          }
        }

        return s0;
      }

      function peg$parsetrueValue() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c24) {
          s1 = peg$c24;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c26();
        }
        s0 = s1;

        return s0;
      }

      function peg$parsefalseValue() {
        var s0, s1;

        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c27) {
          s1 = peg$c27;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c28);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c29();
        }
        s0 = s1;

        return s0;
      }

      function peg$parsename() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        if (peg$c30.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c31);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c30.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c31);
              }
            }
          }
        } else {
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c32(s1);
        }
        s0 = s1;

        return s0;
      }

      function peg$parsestring() {
        var s0;

        s0 = peg$parsestring1();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring2();
        }

        return s0;
      }

      function peg$parsestring1() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c33;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c34);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c35.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s4 = peg$c37;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c38);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenl();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c39(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseescape();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c35.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c36);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c37;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c38);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenl();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c39(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseescape();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c33;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c34);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c40(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parsestring2() {
        var s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c41;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c42);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c43.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c44);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s4 = peg$c37;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c38);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsenl();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c39(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseescape();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c43.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c44);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c37;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c38);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsenl();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c39(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseescape();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c41;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c42);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c40(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      function peg$parsenl() {
        var s0;

        if (input.charCodeAt(peg$currPos) === 10) {
          s0 = peg$c45;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c47) {
            s0 = peg$c47;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c48);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s0 = peg$c49;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c50);
              }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 12) {
                s0 = peg$c51;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c52);
                }
              }
            }
          }
        }

        return s0;
      }

      function peg$parseescape() {
        var s0, s1, s2;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c37;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c53.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c55(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail({ type: 'end', description: 'end of input' });
        }

        throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
      }
    }

    return {
      SyntaxError: SyntaxError,
      parse: parse,
    };
  })();

  /**
   * @fileOverview Draw API / holder of draw engines
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @name DrawEngine
   * @namespace Each DrawEngine encapsulates drawing of primitives in some technology such as Canvas or HTML.
   * The primitives are contained in the the engines primitives member, an associative array keyed
   * with the name of the primitive, and in general containing an object with member functions:
   * <ul>
   * <li>'prepare': call this once in the lifetime of the drawable entity. This is where e.g.
   * svg elements are created</li>
   * <li>'draw': actual drawing routine</li>
   * </li>'cleanup' call to cleanup resources created in prepare</li>
   * </ul>
   *
   * For engines which have no need for 'prepare' or 'cleanup', you can just specify a single function, which will be taken
   * as the 'draw' function, with implied no-ops for the 'prepare' and 'cleanup'
   */

  (function() {
    // Prototype for the draw interface. Essentially it's a forwarder to the
    // various draw engines.
    var DrawPrototype = {
      // Generic forwarder - forwards the same call down to draw engines.
      _forward: function(funcName) {
        $.each(this.engines, function(i, r) {
          if (r.engine[funcName]) {
            r.engine[funcName](r.draw);
          }
        });
      },
      /**
       * Gives the rendering engine a chance to prepare itself before rendering
       *
       * @param iRect - the rect to be drawn in primal coordinats
       * @param iTransform - the affine transform that describes the conversion from
       *                    primal to view coordinate systems
       */

      prepareFrame: function(iRect, iTransform) {
        $.each(this.engines, function(i, r) {
          if (r.engine.prepareFrame) {
            r.engine.prepareFrame(r.draw, iRect, r.preclear, iTransform);
          }
        });
      },
      cleanupFrame: function(iRect) {
        $.each(this.engines, function(i, r) {
          if (r.engine.cleanupFrame) {
            r.engine.cleanupFrame(r.draw, iRect);
          }
        });
      },
      translate: function(dx, dy) {
        $.each(this.engines, function(i, r) {
          if (r.trace) {
            r.engine.translate(r.draw, dx, dy);
          }
        });
      },
      fade: function(alpha) {
        $.each(this.engines, function(i, r) {
          if (r.trace) {
            r.engine.fade(r.draw, alpha);
          }
        });
      },
      // Cleanup function for clearing resources.
      destroy: function() {
        this._forward('destroy');
      },
    };

    // create a wrapper that knows about the right context for the api.
    function createForwarder(enginePrimitives, func, context) {
      return function(drawRef, attrs) {
        return func.call(enginePrimitives, context, drawRef, attrs);
      };
    }

    // create a wrapper that knows about the right context for the api.
    function createNoOpForwarder() {
      return function(drawRef, attrs) {};
    }
    /*
     Instantiate a drawer for the given engine.
     Essentialy this returns an object which forwards
     methods to the engine, currying the context so
     that the caller doesn't have to pass that.
     
     It has general properties, e.g. a link to the underlying engine and index,
     but mainly has drawing primitives for some subset of supported primitives.
     These come in threes - e.g. for the 'Point' primitive, there will be
      preparePoint() - call this once in the lifetime of the drawable entity.
        This is where e.g. svg elements are created.
      drawPoint() - actual drawing routine.
      cleanupPoint() - call to cleanup resources created in preparePoint()
   */
    function createEngineInstance(/** @lends Draw */ engine, context) {
      var r = {},
        f,
        method;

      if (!engine || !context) {
        return null;
      }

      r.engine = engine;
      r.draw = context;

      // Primitives will by name, e.g. 'Point', and need prepare, draw, cleanup forms.
      for (f in engine.primitives) {
        // If it's a function, then it's the draw function - no-ops are implied for prepare and cleanup
        if ('function' === typeof engine.primitives[f]) {
          r['prepare' + f] = createNoOpForwarder();
          r['draw' + f] = createForwarder(
            engine.primitives,
            engine.primitives[f],
            r.draw
          );
          r['cleanup' + f] = createNoOpForwarder();
        } else {
          for (method in engine.primitives[f]) {
            r[method + f] = createForwarder(
              engine.primitives,
              engine.primitives[f][method],
              r.draw
            );
          }
        }
      }

      return r;
    }

    /** @namespace
     */
    GSP.draw = {
      /** {Object} registry of available draw engines */
      availableEngines: {},
      /**
       * Create a Draw interface.
       * @param {args} has of args, including required args.rootNode, jQuery DOM element root.
       * @return {Object} Draw interface.
       */
      create: function(args) {
        var _this = GSP.draw,
          rootNode = args.rootNode,
          engines = {},
          eng,
          ret;

        args.width = args.width || rootNode.width();
        args.height = args.height || rootNode.height();

        var createCanvas = function(isTrace) {
          var canvas = createEngineInstance(
            _this.availableEngines.canvas,
            _this.availableEngines.canvas.create(args)
          );

          if (canvas) {
            if (isTrace) {
              canvas.trace = true;
            } else {
              canvas.preclear = true;
            }
          }
          return canvas;
        };

        if (_this.availableEngines.canvas) {
          //engines.interior = createCanvas(false);
          engines.trace = createCanvas(true);
          engines.canvas = createCanvas(false);
        }

        if (_this.availableEngines.html) {
          eng = createEngineInstance(
            _this.availableEngines.html,
            _this.availableEngines.html.create(args)
          );
          if (eng) {
            engines.html = eng;
          }
        }

        // This engine is rendered on top of the html engine
        if (_this.availableEngines.canvas)
          engines.canvasTop = createCanvas(false);

        ret = Object.create(DrawPrototype);

        // cleanup failed engine instances
        for (eng in engines) {
          if (engines.hasOwnProperty(eng) && !engines[eng]) {
            delete engines[eng];
          }
        }

        ret.engines = engines;

        return ret;
      },
    };
  })();

  /**
   * @fileOverview Canvas Draw API
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */

  (function() {
    var getImage = function(spec, onload) {
      var img = new Image();
      img.src = spec.src;
      if (onload) {
        img.onload = onload;
      }
      return img;
    };

    /**
        Utility function for drawing a line using the current style.
        @param  {Object}  ctx -- the canvas context
        @param  {Object}  iStart -- the start point for the line
        @param  {Object}  iEnd -- the end point for the line
       */
    function drawLine(ctx, iStart, iEnd) {
      ctx.beginPath();
      ctx.moveTo(iStart.x, iStart.y);
      ctx.lineTo(iEnd.x, iEnd.y);
      ctx.stroke();
    }

    /**
        Utility function for drawing an array of lines using the current style.
        @param  {Object}  ctx -- the canvas context
        @param  {Array of Number}   iCoords -- the points to render as a polyline,
                                    ordered as [x0, y0, x1, y1, ..., xn, yn].
                                    May be a typed array or a regular array.
        @param  {Array of Boolean}  iDiscontinuitites -- Discontinuity flags
       */
    function drawPolyline(ctx, iCoords, iDiscontinuities, iColors, closePath) {
      var i,
        ix,
        len = iCoords.length / 2,
        isRendering = false,
        lastSegmentWasSingularity,
        x,
        y,
        lastX,
        lastY,
        color;
      ctx.beginPath();

      var hugeCanvasSize = 10000000; // ten million pixels

      function isRenderable(value) {
        return Math.abs(value) < hugeCanvasSize;
      }

      for (i = 0, ix = 0; i < len; ++i, ix += 2) {
        x = iCoords[ix];
        y = iCoords[ix + 1];
        if (isRenderable(x) && isRenderable(y)) {
          if (x === lastX && y === lastY) {
            lastSegmentWasSingularity = true;
            continue;
          }

          if (iDiscontinuities && iDiscontinuities[i]) {
            if (lastSegmentWasSingularity) {
              ctx.stroke();
              ctx.fillStyle = ctx.strokeStyle;
              drawCircleFill(ctx, { x: lastX, y: lastY }, ctx.lineWidth / 2);
              ctx.beginPath();
            }

            isRendering = false;
          }

          lastSegmentWasSingularity = false;

          if (!isRendering) {
            ctx.moveTo(x, y);
            isRendering = true;
          } else {
            color = iColors && iColors[i];
            if (color && color !== '') {
              ctx.strokeStyle = color;
            }

            ctx.lineTo(x, y);

            //stroke bit by bit in the parametric case
            if (color) {
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x, y);
            }
          }
        } else {
          if (lastSegmentWasSingularity) {
            ctx.stroke();
            ctx.fillStyle = ctx.strokeStyle;
            drawCircleFill(ctx, { x: lastX, y: lastY }, ctx.lineWidth / 2);
            ctx.beginPath();
          }

          isRendering = false;
        }
        lastX = x;
        lastY = y;
      }

      if (closePath && isRendering) {
        if (!(iDiscontinuities && iDiscontinuities[i])) {
          x = iCoords[0];
          y = iCoords[1];

          if (isRenderable(x) && isRenderable(y)) {
            ctx.lineTo(x, y);
          }
        }
      }

      //stroke the single line in the non-parametric case
      //or the final line in the parametric case
      ctx.stroke();
    }

    /**
        Utility function for drawing a filled circle using the current style.
        @param  {Object}  ctx -- the canvas context
        @param  {Object}  iCenter -- the { x, y } center of the circle
        @param  {Number}  iRadius -- the radius of the circle
       */
    function drawCircleFill(ctx, iCenter, iRadius) {
      ctx.beginPath();
      ctx.arc(iCenter.x, iCenter.y, iRadius, 0, Math.PI * 2, true);
      ctx.fill();
    }

    /**
     * Utility for creating an arc path.  Clients
     * @param {Object} ctx
     * @param {GeometricArc} arc
     */
    function makeArcPath(ctx, arc) {
      ctx.beginPath();
      if (arc.orientation !== 0) {
        ctx.arc(
          arc.center.x,
          arc.center.y,
          arc.radius,
          arc.initialAngle,
          arc.finalAngle,
          false
        );
      } else {
        ctx.moveTo(arc.initialPoint.x, arc.initialPoint.y);
        ctx.lineTo(arc.finalPoint.x, arc.finalPoint.y);
      }
    }

    /**
     * Utility function for drawing a series of points as filled circles.
     *
     * @param {Object} ctx
     * @param {Array} iPointVector - an array of x,y coordinates
     * @param {Number} iNumSamples - the number of samples to draw
     * @param {Number} iRadius - radius of the points
     * @param {Array} iColors - optional array of colors
     * @returns {undefined}
     */
    function drawPointVector(ctx, iPointVector, iNumSamples, iRadius, iColors) {
      var i, ix, point;

      for (i = 0, ix = 0; i < iNumSamples; ++i, ix += 2) {
        if (iColors) {
          ctx.fillStyle = iColors[i];
        }
        point = {
          x: iPointVector[ix],
          y: iPointVector[ix + 1],
        };

        drawCircleFill(ctx, point, iRadius);
      }
    }

    /**
        Draws an "ellipse". At this time, an ellipse primitive has been defined
        for canvas but not implemented by most browsers, so we simulate one using
        Bezier curves. See http://www.whizkidtech.redprince.net/bezier/circle/
        and http://stackoverflow.com/questions/5563422/
        drawing-ellipses-with-quadratic-bezier-curves-and-cubic-bezier-curves
        and http://www.tinaja.com/glib/ellipse4.pdf for details.
        @param  {Object}  ctx -- the canvas context
        @param  {Object}  iCenter -- { x: xCenter, y: yCenter }
        @param  {Object}  iRadius -- { x: xRadius, y: yRadius }
       */
    function drawEllipseFrame(ctx, iCenter, iRadius) {
      // Optimize the circle special case
      if (iRadius.x === iRadius.y) {
        ctx.beginPath();
        ctx.arc(iCenter.x, iCenter.y, iRadius.x, 0, Math.PI * 2, true);
        ctx.stroke();
        return;
      }

      var magic = 0.551784, // from http://www.tinaja.com/glib/ellipse4.pdf
        xControl = iRadius.x * magic,
        yControl = iRadius.y * magic,
        xEnd = iCenter.x + iRadius.x,
        yEnd = iCenter.y + iRadius.y;

      ctx.beginPath();
      ctx.moveTo(iCenter.x - iRadius.x, iCenter.y);

      ctx.bezierCurveTo(
        iCenter.x - iRadius.x,
        iCenter.y - yControl,
        iCenter.x - xControl,
        iCenter.y - iRadius.y,
        iCenter.x,
        iCenter.y - iRadius.y
      );

      ctx.bezierCurveTo(
        iCenter.x + xControl,
        iCenter.y - iRadius.y,
        xEnd,
        iCenter.y - yControl,
        xEnd,
        iCenter.y
      );

      ctx.bezierCurveTo(
        xEnd,
        iCenter.y + yControl,
        iCenter.x + xControl,
        yEnd,
        iCenter.x,
        yEnd
      );

      ctx.bezierCurveTo(
        iCenter.x - xControl,
        yEnd,
        iCenter.x - iRadius.x,
        iCenter.y + yControl,
        iCenter.x - iRadius.x,
        iCenter.y
      );

      ctx.stroke();
    }

    /**
     * Draws the head of an arrow. This implement draws a simple filled
     * triangle.
     * @param {object} ctx is the canvas context
     * @param {geometricPoint} vertices (p[0]: left point, p[1]: end point
     *                         p[2]: right point)
     * @param {bool} stroke - if true/present, also strokes a line along the perimeter
     */
    function drawArrowhead(ctx, vertices, stroke) {
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.lineTo(vertices[1].x, vertices[1].y);
      ctx.lineTo(vertices[2].x, vertices[2].y);
      ctx.closePath();
      ctx.fill();
      if (stroke) {
        ctx.stroke();
      }
    }

    /*
     * Computes a new terminal point for a line segment that permits room for
     * an arrowhead.
     * Returns undefined if there if the line is too short for an arrowhead.
     * @param {GeometricPoint} p0, p1 terminal points of a line.
     */
    function computeLineArrowheadCap(p0, p1, width) {
      var ARROW_LENGTH = 10, // length of arrowhead
        //MARGIN = 2 * ARROW_LENGTH / 3,
        MARGIN = ARROW_LENGTH,
        v = p1.subtract(p0),
        len = v.vLength(),
        newLen = len - MARGIN;
      if (len > ARROW_LENGTH) {
        return v.multiply(newLen / len).add(p0);
      } else {
        return;
      }
    }

    /*
     * Computes a new arc angle an arcLength from an initial angle.
     * @param {number} angle The initial angle in radians.
     * @param {number} direction +1 or -1.
     * @param {number} radius Radius of the arc.
     * @param {number} arcLength The distance along the arc to advance
     * @return an angle in degrees [0..2PI)
     */
    function adjustArcArrowheadCap(angle, direction, radius, arcLength) {
      var newAngle;
      newAngle = angle - (direction * arcLength) / radius;
      //m = Math.floor(newAngle / (2 * Math.PI));
      //newAngle = newAngle - (m * 2 * Math.PI);
      return newAngle;
    }

    /*
     * Computes the three vertices of an arrowhead. Returns them as a three
     * element array * consisting of [left vertex, point, right vertex].
     */
    function computeArrowheadVerticesFromBaseAndPoint(base, point, lineWidth) {
      var WING = 2,
        width = lineWidth / 2 + WING || WING, //protect against undefined lineWidth
        vertices = [],
        axisV = point.subtract(base).unit(),
        orthV = new GSP.GeometricPoint(-axisV.y, axisV.x);
      vertices.push(base.add(orthV.multiply(width)));
      vertices.push(point);
      vertices.push(base.add(orthV.multiply(-width)));
      return vertices;
    }

    /**
     * Draws an arc as a portion of an angle marker. Assumes that the
     * canvas context has been initialized with style properties set.
     * @param {object} ctx Canvas context.
     * @param {object} baseArc The base arc. Arc angles and orientation are
     *                         used from this object, but radius is ignored.
     * @param {number} radius  The radius of the arc.
     * @param {string} drawArrow Whether an arrow head should be drawn {'none',
     *                         'head', 'tail', 'both'}
     */
    function drawAngleMarkerArc(
      ctx,
      baseArc,
      radius,
      lineWidth,
      drawArrow,
      doFill,
      fillOpacity
    ) {
      if (baseArc.orientation === 0) {
        ctx.beginPath();
        ctx.moveTo(baseArc.initialPoint.x, baseArc.initialPoint.y);
        ctx.lineTo(baseArc.finalPoint.x, baseArc.finalPoint.y);
        ctx.closePath();
        return;
      }
      var ARROW_LENGTH = 10,
        arc = baseArc,
        // extract needed initial values from arc object
        center = arc.center,
        orientation = baseArc.orientation, // -1: ccw, 0: flat, +1 cw
        arcAngle = baseArc.arcAngle,
        /*
              initialAngle = (orientation > 0)
                                 ? baseArc.initialAngle
                                 : baseArc.finalAngle,
              finalAngle = (orientation > 0)
                                 ? baseArc.finalAngle
                                 : baseArc.initialAngle,
  */
        initialAngle = baseArc.initialAngle,
        finalAngle = baseArc.finalAngle,
        pathInitialAngle = initialAngle,
        pathFinalAngle = finalAngle,
        drawArrowTail = drawArrow === 'tail' || drawArrow === 'both',
        drawArrowHead = drawArrow === 'head' || drawArrow === 'both',
        minArcLength = 0,
        drawArrowInitial = false,
        drawArrowFinal = false,
        arrowPointInitial,
        arrowPointFinal,
        arrowBase,
        opacity;
      if (drawArrowHead) {
        minArcLength += ARROW_LENGTH;
        if (orientation > 0) {
          drawArrowFinal = true;
        } else {
          drawArrowInitial = true;
        }
      }
      if (drawArrowTail) {
        minArcLength += ARROW_LENGTH;
        if (orientation < 0) {
          drawArrowFinal = true;
        } else {
          drawArrowInitial = true;
        }
      }
      if (Math.abs(arcAngle * radius) <= minArcLength) {
        drawArrowInitial = drawArrowFinal = false;
      }

      if (drawArrowInitial) {
        arrowPointInitial = new GSP.GeometricPoint(
          Math.cos(initialAngle),
          Math.sin(initialAngle)
        )
          .multiply(radius)
          .add(center);
        pathInitialAngle = adjustArcArrowheadCap(
          initialAngle,
          orientation,
          radius,
          ARROW_LENGTH
        );
      }

      if (drawArrowFinal) {
        arrowPointFinal = new GSP.GeometricPoint(
          Math.cos(finalAngle),
          Math.sin(finalAngle)
        )
          .multiply(radius)
          .add(center);
        pathFinalAngle = adjustArcArrowheadCap(
          finalAngle,
          orientation,
          radius,
          ARROW_LENGTH
        );
      }

      ctx.beginPath();
      ctx.arc(
        center.x,
        center.y,
        radius,
        pathInitialAngle,
        pathFinalAngle,
        false
      );
      ctx.stroke();
      if (doFill) {
        ctx.beginPath();
        ctx.arc(center.x, center.y, radius, initialAngle, finalAngle, false);
        ctx.lineTo(center.x, center.y);
        ctx.closePath();
        opacity = ctx.globalAlpha;
        ctx.globalAlpha *= fillOpacity;
        ctx.fill();
        ctx.globalAlpha = opacity;
      }
      if (drawArrowInitial) {
        arrowBase = new GSP.GeometricPoint(
          Math.cos(pathInitialAngle),
          Math.sin(pathInitialAngle)
        )
          .multiply(radius)
          .add(center);
        drawArrowhead(
          ctx,
          computeArrowheadVerticesFromBaseAndPoint(
            arrowBase,
            arrowPointInitial,
            lineWidth
          )
        );
      }
      if (drawArrowFinal) {
        arrowBase = new GSP.GeometricPoint(
          Math.cos(pathFinalAngle),
          Math.sin(pathFinalAngle)
        )
          .multiply(radius)
          .add(center);
        drawArrowhead(
          ctx,
          computeArrowheadVerticesFromBaseAndPoint(
            arrowBase,
            arrowPointFinal,
            lineWidth
          )
        );
      }
    }

    function drawRightAngleMarker(
      ctx,
      baseArc,
      radius,
      lineWidth,
      drawArrow,
      doFill,
      fillOpacity
    ) {
      var ARROW_LENGTH = 10,
        arc = baseArc,
        center = arc.center,
        orientation = arc.orientation,
        initialAngle = arc.initialAngle,
        p0Vector = GSP.GeometricPoint(
          Math.cos(initialAngle),
          Math.sin(initialAngle)
        ).multiply(radius),
        p1Vector = GSP.GeometricPoint(-p0Vector.y, p0Vector.x),
        mpVector = p0Vector.add(p1Vector),
        p0 = p0Vector.add(center),
        p1 = p1Vector.add(center),
        p0Fill = p0,
        p1Fill = p1,
        midPoint = mpVector.add(center),
        drawArrowTail = drawArrow === 'tail' || drawArrow === 'both',
        drawArrowHead = drawArrow === 'head' || drawArrow === 'both',
        drawArrowInitial = false,
        drawArrowFinal = false,
        arrowCapInitial,
        arrowCapFinal,
        opacity;

      if (drawArrowHead) {
        if (orientation > 0) {
          drawArrowFinal = true;
        } else {
          drawArrowInitial = true;
        }
      }
      if (drawArrowTail) {
        if (orientation < 0) {
          drawArrowFinal = true;
        } else {
          drawArrowInitial = true;
        }
      }
      if (radius <= ARROW_LENGTH) {
        drawArrowInitial = drawArrowFinal = false;
      }
      if (drawArrowFinal) {
        arrowCapFinal = computeLineArrowheadCap(midPoint, p1, lineWidth);
        if (arrowCapFinal) {
          p1 = arrowCapFinal;
        }
      }
      if (drawArrowInitial) {
        arrowCapInitial = computeLineArrowheadCap(midPoint, p0, lineWidth);
        if (arrowCapInitial) {
          p0 = arrowCapInitial;
        }
      }
      // draw path
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(midPoint.x, midPoint.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      if (doFill) {
        ctx.beginPath();
        ctx.moveTo(p0Fill.x, p0Fill.y);
        ctx.lineTo(midPoint.x, midPoint.y);
        ctx.lineTo(p1Fill.x, p1Fill.y);
        ctx.lineTo(center.x, center.y);
        ctx.closePath();
        opacity = ctx.globalAlpha;
        ctx.globalAlpha *= fillOpacity;
        ctx.fill();
        ctx.globalAlpha = opacity;
      }
      if (arrowCapFinal) {
        drawArrowhead(
          ctx,
          computeArrowheadVerticesFromBaseAndPoint(p1, p1Fill, lineWidth)
        );
      }
      if (arrowCapInitial) {
        drawArrowhead(
          ctx,
          computeArrowheadVerticesFromBaseAndPoint(p0, p0Fill, lineWidth)
        );
      }
    }

    //Utility for preparing a picture or vector of several instances of the
    //same pictures for rendering.
    function preparePicture(drawContext, renderAttrs) {
      var pictureCache = renderAttrs.pictureCache;
      if (pictureCache[renderAttrs.image.src])
        return pictureCache[renderAttrs.image.src];

      var picture = {
        state: 'error',
        id: renderAttrs.id,
        onStateChange: renderAttrs.onStateChange,
      };
      picture.imageSpec = renderAttrs.image;

      if (renderAttrs.image) {
        picture.state = 'loading';
        picture.img = getImage(picture.imageSpec, function() {
          //GSP.log('Image loaded: ' + picture.id);
          picture.state = 'ready';
          if (picture.onStateChange) {
            picture.onStateChange();
          }
        });
      }

      pictureCache[renderAttrs.image.src] = picture;
      return picture;
    }

    //Utility that handles the actual drawing a single picture,
    //or a black box, if the picture has not yet been loaded.
    function drawPicture(drawContext, drawRefCon, renderAttrs) {
      var ctx = drawContext.context,
        t = renderAttrs.transform,
        width = drawRefCon.imageSpec ? drawRefCon.imageSpec.width : 200,
        height = drawRefCon.imageSpec ? drawRefCon.imageSpec.height : 100,
        clip = renderAttrs.clipPolygon,
        i;

      if (!renderAttrs.renderable) {
        return;
      }

      ctx.save();
      ctx.globalAlpha *= renderAttrs.opacity;

      if (clip && clip.length > 0) {
        ctx.beginPath();
        ctx.moveTo(clip[0].getX(), clip[0].getY());
        for (i = 1; i < clip.length; i++) {
          ctx.lineTo(clip[i].getX(), clip[i].getY());
        }
        ctx.closePath();
        ctx.clip();
      }

      ctx.transform(t.m00, t.m01, t.m10, t.m11, t.m20, t.m21);
      if (drawRefCon.state === 'ready') {
        //GSP.log('image ready. id:' + drawRefCon.id);
        ctx.drawImage(drawRefCon.img, 0, 0);
      } else if (drawRefCon.state === 'loading') {
        //GSP.log('image not ready. id:' + drawRefCon.id);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(0, 0, width, height);
      } else {
        ctx.strokeStyle = 'red';
        ctx.strokeRect(0, 0, width, height);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(width, height);
        ctx.moveTo(width, 0);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.stroke();
      }

      if (renderAttrs.isFocusable) {
        ctx.beginPath();
        if (t.m00 >= 1 && t.m11 >= 1) {
          ctx.lineWidth = renderAttrs.width;
        } else {
          ctx.lineWidth = renderAttrs.width * (1 / Math.min(t.m00, t.m11));
        }
        ctx.strokeStyle = renderAttrs.color;
        ctx.strokeRect(0, 0, width, height);
        ctx.closePath();
        ctx.stroke();
      }

      ctx.restore();
    }

    function cleanupPicture(drawContext, drawRefCon, renderAttrs) {
      drawRefCon.onStateChange = null;
    }
    // Utility function to create an HTML5 Canvas.
    // Returns the canvas, canvas context,  width and height
    // The canvas is not attached to the DOM, at this point -
    // that's left for the caller to do if desired.
    function createCanvas(width, height) {
      var canvasWidth = width,
        canvasHeight = height,
        element,
        context,
        devicePixelRatio;

      // When there is a high-def (retina) display,
      // we'll size our canvas larger, and draw with a scaled transform.
      // This means that we draw in high def coords - the graphics system
      // will just blast those high-def pixes to the screen. This gives
      // more detail / better anti-aliasing.
      // However, we need to set the canvas dimensions to integer values;
      // non-integer values can cause fading traces to creep a fraction of
      // a pixel on each pass of the fading loop.
      devicePixelRatio = window.devicePixelRatio;
      if (devicePixelRatio) {
        canvasWidth = Math.round(canvasWidth * devicePixelRatio);
        canvasHeight = Math.round(canvasHeight * devicePixelRatio);
      }

      element = $(
        '<canvas aria-hidden="true" width="' +
          canvasWidth +
          '" height="' +
          canvasHeight +
          '"></canvas>'
      );

      context = element[0].getContext && element[0].getContext('2d');

      if (!context) {
        return null;
      }

      // Line dash polyfill. Just a no-op where not supported.
      // cf. http://www.w3.org/html/wg/drafts/2dcontext/html5_canvas/#dash-list
      if (!context.setLineDash) {
        context.setLineDash = function(segments) {};
        context.getLineDash = function() {
          return [];
        };
      }

      if (devicePixelRatio) {
        context.scale(devicePixelRatio, devicePixelRatio);
      }

      return {
        canvas: element,
        context: context,
        width: canvasWidth,
        height: canvasHeight,
      };
    }

    function addBackbufferToDrawContext(draw) {
      //A theoretical bug could lead to the backbuffer having a different device
      //pixel ratio than the canvas.  It would be better to have a copyCanvas utility
      //for this purpose
      draw.backbuffer = createCanvas(draw.canvas.width(), draw.canvas.height());
    }

    GSP.draw.availableEngines.canvas = {
      create: function(args) {
        var ret = createCanvas(args.width, args.height);

        // Check for error - i.e. Canvas not supported
        if (!ret) {
          return ret;
        }

        ret.canvas.css({
          position: 'absolute',
          top: 0,
          left: 0,
          width: args.width,
          height: args.height,
          overflow: 'hidden',
        });
        ret.canvas.appendTo(args.rootNode);

        return ret;
      },
      destroy: function(draw) {
        if (draw.canvas) {
          draw.canvas.remove();
        }
      },
      prepareFrame: function(draw, iClipRect, iPreclear, iTransform) {
        var clipRect, topLeft, bottomRight, canvasRect, inverse;

        draw.context.save();
        draw.context.transform(
          iTransform.m00,
          iTransform.m01,
          iTransform.m10,
          iTransform.m11,
          iTransform.m20,
          iTransform.m21
        );

        if (!iPreclear) {
          //If we're not preclearing, we're done
          return;
        }

        // Only clip if we have a valid clip rect
        if (!GSP.Geom.isValidRect(iClipRect)) {
          return;
        }

        topLeft = GSP.GeometricPoint(0, 0);
        bottomRight = GSP.GeometricPoint(
          draw.canvas.width(),
          draw.canvas.height()
        );

        inverse = iTransform.inverse();
        inverse.transform(topLeft);
        inverse.transform(bottomRight);

        canvasRect = {
          left: topLeft.x,
          top: topLeft.y,
          right: bottomRight.x,
          bottom: bottomRight.y,
        };

        clipRect = GSP.Geom.insetRect(iClipRect, -1);
        clipRect.left = Math.round(clipRect.left);
        clipRect.top = Math.round(clipRect.top);
        clipRect.right = Math.round(clipRect.right);
        clipRect.bottom = Math.round(clipRect.bottom);
        clipRect = GSP.Geom.intersectRects(clipRect, canvasRect);

        // If the clip rect doesn't intersect the canvas, clip to empty rect
        if (GSP.Geom.isEmptyRect(clipRect))
          clipRect = { left: -1, top: -1, right: -1, bottom: -1 };
        draw.context.beginPath();
        draw.context.rect(
          clipRect.left,
          clipRect.top,
          clipRect.right - clipRect.left,
          clipRect.bottom - clipRect.top
        );
        draw.context.clip();
        draw.context.clearRect(
          topLeft.x,
          topLeft.y,
          bottomRight.x - topLeft.x,
          bottomRight.y - topLeft.y
        );
      },
      cleanupFrame: function(draw, iClipRect) {
        draw.context.restore();
      },
      clear: function(draw) {
        draw.context.clearRect(0, 0, draw.canvas.width(), draw.canvas.height());
      },
      translate: function(draw, dx, dy) {
        var width = draw.canvas.width(),
          height = draw.canvas.height();

        if (!draw.backbuffer) {
          addBackbufferToDrawContext(draw);
        }

        draw.backbuffer.context.clearRect(0, 0, width, height);
        draw.backbuffer.context.drawImage(
          draw.canvas[0],
          -dx,
          -dy,
          width,
          height
        );
        draw.context.clearRect(0, 0, width, height);
        draw.context.drawImage(draw.backbuffer.canvas[0], 0, 0, width, height);
      },
      fade: function(draw, alpha) {
        // Blit the canvas to an offscreen buffer at alpha.
        // In theory, we could blit the canvas back onto itself
        // with globalCompositeOperation = 'copy' (with alpha)
        // but that's buggy - has failed in Mac chrome 29.0.1547.76
        // and occasionally Mac Firefox

        if (!draw.backbuffer) {
          addBackbufferToDrawContext(draw);
        }

        // canvas -> backbuffer at alpha
        draw.backbuffer.context.save();
        draw.backbuffer.context.clearRect(
          0,
          0,
          draw.canvas.width(),
          draw.canvas.height()
        );
        draw.backbuffer.context.globalAlpha = alpha;
        draw.backbuffer.context.drawImage(
          draw.canvas[0],
          0,
          0,
          draw.canvas.width(),
          draw.canvas.height()
        );

        // backbuffer -> canvas
        draw.context.clearRect(0, 0, draw.canvas.width(), draw.canvas.height());
        draw.context.drawImage(
          draw.backbuffer.canvas[0],
          0,
          0,
          draw.canvas.width(),
          draw.canvas.height()
        );
        draw.backbuffer.context.restore();
      },
      primitives: {
        Point: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          ctx.fillStyle = renderAttrs.color;
          ctx.strokeStyle = 'black';
          ctx.lineWidth = renderAttrs.lineWidth;

          if (renderAttrs.dropShadow) {
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 7;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
          }

          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.arc(
            renderAttrs.cx,
            renderAttrs.cy,
            renderAttrs.radius,
            0,
            Math.PI * 2,
            true
          );
          ctx.fill();
          if (renderAttrs.lineWidth > 0) {
            ctx.stroke();
          }
          ctx.closePath();
          ctx.restore();
        },
        String: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.fillStyle = 'black';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.fillText(renderAttrs.text, renderAttrs.x, renderAttrs.y);
          ctx.restore();
        },
        Circle: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.strokeStyle = renderAttrs.color;
          ctx.lineWidth = renderAttrs.width;
          ctx.setLineDash(renderAttrs.lineDash || []);

          ctx.beginPath();
          ctx.arc(
            renderAttrs.cx,
            renderAttrs.cy,
            renderAttrs.r,
            0,
            Math.PI * 2,
            true
          );
          ctx.stroke();
          ctx.restore();
        },
        Arc: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.strokeStyle = renderAttrs.color;
          ctx.lineWidth = renderAttrs.width;
          ctx.setLineDash(renderAttrs.lineDash || []);

          makeArcPath(ctx, renderAttrs.arc);
          ctx.stroke();
          ctx.restore();
        },

        CircleInterior: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.fillStyle = renderAttrs.color;

          if (renderAttrs.drawBorder) {
            ctx.strokeStyle = renderAttrs.borderColor;
            ctx.lineWidth = renderAttrs.borderWidth;
            ctx.setLineDash(renderAttrs.lineDash || []);
          }

          ctx.beginPath();
          ctx.arc(
            renderAttrs.cx,
            renderAttrs.cy,
            renderAttrs.r,
            0,
            Math.PI * 2,
            true
          );
          ctx.fill();
          if (renderAttrs.drawBorder) {
            ctx.stroke();
          }
          ctx.restore();
        },
        ArcInterior: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context,
            arc;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.fillStyle = renderAttrs.color;

          if (renderAttrs.drawBorder) {
            ctx.strokeStyle = renderAttrs.borderColor;
            ctx.lineWidth = renderAttrs.borderWidth;
            ctx.setLineDash(renderAttrs.lineDash || []);
          }

          arc = renderAttrs.arc;

          makeArcPath(ctx, renderAttrs.arc);
          if (renderAttrs.genus === 'ArcSegment') {
            ctx.closePath();
          } else {
            ctx.lineTo(arc.center.x, arc.center.y);
            ctx.closePath();
          }
          ctx.fill();
          if (renderAttrs.drawBorder) {
            ctx.stroke();
          }
          ctx.restore();
        },
        Polygon: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context,
            i,
            origAlpha;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();

          if (renderAttrs.drawBorder) {
            origAlpha = ctx.globalAlpha;
            ctx.strokeStyle = renderAttrs.borderColor;
            ctx.lineWidth = renderAttrs.borderWidth;
            // Set mitre limit relative to border width
            // to prevent pointy bits to point too far
            // note canvas API will ignore inf, nan for
            // mitreLimit
            ctx.miterLimit = 10 / renderAttrs.borderWidth;
            ctx.setLineDash(renderAttrs.lineDash || []);
          }

          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.fillStyle = renderAttrs.color;

          ctx.beginPath();
          ctx.moveTo(renderAttrs.points[0].x, renderAttrs.points[0].y);
          for (i = 1; i < renderAttrs.points.length; i++) {
            ctx.lineTo(renderAttrs.points[i].x, renderAttrs.points[i].y);
          }

          ctx.closePath();

          ctx.fill('evenodd');
          if (renderAttrs.drawBorder) {
            ctx.globalAlpha = origAlpha * renderAttrs.fadeOpacity;
            ctx.stroke();
          }

          ctx.restore();
        },
        /*
         * Draws an unfilled axis-aligned rectangle. This drawing primitive
         * is intended mainly for diagnostic purposes, and so, has few display
         * options.
         * Expects a plain object with pixel coordinates like:
         *    renderAttrs.rect: {
         *            left: 30, top: 50,
         *            right: 40.3, bottom: 60
         *        }
         * Optionally, a color parameter, like:
         *    renderAttrs.color: 'blue';
         */
        Rectangle: function(drawContext, drawRefCon, renderAttrs) {
          function bound(value, min, max) {
            return Math.max(Math.min(value, max), min);
          }
          var ctx = drawContext.context,
            rect = renderAttrs.rect,
            clipRect = {
              left: -1,
              top: -1,
              right: drawContext.width + 1,
              bottom: drawContext.height + 1,
            },
            drawRect;
          // handle alternate rect representation
          //if (rect.width !== undefined) rect.right = rect.left + rect.width;
          //if (rect.height !== undefined) rect.bottom = rect.top + rect.height;

          drawRect = {
            left:
              Math.round(bound(rect.left, clipRect.left, clipRect.right)) - 0.5,
            top:
              Math.round(bound(rect.top, clipRect.top, clipRect.bottom)) - 0.5,
            right:
              Math.round(bound(rect.right, clipRect.left, clipRect.right)) +
              0.5,
            bottom:
              Math.round(bound(rect.bottom, clipRect.top, clipRect.bottom)) +
              0.5,
          };

          //if( !renderAttrs.renderable) {
          // return;
          //}

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.lineWidth = renderAttrs.isFocusable ? renderAttrs.borderWidth : 1;
          ctx.lineCap = 'butt';
          ctx.lineJoin = 'miter';
          ctx.strokeStyle = renderAttrs.isFocusable
            ? renderAttrs.borderColor
            : renderAttrs.color || '#999';

          ctx.beginPath();
          ctx.moveTo(drawRect.left, drawRect.top);
          ctx.lineTo(drawRect.right, drawRect.top);
          ctx.lineTo(drawRect.right, drawRect.bottom);
          ctx.lineTo(drawRect.left, drawRect.bottom);
          ctx.closePath();

          ctx.stroke();

          ctx.restore();
        },
        Segment: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.lineWidth = renderAttrs.width;
          ctx.strokeStyle = renderAttrs.color;
          ctx.setLineDash(renderAttrs.lineDash || []);

          ctx.beginPath();
          ctx.moveTo(renderAttrs.p0x, renderAttrs.p0y);
          ctx.lineTo(renderAttrs.p1x, renderAttrs.p1y);
          ctx.lineCap = 'round';
          ctx.stroke();
          ctx.closePath();
          ctx.setLineDash([]);
          ctx.restore();
        },
        Text: {
          prepare: function(drawContext, renderAttrs) {
            return $.extend({}, renderAttrs);
          },
          measure: function(drawContext, drawRefCon, renderAttrs) {
            var ctx = drawContext.context,
              oldRenderBounds = drawRefCon.renderBounds,
              size;

            // We'll do a save/restore around normal text drawing
            // clipping so that nothing is visible, and taking care
            // to save/restore the cached render bounds.

            // Normalize render attributes for vanilla drawing
            renderAttrs.x = 0;
            renderAttrs.y = 0;
            renderAttrs.renderable = true;
            renderAttrs.visibility = 'visible';
            renderAttrs.opacity = 1;
            renderAttrs.constraintFrame = 0;

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, 0, 0);
            ctx.clip();
            this.Text.draw(drawContext, drawRefCon, renderAttrs);
            size = {
              width:
                drawRefCon.renderBounds.right - drawRefCon.renderBounds.left,
              height:
                drawRefCon.renderBounds.bottom - drawRefCon.renderBounds.top,
            };
            ctx.restore();

            drawRefCon.renderBounds = oldRenderBounds;

            return size;
          },
          draw: function(drawContext, drawRefCon, renderAttrs) {
            var ctx = drawContext.context,
              kDefaultFontSize = 18,
              kFontDiminishmentFactor = 0.7,
              kSubscriptOffsetFactor = 0.2,
              xSketch = Math.round(renderAttrs.x),
              ySketch = Math.round(renderAttrs.y) - 4,
              x = xSketch,
              y = ySketch;

            if (!renderAttrs.renderable) return;

            // Utility function for setting the canvas font property
            function setFontAndStyle(ctx, iSpec) {
              var canvasFont = '';

              function addToCanvasFont(iPropValue, iDefault, iSuffix) {
                if (undefined !== iPropValue && iPropValue !== iDefault) {
                  if (canvasFont.length > 0) canvasFont += ' ';
                  canvasFont += iPropValue;
                  if (iSuffix) canvasFont += iSuffix;
                }
              }

              addToCanvasFont(iSpec['font-weight'], 'normal');
              addToCanvasFont(iSpec['font-style'], 'normal');
              addToCanvasFont(iSpec['font-size'], '', 'px');
              addToCanvasFont(iSpec['font-family']);

              if (canvasFont.length > 0) ctx.font = canvasFont;

              if (undefined !== iSpec.color) ctx.fillStyle = iSpec.color;
            }

            // Utility function to handle fonts that require special
            // metrics adjustments, e.g. Zapfino.
            function getFontScaleFactors(iFontSpec) {
              // the font size corresponds to the em square
              // we adjust the top and bottom by a scale factor to
              // accommodate accents, etc. that can fall outside
              var kDefaultScaleFactors = {
                  ascent: 0.1,
                  descent: 0.2,
                  left: 0.0,
                  right: 0.0,
                },
                // Most fonts can be handled with the default factors, but some fonts
                // break with convention. Rather than burden all fonts with the worst-
                // case factors, we handle known exceptions as the exceptions they are.
                // This has the implication that such exceptional fonts should be
                // considered unsupported until/unless an appropriate exception entry
                // is added for it.
                exceptions = {
                  zapfino: { ascent: 1.2, descent: 2.6, left: 0.2, right: 0.4 },
                },
                fontFamily = iFontSpec['font-family'],
                fontFamilyNorm = fontFamily && fontFamily.toLowerCase(),
                factors;
              // Assume exceptions apply to all font variants,
              // so we search for family name within font name.
              $.each(exceptions, function(iFontKey, iValue) {
                if (fontFamilyNorm.indexOf(iFontKey) >= 0) {
                  factors = iValue;
                  return false; // stop iteration
                }
              });
              // return the exception entry (if any) or the defaults
              return factors || kDefaultScaleFactors;
            }

            /*
             *  Estimates the size of the text for the purpose of allocating
             *  the offscreen canvas required for rendering the text.
             *  For this purpose, it is better to be fast and sufficient
             *  to create a buffer that is at least big enough. To that
             *  end, we combine all of the text into one string and then
             *  measure it at the initial font and style. This requires
             *  only a single call to measureText() and should generally
             *  be good enough since we only support style changes like
             *  subscript that diminish the font size.
             */

            function getSizePreEstimate(ctx, iFontSpec, iParseTree) {
              var fontSize = iFontSpec['font-size'] || kDefaultFontSize,
                factors = getFontScaleFactors(iFontSpec),
                textParams = extractTextFromMFSParseTree(iParseTree),
                textMetrics,
                scriptExtra;

              ctx.save();
              setFontAndStyle(ctx, iFontSpec);
              textMetrics = ctx.measureText(textParams.text);
              ctx.restore();

              // Note: this overestimates the effect of super- and subscripts because
              // it doesn't take into account the font diminishment factor.
              scriptExtra =
                (textParams.maxSubscript + textParams.maxSuperscript) *
                kSubscriptOffsetFactor;

              return {
                width: Math.round(
                  textMetrics.width * (1 + factors.left + factors.right)
                ),
                height: Math.round(
                  fontSize *
                    (1 + factors.ascent + factors.descent + scriptExtra)
                ),
              };
            }

            // Utility function for estimating the bounding box of canvas text
            function getBoundingBoxEstimate(x, y, iWidth, iFontSpec) {
              var fontSize = iFontSpec['font-size'] || kDefaultFontSize,
                factors = getFontScaleFactors(iFontSpec);
              return {
                top: y - Math.round((1.0 + factors.ascent) * fontSize),
                bottom: y + Math.round(factors.descent * fontSize),
                left: x - Math.round(factors.left * fontSize) - 1,
                right: x + iWidth + Math.round(factors.right * fontSize) + 2,
              };
            }

            function getNodeText(node, iFontSpec) {
              var s = node.value;
              if (node.type === 'symbol')
                return GSP.mfs.symMap[s.toUpperCase()] || 'x';
              return s;
            }

            /**
             * Renders the MFS parse tree to the canvas.
             * Note that only
             */
            function extractTextFromMFSParseTree(node) {
              var visitMap = {},
                currSuperscript = 0,
                maxSuperscript = 0,
                currSubscript = 0,
                maxSubscript = 0,
                renderText = '';

              function visit(node) {
                var fn;
                fn = visitMap[node.type];
                if (fn) fn(node);
              }

              visitMap.horizontal = function(node) {
                for (var ix = 0; ix < node.value.length; ++ix) {
                  visit(node.value[ix]);
                }
              };
              visitMap.style = function(node) {
                for (var ix = 0; ix < node.value.length; ix += 1) {
                  if (!node.value[ix].code && node.value[ix].type) {
                    visit(node.value[ix]);
                  }
                }
              };
              visitMap.sub = function(node) {
                if (maxSubscript < ++currSubscript)
                  maxSubscript = currSubscript;
                visit(node.value[0]);
                visit(node.value[1]);
                --currSubscript;
              };
              visitMap['super'] = function(node) {
                if (maxSuperscript < ++currSuperscript)
                  maxSuperscript = currSuperscript;
                visit(node.value[0]);
                visit(node.value[1]);
                --currSuperscript;
              };
              visitMap.text = function(node) {
                renderText += getNodeText(node);
              };
              // symbol nodes can be rendered like text nodes
              visitMap.symbol = visitMap.text;

              visit(node);

              // return the parameters of the text
              return {
                maxSubscript: maxSubscript,
                maxSuperscript: maxSuperscript,
                text: renderText,
              };
            }

            /**
             * Renders the MFS parse tree to the canvas.
             * Note that only a subset of MFS is currently supported:
             *  text, symbol, style (except overbar),
             *  superscript, subscript, and horizontal nodes.
             */
            function renderMFSParseTree(ctx, node, iFontSpec) {
              var visitMap = {},
                renderBounds = { left: x, top: y, right: x, bottom: y };

              function visit(node, iFontSpec) {
                var fn;
                fn = visitMap[node.type];
                if (fn) {
                  fn(node, iFontSpec);
                } else {
                  GSP.log('MFS-Canvas-Render does not support ' + node.type);
                }
              }

              visitMap.horizontal = function(node, iFontSpec) {
                for (var ix = 0; ix < node.value.length; ++ix) {
                  visit(node.value[ix], iFontSpec);
                }
              };
              visitMap.style = function(node, iFontSpec) {
                var ix,
                  ff,
                  r,
                  g,
                  b,
                  fontSpec = $.extend({}, iFontSpec),
                  styles = {},
                  nodes = [];

                for (ix = 0; ix < node.value.length; ix += 1) {
                  if (node.value[ix].code) {
                    styles[node.value[ix].code] = node.value[ix].value;
                  } else if (node.value[ix].type) {
                    nodes.push(node.value[ix]);
                  }
                }

                if (styles.fontFamily) {
                  if (iFontSpec.fontTable) {
                    ff = iFontSpec.fontTable[parseInt(styles.fontFamily, 16)];
                    if (ff) {
                      fontSpec['font-family'] = ff;
                    }
                  }
                }
                if (styles.fontSize) {
                  fontSpec['font-size'] = parseInt(styles.fontSize, 16) + 'px';
                } else if (Number(styles.fontWeight) === 2) {
                  fontSpec['font-weight'] = 'bold';
                }
                if (Number(styles.fontStyle) === 2) {
                  fontSpec['font-style'] = 'italic';
                }
                if (Number(styles.underbar) === 2) {
                  fontSpec['text-decoration'] = 'underline';
                }
                if (styles.red || styles.green || styles.blue) {
                  r = styles.red ? parseInt(styles.red, 16) - 1 : 0;
                  g = styles.green ? parseInt(styles.green, 16) - 1 : 0;
                  b = styles.blue ? parseInt(styles.blue, 16) - 1 : 0;
                  fontSpec.color = 'rgb(' + r + ',' + g + ',' + b + ')';
                }
                ctx.save();
                setFontAndStyle(ctx, fontSpec);
                visit(nodes[0], fontSpec);
                ctx.restore();
              };
              visitMap.sub = function(node, iFontSpec) {
                var fontSpec = $.extend({}, iFontSpec),
                  yOffset = Math.round(
                    kSubscriptOffsetFactor * fontSpec['font-size']
                  );
                visit(node.value[0], fontSpec);
                y += yOffset;
                ctx.save();
                fontSpec['font-size'] = Math.round(
                  kFontDiminishmentFactor * fontSpec['font-size']
                );
                setFontAndStyle(ctx, fontSpec);
                visit(node.value[1], fontSpec);
                ctx.restore();
                y -= yOffset;
              };
              visitMap['super'] = function(node, iFontSpec) {
                var fontSpec = $.extend({}, iFontSpec),
                  yOffset = Math.round(
                    kSubscriptOffsetFactor * fontSpec['font-size']
                  );
                visit(node.value[0], fontSpec);
                y -= yOffset;
                ctx.save();
                fontSpec['font-size'] = Math.round(
                  kFontDiminishmentFactor * fontSpec['font-size']
                );
                setFontAndStyle(ctx, fontSpec);
                visit(node.value[1], fontSpec);
                ctx.restore();
                y += yOffset;
              };
              visitMap.text = function(node, iFontSpec) {
                var s = getNodeText(node),
                  metrics = ctx.measureText(s),
                  nodeBounds = getBoundingBoxEstimate(
                    x,
                    y,
                    metrics.width,
                    iFontSpec
                  );

                // render the text
                ctx.fillText(s, x, y);

                // we have to render any underlines ourselves
                if (iFontSpec['text-decoration'] === 'underline') {
                  var yUnderline = Math.round(y + 2) + 0.5;
                  drawLine(
                    ctx,
                    { x: x, y: yUnderline },
                    { x: x + metrics.width, y: yUnderline }
                  );
                  nodeBounds.bottom = Math.max(
                    nodeBounds.bottom,
                    yUnderline + 1
                  );
                }

                renderBounds = GSP.Geom.unionRects(renderBounds, nodeBounds);

                x += metrics.width;
              };
              // symbol nodes can be rendered like text nodes
              visitMap.symbol = visitMap.text;

              visit(node, iFontSpec);

              // return the estimated bounds of the text
              return renderBounds;
            }

            function getFontSpec() {
              return {
                fontTable: drawRefCon.fontTable,
                'font-weight': drawRefCon['font-weight'],
                'font-style': drawRefCon['font-style'],
                'text-decoration': drawRefCon['text-decoration'],
                'font-size': drawRefCon['font-size'],
                'font-family': drawRefCon['font-family'],
                color: drawRefCon.color,
              };
            }

            /*
             * Updating
             */
            // tmpCtx is the sketch context for direct text rendering (fillText)
            // and an offscreen canvas for indirect text rendering (fillText/drawImage).
            var tmpCtx = renderAttrs.useDrawImage ? null : ctx,
              devicePixelRatio = window.devicePixelRatio || 1,
              fontSize = drawRefCon['font-size'] || kDefaultFontSize,
              fontSpec,
              sizeEstimate;
            // Check the following change, adding forceDomParse to the frame test. forceDomParse is set
            // when the MFS has changed in the absence of reconstraining the sketch (as in relabeling a gobj or button)
            // This change works with the html engine; it seems likely that it will work here also.
            if (
              renderAttrs.constraintFrame !== drawRefCon.constraintFrame ||
              renderAttrs.forceDomParse
            ) {
              if (renderAttrs.parsedMFS !== drawRefCon.parsedMFS) {
                drawRefCon.parsedMFS = renderAttrs.parsedMFS;

                if (renderAttrs.useDrawImage) {
                  if (!drawRefCon.mfsImage) {
                    // create the offscreen canvas
                    drawRefCon.mfsImage = document.createElement('canvas');
                  }
                  // size the offscreen canvas based on the estimated size of the text
                  fontSpec = getFontSpec();
                  sizeEstimate = getSizePreEstimate(
                    ctx,
                    fontSpec,
                    drawRefCon.parsedMFS
                  );
                  drawRefCon.mfsImage.width = Math.round(
                    sizeEstimate.width * devicePixelRatio
                  );
                  drawRefCon.mfsImage.height = Math.round(
                    sizeEstimate.height * devicePixelRatio
                  );
                  tmpCtx = drawRefCon.mfsImage.getContext('2d');
                  // scale the canvas for HiDPI displays (e.g. retina) and for browser zoom
                  tmpCtx.scale(devicePixelRatio, devicePixelRatio);
                }
              }
              drawRefCon.constraintFrame = renderAttrs.constraintFrame;
            }

            /*
             * Rendering to image canvas
             */
            if (drawRefCon.parsedMFS && tmpCtx) {
              if (!fontSpec) fontSpec = getFontSpec();

              var factors = getFontScaleFactors(fontSpec);

              if (renderAttrs.useDrawImage) {
                // adjust location offsets for image rendering
                drawRefCon.imageOffset = {
                  x: Math.round(fontSize * factors.left),
                  y: Math.round(fontSize * factors.ascent),
                };
                x = drawRefCon.imageOffset.x;
                y = drawRefCon.imageOffset.y;
              }

              if (!renderAttrs.useDrawImage) {
                ctx.save();
                ctx.globalAlpha *= renderAttrs.opacity;
              }

              setFontAndStyle(tmpCtx, fontSpec);
              tmpCtx.textBaseline = 'alphabetic';
              y += fontSize;
              drawRefCon.baseRenderBounds = renderMFSParseTree(
                tmpCtx,
                drawRefCon.parsedMFS,
                fontSpec
              );

              if (!renderAttrs.useDrawImage) ctx.restore();
            }

            if (renderAttrs.useDrawImage && drawRefCon.mfsImage) {
              xSketch -= drawRefCon.imageOffset.x;
              ySketch -= drawRefCon.imageOffset.y;

              ctx.save();
              // scale to accommodate HiDPI displays (e.g. retina) and browser zoom
              if (devicePixelRatio !== 1) {
                ctx.scale(1 / devicePixelRatio, 1 / devicePixelRatio);
              }
              ctx.drawImage(
                drawRefCon.mfsImage,
                xSketch * devicePixelRatio,
                ySketch * devicePixelRatio
              );
              drawRefCon.renderBounds = GSP.Geom.offsetRect(
                drawRefCon.baseRenderBounds,
                xSketch,
                ySketch
              );
              ctx.restore();
            } else {
              drawRefCon.renderBounds = drawRefCon.baseRenderBounds;
            }
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {},
        },
        Picture: {
          prepare: preparePicture,
          draw: drawPicture,
          cleanup: cleanupPicture,
        },
        Axis: {
          prepare: function(drawContext, renderAttrs) {},
          draw: function(drawContext, drawRefCon, renderAttrs) {
            function diminishFontSize(iBaseFontSize, iDiminishCount) {
              // nothing to do
              if (iDiminishCount <= 0) return iBaseFontSize;

              var fontSize = iBaseFontSize,
                kLargeFontInitialDiminishmentThreshold = 18,
                kLargeFontInitialDiminishmentFactor = 0.8,
                kRecurringDiminishmentFactor = 0.8,
                kMinFontSize = 6;
              if (iBaseFontSize >= kLargeFontInitialDiminishmentThreshold)
                fontSize *= kLargeFontInitialDiminishmentFactor;
              for (; iDiminishCount > 0; --iDiminishCount) {
                fontSize *= kRecurringDiminishmentFactor;
              }
              return Math.max(Math.round(fontSize), kMinFontSize);
            }

            /*
             * Initialization
             */
            var ctx = drawContext.context,
              canvasMin,
              canvasMax,
              originAlongAxisCoord,
              originCrossAxisCoord,
              renderMin,
              renderMax,
              largeTickSpacing =
                renderAttrs.tickSpacing.pixelsBetweenTicks *
                renderAttrs.tickSpacing.largeTickInterval,
              pixelsPerPIUnits = Math.PI * renderAttrs.unitPixels,
              largeTicksPerPI = Math.round(pixelsPerPIUnits / largeTickSpacing),
              // tick numbers are diminished once from label size
              defaultFontSize = diminishFontSize(renderAttrs['font-size'], 1),
              defaultFontSpec =
                defaultFontSize + 'px' + ' ' + renderAttrs['font-family'],
              lineHeight = defaultFontSize,
              exponentFontSpec,
              kPI = 'π',
              piFontSpec,
              piMetrics,
              kMinus = '−',
              minusMetrics;

            if (renderAttrs.orientation === 'horizontal') {
              canvasMin = renderAttrs.sketchRect.left;
              canvasMax = renderAttrs.sketchRect.right;
              originAlongAxisCoord = renderAttrs.origin.x;
              originCrossAxisCoord = renderAttrs.origin.y;
            } else {
              canvasMin = renderAttrs.sketchRect.top;
              canvasMax = renderAttrs.sketchRect.bottom;
              originAlongAxisCoord = renderAttrs.origin.y;
              originCrossAxisCoord = renderAttrs.origin.x;
            }

            // a little extra for anti-aliasing, etc.
            renderMin = canvasMin - 1;
            renderMax = canvasMax + 1;

            if (!renderAttrs.renderable) {
              return;
            }

            /**
                Render the main axis line.
               */
            function renderAxisLine() {
              ctx.save();
              ctx.setLineDash(renderAttrs.lineDash || []);
              if (renderAttrs.orientation === 'horizontal') {
                drawLine(
                  ctx,
                  { x: renderMin, y: originCrossAxisCoord },
                  { x: renderMax, y: originCrossAxisCoord }
                );
              } else {
                drawLine(
                  ctx,
                  { x: originCrossAxisCoord, y: renderMin },
                  { x: originCrossAxisCoord, y: renderMax }
                );
              }
              ctx.restore();
            }

            /**
                Render the ticks along the axis line.
                Note: Like the GSP 5, only major ticks are rendered.
               */
            function renderTicks() {
              var majorTickLength = renderAttrs.majorTickLength,
                tickCoord,
                tickIndex,
                minTickIndex,
                maxTickIndex;

              // Determine range of x and y values to render (cf. CoordSysKind_RenderProc())
              // Use ~~ to efficiently truncate to integer
              // (cf. http://stackoverflow.com/questions/4055633/what-does-do-in-javascript)
              /*jslint bitwise:true */
              minTickIndex = ~~(
                (renderMin - originAlongAxisCoord) /
                largeTickSpacing
              );
              maxTickIndex = ~~(
                (renderMax - originAlongAxisCoord) /
                largeTickSpacing
              );

              for (
                tickIndex = minTickIndex;
                tickIndex <= maxTickIndex;
                ++tickIndex
              ) {
                tickCoord = originAlongAxisCoord + tickIndex * largeTickSpacing;

                if (tickIndex !== 0) {
                  if (renderAttrs.orientation === 'horizontal') {
                    drawLine(
                      ctx,
                      {
                        x: tickCoord,
                        y: originCrossAxisCoord - majorTickLength,
                      },
                      {
                        x: tickCoord,
                        y: originCrossAxisCoord + majorTickLength,
                      }
                    );
                  } else {
                    drawLine(
                      ctx,
                      {
                        x: originCrossAxisCoord - majorTickLength,
                        y: tickCoord,
                      },
                      {
                        x: originCrossAxisCoord + majorTickLength,
                        y: tickCoord,
                      }
                    );
                  }
                }
              }
            }

            /**
                Rounds the specified value to the specified decimal precision.
               */
            function roundToPrecision(iValue, iPrecision) {
              // Use ~~ to efficiently truncate to integer
              // (cf. http://stackoverflow.com/questions/4055633/what-does-do-in-javascript)
              /*jslint bitwise:true */
              if (iValue !== ~~iValue) {
                var scaleFactor = Math.pow(10, iPrecision);
                return Math.round(iValue * scaleFactor) / scaleFactor;
              }
              return iValue;
            }

            /**
                Format the specified value using scientific/exponential notation.
                Replaces "e" with an appropriate representation of "x10^", for instance.
               */
            function formatExponentialValue(iValue) {
              // Convert to string representation
              var str = iValue.toExponential(
                  renderAttrs.precisionInfo.precision
                ),
                // Separate the base part of the string from the exponent
                eIndex = str.indexOf('e'),
                // Extract base; convert to number then to string to strip trailing zeros
                mantissa = (+str.substr(0, eIndex)).toString(),
                expIndex = str[eIndex + 1] === '+' ? eIndex + 2 : eIndex + 1,
                exponent = str.substr(expIndex);
              return {
                type: 'exponential',
                primary: mantissa + '●10',
                secondary: exponent.toString(),
              };
            }

            /**
                Format trig value as multiple of pi if appropriate.
               */
            function formatTrigValue(iLargeTickIndex, iTickValue) {
              var kLargestSmallFractionDenominator = 72,
                piFraction = GSP.math.reduceFraction(
                  Math.abs(iLargeTickIndex),
                  largeTicksPerPI
                ),
                tickValue,
                tickValueSign,
                tickNumberString,
                tickNumber;

              // Format as a PI fraction
              if (
                piFraction.denominator > 1 &&
                piFraction.denominator <= kLargestSmallFractionDenominator
              ) {
                var numeratorString = '';
                if (piFraction.numerator !== 1)
                  numeratorString += piFraction.numerator;
                tickNumber = {
                  type: 'fraction',
                  negative: iLargeTickIndex < 0,
                  primary: numeratorString,
                  secondary: piFraction.denominator.toString(),
                  pi: true,
                };
              }
              // Format as a multiple of pi
              else if (piFraction.denominator < 72) {
                tickValue = roundToPrecision(
                  iTickValue / Math.PI,
                  renderAttrs.precisionInfo.precision
                );
                tickValueSign = tickValue < 0 ? '-' : '';
                tickValue = Math.abs(tickValue);
                tickNumberString = tickValueSign;
                if (tickValue !== 1) tickNumberString += tickValue;
                tickNumber = {
                  type: 'simple',
                  primary: tickNumberString,
                  pi: true,
                };
              }
              // Format as a straight decimal number
              else {
                tickValue = roundToPrecision(
                  iTickValue,
                  renderAttrs.precisionInfo.precision
                );
                tickNumber = { type: 'simple', primary: tickValue.toString() };
              }
              return tickNumber;
            }

            /**
                Format a numeric axis value as a tick number.
               */
            function formatTickNumber(iLargeTickIndex, iTickValue) {
              var tickValue = iTickValue,
                absTickValue = Math.abs(tickValue),
                tickNumber;
              if (
                absTickValue < renderAttrs.precisionInfo.smallExponentBound ||
                absTickValue > renderAttrs.precisionInfo.largeExponentBound
              ) {
                tickNumber = formatExponentialValue(tickValue);
              } else if (renderAttrs.tickNumbering === 'trigonometric') {
                tickNumber = formatTrigValue(iLargeTickIndex, iTickValue);
              } else {
                tickValue = roundToPrecision(
                  tickValue,
                  renderAttrs.precisionInfo.precision
                );
                tickNumber = { type: 'simple', primary: tickValue.toString() };
              }
              if (tickNumber.primary)
                tickNumber.primary = tickNumber.primary.replace('-', kMinus);
              return tickNumber;
            }

            /**
                Render a tick number with appropriate formatting.
               */
            function renderTickNumber(iTickNumber, iTickCoord, iNumberOffset) {
              var primaryMetrics =
                  iTickNumber.primary && ctx.measureText(iTickNumber.primary),
                secondaryMetrics,
                kPiSpacing = 1, // additional spacing between numeral and PI
                kMinusSpacing = 2, // additional spacing between minus sign and numeral
                totalWidth,
                totalHeight,
                savedBaseline = ctx.textBaseline,
                x,
                y,
                center = {};

              // PI font/metrics
              if (iTickNumber.pi) {
                if (!piFontSpec) piFontSpec = defaultFontSize + 'px Symbol';
                if (!piMetrics) {
                  ctx.font = piFontSpec;
                  piMetrics = ctx.measureText(kPI);
                  ctx.font = defaultFontSpec;
                }
              }

              // total width
              totalWidth = primaryMetrics ? primaryMetrics.width : 0;
              if (iTickNumber.pi) {
                if (totalWidth) totalWidth += kPiSpacing;
                totalWidth += piMetrics.width;
              }

              /*
               * Render a simple tick number
               */
              if (iTickNumber.type === 'simple') {
                totalHeight = defaultFontSize;
                if (renderAttrs.orientation === 'horizontal') {
                  center.x = iTickCoord;
                  center.y =
                    Math.round(
                      originCrossAxisCoord + iNumberOffset + totalHeight / 2
                    ) - 0.5;
                } else {
                  center.x =
                    originCrossAxisCoord - iNumberOffset - totalWidth / 2;
                  center.y = Math.round(iTickCoord) - 1.5;
                }
                x = center.x - totalWidth / 2;
                y = center.y + defaultFontSize / 2 + 2;
                ctx.textBaseline = 'bottom';
                if (iTickNumber.primary) {
                  ctx.fillText(iTickNumber.primary, x, y);
                  x += primaryMetrics.width + kPiSpacing;
                }
                if (iTickNumber.pi) {
                  ctx.font = piFontSpec;
                  ctx.fillText(kPI, x, y);
                  ctx.font = defaultFontSpec;
                }
              } else if (iTickNumber.type === 'exponential') {

              /*
               * Render an exponential tick number
               */
                var exponentFontSize = diminishFontSize(
                    renderAttrs['font-size'],
                    2
                  ),
                  kExponentSpacing = 1,
                  exponent = {};
                if (!exponentFontSpec)
                  exponentFontSpec =
                    exponentFontSize + 'px ' + renderAttrs['font-family'];
                ctx.font = exponentFontSpec;
                secondaryMetrics = ctx.measureText(iTickNumber.secondary);
                totalWidth += kExponentSpacing + secondaryMetrics.width;
                // technically it should be exponentFontSize/2, but adding the full
                // exponentFontSize here centers the mantissa properly.
                totalHeight = defaultFontSize + exponentFontSize;
                if (renderAttrs.orientation === 'horizontal') {
                  center.x = iTickCoord;
                  center.y =
                    Math.round(
                      originCrossAxisCoord + iNumberOffset + totalHeight / 2
                    ) + 0.5;
                } else {
                  center.x =
                    originCrossAxisCoord - iNumberOffset - totalWidth / 2;
                  center.y = Math.round(iTickCoord) + 0.5;
                }
                ctx.textBaseline = 'middle';
                x = center.x - totalWidth / 2;
                // Render the exponent
                exponent.x = x + primaryMetrics.width + kExponentSpacing;
                exponent.y = center.y - defaultFontSize / 2;
                ctx.fillText(iTickNumber.secondary, exponent.x, exponent.y);
                // Render the mantissa/base
                ctx.font = defaultFontSpec;
                ctx.fillText(iTickNumber.primary, x, center.y);
              } else if (iTickNumber.type === 'fraction') {

              /*
               * Render a fraction tick number
               */
                if (!minusMetrics && iTickNumber.negative)
                  minusMetrics = ctx.measureText(kMinus);
                secondaryMetrics = ctx.measureText(iTickNumber.secondary);
                var numeratorWidth = totalWidth,
                  denominatorWidth = secondaryMetrics.width,
                  fractionWidth =
                    Math.max(numeratorWidth, denominatorWidth) + 2,
                  fractionLeft,
                  fractionRight,
                  fractionCenter,
                  kFractionVertOffset = 5,
                  numeratorOffset = (fractionWidth - numeratorWidth) / 2,
                  denominatorOffset = (fractionWidth - denominatorWidth) / 2;
                totalWidth = Math.max(numeratorWidth, denominatorWidth) + 2;
                if (iTickNumber.negative)
                  totalWidth += minusMetrics.width + kMinusSpacing;
                totalHeight = 2 * (lineHeight + 4);

                if (renderAttrs.orientation === 'horizontal') {
                  center.x = iTickCoord;
                  center.y =
                    Math.round(
                      originCrossAxisCoord + iNumberOffset + totalHeight / 2
                    ) - 1.5;
                } else {
                  center.x =
                    originCrossAxisCoord - iNumberOffset - totalWidth / 2 - 1;
                  center.y = Math.round(iTickCoord) + 0.5;
                }

                // Render the minus sign, if present
                if (iTickNumber.negative) {
                  ctx.textBaseline = 'middle';
                  ctx.fillText(kMinus, center.x - totalWidth / 2, center.y - 1);
                  fractionLeft =
                    center.x -
                    totalWidth / 2 +
                    minusMetrics.width +
                    kMinusSpacing;
                } else {
                  fractionLeft = center.x - totalWidth / 2;
                }
                fractionRight = fractionLeft + fractionWidth;
                fractionCenter = (fractionLeft + fractionRight) / 2;

                // Render the fraction bar
                ctx.lineWidth = 1;
                drawLine(
                  ctx,
                  { x: fractionLeft, y: center.y },
                  { x: fractionRight, y: center.y }
                );

                // Render the numerator
                x = fractionLeft + numeratorOffset;
                y = center.y - kFractionVertOffset - 1;
                ctx.textBaseline = 'alphabetic';
                if (iTickNumber.primary) {
                  ctx.fillText(iTickNumber.primary, x, y);
                  x += primaryMetrics.width + kPiSpacing;
                }
                if (iTickNumber.pi) {
                  ctx.font = piFontSpec;
                  ctx.fillText(kPI, x, y);
                  ctx.font = defaultFontSpec;
                }

                // Render the denominator
                x = fractionLeft + denominatorOffset;
                y =
                  center.y +
                  kFractionVertOffset -
                  Math.round(defaultFontSize / 6);
                ctx.textBaseline = 'top';
                ctx.fillText(iTickNumber.secondary, x, y);
              }

              // Restore the original text baseline
              ctx.textBaseline = savedBaseline;
            }

            /**
                Render the axis labels along the axis.
                A subset of the major ticks are generally labeled.
               */
            function renderTickNumbers() {
              var labelSpacing =
                  largeTickSpacing *
                  renderAttrs.tickSpacing.largeIntervalsPerText,
                tickCoord,
                labelIndex,
                minLabelIndex,
                maxLabelIndex,
                labelValue,
                tickNumber,
                labelOffset = renderAttrs.majorTickLength + 3;

              // Determine range of x and y values to render (cf. CoordSysKind_RenderProc())
              // Use ~~ to efficiently truncate to integer
              // (cf. http://stackoverflow.com/questions/4055633/what-does-do-in-javascript)
              /*jslint bitwise:true */
              minLabelIndex =
                ~~((renderMin - originAlongAxisCoord) / labelSpacing) - 1;
              maxLabelIndex =
                ~~((renderMax - originAlongAxisCoord) / labelSpacing) + 1;
              // Note that we render one additional label on each end just in case.
              // Desktop GSP heuristically determines the maximum label size and then
              // only renders an additional label if it's within half the maximum extent.
              // We bypass that level of optimization until it is deemed worthwhile.

              ctx.font = defaultFontSpec;
              ctx.textAlign = 'left';

              for (
                labelIndex = minLabelIndex;
                labelIndex <= maxLabelIndex;
                ++labelIndex
              ) {
                if (labelIndex !== 0) {
                  var largeTickIndex =
                    labelIndex * renderAttrs.tickSpacing.largeIntervalsPerText;
                  tickCoord = originAlongAxisCoord + labelIndex * labelSpacing;
                  labelValue =
                    (labelIndex * labelSpacing) / renderAttrs.unitPixels;

                  // Polar coordinates, vertical axis can affect sign
                  if (renderAttrs.isPolar) {
                    largeTickIndex = Math.abs(largeTickIndex);
                    labelValue = Math.abs(labelValue);
                  } else if (renderAttrs.orientation === 'vertical') {
                    largeTickIndex = -largeTickIndex;
                    labelValue = -labelValue;
                  }

                  // Format the tick number/label appropriately
                  tickNumber = formatTickNumber(largeTickIndex, labelValue);

                  // Render the tick number/label next to its associated tick
                  renderTickNumber(tickNumber, tickCoord, labelOffset);
                }
              }
            }

            /*
             * Rendering
             */
            ctx.save();

            if (undefined !== renderAttrs.width) {
              ctx.lineWidth = renderAttrs.width;
            }
            if (undefined !== renderAttrs.color) {
              ctx.fillStyle = renderAttrs.color;
              ctx.strokeStyle = renderAttrs.color;
            }
            if (undefined !== renderAttrs.opacity) {
              ctx.globalAlpha *= renderAttrs.opacity;
            }

            renderAxisLine();

            renderTicks();

            if (renderAttrs.tickNumberStyle === 'auto') {
              renderTickNumbers();
            }

            ctx.restore();
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {},
        },
        CoordSys: {
          prepare: function(drawContext, renderAttrs) {},
          draw: function(drawContext, drawRefCon, renderAttrs) {
            /*
             * Initialization
             */
            var ctx = drawContext.context,
              canvasXMin = renderAttrs.sketchRect.left,
              canvasXMax = renderAttrs.sketchRect.right,
              canvasYMin = renderAttrs.sketchRect.top,
              canvasYMax = renderAttrs.sketchRect.bottom,
              // a little extra for anti-aliasing, etc.
              renderXMin = canvasXMin - 1,
              renderXMax = canvasXMax + 1,
              renderYMin = canvasYMin - 1,
              renderYMax = canvasYMax + 1,
              x,
              xTick,
              xTickMin,
              xTickMax,
              y,
              yTick,
              yTickMin,
              yTickMax;

            if (!renderAttrs.renderable) {
              return;
            }

            // Determine range of x and y values to render (cf. CoordSysKind_RenderProc())
            // Use ~~ to efficiently truncate to integer
            // (cf. http://stackoverflow.com/questions/4055633/what-does-do-in-javascript)
            /*jslint bitwise:true */
            xTickMin = ~~(
              (renderXMin - renderAttrs.origin.x) /
              renderAttrs.gridSpacing.x
            );
            xTickMax = ~~(
              (renderXMax - renderAttrs.origin.x) /
              renderAttrs.gridSpacing.x
            );
            yTickMin = ~~(
              (renderYMin - renderAttrs.origin.y) /
              renderAttrs.gridSpacing.y
            );
            yTickMax = ~~(
              (renderYMax - renderAttrs.origin.y) /
              renderAttrs.gridSpacing.y
            );

            /*
             * Rendering
             */
            ctx.save();

            if (undefined !== renderAttrs.width) {
              ctx.lineWidth = renderAttrs.width;
            }
            if (undefined !== renderAttrs.color) {
              ctx.strokeStyle = renderAttrs.color;
            }
            if (undefined !== renderAttrs.opacity) {
              ctx.globalAlpha *= renderAttrs.opacity;
            }

            /*
             * Rectangular/square rendering
             */

            /**
                Draws a horizontal line across the width of the canvas.
                @param  {Number}  y -- the y coordinate of the line
               */
            function renderHorizLine(y) {
              drawLine(ctx, { x: renderXMin, y: y }, { x: renderXMax, y: y });
            }

            /**
                Draws a row of dots across the width of the canvas.
                @param  {Number}  y -- the y coordinate of the row
               */
            function renderHorizDots(y) {
              for (xTick = xTickMin; xTick <= xTickMax; ++xTick) {
                x = renderAttrs.origin.x + xTick * renderAttrs.gridSpacing.x;

                drawCircleFill(ctx, { x: x, y: y }, renderAttrs.radius);
              }
            }

            /**
                Draws the rectangular grid as either lines or dotted vertices.
                Based on RenderRectGrid() in render_axis.c.
               */
            function renderRectangularGrid() {
              // Render vertical lines
              if (renderAttrs.grid === 'gridlines') {
                for (xTick = xTickMin; xTick <= xTickMax; ++xTick) {
                  x = renderAttrs.origin.x + xTick * renderAttrs.gridSpacing.x;

                  drawLine(
                    ctx,
                    { x: x, y: renderYMin },
                    { x: x, y: renderYMax }
                  );
                }
              }

              // Render horizontal lines (or rows of dots)
              var renderFn = renderHorizLine;
              if (renderAttrs.grid === 'dotted') {
                renderFn = renderHorizDots;
                ctx.fillStyle = renderAttrs.color;
              }
              for (yTick = yTickMin; yTick <= yTickMax; ++yTick) {
                y = renderAttrs.origin.y + yTick * renderAttrs.gridSpacing.y;

                // render horizontal line or row of dots
                renderFn(y);
              }
            }

            /*
             * Polar rendering
             */

            /**
                Draws the polar grid in its lined or dotted form.
                Based on RenderPolarGrid() in render_axis.c.
               */
            function renderPolarGrid() {
              /*
               * Polar initialization
               */
              var xRadialTickMax = Math.max(
                  Math.abs(xTickMin),
                  Math.abs(xTickMax)
                ),
                yRadialTickMax = Math.max(
                  Math.abs(yTickMin),
                  Math.abs(yTickMax)
                ),
                radialTickMin = 1,
                radialTickMax = xRadialTickMax + yRadialTickMax,
                radialTickMaxSquare =
                  xRadialTickMax * xRadialTickMax +
                  yRadialTickMax * yRadialTickMax,
                gridRatio =
                  renderAttrs.gridSpacing.y / renderAttrs.gridSpacing.x,
                isOriginVisibleInX = xTickMin * xTickMax <= 0,
                isOriginVisibleInY = yTickMin * yTickMax <= 0;

              // Set maximum of radial tick range for rendering
              while (radialTickMax * radialTickMax > radialTickMaxSquare) {
                --radialTickMax;
              }
              ++radialTickMax;

              // Set minimum of radial tick range for rendering
              if (!isOriginVisibleInX || !isOriginVisibleInY) {
                var xRadialTickMin = Math.min(
                    Math.abs(xTickMin),
                    Math.abs(xTickMax)
                  ),
                  yRadialTickMin = Math.min(
                    Math.abs(yTickMin),
                    Math.abs(yTickMax)
                  );
                if (isOriginVisibleInX) {
                  radialTickMin = yRadialTickMin;
                } else if (isOriginVisibleInY) {
                  radialTickMin = xRadialTickMin;
                } else {
                  // Origin not in X or Y range. Set radialTickMin from closest corner.
                  var radialTickMinSquare =
                    xRadialTickMin * xRadialTickMin +
                    yRadialTickMin * yRadialTickMin;
                  while (radialTickMin * radialTickMin <= radialTickMinSquare) {
                    ++radialTickMin;
                  }
                  --radialTickMin;
                }
              }

              /*
               * Polar annular rendering
               */

              /**
                  Draws an annulus of dots at 15-deg intervals.
                  Based on RenderPolarGrid() in render_axis.c.
                  Uses several closure variables:
                    renderAttrs.radius -- the radius of the rendered dots
                    renderAttrs.color -- the color of the rendered dots
                  @param  {Object}  ctx -- the canvas context
                  @param  {Object}  iOrigin -- the center of the annulus
                  @param  {Number}  iRadius -- the { x, y } radius of the annulus
                 */
              function renderAnnularDots(ctx, iOrigin, iRadius) {
                var latticePt, // index of 15-deg polar line (0..23)
                  relativePt = { x: 0, y: 0 }, //
                  dotRadius = renderAttrs.radius,
                  // Lookup table so RenderPolarGrid can avoid using trig functions.
                  // Each pair gives {cos,sin} values for 15-deg increments in Quadrant I.
                  kCosSin15Deg = [
                    { cos: 1.0, sin: 0.0 }, //  0 deg
                    { cos: 0.96592582628907, sin: 0.25881904510252 }, // 15 deg
                    { cos: 0.86602540378444, sin: 0.5 }, // 30 deg
                    { cos: 0.70710678118655, sin: 0.70710678118655 }, // 45 deg
                    { cos: 0.5, sin: 0.86602540378444 }, // 60 deg
                    { cos: 0.25881904510252, sin: 0.96592582628907 }, // 75 deg
                    { cos: 0.0, sin: 1.0 }, // 90 deg
                  ];

                ctx.fillStyle = renderAttrs.color;
                for (latticePt = 0; latticePt < 7; ++latticePt) {
                  relativePt.x = iRadius.x * kCosSin15Deg[latticePt].cos;
                  relativePt.y = iRadius.y * kCosSin15Deg[latticePt].sin;

                  // Quadrant I
                  drawCircleFill(
                    ctx,
                    {
                      x: iOrigin.x + relativePt.x,
                      y: iOrigin.y - relativePt.y,
                    },
                    dotRadius
                  );
                  // Quadrant II
                  if (latticePt > 0 && latticePt < 6) {
                    // skip for axes
                    drawCircleFill(
                      ctx,
                      {
                        x: iOrigin.x - relativePt.x,
                        y: iOrigin.y - relativePt.y,
                      },
                      dotRadius
                    );
                  }
                  // Quadrant III
                  drawCircleFill(
                    ctx,
                    {
                      x: iOrigin.x - relativePt.x,
                      y: iOrigin.y + relativePt.y,
                    },
                    dotRadius
                  );
                  // Quadrant IV
                  if (latticePt > 0 && latticePt < 6) {
                    // skip for axes
                    drawCircleFill(
                      ctx,
                      {
                        x: iOrigin.x + relativePt.x,
                        y: iOrigin.y + relativePt.y,
                      },
                      dotRadius
                    );
                  }
                }
              }

              // Draw annular gridlines or dots
              var renderFn =
                  renderAttrs.grid === 'dotted'
                    ? renderAnnularDots
                    : drawEllipseFrame,
                i;
              for (i = 1; i <= radialTickMax; ++i) {
                var radius = {
                  x: i * renderAttrs.gridSpacing.x,
                  y: i * renderAttrs.gridSpacing.y,
                };
                renderFn(ctx, renderAttrs.origin, radius);
              }

              /*
               * Polar radial rendering
               */

              /**
                  Utility function for determining if a given radial line is visible
                  given the origin placement within the canvas.
                  Based on RenderPolarGrid() in render_axis.c.
                  @param  {Number}  iTheta -- angle of the radial in radians
                  @param  {Array of Points} iPts -- Array of two { x, y } points
                                                    defining the endpoints of the radial
                  @param  {String}  iProp -- 'x' or 'y' for the coordinate to be checked
                  @param  {Object}  iRange -- { min, max } values for the coordinate
                  @returns  {Boolean} True if the radial is visible and should
                                      be rendered, false otherwise.
                 */
              function isRadialInRange(iTheta, iPts, iProp, iRange) {
                if (iTheta === 0.0) {
                  return (
                    iRange.min <= iPts[0][iProp] && iPts[0][iProp] <= iRange.max
                  );
                } else if (iTheta > 0.0) {
                  return iPts[0][iProp] > iRange.max
                    ? iPts[1][iProp] <= iRange.max
                    : iPts[0][iProp] >= iRange.min;
                } else if (iTheta < 0.0) {
                  return iPts[0][iProp] < iRange.min
                    ? iPts[1][iProp] >= iRange.min
                    : iPts[0][iProp] <= iRange.max;
                }
              }

              // Draw radial gridlines
              if (renderAttrs.grid === 'gridlines') {
                var deltaTheta = Math.PI / 12.0, // increment by 15 deg
                  theta0 = -2.0 * deltaTheta, // start at -30 deg
                  p0 = { x: renderAttrs.origin.x, y: renderAttrs.origin.y },
                  p1 = { x: renderAttrs.origin.x, y: renderAttrs.origin.y },
                  rp = [
                    { x: p0.x, y: p0.y },
                    { x: p1.x, y: p1.y },
                  ],
                  theta,
                  tangent;

                // Render the radials from -30 deg to 30 deg.
                // These radials are clipped horizontally.
                p0 = {
                  x: renderXMin - renderAttrs.origin.x,
                  y: renderAttrs.origin.y,
                };
                rp[0].x = renderXMin;
                p1.x = renderXMax - renderAttrs.origin.x;
                rp[1].x = renderXMax;

                for (i = 0; i < 5; ++i) {
                  theta = theta0 + i * deltaTheta;
                  tangent = -Math.tan(theta) * gridRatio;
                  rp[0].y = renderAttrs.origin.y + p0.x * tangent;
                  rp[1].y = renderAttrs.origin.y + p1.x * tangent;
                  if (
                    isRadialInRange(theta, rp, 'y', {
                      min: renderYMin,
                      max: renderYMax,
                    })
                  ) {
                    drawLine(ctx, rp[0], rp[1]);
                  }
                }

                // Render the radials from 45 deg to 135 deg.
                // Let theta be the complement of the desired angle, so that
                // we can still use tan() without dividing to find cotan().
                // These radials are clipped vertically.
                gridRatio = 1.0 / gridRatio;
                p0.y = renderYMin - renderAttrs.origin.y;
                rp[0].y = renderYMin;
                p1.y = renderYMax - renderAttrs.origin.y;
                rp[1].y = renderYMax;

                theta0 = 3 * deltaTheta; // start at 45 deg
                for (i = 0; i < 7; ++i) {
                  theta = theta0 - i * deltaTheta;
                  tangent = -Math.tan(theta) * gridRatio;
                  rp[0].x = renderAttrs.origin.x + p0.y * tangent;
                  rp[1].x = renderAttrs.origin.x + p1.y * tangent;
                  if (
                    isRadialInRange(theta, rp, 'x', {
                      min: renderXMin,
                      max: renderXMax,
                    })
                  ) {
                    drawLine(ctx, rp[0], rp[1]);
                  }
                }
              }
            }

            // Body of CoordSys.draw()
            if (renderAttrs.shape === 'polar') {
              renderPolarGrid();
            } else {
              renderRectangularGrid();
            }

            ctx.restore();
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {},
        },
        AngleMarker: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }

          var ctx = drawContext.context,
            baseArc = renderAttrs.firstArc,
            baseRadius = baseArc.radius,
            isRight = renderAttrs.isRight,
            strokeFn = isRight ? drawRightAngleMarker : drawAngleMarkerArc,
            SQRT2 = 0.7071067811865475,
            radialMultiplier = isRight ? SQRT2 : 1,
            ix,
            radius,
            drawArrow;

          ctx.save();
          ctx.globalAlpha *= renderAttrs.fadeOpacity;
          ctx.strokeStyle = renderAttrs.color;
          ctx.fillStyle = renderAttrs.color;
          ctx.lineWidth = renderAttrs.width;
          ctx.setLineDash(renderAttrs.lineDash || []);

          // draw each stroke
          for (ix = 0; ix < renderAttrs.strokes; ix += 1) {
            radius =
              baseRadius * radialMultiplier +
              ix * (renderAttrs.radialSpacing + renderAttrs.width);

            drawArrow = 'none';
            if (
              ix + 1 === renderAttrs.strokes &&
              renderAttrs['show-angle-direction']
            ) {
              drawArrow = 'head';
            }
            strokeFn(
              ctx,
              baseArc,
              radius,
              renderAttrs.width,
              drawArrow,
              ix === 0,
              renderAttrs.opacity
            );
          }

          ctx.restore();
        },
        PathMarker: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context,
            tickMarkStyle = renderAttrs['tick-mark-style'],
            m = renderAttrs.metrics,
            ix,
            base = m.origin.copy(),
            p0,
            p1,
            arrowDelta0,
            arrowDelta1;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;
          ctx.strokeStyle = renderAttrs.color;
          ctx.fillStyle = renderAttrs.color;
          ctx.lineWidth = renderAttrs.width;
          ctx.setLineDash(renderAttrs.lineDash || []);

          ctx.lineCap = 'round';

          if (tickMarkStyle === 'Crossbar') {
            for (
              ix = 0;
              ix < renderAttrs.strokes;
              ix += 1, base = base.add(m.delta)
            ) {
              ctx.beginPath();
              p0 = base.subtract(m.normal);
              p1 = base.add(m.normal);
              ctx.moveTo(p0.x, p0.y);
              ctx.lineTo(p1.x, p1.y);
              ctx.stroke();
            }
          } else {
            arrowDelta0 = GSP.GeometricPoint(
              -m.normal.x - m.normal.y,
              m.normal.x - m.normal.y
            );
            arrowDelta1 = GSP.GeometricPoint(
              -m.normal.x + m.normal.y,
              -m.normal.x - m.normal.y
            );

            for (
              ix = 0;
              ix < renderAttrs.strokes;
              ix += 1, base = base.add(m.delta)
            ) {
              ctx.beginPath();

              p0 = base.add(arrowDelta0);
              p1 = base.subtract(arrowDelta1);
              ctx.moveTo(p0.x, p0.y);
              ctx.lineTo(base.x, base.y);
              ctx.lineTo(p1.x, p1.y);
              if (tickMarkStyle === 'OpenArrow') {
                ctx.stroke();
              } else if (tickMarkStyle === 'HollowArrow') {
                ctx.closePath();
                ctx.stroke();
              } else {
                ctx.fill();
              }
            }
          }

          if (renderAttrs.isFocusable) {
            this.Rectangle(drawContext, drawRefCon, renderAttrs);
          }
          ctx.restore();
        },
        ContinuousPointVector: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }
          var ctx = drawContext.context,
            samples = renderAttrs.samples,
            numArrayValues = samples.length,
            firstSample, // secondSample,
            lastSample, //nextToLastSample,
            numSamples = numArrayValues / 2;

          function computeArrowheadVerticesForSamples(
            s0x,
            s0y,
            s1x,
            s1y,
            radius,
            width
          ) {
            var firstSample = GSP.GeometricPoint(s0x, s0y), //(or last sample)
              nextSample = GSP.GeometricPoint(s1x, s1y), //(or next to last sample)
              normalizedPt = nextSample
                .subtract(firstSample)
                .unit()
                .multiply(radius);

            return computeArrowheadVerticesFromBaseAndPoint(
              firstSample.add(normalizedPt),
              firstSample,
              width
            );
          }

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          ctx.lineWidth = renderAttrs.width;

          if (renderAttrs.color) ctx.strokeStyle = renderAttrs.color;

          drawPolyline(
            ctx,
            samples,
            renderAttrs.discontinuities,
            renderAttrs.colors,
            renderAttrs.closedPath
          );

          if (renderAttrs.leftEndpoint === 'endpoint') {
            firstSample = GSP.GeometricPoint(samples[0], samples[1]);
            ctx.fillStyle = renderAttrs.colors
              ? renderAttrs.colors[0]
              : renderAttrs.color;
            drawCircleFill(ctx, firstSample, renderAttrs.endpointRadius);
          } else if (renderAttrs.leftEndpoint === 'arrowhead') {
            ctx.fillStyle = renderAttrs.colors
              ? renderAttrs.colors[0]
              : renderAttrs.color;
            ctx.strokeStyle = renderAttrs.colors
              ? renderAttrs.colors[0]
              : renderAttrs.color;
            drawArrowhead(
              ctx,
              computeArrowheadVerticesForSamples(
                samples[0],
                samples[1],
                samples[2],
                samples[3],
                renderAttrs.arrowheadRadius,
                renderAttrs.width
              ),
              true
            );
          }

          if (renderAttrs.rightEndpoint === 'endpoint') {
            lastSample = GSP.GeometricPoint(
              samples[numArrayValues - 2],
              samples[numArrayValues - 1]
            );
            ctx.fillStyle = renderAttrs.colors
              ? renderAttrs.colors[numSamples - 1]
              : renderAttrs.color;
            drawCircleFill(ctx, lastSample, renderAttrs.endpointRadius);
          } else if (renderAttrs.rightEndpoint === 'arrowhead') {
            ctx.fillStyle = renderAttrs.colors
              ? renderAttrs.colors[numSamples - 1]
              : renderAttrs.color;
            ctx.strokeStyle = renderAttrs.colors
              ? renderAttrs.colors[numSamples - 1]
              : renderAttrs.color;
            drawArrowhead(
              ctx,
              computeArrowheadVerticesForSamples(
                samples[numArrayValues - 2],
                samples[numArrayValues - 1],
                samples[numArrayValues - 4],
                samples[numArrayValues - 3],
                renderAttrs.arrowheadRadius,
                renderAttrs.width
              ),
              true
            );
          }

          ctx.restore();
        },
        DiscretePointVector: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }
          var ctx = drawContext.context;

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          if (renderAttrs.color) ctx.fillStyle = renderAttrs.color;

          drawPointVector(
            ctx,
            renderAttrs.samples,
            renderAttrs.numSamples,
            renderAttrs.radius,
            renderAttrs.colors
          );

          ctx.restore();
        },
        SegmentVector: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }
          var ctx = drawContext.context,
            i,
            stride = 4,
            numSamples = renderAttrs.numSamples,
            p0x,
            p0y,
            p1x,
            p1y;

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          ctx.lineWidth = renderAttrs.width;
          ctx.strokeStyle = renderAttrs.color;
          ctx.setLineDash(renderAttrs.lineDash || []);

          for (i = 0; i < numSamples; i++) {
            p0x = renderAttrs.samples[i * stride];
            p0y = renderAttrs.samples[i * stride + 1];
            p1x = renderAttrs.samples[i * stride + 2];
            p1y = renderAttrs.samples[i * stride + 3];

            if (renderAttrs.colors) {
              ctx.strokeStyle = renderAttrs.colors[i];
            }

            ctx.beginPath();
            ctx.moveTo(p0x, p0y);
            ctx.lineTo(p1x, p1y);
            ctx.lineCap = 'round';
            ctx.stroke();
          }

          ctx.setLineDash([]);
          ctx.restore();
        },
        ArcVector: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }
          var ctx = drawContext.context,
            i,
            arc,
            numSamples = renderAttrs.numSamples,
            type = renderAttrs.arcType,
            isInterior = type !== 'arc';

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          if (isInterior) {
            ctx.fillStyle = renderAttrs.color;
          } else {
            ctx.lineWidth = renderAttrs.width;
            ctx.strokeStyle = renderAttrs.color;
            ctx.setLineDash(renderAttrs.lineDash || []);
          }

          for (i = 0; i < numSamples; i++) {
            arc = GSP.GeometricArc.FromPackedSampleArray(
              renderAttrs.samples,
              i
            );

            if (renderAttrs.colors) {
              if (isInterior) {
                ctx.fillStyle = renderAttrs.colors[i];
              } else {
                ctx.strokeStyle = renderAttrs.colors[i];
              }
            }

            makeArcPath(ctx, arc);
            if (type === 'arcSegment') {
              ctx.closePath();
            } else if (type === 'arcSector') {
              ctx.lineTo(arc.center.x, arc.center.y);
              ctx.closePath();
            }

            if (isInterior) {
              ctx.fill();
            } else {
              ctx.stroke();
            }
          }

          ctx.setLineDash([]);
          ctx.restore();
        },
        CircleVector: function(drawContext, drawRefCon, renderAttrs) {
          if (!renderAttrs.renderable) {
            return;
          }
          var ctx = drawContext.context,
            i,
            stride = 3,
            numSamples = renderAttrs.numSamples,
            isInterior = renderAttrs.isInterior,
            base,
            centerX,
            centerY,
            radius;

          ctx.save();
          ctx.globalAlpha *= renderAttrs.opacity;

          if (isInterior) {
            ctx.fillStyle = renderAttrs.color;
          } else {
            ctx.lineWidth = renderAttrs.width;
            ctx.strokeStyle = renderAttrs.color;
          }

          ctx.setLineDash(renderAttrs.lineDash || []);

          for (i = 0; i < numSamples; i++) {
            base = i * stride;
            centerX = renderAttrs.samples[base];
            centerY = renderAttrs.samples[base + 1];
            radius = renderAttrs.samples[base + 2];

            if (renderAttrs.colors) {
              if (isInterior) {
                ctx.fillStyle = renderAttrs.colors[i];
              } else {
                ctx.strokeStyle = renderAttrs.colors[i];
              }
            }

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            if (isInterior) {
              ctx.fill();
            } else {
              ctx.stroke();
            }
          }

          ctx.setLineDash([]);
          ctx.restore();
        },
        PolygonVector: function(drawContext, drawRefCon, renderAttrs) {
          var ctx = drawContext.context,
            samples = renderAttrs.samples,
            sampleIndex,
            numVertices = renderAttrs.numVertices,
            numSamples = renderAttrs.numSamples, //number of complete polygon samples
            i = 0,
            vertexIndex;

          if (!renderAttrs.renderable) {
            return;
          }

          ctx.save();

          ctx.fillStyle = renderAttrs.color;
          ctx.globalAlpha *= renderAttrs.opacity;

          for (sampleIndex = 0; sampleIndex < numSamples; sampleIndex++) {
            if (renderAttrs.colors) {
              ctx.fillStyle = renderAttrs.colors[sampleIndex];
            }

            ctx.beginPath();
            ctx.moveTo(samples[i], samples[i + 1]);
            i += 2;
            for (vertexIndex = 1; vertexIndex < numVertices; vertexIndex++) {
              ctx.lineTo(samples[i], samples[i + 1]);
              i += 2;
            }
            ctx.closePath();
            ctx.fill('evenodd');
          }

          ctx.restore();
        },
        PictureVector: {
          prepare: preparePicture,
          draw: function(drawContext, drawRefCon, renderAttrs) {
            var transformSamples = renderAttrs.transformSamples,
              numSamples = renderAttrs.numSamples;

            for (var i = 0; i < numSamples; ++i) {
              renderAttrs.transform = GSP.AffineTransform.fromPackedSampleArray(
                transformSamples,
                i
              );
              renderAttrs.clipPolygon =
                renderAttrs.clipPolygons && renderAttrs.clipPolygons[i];
              drawPicture(drawContext, drawRefCon, renderAttrs);
            }
          },
          cleanup: cleanupPicture,
        },
      },
    };
  })();

  /**
   * @fileOverview HTML Render API
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */
  (function() {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1,
      // Base class for table and text primitives
      DOMPrimitivePrototype = {
        initWithAttrs: function(renderAttrs) {
          this.fontTable = renderAttrs.fontTable;

          // baseStyles will be passed in to mfs creators
          this.baseStyles = {
            color: renderAttrs.color,
            'font-family': renderAttrs['font-family'],
            'font-style': renderAttrs['font-style'],
            'font-weight': renderAttrs['font-weight'],
            'font-size': renderAttrs['font-size'],
            'text-decoration': renderAttrs['text-decoration'],
          };
        },

        width: function() {
          return $(this.element).outerWidth();
        },
        height: function() {
          return $(this.element).outerHeight();
        },

        draw: function(drawContext, renderAttrs) {
          var element = this.element,
            isVisible = renderAttrs.visibility === 'visible',
            zIndex,
            updateDOM = isVisible || renderAttrs.measurable;

          // we need to update the DOM if it's visible, but also
          // if we have been told that this element is going to
          // be measured.

          // first display: we create the html base element
          if (!element && updateDOM) {
            element = this.createAndAddElement(drawContext);
          }

          if (element) {
            if (updateDOM) {
              // Track changes in our zIndex resulting from the
              // addition of new gobjects to the render list.

              /*jshint -W116*/ // permit "!="
              zIndex = renderAttrs.zIndex;
              if (zIndex !== undefined && element.css('z-index') != zIndex) {
                element.css('z-index', zIndex);
              }
              /*jshint +W116*/
              // If forceDomParse is true, reparse the MFS (via updateFromModel) even if the sketch has not been reconstrained.
              // This handles MFS changes due to changing a label.
              if (
                renderAttrs.constraintFrame !== this.constraintFrame ||
                renderAttrs.forceDomParse
              ) {
                this.updateFromModel(renderAttrs);
                this.constraintFrame = renderAttrs.constraintFrame;
              }
              this.updateModelToViewTransform(drawContext.modelToViewTransform);

              this.prepareToShow(element, renderAttrs);

              this.setOpacity(element, renderAttrs);

              // If the width and height are specified, set our element to
              // that. We use outer*, since that's our external getters notion
              // of dimensions. The '' empty string unsets the value, since
              // under the hood it's just the jQuery css() function, which
              // documents '' as meaning unset. Doc's not specific for outer*
              // but there's not really any other way they can do it. And there's
              // no blessed way to unset outer*.
              element.outerWidth(renderAttrs.width ? renderAttrs.width : '');
              element.outerHeight(renderAttrs.height ? renderAttrs.height : '');
            }
          }

          if (this.visible !== isVisible) {
            if (element) element.toggle(isVisible);
            this.visible = isVisible;
          }
        },

        // Hooks for subclasses. By default, these do nothing.
        prepareToShow: function(element, renderAttrs) {},
        didShow: function(element) {},

        setOpacity: function(element, renderAttrs) {
          element.css({
            opacity: renderAttrs.opacity,
          });
        },

        updateModelToViewTransform: function(transform) {
          var element = this.element,
            transformString;

          // Firefox (as of v36) has an annoying jitter which happens
          // when transforming via CSS under scale < 1. If all we are doing
          // is translation, then we can just move the top, left and not
          // do any CSS transforming. C.f. long standing bug
          // https://bugzilla.mozilla.org/show_bug.cgi?id=757870
          // Of course, webkit shows a similar issue when using positioning,
          // so we want css transforms there!
          if (isFirefox && transform.isTranslation()) {
            element.css({
              left: this.left + transform.m20,
              top: this.top + transform.m21,
            });
          } else {
            transformString = transform.toStringCSS();
            element.css({
              left: this.left,
              top: this.top,
              transform: transformString,
            });
          }
        },

        createAndAddElement: function() {
          throw GSP.createError(
            'capability not implemented (createAndAddElement)'
          );
        },

        updateFromModel: function() {
          throw GSP.createError('capability not implemented (updateFromModel)');
        },
      },
      TextPrimitivePrototype = Object.create(DOMPrimitivePrototype);

    TextPrimitivePrototype.createAndAddElement = function(
      drawContext,
      isButton
    ) {
      var priorElement = drawContext.layer;
      var elementText = '';
      var elementNode = 'div';
      if (isButton) {
        elementText = 'type="button" role="button" tabindex="0"';
        elementNode = 'button';
      } else if (!this.isParameter && !this.isCompositeText) {
        elementText = 'role="text" tabindex="0"';
      }

      // element is the top-level DOM element of the button
      var element = $(
        '<' +
          elementNode +
          ' wsp-id="' +
          this.id +
          '" class="wsp-accessible wsp-' +
          this.kind +
          '" ' +
          elementText +
          '/>'
      );
      // mfsElement is the DOM element that gets the MFS. For buttons it's
      // a child of element.

      var mfsElement = element;

      if (isButton) {
        mfsElement = $('<div class="wsp-Button-label"></div>');
        mfsElement.wrap('<div class="wsp-Button-label-frame"></div>');

        element.append(
          $(
            '<span class="wsp-Button-row"><span class="wsp-Button-drag-handle"></span></span>'
          ).append(mfsElement.parent())
        );
      }

      this.element = element;
      this.mfsElement = mfsElement;
      element.css(this.css);
      element.hide();
      this.visible = false;
      element.appendTo(priorElement);
      if (this.isEditableByCalculator) {
        var registerElementFunc = GSP.getConfigValue(
          'NumberpadManager.delegates.registerCalculatorElement'
        );
        registerElementFunc(element);
      }
      return element;
    };
    TextPrimitivePrototype.updateFromModel = function(renderAttrs) {
      var meas, top, left;

      if (renderAttrs.parsedMFS && this.parsedMFS !== renderAttrs.parsedMFS) {
        /* 
               This is some code helpful for diagnosing performance
               issues. If the following expression is true, then we are
               doing too much parsing and performance may suffer. Note
               that the expression has never been observed to be true.
  
              if(JSONcanonical.stringify(this.parsedMFS) ===
                 JSONcanonical.stringify(renderAttrs.parsedMFS)) {
                alert('boo');
              }
               */
        this.parsedMFS = renderAttrs.parsedMFS;
        this.mfsElement.empty();

        if (this.isParameter || this.isCompositeText) {
          this.mfsElementSrOnly = $(
            '<div class="wsp-parameter-sr-only" tabindex="0" role="text" />'
          );
          this.mfsElement.prepend(this.mfsElementSrOnly);
        }

        this.valueMap = renderMFSParsed(
          this.parsedMFS,
          this.mfsElement,
          this.fontTable,
          this.baseStyles
        );
        this.speakableTextMap = GSP.mfs.makeSpeakableTextFromMFSParseTree(
          this.parsedMFS
        );
      }

      if (renderAttrs.MFSValues) {
        replaceMFSValues.call(
          this,
          this.valueMap,
          renderAttrs.MFSValues,
          this.fontTable,
          this.baseStyles
        );
      }
      replaceMFSValuesInSpeakableText.call(
        this,
        this.speakableTextMap,
        renderAttrs.MFSValues,
        this.mfsElement
      );

      if (this.attrs['text-align'] === 'center') {
        meas = this.width() / 2;
        left = renderAttrs.x - meas;
      } else {
        left = renderAttrs.x;
      }

      if (this.attrs['vertical-align'] === 'middle') {
        meas = this.height() / 2;
        top = renderAttrs.y - meas;
      } else {
        top = renderAttrs.y;
      }

      if (this.attrs['vertical-align'] === 'bottom') {
        var paddingBottom = parseInt($(this.element).css('padding-bottom'), 10);
        var innerHeight = $(this.element).height();
        top = renderAttrs.y - (innerHeight - paddingBottom);
      }

      if ((this.isParameter || this.isCompositeText) && this.mfsElementSrOnly) {
        this.mfsElement.find('.mfs-text').attr('aria-hidden', 'true');
      }

      // updateModelToViewTransform() will do what's needful to actually move the element
      this.left = left;
      this.top = top;
    };

    var ButtonPrimitivePrototype = Object.create(TextPrimitivePrototype);

    ButtonPrimitivePrototype.createAndAddElement = function(drawContext) {
      return TextPrimitivePrototype.createAndAddElement.call(
        this,
        drawContext,
        true
      );
    };

    // Buttons have a drag-handle - clients may need the width
    ButtonPrimitivePrototype.dragHandleWidth = function() {
      return $('.wsp-Button-drag-handle', this.element).outerWidth();
    };

    ButtonPrimitivePrototype.prepareToShow = function(element, renderAttrs) {
      // Set top level appearance class on the element
      element.toggleClass('wsp-appearance-active', !!renderAttrs.isHighlight);
      element.toggleClass('wsp-appearance-pressed', !!renderAttrs.inClick);
      element.toggleClass(
        'wsp-appearance-drag',
        !!renderAttrs.isDragging && renderAttrs.selectable
      );
      element.toggleClass('wsp-appearance-short', element.outerHeight() < 28);
      element.toggleClass(
        'wsp-appearance-unselectable',
        !renderAttrs.selectable
      );

      // Background color
      $('.wsp-Button-drag-handle', element).css({
        'background-color': renderAttrs['handle-color'],
      });
    };

    ButtonPrimitivePrototype.setOpacity = function(element, renderAttrs) {
      // Check the element for opacity set by external
      // css, and combine it with the internal opacity.
      element.css('opacity', '');
      var styledOpacity = element.css('opacity');
      styledOpacity = styledOpacity ? parseFloat(styledOpacity) : 1;
      styledOpacity = isNaN(styledOpacity) ? 1 : styledOpacity;
      element.css({
        opacity: renderAttrs.opacity * styledOpacity,
      });
    };

    var NonButtonPrimitivePrototype = Object.create(TextPrimitivePrototype);

    NonButtonPrimitivePrototype.didShow = function(element) {};

    NonButtonPrimitivePrototype.prepareToShow = function(element, renderAttrs) {
      element.toggleClass(
        'wsp-text-target-highlight',
        renderAttrs.targetHighlight === true
      );
      element.toggleClass(
        'wsp-text-unmatched-given',
        renderAttrs.unmatchedGiven === true
      );
      element.toggleClass(
        'wsp-text-fancy-pulse',
        renderAttrs.fancyPulse === true
      );
    };

    var TextPrimitive = {
      createWithAttrs: function(renderAttrs, isButton) {
        var ret = Object.create(
          isButton ? ButtonPrimitivePrototype : NonButtonPrimitivePrototype
        );
        ret.initWithAttrs(renderAttrs);
        ret.id = renderAttrs.id;
        ret.kind = renderAttrs.kind;
        ret.isEditableByCalculator = renderAttrs.isEditableByCalculator;
        ret.selectable = renderAttrs.selectable;
        ret.genus = renderAttrs.genus;
        ret.isParameter = renderAttrs.isParameter;
        ret.isCompositeText = renderAttrs.isCompositeText;
        ret.wspSays = renderAttrs.wspSays;

        ret.attrs = {
          'text-align': renderAttrs['text-align'],
          'vertical-align': renderAttrs['vertical-align'],
        };

        // baseStyles will be passed in on to mfs creators
        ret.baseStyles['line-height'] = renderAttrs['line-height'];
        ret.baseStyles.opacity = renderAttrs.opacity;

        // css will be directly applied to base DOM node, and not passed down to MFS.
        // We'll make this a superset of the baseStyles.
        ret.css = { padding: renderAttrs.padding };
        $.extend(ret.css, ret.baseStyles);

        if (isButton) {
          ret.attrs['highlight-color'] = renderAttrs['highlight-color'];
          ret.attrs['handle-color'] =
            renderAttrs['background-color'] || 'white';
        }

        return ret;
      },
    };

    var TablePrimitivePrototype = Object.create(DOMPrimitivePrototype);

    TablePrimitivePrototype.createAndAddElement = function(drawContext) {
      var element = $('<div tabindex="0" class="wsp-Table wsp-accessible"/>');
      this.element = element;
      element.hide();
      this.visible = false;
      element.appendTo(drawContext.layer);
      return element;
    };

    // Tables are rendered as an outermost div elt, containing a
    // table elt. This gives us nicer, inset borders, like desktop.
    TablePrimitivePrototype.updateFromModel = function(renderAttrs) {
      var tableAriaLabel = renderAttrs.kind + ' ' + renderAttrs.genus;
      var tableDocumentAriaLabel = renderAttrs.label
        ? 'aria-label="' + renderAttrs.label + '"'
        : '';
      var top,
        left,
        iRow,
        rowsMFS = renderAttrs.rowsMFS,
        headersMFS = renderAttrs.headersMFS,
        finalRowMFS = renderAttrs.finalRowMFS,
        borderColor = this.attrs['border-color'],
        wrapper = this.element,
        fontTable = this.fontTable,
        baseStyles = this.baseStyles,
        table = $('<table aria-labelledby="wsp-id-' + renderAttrs.id + '" />'),
        container = $(
          '<div role="document" tabindex="0" ' + tableDocumentAriaLabel + ' />'
        ),
        setBorderCss = function($elt) {
          $elt.addClass('wsp-responsive-borderwidth');
          $elt.css('border-color', borderColor);
        },
        needsFullRender =
          this.headersMFS !== headersMFS ||
          this.rowsMFS !== rowsMFS ||
          this.finalRowMFS !== finalRowMFS;

      this.headersMFS = headersMFS;
      this.rowsMFS = rowsMFS;
      this.finalRowMFS = finalRowMFS;

      wrapper.attr({
        'wsp-id': renderAttrs.id,
        'aria-label': tableAriaLabel,
        id: 'wsp-id-' + renderAttrs.id,
      });

      function renderOneRow(cellHTML, ColumnsMFS) {
        var $tr = $('<tr/>'),
          $cell,
          iColumn;

        for (iColumn = 0; iColumn < ColumnsMFS.length; iColumn++) {
          $cell = $('<' + cellHTML + '/>');
          setBorderCss($cell);
          $tr.append($cell);
          renderMFSParsed(ColumnsMFS[iColumn], $cell, fontTable, baseStyles);
          $cell.children().attr({
            role: 'text',
            'aria-label': GSP.mfs.makeSpeakableTextFromMFSParseTree(
              ColumnsMFS[iColumn]
            ),
          });
          $cell
            .children()
            .children()
            .attr('aria-hidden', 'true');
        }
        table.append($tr);
      }

      if (needsFullRender) {
        wrapper.empty();
        setBorderCss(wrapper);
        wrapper.css('background-color', renderAttrs['background-color']);

        setBorderCss(table);
        table.css('font-size', baseStyles['font-size']);

        // render header
        renderOneRow('th', headersMFS);

        // render rows
        for (iRow = 0; iRow < rowsMFS.length; iRow++) {
          renderOneRow('td', rowsMFS[iRow]);
        }

        // render final (live update) row
        if (finalRowMFS) {
          renderOneRow(
            // A live update table with no "dead" rows does not display
            // the live row as semitransparent.
            rowsMFS.length > 0 ? 'td class="wsp-final-row-cell"' : 'td',
            finalRowMFS
          );
        }

        container.append(table);
        wrapper.append(container);
      }

      left = renderAttrs.x;
      top = renderAttrs.y;

      // updateModelToViewTransform() will do what's needful to actually move the element
      this.left = left;
      this.top = top;
    };

    var TablePrimitive = {
      createWithAttrs: function(renderAttrs) {
        var ret = Object.create(TablePrimitivePrototype);
        ret.initWithAttrs(renderAttrs);
        ret.attrs = {
          'border-color': renderAttrs['border-color'],
          opacity: renderAttrs.opacity,
        };
        return ret;
      },
    };

    /*
     * Render the mfs parse tree as HTML under the element el.
     */
    function renderMFSParsed(parsed, el, fontTable, baseStyles) {
      var ret;
      try {
        ret = GSP.mfs.makeHTMLFromMFSParseTree(
          parsed,
          el,
          fontTable,
          baseStyles
        );
        return ret;
      } catch (ex) {
        GSP.signalCaughtError(ex);
      }
    }

    function replaceMFSValues(valueMap, valuesMFS, fontTable, baseStyles) {
      var key,
        valueArray,
        ix,
        valuesLastFrame = valuesMFS.lastRealizedFrame,
        replacedAny = false,
        rawText;

      function getStyles(el) {
        // returns either el's specific styles, or baseStyles
        // Do we ever want to use baseStyles here?
        // Won't they be used by default unless a parent of el overrides them?
        var sx,
          styleName,
          retVal = baseStyles, // default to the baseStyles
          curStyle = el[0].style;
        if (curStyle && curStyle.length > 0) {
          // Use the styles from the container
          retVal = {};
          for (sx = 0; sx < curStyle.length; sx++) {
            styleName = curStyle[sx];
            retVal[styleName] = curStyle[styleName];
          }
        }
        return retVal;
      }

      if (valueMap && valuesMFS) {
        for (key in valuesMFS) {
          if (valuesMFS.hasOwnProperty(key) && valueMap.hasOwnProperty(key)) {
            valueArray = valueMap[key];
            for (ix = 0; ix < valueArray.length; ix += 1) {
              if (
                valuesLastFrame &&
                valuesLastFrame.hasOwnProperty(key) &&
                valuesLastFrame[key] === valuesMFS[key]
              ) {
                //The mfs string has already been rendered.  Don't do anything
                continue;
              }

              //special case a single text node, and just replace the text of the object
              if (valuesMFS[key].type === 'text') {
                rawText = valuesMFS[key].value;
                $(valueArray[ix]).text(rawText);
              } else {
                // if valueArray[ix] is styled, use those styles; otherwise use baseStyles
                valueArray[ix].empty();
                renderMFSParsed(
                  valuesMFS[key],
                  valueArray[ix],
                  fontTable,
                  getStyles(valueArray[ix])
                );
              }

              // If this is a hot-text reference, then add classes and info to it.
              if (valuesMFS[key].referenceId !== undefined) {
                valueArray[ix].toggleClass('wsp-mfs-reference', true);
                valueArray[ix].data(
                  'wsp-mfs-reference-id',
                  valuesMFS[key].referenceId
                );
              }

              replacedAny = true;
            }
          }
        }
      }

      if (replacedAny) {
        //copy the current state of the values into lastRealizedFrame for next time
        valuesMFS.lastRealizedFrame = undefined;
        var lastFrame = $.extend(true, {}, valuesMFS);
        valuesMFS.lastRealizedFrame = lastFrame;
      }
      return replacedAny;
    }

    function replaceMFSValuesInSpeakableText(
      speakableTextMap,
      valuesMFS,
      mfsElement
    ) {
      var key,
        replaceValue = '',
        replaceValueObj = [],
        replaceValueArr = [];
      this.speakableText = speakableTextMap;

      if (this.speakableText) replaceValueArr = this.speakableText.split(' ');
      replaceValueArr.forEach(function(value, index) {
        if (value.indexOf('<%') > -1) {
          replaceValueObj.push(value);
        }
      });

      function updateHotTextArray(keyValue, replaceVal) {
        replaceValueObj.forEach(function(value, index) {
          if (value.indexOf(keyValue) > -1) {
            replaceValueObj[index] = replaceVal;
          }
        });
      }

      for (key in valuesMFS) {
        if (
          this.speakableText &&
          this.speakableText.indexOf('<%' + key + '>') > -1
        ) {
          //special case a single text node, and just replace the text of the object
          if (valuesMFS[key].type === 'text') {
            replaceValue = valuesMFS[key].value;
          } else {
            replaceValue = GSP.mfs.makeSpeakableTextFromMFSParseTree(
              valuesMFS[key]
            );
          }
          if (this.isCompositeText) {
            updateHotTextArray(key, replaceValue);
          }
          var replace = '<%' + key + '>';
          var regexExp = new RegExp(replace, 'g');
          this.speakableText = this.speakableText.replace(
            regexExp,
            replaceValue
          );
        }
      }

      var ariaLabel = '';
      if (
        this.kind === 'Text' ||
        this.kind === 'Expression' ||
        this.kind === 'Measure' ||
        this.kind === 'Button'
      ) {
        ariaLabel = this.speakableText;
      } else {
        ariaLabel =
          this.kind +
          ' ' +
          (this.genus ? GSP.mfs.updatedGenus[this.genus] + ' ' : '') +
          this.speakableText;
      }

      if (this.mfsElementSrOnly) {
        this.mfsElementSrOnly.text(ariaLabel).attr('aria-label', ariaLabel);
        if (this.isParameter) {
          mfsElement
            .find('.mfs-input')
            .attr(
              'aria-label',
              replaceValue + ' editable. Click or double tap to edit.'
            );
        }
        if (this.isCompositeText) {
          mfsElement
            .find('.mfs-param')
            .each(function(index) {
              $(this).attr('aria-label', replaceValueObj[index]);
            })
            .attr({ tabindex: 0, role: 'button' });
        }
      } else {
        mfsElement.attr('aria-label', ariaLabel);
      }

      if (!this.lastSpeakableText) {
        this.lastSpeakableText = this.speakableText;
      }
    }

    GSP.draw.availableEngines.html = {
      /*
       * Called once to initialize the engine.
       * @param {object: {width:'number', height: 'number', rootNode: 'element'}
       *        args Arguments.
       * @return an context object that will be used in subsequent calls.
       */
      create: function(args) {
        var root = args.rootNode,
          layer = $('<div class="wsp-text-layer"></div>').appendTo($(root));
        layer.css({ width: '100%', height: '100%' });
        return {
          layer: layer, // a div container placed above the
          // root object and containing text layer objs
          modelToViewTransform: null,
        };
      },
      destroy: function(draw) {},
      prepareFrame: function(draw, iClipRect, iPreclear, iTransform) {
        draw.modelToViewTransform = iTransform;
      },
      cleanupFrame: function(draw) {},
      clear: function(draw) {
        draw.layer.remove();
      },
      primitives: {
        Text: {
          /**
           * prepareText: receive styling information and initialize the
           * drawRefCon.
           */
          prepare: function(drawContext, renderAttrs) {
            return TextPrimitive.createWithAttrs(renderAttrs);
          },
          /**
           * drawText: parse mfs and render.
           */
          draw: function(drawContext, drawRefCon, renderAttrs) {
            return drawRefCon.draw(drawContext, renderAttrs);
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {
            $(drawRefCon.element).remove();
          },
        },
        Button: {
          prepare: function(drawContext, renderAttrs) {
            return TextPrimitive.createWithAttrs(renderAttrs, true);
          },
          draw: function(drawContext, drawRefCon, renderAttrs) {
            return drawRefCon.draw(drawContext, renderAttrs);
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {
            $(drawRefCon.element).remove();
          },
        },
        Table: {
          prepare: function(drawContext, renderAttrs) {
            return TablePrimitive.createWithAttrs(renderAttrs);
          },
          draw: function(drawContext, drawRefCon, renderAttrs) {
            return drawRefCon.draw(drawContext, renderAttrs);
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {
            $(drawRefCon.element).remove();
          },
        },
        Point: {
          prepare: function(drawContext, renderAttrs) {
            var rslt = {
              rendered: false,
              element: $(
                '<div class="wsp-' +
                  renderAttrs.kind +
                  '" id="' +
                  renderAttrs.id +
                  '">&#x2b24;</div>'
              ),
            };
            rslt.element.css({ visibility: 'hidden' });
            return rslt;
          },
          draw: function(drawContext, drawRefCon, renderAttrs) {
            var element = drawRefCon.element,
              visibility = renderAttrs.renderable ? 'visible' : 'hidden',
              width,
              height,
              priorElement;
            if (!drawRefCon.rendered && visibility === 'visible') {
              priorElement = drawContext.layer;
              drawRefCon.rendered = true;
              $(priorElement).append(element);
            }
            if (drawRefCon.rendered) {
              element.css({
                visibility: visibility,
              });
            }
            if (renderAttrs.renderable) {
              width = element.width();
              height = element.height();
              element.css({
                left: renderAttrs.cx - width / 2,
                top: renderAttrs.cy - height / 2,
                color: renderAttrs.color,
              });
            }
          },
          cleanup: function(drawContext, drawRefCon, renderAttrs) {
            drawRefCon.element.remove();
          },
        },
      },
    };
  })();

  /**
   * @fileOverview Localization Utilities
   * @author <a href="mailto:kswenson@kcptech.com">Kirk Swenson</a>
   * @version 0.0
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * The GSP.Locale object contains localization utilities.
   *
   *  It is initially empty, but can be filled with a set of locales keyed by
   *  language code (e.g. GSP.Locale.locales['en'] = { ... }) and possibly
   *  country code (e.g. GSP.Locale.locales['en-GB'] = {...}) or perhaps
   *  (GSP.Locale.locales['en'].countries['GB'] = {...}). For now we start
   *  simple and assume a simple language model.
   *
   *  Clients should simply use GSP.Locale.current which is a {key,value} map
   *  where the keys are the localizable string keys (e.g. 'GSP.Error.invalidSketch')
   *  and the values are the localized strings for the particular locale, e.g.
   *  "Error: The specified sketch is empty or invalid."
   *
   */
  GSP.Locale = (function() {
    return {
      current: null,

      locales: {},
    };
  })();

  /**
   * @fileOverview String Localization Utilities
   * @author <a href="mailto:kswenson@kcptech.com">Kirk Swenson</a>
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * The GSP.Strings module provides a set of string utilities that support
   * parameter replacement and localization. Current functionality is preliminary
   * with further design work/thinking expected to refine the approach further.
   * The current approach is patterned after SproutCore's.
   *
   */
  GSP.Strings = (function() {
    return {
      /**
       * Returns a new string formatted with appropriate replacement strings.
       * @param {String}  iFmt: format string with '%@' representing replacement targets
       * @param {Array}   iArgsArray: array of arguments used as replacements
       */
      format: function(iFmt, iArgsArray) {
        var str = iFmt,
          i,
          count = iArgsArray.length;
        if (str && count) {
          for (i = 0; i < count; ++i) {
            str = str.replace('%@', iArgsArray[i]);
          }
        }
        return str;
      },

      /**
       * Returns a formatted version of the specified format string with any
       * additional arguments beyond the format string used as replacements
       * for any replacement targets in the format string.
       * @param {String}  iFmt: format string with '%@' representing replacement targets
       * @param {...*} var_args: additional arguments used as replacement strings
       */
      fmt: function(iFmt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return GSP.Strings.format(iFmt, args);
      },

      /**
       * Returns a formatted and localized version of the specified string key
       * with any additional arguments beyond the format string used as
       * replacements for any replacement targets in the format string.
       * @param {String}  iKey: key used to lookup localized string from current locale
       * @param {...*} var_args: additional arguments used as replacement strings
       */
      loc: function(iKey) {
        var args = Array.prototype.slice.call(arguments, 1),
          str = GSP.Locale.current && GSP.Locale.current[iKey];
        if (str) {
          str = GSP.Strings.format(str, args);
        } else if (str == null) {
          GSP.signalErrorWithMessage(
            'Localized string ' + iKey + ' not found.',
            'GSP.Error.localeStringNotFound'
          );

          // Return the key in case of failure
          str = iKey;
        }
        return str;
      },
    };
  })();

  /**
   * @fileOverview Localization Utilities
   * @author <a href="mailto:kswenson@kcptech.com">Kirk Swenson</a>
   * @version 0.0
   * @preserve Copyright © 2014 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * This module contains the localized strings for a single locale,
   * in this case 'en' === "English".
   * The {key,value} map for the localizable strings is loaded into the
   * GSP.Locale.locales map and (optionally) set as the current locale.
   * Only one locale at a time can be the current locale.
   *
   */
  GSP.Locale.locales.en = {
    'GSP.Error.incompatibleSketchVersion':
      "Web Sketchpad version '%@' cannot load a document created for version '%@'.",
    'GSP.Error.invalidSketchVersion':
      "Cannot compare WSP version '%@' with sketch version '%@'.",
    'GSP.Error.invalidSketch':
      'The specified sketch appears to be empty or invalid.',
    'GSP.Error.invalidSwitchPage': "The page requested doesn't exist.",
    'GSP.Error.loadSketchFailed': 'An error occurred when loading the sketch.',
    'GSP.Error.invalidDocDelta': 'The document delta could not be applied.',
    'GSP.Error.invalidSketchDelta': 'The sketch delta could not be applied.',
    'GSP.Error.invalidGeomBounds': 'Invalid geom bounds for object: %@ (%@)',
    'GSP.Error.constraintException': 'Error constraining object: %@ (%@)',
    'GSP.Error.destroyObjectException':
      "Exception destroying object ('%@' (%@)): %@",
    'GSP.Error.touchStartException':
      "Exception in Sketch.handleTouchStart (touch.identifier='%@')",
    'GSP.Error.touchMoveException':
      "Exception in Sketch.handleTouchMove (touch.identifier='%@')",
    'GSP.Error.touchEndException':
      "Exception in Sketch.handleTouchEnd (touch.identifier='%@')",
    'GSP.Error.renderBoundsException':
      "Exception rendering object bounds ('%@' (%@))",
    'GSP.Error.renderObjectException':
      "Exception rendering object ('%@' (%@)): %@",
    'GSP.Error.renderLabelException':
      "Exception rendering object label ('%@' (%@)): %@",
    'GSP.Error.renderPrepareException':
      "Exception in renderPrepare ('%@' (%@)): %@",
    'GSP.Error.renderCleanupException':
      "Exception in renderCleanup ('%@' (%@)): %@",
    'GSP.Error.invalidSketchStart': 'Sketch.start called for running sketch',
    'GSP.Error.invalidSketchResume': 'Sketch.resume called for running sketch',
    'GSP.Error.invalidSketchStop': 'Sketch.stop called for stopped sketch',
    'GSP.Measure.arcLength': 'Length',
    'GSP.UI.undo': 'Undo',
    'GSP.UI.redo': 'Redo',
    'GSP.UI.ok': 'OK',
    'GSP.UI.cancel': 'Cancel',
    'GSP.Label.ShowButton': 'Show %@ %@',
    'GSP.Label.HideButton': 'Hide %@ %@',
    'GSP.Label.ShowButtonSwap': 'Show',
    'GSP.Label.HideButtonSwap': 'Hide',
    'GSP.Label.MoveButton': 'Move %@ → %@',
  };

  // Default to English
  GSP.Locale.current = GSP.Locale.locales.en;

  /*
   * @fileOverview API for creating and playing tools
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  /*
   * A Tool object is an abstraction of a tool in the toolbox.  It exists at the
   * document level, and it's lifecycle would typically be identical to the document's.
   * A Tool is instantiated with a spec object, analogous to the way a sketch is
   * instantiated, and its lifecycle is analagous to that of a document.  A tool is
   * not tied to a particular sketch, and can support being played into several
   * sketches simultaneously
   *
   *
   * Tools have only one method: createSession(), which initiates a tool-playing in
   * a given sketch. A session has a getNextGiven() method that returns the next
   * given in the tool, until all givens are gone. Clients who wish to continue
   * the session for multiple plays of a tool should call controller.setActiveTool()
   * with the sticky parameter set to true.
   *
   * All properties of the Tool Session should be considered private.
   *
   */

  GSP.Tool = (function() {
    /*  Defines:
     *  var toolplaySessionProto
     *    resetPlayback: function()
     *    setRelativePositions: function()
     *    _playGiven: function(given, isAssumed, position, speculative)
     *    playAssumeds: function()
     *    getNextGiven: function()
     *    playGiven: function(theGiven, position, speculative)
     *    addCompletionHandler(handler)
     *    getLegalMatchesForGiven: function(given, optCandidateList)
     *    isComplete: function()
     *    _mergeGObjToSpecGObj: function(gobj, specGObjToCreate)
     *    abortPlayback: function ()
     *    confirmPlayback: function ()
     *    putGivenOnIntersection: function(intersectionInfo, givenGObj)
     *    putGivenOnPath: function(path, givenGObj, value)
     *    addGObjAsMatchedGiven: function (gobj)
     *    findExistingMatchedGivenWithProperty: function (propertyName, value)
     *    existingMatchedGivenForGObj: function (gobj)
     *    existingMatchedGivenForMergeCandidate: function (candidate)
     *    arrayOfMatchedGivenGObjs: function ()
     *  var toolProto
     *    objectGraph: null,
     *    $element: null,
     *    createSession: function(sketch)
     *  var transactionProto
     *    setProp: function(source, target, prop)
     *    setMutableFrom: function (source)
     *    postProcessMutable: function()
     *    snapGivenToCandidate: function()
     *    saveMutable: function()
     *    restoreMutable: function()
     *  function Transaction(mutable, transactionSpec, matchedGiven)
     *  function postProcessMutableFunctionOrCalculation (mutable)
     *  function postProcessMutableParameter (mutable)
     *  function isParameterOrCalculation (gobj)
     *  function setNameMFSOverride (source, mutable)
     *  var parameterTransactionSpec
     *  var pointTransactionSpec
     *  var functionTransactionSpec
     *  var calculationTransactionSpec
     *  var pathTransactionSpec
     *  var transactionSpecs
     *  function transactionSpecFor(mutable)
     *  var matchedGivenProto
     *  Returns:
     *  createWithSpec: function(spec)
     *  createMatchedGiven: function (given, session)
     */

    var toolplaySessionProto = {
      sketch: null,
      objectGraph: null,
      givenArray: null, //original givenArray to spawn proto tools from
      completion: null,
      constructedObjects: null,
      /**
       * Resets the session back to its initial state.
       */
      resetPlayback: function() {
        var self = this;
        var protoGraph = GSP.ObjectGraph.copy(this.objectGraph);
        var givenArray = protoGraph.filter(function(obj) {
          if (
            ['given', 'givenParent', 'constructibleGiven'].includes(
              obj.toolRole
            )
          ) {
            return true;
          }
          return false;
        });
        var uniqueSignature = 'toolplay' + Date.now();
        //It is critical that the ids of the protoGraph not conflict with the real
        //ids in the sketch, so we give them all unique ids based on the current
        //timestamp

        function constructDefaultAssumed(sketch, automatchSpec) {
          if (automatchSpec.genus === 'CoordSys') {
            automatchSpec.kind = 'CoordSys';
            automatchSpec.constraint = 'CoordSys';
          }
          var gobjClass = GSP.gobjPrototype(
            automatchSpec.kind,
            automatchSpec.constraint
          );
          var spec =
            gobjClass.createDefaultSpec &&
            gobjClass.createDefaultSpec(sketch, automatchSpec);
          if (spec) {
            var nextIndex = GSP.ObjectGraph.getNextFreeIdNumber(
              sketch.gobjList.constraintList
            );
            var graph = GSP.ObjectGraph.convertObjectSpec(spec);
            //re-id the objects in graph form
            graph.forEach(function(obj) {
              obj.id = '' + nextIndex;
              ++nextIndex;
            });
            //then create a spec for instantiating
            var newSpecObjs = GSP.ObjectGraph.createSpecFromGraph(graph);
            //and construct it
            var constructedObjects = sketch.constructGObjects(newSpecObjs, {
              speculative: true,
              autoplace: true,
            });
            //the match is the last item in the objectGraph
            var matchedId = graph[graph.length - 1].id;
            return {
              constructedObjects: constructedObjects,
              matched: constructedObjects[matchedId],
            };
          }
        }

        /* Search for an object whose label matches that of the assumedSpec,
           and to which it makes sense to merge the assumed.  Prefer visible
           over hidden, but if no visibe one exists, return a hidden match.
           Returns the most recently created GObj matching this criteria.
      
           If it is a coordinate system, call through to the sketch method for finding an existing coord sys.
         */
        function findExistingAssumed(sketch, assumedSpec) {
          var constraintList = sketch.gobjList.constraintList,
            foundHiddenMatch,
            curGObj,
            assumedLabel = assumedSpec.label;

          function isMatch(gobj, spec) {
            var matches,
              specGObj,
              strippedSpec = {};
            if (gobj.isOfKind(spec.kind) && gobj.isOfGenus(spec.genus)) {
              return true;
            }
            // matchesAssumedSpec() by default matches by genus (in kind.js).
            // It's overridden for points (which are matched by kind==='Point'),
            // and for measures and expressions (either of which can be matched by parameters, provided
            // that there's also a match by 'Scalar', 'Angle', or 'Distance').
            // matchesAssumedSpec checks only the genus, so returns false (e.g.) if a tool tries to match an assumed line to a perpendicular. This naïve check is hard to fix because there's no genera tree in WSP.
            // Neither the kind nor the genus suffices to identify them both as lines.
            // The next best thing is to call getLegalMatches, which suffers from a similar problem, but addresses
            // it differently: the match fails for candidates, returning false if the assumed has any "side constructions."

            // getLegalMatchesForGiven() needs a instantiated gobj, not a spec, so make a gobj from the spec,
            // first copying the spec and stripping its children, if any
            $.extend(strippedSpec, spec);
            delete strippedSpec.children; // we care only about the assumed gobj itself
            specGObj = GSP.gobjectsFromSpec({ copy: strippedSpec }, gobj.sQuery)
              .copy;
            matches = self.getLegalMatchesForGiven(specGObj, [gobj], true);
            return matches.length > 0;
          }

          if (assumedSpec.genus === 'CoordSys') {
            //Coord sys is a special case which is not matched by label and has its own logic for choosing an existing one
            return sketch.findExistingCoordSys(assumedSpec);
          }
          if (assumedLabel) {
            assumedLabel = assumedLabel.trim(); // leading or trailing whitespace shouldn't prevent a match
          }
          //search in backwards construction order for objects of the same automatch type
          for (var i = constraintList.length - 1; i >= 0; --i) {
            curGObj = constraintList[i];
            if (
              curGObj.label &&
              curGObj.label.trim() === assumedLabel &&
              isMatch(curGObj, assumedSpec)
            ) {
              if (!curGObj.style.hidden) return curGObj;
              else if (!foundHiddenMatch) foundHiddenMatch = curGObj;
            }
          }
          //Either we've found the hidden one or we return undefined
          return foundHiddenMatch;
        }

        // body of resetPlayback
        protoGraph.forEach(function(node) {
          node.id += uniqueSignature;
        });
        this.givenArray = givenArray;
        this.constructedObjects = {};
        this.existingMatches = {};
        var assumeds = protoGraph.filter(function(obj) {
          if (obj.toolRole === 'assumed') {
            delete obj.toolRole;
            return true;
          }
          return false;
        });
        if (
          (!givenArray || !givenArray.length) &&
          (!assumeds || !assumeds.length)
        ) {
          throw GSP.createError('This tool has no givens or assumeds');
        }
        //Now either match or create all of the assumed givens in the sketch
        assumeds.forEach(function(assumed) {
          var matched = findExistingAssumed(self.sketch, assumed);
          if (matched) {
            self.existingMatches[matched.id] = matched;
          } else {
            var constructedInfo = constructDefaultAssumed(self.sketch, assumed);
            if (constructedInfo) {
              $.extend(
                self.constructedObjects,
                constructedInfo.constructedObjects
              );
              matched = constructedInfo.matched;
            } else {
              //Message to the user?
              GSP.log('Missing non-constructable assumed: ' + assumed.label);
              throw GSP.createError(
                'Missing non-constructable assumed: ' + assumed.label
              );
            }
          }
          //update the node in objectGraph to refer to the correct id
          assumed.id = matched.id;
        });
        this.assumedArray = assumeds;
      },

      // Tries to maintain the relative positions of a group of
      // autoplaceable gobjs. Looks for a space in which they all fit by
      // walking a bounding box around the sketchRect and checking for
      // conflicts with already-placed gobjs.
      setRelativePositions: function() {
        var session = this,
          sketch = this.sketch,
          sketchRect = sketch.sketchRect(),
          relatives = [],
          boundingBox,
          sketchLeftMargin = 10,
          sketchTopMargin = 5,
          findResult;

        // Pick out the newly constructed gobjs we'll relatively position.
        function selectRelatives() {
          $.each(session.constructedObjects, function(id, gobj) {
            if (gobj.supportsAutoplacement() && sketch.avoidableGObject(gobj)) {
              relatives.push({
                gobj: gobj,
                relPos: null,
              });
            }
          });
        }

        function isRelative(gobj) {
          for (var i = 0; i < relatives.length; i++) {
            if (relatives[i].gobj === gobj) return true;
          }
          return false;
        }

        // This is our fallback, in case we can't find enough space for relative placement.
        function justAutoplaceIt(positionInfo) {
          // Don't bother avoiding our yet-to-be-autoplaced relatives
          sketch.autoplaceGObj(positionInfo.gobj, {
            ignoreConflictIf: isRelative,
          });
          positionInfo.gobj.invalidateGeom();
          sketch.renderPrepare();
          sketch.constrainAndRedraw();
        }

        // Core placement routine
        function placeMultipleRelatives() {
          // Returns a bounding box containing all the relatives.

          function getBoundingBox() {
            // Make sure we have bounds for our objects
            sketch.constrainAndRedraw();
            var rects = relatives.map(function(relative) {
                return sketch.getGObjGeomBounds(relative.gobj);
              }),
              box = rects.reduce(GSP.Geom.unionRects);
            return {
              topLeft: GSP.GeometricPoint(box.left, box.top),
              width: box.right - box.left,
              height: box.bottom - box.top,
            };
          }

          // Determine relative positions
          boundingBox = getBoundingBox();
          relatives.forEach(function(relative) {
            relative.relPos = boundingBox.topLeft.subtract(
              relative.gobj.geom.loc
            );
          });
          // Try to place them all.
          findResult = sketch.findPositionForBoundingBox({
            boxDimensions: {
              width: boundingBox.width,
              height: boundingBox.height,
            },
            // mustAvoid: everything autoplaceable EXCEPT our own cohort of relatives.
            mustAvoid: function(gobj) {
              return gobj.autoplacementType && !isRelative(gobj);
            },
            metrics: {
              gObjTopMargin: 3,
              sketchLeftMargin: sketchLeftMargin,
              sketchTopMargin: sketchTopMargin,
              rightIsolation: boundingBox.width,
              bottomIsolation: boundingBox.height,
            },
            start: GSP.GeometricPoint(
              sketchRect.left + sketchLeftMargin,
              sketchRect.top + sketchTopMargin
            ),
            placingOneGobjOnly: false,
          });

          if (findResult.success) {
            // set final in-sketch positions
            relatives.forEach(function(relative) {
              relative.gobj.geom.loc = findResult.position.subtract(
                relative.relPos
              );
              relative.gobj.invalidateGeom();
            });
          } else {
            // Give up.
            while (relatives.length) {
              justAutoplaceIt(relatives[0]);
              relatives.shift(); // subsequent invocations SHOULD avoid this one
            }
          }
        }
        selectRelatives();
        switch (relatives.length) {
          case 0:
            return; // Nothing to do.
          case 1:
            justAutoplaceIt(relatives[0]);
            return;
          default:
            placeMultipleRelatives();
        }
      },

      /**
       * Internal workhorse that plays either a given or assumed given into the sketch.
       *
       * @param given
       * @param isAssumed
       * @param position
       * @param speculative
       * @returns {Object} The actual given/assumed instantiated in the sketch
       * @private
       */
      _playGiven: function(given, isAssumed, position, speculative) {
        var preexistingObjects = $.extend(
          false,
          {},
          this.constructedObjects,
          this.existingMatches
        );
        var subGraph = GSP.ObjectGraph.subgraphFromNode(
          given,
          preexistingObjects
        );
        var mapOfNewObjects = {};
        if (isAssumed) {
          //Assumeds are already constructed - don't need to construct them, so prune them from the graph that
          //we will be constructing
          subGraph = subGraph.filter(function(node) {
            return node !== given;
          });
        }
        //Convert the ids for the objects to construct from toolplay-unique ids
        //to their final in-sketch ids:
        var sketchGraph = this.sketch.gobjList.constraintList;
        var nextIndex = GSP.ObjectGraph.getNextFreeIdNumber(sketchGraph);
        subGraph.forEach(function(obj) {
          obj.id = '' + nextIndex;
          mapOfNewObjects[obj.id] = obj;
          ++nextIndex;
        });
        var needsLabelGenerated =
          !given.label &&
          (given.genus === 'Function' ||
            given.style.nameOrigin === 'namedFromLabel');
        if (needsLabelGenerated) {
          given.label = this.sketch.labelPool.generateLabel(
            given.kind,
            given.genus,
            given.id
          );
        }
        var givensInSketch = {};
        //then create a spec for instantiating
        //(We can't instantiate GObjs in-place, so converting to a spec at this point
        // is the path of least resistance).  Also, if we tried to merge graphs, we'
        //have to break and potentially repair child links, so this does make some sense.
        var newSpecObjs = GSP.ObjectGraph.createSpecFromGraph(subGraph);
        for (var id in newSpecObjs) {
          if (
            newSpecObjs.hasOwnProperty(id) &&
            newSpecObjs[id].style.layerOrder
          ) {
            // Put all tool interior/images in front of existing ones.
            newSpecObjs[id].style.layerOrder += this.nextLayerOrder;
          }
        }
        var theGivenId = given.id;
        if (!isAssumed) {
          var theGivenToAdd = {};
          theGivenToAdd[theGivenId] = newSpecObjs[theGivenId];
          //Now seed the new given with our current position.  This should potentially become
          //a kind-level method, since different givens will have different means for
          //placing themselves.
          newSpecObjs[theGivenId].geom = {
            loc: { x: position.x, y: position.y },
          };
          delete newSpecObjs[theGivenId];
          //Add the given - not speculative, but needs constraining
          givensInSketch = this.sketch.constructGObjects(theGivenToAdd, {
            forceConstrain: true,
          });
        }
        //Add the productions, as speculative constructions
        var productionsInSketch = this.sketch.constructGObjects(newSpecObjs, {
          speculative: speculative,
        });
        //Lastly, update our tool regime's shared state with the instantiated objects
        $.extend(this.constructedObjects, givensInSketch, productionsInSketch);
        return this.sketch.gobjList.gobjects[theGivenId];
      },

      /**
       * Plays the tool's assumed givens into the sketch.  By definition, the assumeds are already
       * instantiated in the sketch, but the tool may describe children that descend from them that
       * need instantiating.  Therefore, they must be played into the sketch just like givens.
       */
      playAssumeds: function() {
        var assumed = this.assumedArray.shift();
        while (assumed) {
          this._playGiven(assumed, true, null, true);
          assumed = this.assumedArray.shift();
        }
        if (this.completion && this.isComplete()) {
          this.completion();
        }
      },

      /**
       * Returns the next given to be played in the session
       *
       * @returns {Object} the next given or undefined if there are no more
       */
      getNextGiven: function() {
        return this.givenArray.shift();
      },

      /**
       * Plays the next given (and all its productions) into the sketch
       *
       * @param {Object} theGiven - generated from getNextGiven()
       * @param {Object} position {x,y} position to place the given
       * @param {Bool} speculative - optional, when true the object will be instantiated
       *    with a speculative state.
       *
       * @returns {Object} returns the given as the actual GObj in sketch
       */
      playGiven: function(theGiven, position, speculative) {
        if (!this.labelStateSaved) {
          this.sketch.labelPool.saveState(this);
          this.labelStateSaved = true;
        }
        var ret = this._playGiven(theGiven, false, position, speculative);
        if (this.completion && this.isComplete()) {
          // delete all the toolRole fields of the given objects.
          this.completion();
        }
        return ret;
      },

      /**
       * Add a completion handler that will be executed at the moment the tool completes
       * playing all givens.  Only one completion handler is supported at a time
       *
       * @param {type} handler
       * @returns {undefined}
       */
      addCompletionHandler: function(handler) {
        this.completion = handler;
      },

      /**
       * returns an array of legal matches for a given, from either a passed in array
       * of candidates, or from the current sketch's render list
       * Set allowHiddens true when checking assumed objects, which can match hidden sketch objects.
       *
       * @param {Object} given
       * @param {Array} optCandidateList
       * @returns {Array}
       */
      getLegalMatchesForGiven: function(given, optCandidateList, isAssumed) {
        /* If the given has parents (e.g., a constructible given) and any such parent has more than one child,
         * the given is trying to add a construction that may not be possible. For instance, a constructibleGiven
         * line might have parents that also define a circle, and it's impossible to match such a given (with two
         * point parents) to an existing perpendicular line (with its one point parent and one straight parent).
         * Such side constructions can be allowed ONLY when the given and the candidate have the same constraint.
         * We test the given for this situation and set the boolean sideConstructions accordingly.
         * We do NOT test for the situation in which a given segment, with a child length measurement,
         * is matched to a line or ray. This requires determination of the abstract genera of the given
         * based on the genus support present in GSP but currently unimplemented in WSP.
         */
        var givenKind = given.kind,
          sideConstructions = false;

        function canMatchForGiven(match) {
          if (!match || (match.style.hidden && !isAssumed)) {
            // A normal (not assumed) given cannot match a hidden object
            return false;
          }
          switch (givenKind) {
            case 'Point':
              return match.kind === 'Point' || (match.isAPath() && !isAssumed); // assumed point cannot match a path
            case 'Straight': // givenParents match the control points of the straight.
              return (
                match.isOfKind('Straight') &&
                (match.constraint === given.constraint || !sideConstructions)
              );

            //if (!match.isOfKind ("Straight")) return false;
            //matchGenus = match.straightGenus && match.straightGenus (); // Is match a line, ray, or segment?
            ////  Match is ok if constraints match or if superGenera match and there are no side constructions.
            //return match.constraint === given.constraint || !sideConstructions && match.isOfGenus (given.genus);

            case 'Circle': // givenParents match only if constraints are the same or there are no side constructions
            case 'Arc': // givenParents match only if constraints are the same
              return (
                match.kind === given.kind &&
                (match.constraint === given.constraint || !sideConstructions)
              );
            case 'Polygon': // Check number of vertices
              // Current check will lose children of givenParents if the match is a transformed image
              // Current check will also fail to work for a polygon-area tool or a polygon-perimeter tool.
              // If the givenParents have no children other than the polygon, the match should work.
              return (
                match.isOfKind('Polygon') &&
                ((match.constraint === given.constraint &&
                  given.parentsList.length === match.parentsList.length) ||
                  !sideConstructions)
              );
            case 'Expression':
              if (given.genus === 'Function') {
                return match.isOfGenus('Function');
              }
              if (given.genus.match(/Parameter/)) {
                // Cannot call given.isOfGenus for an assumed
                return given.getLegalMatchForParam(match);
              }
              if (given.constraint === 'Calculation') {
                // What should a calculation match?
                if (given.parentsList.length) {
                  throw GSP.createError(
                    'getLegalMatchesForGiven: given is a calculation with parents.'
                  );
                }
                return (
                  match.matchesAssumedSpec && match.matchesAssumedSpec(given)
                );
              }
              throw GSP.createError(
                'getLegalMatchesForGiven: given is of an unexpected genus.'
              );
            default:
              return false;
          }
        }

        var candidates = optCandidateList || this.sketch.gobjList.renderList;
        if (given.parentsList) {
          for (var i = 0; i < given.parentsList.length; i++) {
            if (given.parentsList[i].children.length > 1)
              sideConstructions = true;
            break;
          }
        }
        return candidates.filter(canMatchForGiven);
      },

      /**
       *
       * @returns {Boolean} true if the tool has completed playing all givens
       */
      isComplete: function() {
        return this.givenArray.length === 0;
      },

      abortPlayback: function() {
        this.matchedGivens.forEach(function(match) {
          if (match.preexistingTransaction)
            match.preexistingTransaction.restoreMutable();
          match.clearMatches();
        });
        this.sketch.gobjList.removeGObjects(
          this.constructedObjects,
          this.sketch
        );
        this.constructedObjects = {};
        if (this.labelStateSaved) {
          this.labelStateSaved = false;
          this.sketch.labelPool.restoreSavedState();
          this.generatedLabels = undefined;
        }
      },

      confirmPlayback: function(calcPresent) {
        //  The caller passes calcPresent if the tool has created a blank calculation
        //  The caller has access to the unmatchedGivens, so we can't do the check here
        var self = this,
          id,
          gobj;
        this.matchedGivens.forEach(function(match) {
          match.preFinalize(self);
        });
        this.matchedGivens.forEach(function(match) {
          match.finalize(self);
        });
        for (id in this.constructedObjects) {
          if (this.constructedObjects.hasOwnProperty(id)) {
            gobj = this.constructedObjects[id];
            gobj.setRenderState('none');
            if (gobj.toolRole) {
              delete gobj.toolRole;
            }
            gobj.onLoad(self.sketch, 'toolDone');
          }
        }
        this.matchedGivens = [];
        this.constructedObjects = {};
        if (this.labelStateSaved) {
          this.labelStateSaved = false;
          this.sketch.labelPool.forgetSavedState();
          this.generatedLabels = undefined;
        }
        //  Show the Calculator, _unless_ it was already shown at the end of toolplay.
        if (calcPresent && !$('.wsp-Calculator').is(':visible')) {
          calcPresent.presentUI();
        }
      },

      /**
       * @param gobj
       * @return {Object} MatchedGiven obj
       */
      addGObjAsMatchedGiven: function(gobj) {
        var self = this,
          ix,
          newMatchedGiven;

        function findExistingMatchedGivenIndex(gobj) {
          var retVal;
          self.matchedGivens.forEach(function(item, ix) {
            if (item.given === gobj) {
              retVal = ix;
              return false;
            }
            return true;
          });
          return retVal;
        }

        newMatchedGiven = GSP.Tool.createMatchedGiven(gobj, this);
        ix = findExistingMatchedGivenIndex(gobj);
        if (ix) {
          self.matchedGivens[ix].unsnapFromCandidate();
          self.matchedGivens[ix] = newMatchedGiven;
        } else {
          this.matchedGivens.push(newMatchedGiven);
        }
        return newMatchedGiven;
      },

      /**
       * given a property name and a value, returns the MatchedGiven
       * object with a matching value at the property name, if one
       * exists.  Otherwise, returns undefined.  If multiple
       * MatchedGiven objects exist for this property value, the first
       * one encountered is returned.
       *
       * @param propertyName
       * @param value
       * @returns {Object} MatchedGiven obj
       */
      findExistingMatchedGivenWithProperty: function(propertyName, value) {
        var matchedGiven;
        this.matchedGivens.every(function(item) {
          if (item[propertyName] === value) {
            matchedGiven = item;
            return false;
          }
          return true;
        });
        return matchedGiven;
      },

      /**
       * given a gobj, returns the MatchedGiven object
       * associated with it if one exists.  Otherwise,
       * returns undefined.  If multiple MatchedGiven
       * objects exist for this gobj, the first one
       * encountered is returned.
       *
       * @param gobj
       * @returns {Object} MatchedGiven obj
       */
      existingMatchedGivenForGObj: function(gobj) {
        return this.findExistingMatchedGivenWithProperty('given', gobj);
      },

      /**
       * given a mergeCandidate, returns the MatchedGiven object
       * associated with it if one exists.  Otherwise,
       * returns undefined.  If multiple MatchedGiven
       * objects exist for this mergeCandidate, the first one
       * encountered is returned.
       *
       * @param gobj
       * @returns {Object} MatchedGiven obj
       */
      existingMatchedGivenForMergeCandidate: function(candidate) {
        return this.findExistingMatchedGivenWithProperty(
          'mergeCandidate',
          candidate
        );
      },

      /**
       * Returns an array of GObjs that are currently matched
       * as MatchedGivens.  Does not prune duplicates.
       *
       * @returns {Array} array of gobjs
       */
      arrayOfMatchedGivenGObjs: function() {
        return this.matchedGivens.map(function(match) {
          return match.given;
        });
      },
    }; // toolplaySessionProto

    var toolProto = {
      objectGraph: null,
      $element: null, //reference to the jQuery element of the tool
      createSession: function(sketch) {
        var ret = Object.create(toolplaySessionProto);
        ret.sketch = sketch;
        ret.objectGraph = this.objectGraph;
        ret.givenArray = [];
        ret.constructedObjects = {};
        ret.matchedGivens = [];
        ret.resetPlayback();
        ret.nextLayerOrder = 0; // track so that tool interiors can be in front of existing interiors/images
        return ret;
      },
    };

    //
    // Uses a transaction specification to control mutating (setting the
    // relevant properties of) a mutable gobj, and restoring it to its
    // original values.  The mutable is either a given, or a
    // preexisting. If a given, we can "snap" the given to a candidate
    // match, and thus acquire its properties, or unSnap away from a
    // candidate, thereby restoring the mutable's original property
    // values. If the mutable is a preexising, we simply save and
    // restore original values. Thus, either a "candidate" or an
    // "original" can be the "source" of properties used to fill in the
    // mutable.
    //
    var transactionProto = {
      setProp: function(source, target, prop) {
        if (source[prop] === undefined) return;
        if (
          this.transactionSpec.properties[prop] &&
          this.transactionSpec.properties[prop].copy
        ) {
          target[prop] = $.extend(true, {}, source[prop]);
        } else {
          target[prop] = source[prop];
        }
      },

      // Fill in the properties of our mutable from source, which may be a
      // candidate or an original.
      setMutableFrom: function(source) {
        var prop,
          proto,
          cPropList,
          cProp,
          mutable = this.mutable;
        for (prop in this.transactionSpec.properties) {
          if (this.transactionSpec.properties.hasOwnProperty(prop)) {
            if (
              prop === 'constraint' &&
              mutable.constraint !== source.constraint
            ) {
              // constraint functions are built into the prototype
              proto = Object.getPrototypeOf(source);
              Object.setPrototypeOf(mutable, proto);
              // In addition to the constraint prototype, copy other constraint-related properties
              // It would be wise to test this code against all transformation constraints, as any
              // errors in the constraint's "doc.properties" field might result in failure.
              // BUG ALERT: it's not clear that all properties lists in cPropList are actually constraint-related.
              // For instance, Intersection pulls in the style, which may not be in the transactionSpec properties
              // in which case the style of a mutable given will be irretrievably changed, and cannot be
              // recovered when the given is unsnapped. The visible consequence occurred when matching a free point
              // to an intersection; when the point was unsnapped it had lost its original size, color, and showLabel props.
              // There's a one-off fix for this below, but a robust fix requires checking what properties the various
              // constraints might pull in, determining which of them are essential, and copying only those.
              cPropList = GSP.gConstraints[source.constraint].doc.properties;
              for (cProp in cPropList)
                if (cProp !== 'style' && cPropList.hasOwnProperty(cProp)) {
                  this.setProp(source, mutable, cProp);
                }
            }
            if (this.transactionSpec.properties[prop].setter) {
              this.transactionSpec.properties[prop].setter(source, mutable);
            } else {
              this.setProp(source, mutable, prop);
            }
          }
        }
      },

      // After filling a mutable from a source, we might need to
      // post-process the mutable. TransactionSpecs can specify how to do that.
      postProcessMutable: function() {
        if (this.transactionSpec.postProcessMutable) {
          this.transactionSpec.postProcessMutable(this.mutable);
        }
      },

      // Before filling a mutable from a source, we might need to pre-process the objects
      // For instance, when a parentally-labeled constructibleGiven is snapped to a candidate with unlabeled parents,
      // the candidate parents should take on the given parent labels, and return to unlabeled when unsnapped.
      preProcess: function(direction) {
        if (this.transactionSpec.preProcess) {
          this.transactionSpec.preProcess(this, direction);
        }
      },

      // Snap our mutable given to the candidate (if it's compatible).
      snapGivenToCandidate: function() {
        var transaction = this,
          candidate = this.matchedGiven.mergeCandidate,
          given = this.matchedGiven.given;
        function updateMutable() {
          transaction.preProcess('fromCandidate');
          transaction.setMutableFrom(candidate);
          if (given.kind === 'Point' && candidate.kind === 'Point') {
            given.geom.loc = GSP.GeometricPoint(
              candidate.geom.loc.x,
              candidate.geom.loc.y
            );
            given.invalidateGeom();
          }
          transaction.postProcessMutable();
        }
        if (!this.transactionSpec.testCandidate(candidate)) {
          throw GSP.createError(
            'snapGivenToCandidate cannot snap ' +
              given.kind +
              given.id +
              ' to ' +
              candidate.kind +
              candidate.id
          );
        }
        updateMutable();
        this.matchedGiven.startWatchingCandidate(updateMutable);
      },

      // Save our mutable's original properties if they are not yet saved.
      saveMutable: function() {
        var prop, proto;
        if (this.original === null) {
          this.original = {};
          // save mutable props in original. This is slightly different
          // from setMutableFrom because an original is just a dumb
          // object; it will not have any setter methods.
          for (prop in this.transactionSpec.properties) {
            if (this.transactionSpec.properties.hasOwnProperty(prop)) {
              if (prop === 'constraint') {
                // constraint functions are built into the prototype
                proto = Object.getPrototypeOf(this.mutable);
                Object.setPrototypeOf(this.original, proto);
              }
              this.setProp(this.mutable, this.original, prop);
            }
          }
        }
      },

      restoreMutable: function() {
        if (this.original !== null) {
          this.preProcess('fromOriginal');
          this.setMutableFrom(this.original);
          this.postProcessMutable();
        }
        this.original = null;
      },
    }; // transactionProto

    function Transaction(mutable, transactionSpec, matchedGiven) {
      this.transactionSpec = transactionSpec;
      this.mutable = mutable;
      this.original = null;
      this.matchedGiven = matchedGiven;
    }

    Transaction.prototype = transactionProto;

    function postProcessMutableFunctionOrCalculation(mutable) {
      mutable.expressionAndParentsWereUpdated();
    }

    function postProcessMutableParameterOrPoint(mutable) {
      mutable.descendantGraphHasChanged();
    }

    function postProcessMutablePath(mutable) {
      mutable.children.forEach(function(child) {
        child.descendantGraphHasChanged();
      });
    }

    function preProcessPath(trans, direction) {
      var candidate = trans.matchedGiven.mergeCandidate,
        candList = candidate.parentsList,
        mutList = trans.mutable.parentsList,
        candPar,
        mutPar,
        ix;
      if (
        candidate.constraint === trans.mutable.constraint &&
        candList.length === mutList.length
      ) {
        for (ix = 0; ix < mutList.length; ix++) {
          candPar = candList[ix];
          mutPar = mutList[ix];
          if (
            direction === 'fromCandidate' &&
            candPar.hasLabel &&
            mutPar.hasLabel
          ) {
            if (!candPar.label && mutPar.label) {
              // copy the mutable label to the candidate
              if (!trans.candParLabelEmpty) {
                trans.candParLabelEmpty = [];
              }
              trans.candParLabelEmpty[ix] = true;
              candPar.label = mutPar.label;
            }
          } else if (
            candPar.label &&
            trans.candParLabelEmpty &&
            trans.candParLabelEmpty[ix]
          ) {
            delete candPar.label;
          }
        }
      }
    }

    function isParameterOrCalculation(gobj) {
      return GSP.isParameter(gobj) || GSP.isCalculation(gobj);
    }

    function setNameMFSOverride(source, mutable) {
      var displayObj;
      if (source.getNameMFS && source.sQuery) {
        // set properties from an actual gobject source
        mutable.nameMFSOverride = {};
        mutable.nameMFSOverride.mfs = source.getNameMFS();
        displayObj = source.sQuery.sketch.getDisplayObjForGObj(source);
        mutable.nameMFSOverride.width = displayObj && displayObj.width();
        mutable.nameMFSOverride.height = displayObj && displayObj.height();

        displayObj = mutable.sQuery.sketch.getDisplayObjForGObj(mutable);

        mutable.nameMFSOverride.originalWidth =
          displayObj && displayObj.width();
        mutable.nameMFSOverride.originalHeight =
          displayObj && displayObj.height();
      } else {
        // restoreMutable
        mutable.nameMFSOverride = undefined;
      }
    }

    function isPoint(gobj) {
      return gobj.isOfKind('Point');
    }

    var pointTransactionSpec = {
      testMutable: isPoint,
      testCandidate: isPoint,
      properties: {
        parents: {},
        genus: '',
        constraint: '',
        label: '',
        value: 0, // In case constraint is "PointOnPath"
        scaleFactor: 0, // for "DilateFixFactor"
        angle: 0, // for Rotate or Translate...FixAngle
        offset: {}, // TranslateFixXFixY
        distance: 0, // TranslateFixDist
        offsetX: 0, // TranslateFixX...
        offsetY: 0, // Translate...FixY
      },
      postProcessMutable: postProcessMutableParameterOrPoint,
    };

    var parameterTransactionSpec = {
      testMutable: GSP.isParameter,
      testCandidate: function(gobj) {
        return isParameterOrCalculation(gobj) || gobj.isOfKind('Measure');
      },
      properties: {
        value: {
          setter: function(source, mutable) {
            mutable.setParameterValue(source.uValue);
          },
        },
        uValue: {},
        nameMFSOverride: { setter: setNameMFSOverride },
        blank: {},
      },
      postProcessMutable: postProcessMutableParameterOrPoint,
    };

    var functionTransactionSpec = {
      testMutable: GSP.isFunction,
      testCandidate: GSP.isFunction,
      properties: {
        nameMFSOverride: { setter: setNameMFSOverride },
        functionExpr: { copy: true },
        expressionType: {},
        parents: {},
        expression: {},
      },
      postProcessMutable: postProcessMutableFunctionOrCalculation,
    };

    var calculationTransactionSpec = {
      testMutable: GSP.isCalculation,
      testCandidate: isParameterOrCalculation,
      properties: {
        parents: {},
        nameMFSOverride: { setter: setNameMFSOverride },
        expression: {
          setter: function(source, mutable) {
            // Catch up with any parameter animations
            if (source.prepareToSerialize) source.prepareToSerialize();
            // TODO - handle measures (WSP-1818)
            mutable.expression = source.expression;
          },
        },
      },
      postProcessMutable: postProcessMutableFunctionOrCalculation,
    };

    var axisTransactionSpec = {
      testMutable: GSP.isAPath,
      testCandidate: function(gobj) {
        return gobj.isOfKind('Axis');
      },
      properties: {
        kind: '',
        genus: '',
        constraint: '',
        parents: {},
        style: {}, // A mutable straight that becomes an axis needs to know about tick numbering, etc.
        orientation: '',
      },
      preProcess: preProcessPath,
      postProcessMutable: postProcessMutablePath,
    };

    var pathTransactionSpec = {
      testMutable: GSP.isAPath,
      testCandidate: GSP.isAPath,
      properties: {
        kind: '',
        genus: '',
        constraint: '',
        parents: {},
      },
      preProcess: preProcessPath,
      postProcessMutable: postProcessMutablePath,
    };

    var transactionSpecs = [
      parameterTransactionSpec,
      functionTransactionSpec,
      calculationTransactionSpec,
      axisTransactionSpec,
      pathTransactionSpec,
      pointTransactionSpec,
    ];

    function transactionSpecFor(mutable, candidate) {
      for (var i = 0; i < transactionSpecs.length; i++) {
        if (
          transactionSpecs[i].testMutable(mutable) &&
          (!candidate || transactionSpecs[i].testCandidate(candidate))
        ) {
          return transactionSpecs[i];
        }
      }
      return null;
    }

    /*  --------------  matchedGivenProto  ---------------------
     *  clearMatches: function() {  // reset render states, stop watching. Does NOT unsnap candidate before removal.
     *  updateDeltaToGiven: function (dragPos)
     *  prepareTransactionsForSnap: function ()
     *  snapPointToPath: function (touchLoc) { // temporarily put the point on the path; doesn't make a permanent attachment
     *  unsnapFromCandidate: function (newLoc)
     *  setMergeCandidate: function(candidate, proxy)
     *  startWatchingCandidate: function(updateHandler)
     *  stopWatchingCandidate: function()
     *  setIntersectInfo: function(intersectInfo)
     *  clearIntersectInfo: function ()
     *  getSnappedPosition: function(pos)
     *  completeMatch: function (pos)
     *  preFinalize: function()
     *  finalize: function(session)
     */

    var matchedGivenProto = {
      given: null,
      mergeCandidate: null,
      intersectInfo: null,
      transactionSpec: null,

      clearMatches: function() {
        // reset render states, stop watching. Does NOT unsnap candidate before removal.
        this.clearIntersectInfo();
        this.stopWatchingCandidate();
        if (this.proxy) {
          this.proxy.setRenderState('none');
          delete this.proxy;
        }
        if (this.mergeCandidate) {
          this.mergeCandidate.setRenderState('none');
        }
        this.mergeCandidate = null;
      },

      // On touch down, we'll track how far the touch is from the
      // geometry of the gobject, so that we preserve that when it
      // snaps to a differently sized gobject.
      // We might also need to adjust the initial drag position,
      // so a drag position is returned.
      updateDeltaToGiven: function(dragPos) {
        var given = this.given,
          gobjLoc,
          adjustedDeltaToGiven,
          nameMFSOverride,
          newDragPos = dragPos,
          regime = this.session.sketch.currentTouchRegime();

        // delta is the distance from the drag to the geom origin.
        if (given.isOfKind('ArcInterior') || given.isOfKind('Sampler')) {
          GSP.signalErrorWithMessage(
            'Tool tracker: current matchedGiven may not support mapPositionToPathValue'
          );
        }
        if (given.kind === 'Point' || given.isOfKind('Text')) {
          //if (regime && regime.animateMatching) {  // a tap away from the gobj should generate a (0, 0) delta
          //  gobjLoc = dragPos;
          //} else {
          gobjLoc = given.geom.loc;
          //}
        } else if (given.isAPath()) {
          if (regime.pointInRegion(dragPos, given)) {
            gobjLoc = dragPos;
          } else {
            gobjLoc = given.mapPositionToPathPosition(dragPos);
          }
        } else {
          gobjLoc = GSP.GeometricPoint(0, 0);
        }
        this.deltaToGiven = dragPos.subtract(gobjLoc);

        // ... but: if we've snapped to some other text gobject,
        // and the user has touched down again to readjust, then
        // we'll rescale the delta proportionally to match the actual
        // size of the given. That way e.g. when they touch down on a
        // on the right size of a larger snapped object, the drag ends
        // up with the actual object still connected to the touch.
        if (given.nameMFSOverride) {
          nameMFSOverride = given.nameMFSOverride;
          adjustedDeltaToGiven = GSP.GeometricPoint(
            (this.deltaToGiven.x * nameMFSOverride.originalWidth) /
              nameMFSOverride.width,
            (this.deltaToGiven.y * nameMFSOverride.originalHeight) /
              nameMFSOverride.height
          );
          newDragPos = dragPos.add(
            adjustedDeltaToGiven.subtract(this.deltaToGiven)
          );
          this.deltaToGiven = adjustedDeltaToGiven;
        }
        console.log('updateDeltaToGiven: new value = ', this.deltaToGiven);
        return newDragPos;
      },

      // Prepare the transactions for snapping a given's relevant properties to those
      // of its merge candidate. Also stores the original properties for later restoration.
      // Call snapToCandidate() to actually execute the snap.
      prepareTransactionsForSnap: function() {
        var given = this.given,
          candidate = this.mergeCandidate,
          preexistingTransactionSpec;
        if (candidate) {
          if (given.isOfKind('Text') && candidate.constraint === 'Pegged') {
            candidate = candidate.parents.text;
          }
          // To snap, we need a givenTransaction for which testCandidate succeeds.
          if (
            !this.givenTransaction ||
            !this.givenTransaction.transactionSpec.testCandidate(candidate)
          ) {
            this.givenTransaction = null;
            this.givenTransactionSpec = transactionSpecFor(given, candidate);
            if (!this.givenTransactionSpec) {
              if (given.kind === 'Point' && candidate.isAPath()) {
                this.snapPointToPath();
              } else {
                throw GSP.createError(
                  "prepareTransactionsForSnap couldn't find a matching transaction for " +
                    given.kind +
                    ' and ' +
                    candidate.kind
                );
              }
            }
          }
          if (!this.givenTransaction) {
            this.givenTransaction = new Transaction(
              given,
              this.givenTransactionSpec,
              this
            );
            this.givenTransaction.saveMutable();
          }
          // Save the candidate's properties for later restoration
          preexistingTransactionSpec = transactionSpecFor(candidate);
          if (preexistingTransactionSpec) {
            this.preexistingTransaction = new Transaction(
              candidate,
              preexistingTransactionSpec,
              this
            );
            this.preexistingTransaction.saveMutable();
          }
        }
      },

      snapPointToPath: function(touchLoc) {
        // temporarily put the point on the path; doesn't make a permanent attachment
        var path = this.mergeCandidate,
          point = this.given,
          loc = touchLoc || point.geom.loc,
          map = this.getSnappedPosition(loc);
        point.geom.loc = map;
        point.invalidateGeom();
        path.setRenderState('targetHighlit');
      },

      // Snaps a given's relevant properties to those of its merge candidate,
      // storing the original properties for later restoration.
      snapToCandidate: function(touchLoc) {
        var given = this.given,
          candidate = this.mergeCandidate;
        if (candidate) {
          if (given.isOfKind('Text') && candidate.constraint === 'Pegged') {
            candidate = candidate.parents.text;
          }
          if (candidate.isOfGenus('Path') && given.kind === 'Point') {
            if (!touchLoc) touchLoc = given.geom.loc;
            this.snapPointToPath(touchLoc);
          } else {
            if (!this.givenTransaction) {
              this.prepareTransactionsForSnap();
            }
            this.givenTransaction.snapGivenToCandidate();
            candidate.invalidateGeom();
          }
          if (!candidate.isAPath()) {
            given.setRenderState('invisible'); // for a non-path candidate, depend on candidate highlighting
            candidate.setRenderState('targetHighlit');
          }
        }
      },

      unsnapFromCandidate: function(newLoc) {
        // newLoc is optional. If passed, it indicates where to put the unsnapped given
        var el,
          given = this.given;
        if (this.givenTransaction) {
          this.givenTransaction.restoreMutable();
          delete this.givenTransaction;
          this.preexistingTransaction.restoreMutable();
          delete this.preexistingTransaction;
        }
        this.clearMatches();
        if (newLoc) {
          // Center the unsnapped given on the cursor
          if (given.isOfKind('Text')) {
            el = given.sQuery.sketch.renderRefCon.gobj[given.id].element[0];
            newLoc = newLoc.subtract(
              GSP.GeometricPoint(el.clientWidth / 2, el.clientHeight / 2)
            );
          } else if (given.kind === 'Point') {
            newLoc = newLoc.add(this.deltaToGiven);
          }
          given.geom.loc = newLoc;
          this.updateDeltaToGiven(given.geom.loc);
        }
        given.invalidateGeom();
        given.setRenderState('matchedGiven');
      },

      // Set the merge candidate and create transactions ready for snapping (which may be delayed by animation).
      // Does NOT actually snap the given to the candidate; call snapToCandidate() to do so.
      // But if there is no new candidate, this DOES unsnap any old candidate.
      // The proxy, if defined, is a visible descendant derived from a value object that's the actual candidate
      setMergeCandidate: function(candidate, proxy) {
        var oldCandidate = this.mergeCandidate;
        if (oldCandidate === candidate || (!oldCandidate && !candidate)) {
          return; // nothing to do if they're the same, or if both are falsy
        }
        this.clearMatches();
        if (
          oldCandidate &&
          this.session.existingMatchedGivenForMergeCandidate(oldCandidate)
        ) {
          // Some OTHER given is still matched to this candidate
          oldCandidate.setRenderState('matchedGiven');
        }
        if (oldCandidate) {
          this.unsnapFromCandidate();
        }
        this.given.setRenderState('matchedGiven'); // default appearance
        if (candidate) {
          if (proxy) {
            proxy.setRenderState('targetHighlit');
            this.proxy = proxy;
          } else {
            candidate.setRenderState('targetHighlit');
          }
          this.mergeCandidate = candidate;
          if (this.given.kind !== 'Point' || !candidate.isOfGenus('Path')) {
            this.prepareTransactionsForSnap();
          }
        }
      },

      startWatchingCandidate: function(updateHandler) {
        var sq = this.mergeCandidate.sQuery('#' + this.mergeCandidate.id);
        if (this._onUpdate) {
          sq.off('update', this._onUpdate);
        }
        this._onUpdate = updateHandler;
        sq.on('update', this._onUpdate);
      },

      stopWatchingCandidate: function() {
        if (this._onUpdate) {
          if (!this.mergeCandidate) {
            throw GSP.createError(
              'matched given is still updating a rejected candidate'
            );
          }
          this.given
            .sQuery('#' + this.mergeCandidate.id)
            .off('update', this._onUpdate);
          this._onUpdate = null;
        }
      },

      setIntersectInfo: function(intersectInfo) {
        var newInfo = intersectInfo,
          oldInfo = this.intersectInfo;
        if (
          oldInfo &&
          newInfo.path1 === oldInfo.path1 &&
          newInfo.path2 === oldInfo.path2
        ) {
          oldInfo.location = newInfo.location;
        } else {
          this.clearMatches();
          newInfo.path1.setRenderState('targetHighlit');
          newInfo.path2.setRenderState('targetHighlit');
          this.intersectInfo = newInfo;
        }
      },

      clearIntersectInfo: function() {
        if (this.intersectInfo) {
          this.intersectInfo.path1.setRenderState('none');
          this.intersectInfo.path2.setRenderState('none');
          this.intersectInfo = null;
        }
      },

      getSnappedPosition: function(pos) {
        var candidate = this.mergeCandidate;
        if (this.intersectInfo) {
          return this.intersectInfo.location;
        } else if (candidate) {
          if (candidate.kind === 'Point') {
            return candidate.geom.loc;
          } else if (candidate.isAPath()) {
            return candidate.mapPositionToPathPosition(pos);
          } else if (candidate.isOfKind('Text')) {
            return candidate.geom.loc.add(this.deltaToGiven);
          } else {
            throw GSP.createError(
              'getSnappedPosition cannot map ' +
                this.given.kind +
                this.given.id +
                ' to ' +
                candidate.kind +
                candidate.id
            );
          }
        }
      },

      completeMatch: function(pos) {
        var given = this.given,
          candidate = this.mergeCandidate;
        if (this.intersectInfo) {
          this.intersectInfo.path1.setRenderState('none');
          this.intersectInfo.path2.setRenderState('none');
        }
        if (candidate) {
          if (candidate.isAPath() && given.isOfKind('Point')) {
            candidate.setRenderState('none');
            given.geom.loc = candidate.mapPositionToPathPosition(pos);
            given.invalidateGeom();
          } else {
            candidate.setRenderState('matchedGiven');
          }
        }
      },

      preFinalize: function() {
        if (this.mergeCandidate) {
          var candidate = this.mergeCandidate;
          if (this.given.kind === 'Point' && candidate.isAPath()) {
            this.value = candidate.mapPositionToPathValue(this.given.geom.loc);
          }
          candidate.prepareToSerialize();
        }
      },

      finalize: function(session) {
        var candidate = this.mergeCandidate,
          given = this.given,
          parentalUpdateSkipped;

        function mergeGivenParents(session) {
          // Merge all the parents, but skip updating descendants until the given itself is merged.
          // Otherwise label changes from merging one parent interfere with subsequent parental merges
          given.parentsList.forEach(function(givenPar, ix) {
            var destPar = candidate.parentsList[ix];
            session.sketch.mergeGobjToCandidate(
              givenPar,
              destPar,
              /*session.sketch, session.constructedObjects, */ {
                skipDescendantUpdate: true,
              }
            );
          });
          parentalUpdateSkipped = true;
        }

        function updateParentalDescendants() {
          // update the descendants skipped earlier
          candidate.parentsList.forEach(function(par, ix) {
            par.descendantGraphHasChanged();
            par.descendantLabelGraphHasChanged();
          });
        }

        function deleteGivenParents(sketch) {
          var pList = {};
          if (session.generatedLabels) {
            // give back any parental labels
            sketch.labelPool.restoreSavedState();
            sketch.labelPool.saveState(session);
          }
          given.parentsList.forEach(function(par) {
            pList[par.id] = par;
            par.children = [];
            session.generatedLabels[par.id] = false;
          });
          given.parentsList = [];
          given.parents = {};
          sketch.gobjList.removeGObjects(pList, sketch);
        }

        if (this.intersectInfo) {
          session.sketch.putGivenOnIntersection(given, this.intersectInfo);
        } else if (!candidate) {
          return; // No intersection, no candidate: nothing to do.
        } else {
          if (
            candidate.kind === 'Point' ||
            candidate.isOfKind('Text') ||
            (candidate.isAPath() && given.isAPath())
          ) {
            session.sketch.mergeGobjToCandidate(
              given,
              candidate /*, session.sketch, session.constructedObjects*/
            );
            if (parentalUpdateSkipped) {
              updateParentalDescendants(candidate);
            }
          } else if (candidate.isAPath()) {
            session.sketch.putGivenOnPath(given, candidate, this.value);
          }
          // Wait till after merging the constructibleGiven to merge its parents. Otherwise the constructibleGiven can
          // be added (erroneously) as a child to one of the givenParents
          if (this.given.toolRole === 'constructibleGiven') {
            if (
              given.constraint === candidate.constraint &&
              given.parentsList.length === candidate.parentsList.length
            ) {
              mergeGivenParents(session);
            } else {
              // constraints or # of parents don't match
              deleteGivenParents(session.sketch);
            }
          }
        }
        this.clearMatches();
      },
    }; // matchedGivenProto

    return {
      createWithSpec: function(spec) {
        var ret = Object.create(toolProto);
        var specObjs = spec.objects;
        ret.metadata = $.extend(true, {}, spec.metadata);
        // Labels tools have neither givens nor objectGraph
        if (ret.metadata.name === 'Label') {
          return ret;
        }
        //Validate that the tool has at least one given or assumed
        var hasAGiven = false;
        for (var key in specObjs) {
          if (
            specObjs.hasOwnProperty(key) &&
            ['given', 'givenParent', 'constructibleGiven', 'assumed'].includes(
              specObjs[key].toolRole
            )
          ) {
            hasAGiven = true;
            break;
          }
        }
        if (!hasAGiven) {
          throw GSP.createError('Attempting to create a tool with no givens');
        }
        ret.objectGraph = GSP.ObjectGraph.convertObjectSpec(
          $.extend(true, {}, specObjs)
        );
        return ret;
      },

      createMatchedGiven: function(given, session) {
        var ret = Object.create(matchedGivenProto);
        ret.given = given;
        ret.session = session;
        ret.givenTransactionSpec = transactionSpecFor(given);
        given.setRenderState('matchedGiven');
        return ret;
      },
    };
  })(); // GSP.Tool

  /**
   * @fileOverview Controller object for managing the playing of tools
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2015.
   */

  GSP.ToolController = (function() {
    /*  Defines:
     *    var controllerProto
     *    _getUndoRedoContainer: function()
     *    _clearOutActiveTool: function()
     *    abortActiveTool: function()
     *    regimeDidPop: function(regime)
     *    createToolRegime: function()
     *    setActiveTool: function(tool, sticky)
     *    toggleTool: function(tool, timeStamp)
     *  Returns:
     *    createInSketch: function (sketch) {
     */

    var controllerProto = {
      _getUndoRedoContainer: function() {
        var usingNewLook = this.sketch.getAuthorPreference('toolplayNewLook');
        var container;
        if (usingNewLook) {
          container = this.sketch.baseNode.find('.wsp-sketch-container');
        } else {
          container = this.sketch.baseNode
            .find('.wsp-ok-cancel-container')
            .filter(':visible');
        }
        return container;
      },

      //Private method to clear out the current active tool and associated ui updating
      //(Undoes all ui that was set up in setActiveTool)
      _clearOutActiveTool: function() {
        var container = this._getUndoRedoContainer();
        if (this.activeTool) {
          this.activeTool.$element.removeClass('wsp-tool-active');
          this.activeTool = null;
        }
        this.sketch.canvasNode.toggleClass('wsp-tool-background', false);
        if (this.$closeBox) {
          this.$closeBox.remove();
          this.$closeBox = null;
        }
        if (this.$okBox) {
          this.$okBox.remove();
          this.$okBox = null;
        }
        container.toggleClass('wsp-ok-cancel-mode', false);
      },

      /**
       * Aborts the active tool, if there is one.  It cancels any tool in progress.
       * This does the job of cleaning up any associated ui.
       * It's a no-op if there's no active tool
       */
      abortActiveTool: function() {
        var regime = this.activeRegime,
          name = GSP._get(this.activeTool, 'metadata.name');
        if (regime) {
          // Original code tested for activeTool AFTER popping, so never generated an event
          // Now we get tool name before popping (while activeTool exists)
          // Popping the regime will trigger our delegate who performs all of the cleanup
          this.sketch.popAllTouchRegimesIncluding(regime);
        }
        this.sketch.event('ToolAborted', {}, { tool: { name: name } });
      },

      /**
       * confirms the active tool, and cleans up any associated ui.  No-op if there is no
       * active tool.
       */
      confirmActiveTool: function() {
        var controller = this,
          sketch = this.sketch,
          regime = this.activeRegime;
        if (this.activeTool) {
          this.activeTool.$element.removeClass('wsp-tool-active');
          var onConfirmComplete = function(sketchWasModified) {
            var oldTool = controller.activeTool,
              wasSticky = regime.sticky,
              delta;
            if (sketchWasModified) {
              delta = sketch.document.pushConfirmedSketchOpDelta(
                controller.preToolDelta
              );
            }
            //Here we leave it to our delegate callback to perform the remaining cleanup
            sketch.popAllTouchRegimesIncluding(regime);
            sketch.event(
              'ToolPlayed',
              {},
              {
                delta: delta,
                tool: {
                  name: oldTool.metadata.name,
                },
              }
            );
            if (wasSticky) {
              // if this tool was sticky, reactivate it in a new regime
              controller.setActiveTool(oldTool, wasSticky);
            }
          };
          if (regime) {
            regime.confirmActiveTool(onConfirmComplete);
            // removeDiscardedParents ();
          } else {
            GSP.log(
              'confirmActiveTool called when there is no active tool regime'
            );
          }
        }
      },

      /**
       * Regime delegate implementation - This method is called when the tool regime is
       * popped.
       */
      regimeDidPop: function(regime) {
        if (regime !== this.activeRegime) {
          GSP.log('regimeDidPop called with wrong active regime');
          return;
        }
        this.activeRegime = null;
        regime.doCleanup();
        //Now clean up all the ui elements
        this._clearOutActiveTool();
        this.sketch.document.changedUIMode();
      },

      createToolRegime: function() {
        var ToolRegime;
        if (this.activeTool.metadata.name === 'Label') {
          ToolRegime = GSP.LabelRegime;
        } else {
          ToolRegime = GSP.ToolRegime;
        }
        return ToolRegime.createWithTool(this.sketch, this.activeTool);
      },

      setActiveTool: function(tool, sticky) {
        function makeButtonDom(buttonLocalization, wspClass) {
          var $btn = $(
            '<button><div class="wsp-inner-icon"></div><div class="wsp-inner-text">' +
              GSP.Strings.loc(buttonLocalization) +
              '</div></button>'
          );
          $btn.addClass('wsp-ok-cancel-button');
          $btn.addClass(wspClass);
          return $btn;
        }

        var toolRegime;
        this.preToolDelta = this.sketch.document.getRecentChangesDelta();
        this.sketch.event(
          'WillPlayTool',
          {},
          {
            tool: {
              name: tool.metadata.name,
            },
            preToolDelta: this.preToolDelta,
          }
        );
        this.activeTool = tool;
        tool.$element.addClass('wsp-tool-active');

        try {
          var self = this;
          var initializeControls = !this.$closeBox;
          var container = this._getUndoRedoContainer();
          var newObjIds = [];
          toolRegime = this.createToolRegime();
          $.each(toolRegime.toolplaySession.constructedObjects, function() {
            newObjIds.push(this.id);
          });
          this.sketch.event(
            // Let client know tool gobjs are instantiated
            'ToolPlayBegan',
            {},
            {
              tool: {
                name: tool.metadata.name,
              },
              newObjIds: newObjIds,
            }
          );
          toolRegime.delegate = self;
          this.sketch.pushTouchRegime(toolRegime);
          this.activeRegime = toolRegime;
          if (!toolRegime.confirmToolWhenReady()) {
            // If it's a one-shot tool, no need to change UI
            toolRegime.sticky = sticky;
            this.sketch.document.changedUIMode();
            if (initializeControls) {
              var $closeBox = makeButtonDom('GSP.UI.cancel', 'wsp-tool-cancel');
              container.append($closeBox);
              $closeBox.on('click', function(/*event*/) {
                //Don't do anything unless we're still in our tool regime
                if (self.sketch.touchRegimeBlocksOtherButtons()) return false;
                self.abortActiveTool();
                //Blur after abort so that a numpad blur doesn't inadvertently
                // confirm the tool
                GSP.blurDocumentActiveElement(self.sketch.baseNode);
              });
              this.$closeBox = $closeBox;
              var $okBox = makeButtonDom('GSP.UI.ok', 'wsp-tool-ok');
              container.append($okBox);
              $okBox.on('click', function(/*event*/) {
                if (self.sketch.touchRegimeBlocksOtherButtons()) return false;
                GSP.blurDocumentActiveElement(self.sketch.baseNode);
                self.confirmActiveTool();
              });
              this.$okBox = $okBox;
            }
            this.sketch.canvasNode.toggleClass('wsp-tool-background', true);
            container.toggleClass('wsp-ok-cancel-mode', true);
          }
        } catch (e) {
          GSP.signalCaughtError(e);
          if (toolRegime && toolRegime.isPushed) {
            this.abortActiveTool();
          } else {
            //Didn't get far enough to abort - just reset the ui
            this._clearOutActiveTool();
          }
        }
      },

      toggleTool: function(tool, timeStamp) {
        if (this.sketch.touchRegimeBlocksOtherButtons()) return false;
        GSP.blurDocumentActiveElement(this.sketch.baseNode);
        var oldTool = this.activeTool,
          doubleTapTime = 500,
          regime = this.activeRegime;
        if (oldTool) {
          // If the tool is unchanged, check the timeStamp: a double-tap makes it sticky, otherwise abort it
          if (oldTool === tool) {
            if (timeStamp - regime.startTime < doubleTapTime) {
              regime.sticky = true;
              tool.$element.addClass('wsp-tool-active'); // Make sure the tool icon stays active
              return;
            }
          }
          if (regime.toolplaySession.matchedGivens.length) {
            this.confirmActiveTool(); // not a double-tap and the user has already matched at least one given.
          } else {
            this.abortActiveTool(); // not a double-tap and the user hasn't matched any givens.
          }
          if (oldTool === tool) {
            // if the tap was on the active tool, just toggle it off and return.
            return true;
          }
        }
        this.setActiveTool(tool, false); // initial activation of a tool sets sticky to false
        if (this.activeRegime) this.activeRegime.startTime = timeStamp;
      },
    };

    return {
      createInSketch: function(sketch) {
        var ret = Object.create(controllerProto);
        ret.sketch = sketch;
        return ret;
      },
    };
  })(); // GSP.ToolController

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class
   */

  GSP.Genus = (function(/** @lends GSP.Genus */) {
    return {};
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class GSP.gObjects.Circle
   *  @augments GSP.Genus
   */
  GSP.genera.Path = GSP.makeClass(/** @lends GSP.genera.Path */ GSP.Genus, {
    genus: 'Path',

    /* Given an arbitrary position, mapPositionToPathValue should return a valid
     * value on that path.  (Valid implies it should be clamped to legal values
     * for the path.)
     */
    mapPositionToPathValue: function(position) {
      throw GSP.createError('mapPositionToPathValue not Implemented');
    },
    mapPathValueToPosition: function(pathValue) {
      throw GSP.createError('mapPathValueToPosition not Implemented');
    },
    //Vectorized version of mapPathValueToPosition():
    //Given an array of values, return an array of point positions
    //default implementation just calls mapPathValueToPosition() on each element
    mapVectorPathValuesToPositions: function(pathValues) {
      var i,
        numElements = pathValues.length,
        ret = [];

      for (i = 0; i < numElements; i++) {
        ret[i] = this.mapPathValueToPosition(pathValues[i]);
      }

      return ret;
    },
    /* Given an arbitrary position, mapPositionToPathPosition should return a valid (x, y) location on that path.
     */
    mapPositionToPathPosition: function(iPosition) {
      var val = this.mapPositionToPathValue(iPosition);
      return this.mapPathValueToPosition(val);
    },
    /*
     *  Get an object describing the internal min and max animation values for
     *  the path. These values are internal in that they are used in the mechanics
     *  of animation rather than appropriate values to display to the user.
     *  @return {Object} {min: Number, max: Number}
     */

    getAnimationRange: function() {
      return { min: 0, max: 1 };
    },
    /*
     * Returns the length of one unit (parameter value 0 to 1) in pixel distance
     * @return {Number}
     */
    unitLength: function() {
      var range = this.getAnimationRange();
      return this.pathLength() / (range.max - range.min);
    },
    /**
     * A value bound to within the range of values on the path.
     * Points on paths are implicitly scaled. For example, the values of
     * points on segments ranges from zero to one, inclusive, where zero
     * is coincident with p0, and one with p1. This method makes sure values are
     * within the implied range, if such a range exists.
     * @param {Number} v
     * @return {Number}
     */
    constrainRange: function(v) {
      return v;
    },

    /**
     *  Returns true if the specified value is within the domain bounds of the path.
     *  By default, all finite values are considered in bounds. Derived classes with
     *  more restrictive bounds should override appropriately.
     *  @param  {Number}  v -- The value to test against the domain bounds of the path
     *  @return {Boolean} true if the value is within the bounds, false otherwise
     */
    isValueInBounds: function(v) {
      return GSP.math.isFiniteScalar(v);
    },
    pathLength: function() {
      throw GSP.createError('pathLength not Implemented');
    },
    constrainLabelForPath: function() {
      var style = this.style.label,
        state = this.state,
        domain = this.getAnimationRange(),
        loc = style.labelParam;

      if (typeof loc === 'undefined') {
        loc =
          (domain.max - domain.min) * this.getDefaultLabelPathParam() +
          domain.min;
      }
      if (state.exists && style.showLabel) {
        this.labelSpec.location = this.mapPathValueToPosition(loc);
      }
    },

    // Note, if you override this in a constraint which may apply to
    // paths, be sure to call constrainLabelForPath() from your code.
    constrainLabel: function() {
      this.constrainLabelForPath();
    },

    /* Returns how "far along" the path the label should be placed. */
    getDefaultLabelPathParam: function() {
      return 0.25;
    },
    /**
     * Augment the attr array with styles to make dashing according
     * to this.style['line-style']
     *
     * @param {Object} attrs - style attribute object to be dashed dashed.
     * @return {Object} the augmented attr object
     */
    setLineDash: function(attrs) {
      GSP.modifyRenderAttrsForLineStyle(this.style['line-style'], attrs);

      return attrs;
    },

    openMotionPathProto: {
      advance: function(pixelDistance) {
        var value = this.start,
          unitLength = this.path.unitLength(),
          delta = pixelDistance / unitLength;
        if (this.start < this.end) {
          value = Math.min(this.end, this.start + delta);
        } else if (this.end < this.start) {
          value = Math.max(this.end, this.start - delta);
        }
        return value;
      },
      getDistance: function() {
        return Math.abs(this.end - this.start) * this.path.pathLength();
      },
    },
    closedMotionPathProto: {
      /*
       * returns a value in normalized value units representing the shortest
       * arc between the start and end. A positive number represents a
       * counterclockwise traversal, and a negative number, a clockwise
       * traversal. Normalized value units range from -0.5 to 0.5, with -0.5
       * corresponding to pi radians clockwise and 0.5, pi radians
       * counterclockwise.
       */
      getArcLength: function() {
        var nvu = this.end - this.start;
        if (nvu > 0.5) {
          nvu -= 1;
        }
        if (nvu < -0.5) {
          nvu += 1;
        }
        return nvu;
      },
      advance: function(pixelDistance) {
        var value = this.start,
          pathLength = this.path.pathLength(),
          delta = pixelDistance / pathLength,
          arcLength = this.getArcLength();
        //GSP.log('start/end/value/pathLength/delta/arcLength: '
        //    + [this.start, this.end, value, pathLength, delta,
        //    arcLength].join('/'));
        if (Math.abs(arcLength) < delta) {
          value = this.end;
        } else if (arcLength < 0) {
          value = value - delta;
        } else {
          value = value + delta;
        }
        value -= Math.floor(value);
        return value;
      },
      getDistance: function() {
        return Math.abs(this.getArcLength()) * this.path.pathLength();
      },
    },
    makeMotionPath: function(start, end) {
      var motionPath = Object.create(
        this.closedPath ? this.closedMotionPathProto : this.openMotionPathProto
      );
      motionPath.path = this;
      motionPath.start = start;
      motionPath.end = end;
      return motionPath;
    },
    /**
     * Paths compare 3 positions along the path with the exporter-calculated positions
     * along the path.  We test the 0 position, the 0.5 position and the 1 position.
     */
    pathValidationString: function(expectedPathPositions) {
      var msg = '',
        self = this;

      function makePoint(pointSpec) {
        if (!pointSpec) {
          return GSP.GeometricPoint.UNDEFINED;
        }

        return GSP.GeometricPoint(pointSpec.x, pointSpec.y);
      }

      //utility for testing 2 points.  The test passes if:
      // - GeometricPoint.expect() passes
      // - both points are undefined where undefined can mean ANY of the following:
      //    undefined,
      //    GeometricPoint.UNDEFINED
      //    a point where either x or y is Nan or Infinity or -Infinity
      //
      function pointsAreEqual(pointOne, pointTwo, tol) {
        var ptOneDefined =
            pointOne && pointOne.isDefined() && pointOne.isFinite(),
          ptTwoDefined =
            pointTwo && pointTwo.isDefined() && pointTwo.isFinite();

        if (ptOneDefined && ptTwoDefined) {
          return GSP.GeometricPoint.expect(pointOne, pointTwo, tol);
        } else {
          return ptOneDefined === ptTwoDefined;
        }
      }

      [
        {
          name: 'Zero',
          value: 0,
          expectedPosition: expectedPathPositions.zeroPosition,
          expectedDerivative: expectedPathPositions.zeroDerivative,
        },
        {
          name: 'Middle',
          value: 0.5,
          expectedPosition: expectedPathPositions.middlePosition,
          expectedDerivative: expectedPathPositions.middleDerivative,
        },
        {
          name: 'One',
          value: 1,
          expectedPosition: expectedPathPositions.onePosition,
          expectedDerivative: expectedPathPositions.oneDerivative,
        },
      ].forEach(function(testInfo) {
        var actualPosition,
          actualDerivative,
          output = {},
          expectPosition = makePoint(testInfo.expectedPosition),
          expectDerivative = makePoint(testInfo.expectedDerivative);

        actualPosition = self.mapPathValueToPosition(testInfo.value, output);
        actualDerivative = output.derivative;

        if (!pointsAreEqual(actualPosition, expectPosition)) {
          msg +=
            testInfo.name +
            ' Path Position: <span class="error">' +
            actualPosition +
            '</span>(<span class="expected">' +
            expectPosition +
            '</span>)';
        }

        // Derivative calculations involve subtraction of near-equal vaules,
        // so there's round-off error in abundance.

        // We'll also skip derivatives that are big - that's pretty much
        // garbage in -> garbage out.
        if (
          expectDerivative &&
          expectDerivative.l1Norm() < 100 &&
          !pointsAreEqual(actualDerivative, expectDerivative, 1)
        ) {
          msg +=
            testInfo.name +
            ' Path Derivative: <span class="error">' +
            actualDerivative +
            '</span>(<span class="expected">' +
            expectDerivative +
            '</span>)';
        }
      });

      return msg;
    },

    /*
     * Paths (including at least straights and polygons) sometimes function as transformed images,
     * and need to be labeled accordingly. If the path is descended from point parents that are all
     * transformed images based on the same transformation, and if the preimages (sources) of these
     * points have a child that bears the same relationship to its parents as the current path does
     * to its parents, the current path functions precisely as if it were a transformed image, and
     * should be so labeled.
     * NOTE that the caller is responsible for ensuring that this path meets the criteria!
     * We implement this with a bit of a hack, because it's the point parents of the path that know
     * how to create transformed-image labels. We choose one such point and use it and its preimage
     * point) as proxies to generate the label, and restore them when finished.
     */
    makeParentalLabel: function(nameOrigin, option) {
      var legalOrigins = ['namedByPrime', 'namedByFullFn', 'namedByShortFn'],
        imgGobj,
        preGobj,
        preLabel, // save preimage proxy data
        retVal,
        parLabel = this.getParentLabel('labelParent', { create: true });
      if (legalOrigins.indexOf(nameOrigin) < 0) {
        retVal = this.label;
      } else {
        if (!parLabel)
          throw GSP.createError(
            'makeParentalLabel() call to findParentLabel() failed.'
          );
        imgGobj = this.parentsList[0]; // Identify our proxy image and preimage
        preGobj = imgGobj.parents.source;
        if (!preGobj)
          throw GSP.createError(
            "makeParentalLabel() didn't find a parent's preimage."
          );
        preLabel = preGobj.label; // cache proxy original label, which may be undefined
        preGobj.label = parLabel; // temporarily change preimage label
        retVal = imgGobj.makeParentalLabel(nameOrigin, option);
        if (preLabel)
          // restore proxy labels
          preGobj.label = preLabel;
        else delete preGobj.label;
      }
      return retVal;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class GSP.genera.Point
   *  @augments GSP.Genus
   */

  GSP.genera.Point = (function(/** @lends GSP.genera.Point */) {
    var pointGenus = Object.create(GSP.Genus);
    return pointGenus;
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class GSP.genera.Interior
   */
  GSP.genera.Interior = GSP.makeClass(
    /** @lends GSP.genera.Interior */ GSP.Genus,
    {
      /* Currently just a stub */

      genus: 'Interior',
      modifyRenderAttrsForInterior: function(attrs, state) {
        switch (state) {
          case 'speculative':
            attrs.color = GSP.speculativeColor;
            break;
          case 'targetHighlit':
            attrs.drawBorder = true;
            attrs.borderColor = GSP.targetHighlightColor;
            attrs.borderWidth = 3 + GSP.targetHighlightPathBolding;
            break;
          case 'targetOnFocus': // This case will be triggered when gobject get focus.
            attrs.isFocusable = true;
            attrs.opacity = 1;
            attrs.color = GSP.targetFocusColor;
            // attrs.color = '#7efbfb';
            break;
          default:
            break;
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * Labels a geometric object. The following object kinds can have labels:
   * Points, Straights, Polygons, Circles, Arcs, CircleInteriors, Axis, Measures.
   */
  GSP.mixins.labelBase = {
    doc: {
      properties: {
        label: {
          description: 'Text for the label, if any.',
          type: 'String',
        },

        style: {
          properties: {
            label: {
              description:
                'Properties that influence the appearance of a Label. Overrides of the GObject style, and as follows.',
              properties: {
                color: {
                  description: 'The color of label text',
                  type: 'Color',
                },
                'font-family': {
                  description:
                    'The basis font family for text in this GObject. See GSP.getFontFamilyFromStyle() for supported formats.',
                  type: 'FontFamily',
                },
                'font-size': {
                  description: 'The basis font size for text in this GObject',
                  type: 'FontSize',
                },
                'font-style': {
                  description:
                    'The basis font style (slant) for text in this GObject',
                  type: 'FontStyle',
                },
                'font-weight': {
                  description:
                    'The basis font weight (boldness) for text in this GObject',
                  type: 'FontWeight',
                },
                labelOffsetX: {
                  description:
                    'Horizontal offset of the upper left corner of the label, in pixels.',
                  type: 'Number',
                  required: false,
                },
                labelOffsetY: {
                  description:
                    'Vertical offset of the upper left corner of the label, in pixels.',
                  type: 'Number',
                  required: false,
                },
                labelParam: {
                  description:
                    'Position on the path where a label will be placed.',
                  type: 'Number',
                  required: false,
                },
                'letter-spacing': {
                  description:
                    'The basis font letter spacing for text in this GObject',
                  type: 'LetterSpacing',
                },
                showLabel: {
                  description:
                    'Whether or not a label should accompany the gObject.',
                  type: 'Boolean',
                },
                'text-decoration': {
                  description:
                    'line-through, underlines, and other variations on the label text',
                  type: 'TextDecoration',
                },
              },
            },
          },
        },
      },
    },
    style: {
      label: {},
    },
  };

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2012 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * Labels a geometric object. The following object kinds can have labels:
   * Points, Straights, Polygons, Circles, Arcs, CircleInteriors, Axis.
   */
  GSP.mixins.label = GSP.makeClass(GSP.mixins.labelBase, {
    getLabelSpec: function() {
      return !$.isEmptyObject(this.labelSpec) ? this.labelSpec : undefined;
    },
    getLabelBounds: function(drawContext) {
      // set at render time
      return this.labelRenderBounds || GSP.Geom.kInfiniteRect;
    },
    // Make sure this.parsedMFS is set, autogenerating if needed.
    // returns this.parsedMFS as a convenience.
    ensureLabelMFS: function(mathItalicization) {
      if (this.parsedMFS) return this.parsedMFS;

      try {
        if (this.label) {
          this.parsedMFS = GSP.labels.parseLabelExpression(
            this.label,
            mathItalicization
          );
        } else {
          this.parsedMFS = this.getNameMFSForLabel();
        }
      } catch (ex) {
        ex.message = 'Error parsing label: "' + this.label + '": ' + ex.message;
        GSP.signalCaughtError(ex);
      }

      return this.parsedMFS;
    },
    renderLabelPrepare: function(drawContext, renderArgs) {
      if (!this.hasLabel) {
        return;
      }
      var fontFamily = GSP.getFontFamilyFromStyle(
          this.style.label,
          this.sQuery()
        ),
        labelStyle = this.style.label;

      renderArgs.id = String(this.id) + '-label';
      renderArgs.kind = 'Label';
      renderArgs.color = labelStyle.color;
      renderArgs['font-family'] = fontFamily;
      renderArgs['font-style'] = labelStyle['font-style'];
      renderArgs['font-weight'] = labelStyle['font-weight'];
      renderArgs['font-size'] = labelStyle['font-size'];
      renderArgs['text-decoration'] = labelStyle['text-decoration'];
      renderArgs['text-align'] = 'left';

      return drawContext.prepareText(renderArgs);
    },
    /**
     * label specific version of kind.doPostRenderPrepare(), q.v.
     */
    labelPreRenderJITPrepare: function(drawContext, drawRefCon) {
      var size, topLeft;

      if (this.hasLabel && !this.state.labelPreRenderJITPrepareDone) {
        size = this.measureLabel(drawContext, drawRefCon);
        if (!this.hasLabelOffset()) {
          this.initLabelOffset(size);
        }
        this.restrictLabelOffset(size);
        // In case the bounds are out of date, reset them
        topLeft = this.getLabelTopLeft();
        drawRefCon.renderBounds = {
          top: topLeft.y,
          bottom: topLeft.y + size.height,
          left: topLeft.x,
          right: topLeft.x + size.width,
        };
        this.sQuery.sketch.invalidateRect(drawRefCon.renderBounds);
        // with multiple copies of the label renderBounds, should any of the others be updated?
        // (The copies in drawRefCon and sketch.renderRefCon.label[this.id] are the same.)
        this.labelRenderBounds =
          // Empirically, this doesn't seem to be needed AFAIK
          {
            top: topLeft.y,
            bottom: topLeft.y + size.height,
            left: topLeft.x,
            right: topLeft.x + size.width,
          };
        this.sQuery.sketch.renderRefCon.labelBounds[this.id] =
          // This one does seem to be important.
          {
            top: topLeft.y,
            bottom: topLeft.y + size.height,
            left: topLeft.x,
            right: topLeft.x + size.width,
          };
        this.state.labelPreRenderJITPrepareDone = true;
      }
    },
    /*
     * make sure the label has not strayed too far from the central point.
     * If / when labels are draggable, this will need to be called to tether
     * the label to the gobject. It's also used as a sanity pass on initial load,
     * which can address issues in toolplay where there are nonsensical offsets
     * for labels whose name in the original desktop sketch's tool page had
     * a prefix like "given: ", which has been stripped out in the json.
     *
     * See labels.c:RestrictLabelOffset()
     */
    restrictLabelOffset: function(size) {
      var LABEL_SLOP_X = 8,
        LABEL_SLOP_Y = 5,
        LABEL_SLOP_BOTTOM_RIGHT = 5,
        ls = this.style.label;

      /* must be at least -width - LABEL_SLOP */
      ls.labelOffsetX = Math.max(ls.labelOffsetX, -size.width - LABEL_SLOP_X);
      /* and no larger than LABEL_SLOP */
      ls.labelOffsetX = Math.min(
        ls.labelOffsetX,
        LABEL_SLOP_X + LABEL_SLOP_BOTTOM_RIGHT
      );

      ls.labelOffsetY = Math.max(ls.labelOffsetY, -size.height - LABEL_SLOP_Y);
      ls.labelOffsetY = Math.min(
        ls.labelOffsetY,
        LABEL_SLOP_Y + LABEL_SLOP_BOTTOM_RIGHT
      );
    },
    /**
     * Return the width, height of the label.
     * If there is no label, width and height are construed to be 0.
     */
    measureLabel: function(drawContext, drawRefCon, renderArgs) {
      var size = { width: 0, height: 0 };

      if (this.hasLabel) {
        size = drawContext.measureText(drawRefCon, {
          parsedMFS: this.ensureLabelMFS(this.getMathItalicization()),
        });
      }

      return size;
    },

    getLabelOrigin: function() {
      return this.labelSpec.location || this.geom.loc;
    },

    // The actual topLeft of the label Bounding box.
    // labelTopLeft = labelOrigin + labelOffset
    getLabelTopLeft: function() {
      var ls = this.style.label,
        labelOrigin = this.getLabelOrigin();
      return GSP.GeometricPoint(
        labelOrigin.x + ls.labelOffsetX,
        labelOrigin.y + ls.labelOffsetY
      );
    },

    getLabelCornerDelta: function(touchPos) {
      var topLeft = this.getLabelTopLeft();
      return GSP.GeometricPoint(touchPos.x - topLeft.x, touchPos.y - topLeft.y);
    },

    // Positions a label during touch-dragging.
    //
    // touchPos: the touch position
    // labelCornerDelta: original delta from the first touchdown of this touch.
    //
    // We maintain these invariants:
    // labelTopLeft = touchPos - labelCornerDelta
    // labelTopLeft = labelOrigin + labelOffset
    setLabelPosition: function(touchPos, labelCornerDelta) {
      var labelOrigin, labelTopLeft, ls;
      // If we're a path, first set the label's origin to the closest
      // point on path. The exporter calls this the
      // "labelSpec.location"
      if (this.mapPositionToPathValue) {
        // Some paths (e.g. AngleMarkers) don't place labels directly
        // on themselves, but onto a special "label path"
        if (this.mapPositionToLabelPathParam) {
          this.userSetLabelPathParam = this.mapPositionToLabelPathParam(
            touchPos
          );
          this.constrainLabel(); // sets origin based on path param
        } else {
          this.style.label.labelParam = this.mapPositionToPathValue(touchPos);
          this.labelSpec.location = this.mapPathValueToPosition(
            this.style.label.labelParam
          );
        }
      }
      // Now set the label offset. Don't worry if the offset is huge,
      // as it will be adjusted forthwith (by restrictLabelOffset).
      labelOrigin = this.getLabelOrigin();
      labelTopLeft = GSP.GeometricPoint(
        touchPos.x - labelCornerDelta.x,
        touchPos.y - labelCornerDelta.y
      );
      ls = this.style.label;
      ls.labelOffsetX = labelTopLeft.x - labelOrigin.x;
      ls.labelOffsetY = labelTopLeft.y - labelOrigin.y;
      this.restrictLabelOffset({
        width: this.labelRenderBounds.right - this.labelRenderBounds.left,
        height: this.labelRenderBounds.bottom - this.labelRenderBounds.top,
      });
    },

    renderLabel: function(drawContext, drawRefCon, renderArgs) {
      if (!this.hasLabel) {
        return;
      }
      var labelStyle = this.style.label,
        loc,
        renderable = this.isRenderable() && this.style.label.showLabel,
        visibility = renderable ? 'visible' : 'hidden',
        // must be mixed in with a kind for this to work
        mathItalicization = this.getMathItalicization(),
        x,
        y;
      if (renderable) {
        this.ensureLabelMFS(mathItalicization);
        // If the label has changed and ensureLabelMFS has reparsed it, the result is in the gobj: this.parsedMFS.
        // drawRefCon.parsedMFS (from sketch.renderRefCon.label[gobj.id]) is now out of date, which will result in incorrect measurements.
        // A concern: is there a reason that the parsedMFS data is cached separately in the gobj and the refCon?
        // Without the following assignment, when would the two be brought back into agreement?
        drawRefCon.parsedMFS = this.parsedMFS;

        this.labelPreRenderJITPrepare(drawContext, drawRefCon);
        loc = this.getLabelOrigin();
        x = loc.x + labelStyle.labelOffsetX;
        y = loc.y + labelStyle.labelOffsetY;
      }

      drawContext.drawText(drawRefCon, {
        x: x,
        y: y,
        renderable: renderable,
        visibility: visibility,
        opacity: this.calculateFadeOpacity(),
        parsedMFS: this.parsedMFS,
        label: this.label,
        useDrawImage: false,
        constraintFrame: this.state.constraintFrame,
      });

      // stash the estimated bounds determined at render time
      if (renderable) {
        // This is only used by the Canvas engine, but needs to be stashed
        // with the object so that it can be returned when requested.
        this.labelRenderBounds = drawRefCon.renderBounds;
      }
    },
    renderLabelCleanup: function(drawContext, drawRefCon) {
      drawContext.cleanupText(drawRefCon);
    },
    hideExistingLabel: function() {
      if (this.labelExists()) {
        this.style.label.showLabel = false;
        this.invalidateAppearance();
      }
    },

    showExistingLabel: function() {
      if (this.labelExists()) {
        this.style.label.showLabel = true;
        this.invalidateAppearance();
        return true; // allow caller to detect success
      }
    },

    useTransformLabel: function() {
      // true if this is a transformation or all parents are identically transformed pre-image points,
      // and those pre-images have a child of the same constraint.
      var legalConstraints = ['PolygonFromPoints', 'Segment', 'Ray', 'Line'];

      function transEqual(trans1, trans2) {
        function eq(a) {
          return trans1[a] === trans2[a];
        }
        return (
          eq('m00') &&
          eq('m10') &&
          eq('m10') &&
          eq('m11') &&
          eq('m20') &&
          eq('m21')
        );
      }

      function checkLabelParent(gobj) {
        // Recursively look for appropriate label parents.
        var retVal,
          parSource = [],
          parTransform,
          labelParent;

        function fixConnections() {
          var parState = labelParent.state,
            i;
          if (retVal) {
            // using transformation labeling, so connect gobj and labelParent, and recurse
            parState = labelParent.state;
            gobj.state.labelParent = labelParent;
            if (!parState.labelChildren) parState.labelChildren = [];
            if (parState.labelChildren.indexOf(gobj) < 0) {
              parState.labelChildren.push(gobj);
            }
            checkLabelParent(labelParent);
          } else if (labelParent) {
            // not using transformation labeling: disconnect any existing connection.
            i = parState.labelChildren.indexOf(gobj);
            if (i < 0)
              throw GSP.createError(
                "WIDGETS.fixConnections() couldn't find gobj in labelParent's array."
              );
            parState.labelChildren.splice(i, 1);
            if (parState.labelChildren.length === 0) {
              delete parState.labelChildren;
            }
            delete gobj.state.labelParent;
          }
        }

        // Transform labeling can be used with a specific subset of path objects
        retVal = legalConstraints.indexOf(gobj.constraint) >= 0;
        if (retVal) {
          // Are all gobj's parents identically transformed points?
          $.each(gobj.parentsList, function(idx, par) {
            if (
              !par.isTransformationConstraint ||
              (parTransform &&
                !transEqual(
                  parTransform,
                  par.getTransformer().getAffineTransform()
                ))
            ) {
              retVal = false;
              return false; // exit the $.each loop
            }
            if (!parTransform) {
              parTransform = par.getTransformer().getAffineTransform(); // get the transformation for the first parent
            }
            parSource.push(par.getParent('source'));
          });
        }
        if (retVal) {
          // All gobj parents are identically transformed, and their sources are stored in parSource[].
          // Do the parSource[] objects have a child constrained identically to gobj?
          // To find out, check each child of parSource[0].
          $.each(parSource[0].children, function(idx, child) {
            // We've found a labelParent if both gobj and child have same constraint and corresponding parents.
            // To correspond, parents must be in same order, but not necessarily same direction or starting point.
            // For instance, polygon C'B'A' is a transformed image of polygon ABC.
            // For path objects other than polygons, segments, and lines, the check must be more sophisticated.
            var i,
              j,
              jStart = child.parentsList.indexOf(parSource[0]),
              n = child.parentsList.length;
            if (
              child.constraint === gobj.constraint &&
              n === gobj.parentsList.length &&
              jStart >= 0
            ) {
              // We already know that parSource[0] === child.parentsList [j], the first match
              // Try forward direction first, assuming success
              labelParent = child;
              for (i = 1, j = jStart; i < n; i++) {
                j = (j + 1) % n;
                if (parSource[i] !== child.parentsList[j]) {
                  labelParent = undefined;
                  break;
                }
              }
              if (!labelParent) {
                // Forward failed; try backward
                labelParent = child;
                for (i = n - 1, j = jStart; i > 0; i--) {
                  j = (j + 1) % n;
                  if (parSource[i] !== child.parentsList[j]) {
                    labelParent = undefined;
                    break;
                  }
                }
              }
            }
            if (labelParent) return false;
          });
          if (!labelParent) {
            retVal = false;
          } else {
            fixConnections(); // connect gobj if retVal is true; disconnect otherwise.
          }
        }
        return retVal;
      }

      return this.isTransformationConstraint || checkLabelParent(this);
    },

    // This handles setting the label's content as well as
    // hiding/showing it. Also, some labels auto-generate unless/until
    // a user explicitly modifies them, and we handle that here too.
    setLabel: function(newLabel, option) {
      var labelStyle;
      option = option || {};

      if (newLabel === '')
        throw GSP.createError('Cannot set Label to empty string');

      this.style.label = this.style.label || {};
      labelStyle = this.style.label;
      if (option && option.show !== undefined) {
        labelStyle.showLabel = option.show;
      }
      // If the user explicitly changes a label, we won't auto-generate it anymore.
      if (this.label !== newLabel && option && option.wasUserInitiated) {
        this.shouldAutogenerateLabel = false;
      }
      this.label = newLabel;
      this.parsedMFS = undefined;
      this.state.labelPreRenderJITPrepareDone = false; // The label has changed, so force it to be remeasured.
      if (!option || !option.init) {
        this.descendantLabelGraphHasChanged(); // Update labels without calling invalidateGeom()
      }
    },

    // This returns the gobj label, forcing the label to be generated.
    // Some callers require a defined return value, so the label must be created
    // when option has any of these values set: init, show, create, or constrain.
    // Generating the label may require walking up a chain of transformed images or generating a label from the pool.
    getLabel: function(option) {
      var label = this.label;
      option = option || {};
      // Removed option.init from following "if" to prevent label generation when testing for possible nameOrigin values.
      // If this.label really is part of a parental name for a child, this.label must already exist
      if (!label && (option.show || option.create || option.constrain)) {
        // this should not remain unlabeled.
        // Transformed images should be parentally labeled unless their nameOrigin is "namedFromLobel"
        if (
          (this.isTransformationConstraint &&
            this.style.nameOrigin &&
            this.style.nameOrigin !== 'namedFromLabel') ||
          this.state.labelParent
        ) {
          // an unlabeled image requires walking back to a labeled source
          label = this.getParentLabel('source', option) + "'";
          this.style.nameOrigin = 'namedByPrime';
        } else {
          label = this.sQuery.sketch.labelPool.generateLabel(
            this.kind,
            this.genus,
            this.id
          );
        }
        this.setLabel(label, option);
      }
      if (option.show && !this.style.label.showLabel) {
        // whether or not the gobj is visible, make sure its label is showing
        this.style.label.showLabel = true;
        if (!option.init) this.constrainLabel(); // set up parent.labelSpec for gobjs that need it
        if (!this.style.hidden) {
          this.invalidateAppearance();
        }
      }
      return this.label;
    },

    // This returns the parent label, optionally forcing the label to be generated.
    // If option.create and the parent doesn't have a label, the label is created.
    // If option.show, the parent object is shown along with its (possibly newly created) label.
    // If option.init without either option.create or option.show, the parent label is NOT created.
    // Generating the label may require walking up a chain of transformed images or generating a label from the pool.
    // This function creates labels for transformed images and for other objects whose labels refer to parents.
    getParentLabel: function(parentID, option) {
      var parent,
        retVal = '';
      if (this.state.labelParent) {
        parent = this.state.labelParent;
      } else {
        parent = this.getParent(parentID);
      }
      if (parent) {
        if (parent.getLabel) {
          retVal = parent.getLabel(option);
        } else if (parent.label) {
          retVal = parent.label;
        }
      }
      return retVal;
    },

    // This returns the parent label if it exists and is visible. If option.show or option.constrain, the label is created and shown (if needed). Otherwise, the return is empty if the label isn't already showing.
    getVisibleParentLabel: function(parentID, option) {
      var parent = this.getParent(parentID),
        label;
      if (!parent || !parent.hasLabel) {
        return '';
      }
      label = parent.label;
      if (!(option && (option.show || option.constrain))) {
        return parent.style.label.showLabel ? label : '';
      }
      if (!label) {
        // Need to create and/or show the label
        label = this.getParentLabel(parentID, option);
      }
      parent.showExistingLabel();
      return label;
    },
  });

  /**
   * @fileOverview
   *
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2011.
   */
  GSP.mixins.transformable = {
    doc: {},
    /**
        Subclasses may override.
        
        @return {function} function to be applied to geom vectors in constrain().
      */
    getTransform: function() {
      return function(point) {
        return point.copy();
      };
    },
    /**
        Subclasses may override.
  
        @return {function} function to be applied to geom scalars in constrain().
      */
    getScalarTransform: function() {
      return function(dist) {
        return dist;
      };
    },
    /**
        Subclasses may override.
  
        @return {function} GSP.transformer to be applied to geom in constrain().
      */

    getTransformer: function() {
      // The transformer was formerly cached in the image's state, causing trouble when transform-parents were merged
      return this.getParent('source').createTransformer(this);
    },
  };

  /**
   * @fileOverview vector describes a protocol for samplable objects.  These objects
   *  must override all of the methods of this mixin to be sampled.  Including the
   *  mixin in the class creation simply verifies that the methods are overridden.
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2011.
   */

  /*  Returns either an untyped array or a packed float array of size numElements.
   *  The decision is based on browser support and performance of typed float arrays.
   *  Theoretically this should be a performance boost over a regular untyped array,
   *  but this seems to vary by browser, with some (Safari?) performing worse.
   *
   *  @param numElements
   *  @return {Array|Float64Array}
   */
  GSP.createFloatVector = function(numElements) {
    if (numElements > 0) {
      return window.Float64Array
        ? new Float64Array(numElements)
        : new Array(numElements);
    } else {
      //For 0 elements, return an empty array rather than undefined.
      //It's not clear that a typed array of 0 elements is legal
      //(For an empty array, we don't care what kind of array it is)
      return [];
    }
  };

  GSP.mixins.vector = {
    doc: {},
    /**
     * Initialize state object to be used by sampling implementation
     *
     * @param {Number} numSamples
     * @param {Boolean} colorize
     * @returns {Object} the sampling object to be used by the
     */

    createVectorContext: function(numSamples, parentSampler, colorize) {
      throw GSP.createError('createVectorContext not Implemented');
    },
    /**
     * The vector context should reset any running state that gets updated as
     * samples are collected (eg. GeomBounds)
     */
    resetVectorSamples: function(vectorContext) {
      vectorContext.geomBounds = null;
      vectorContext.filledSampleCount = 0;
    },
    /**
     * Fills a single sample at index with the current state (geometry and possibly
     * color) of the sample object.  A standard implementation will also grow the
     * geomBounds property in increase the filledSampleCount at this time.
     * Vector context that don't define an 'isContinuous' property can rely on the
     * object existing when this call is made.  Contexts that define 'isContinuous'
     * must be prepared for this call to be made on a non-existing sample object.
     *
     * @param {Object} vectorContext
     * @param {Number} index
     * @returns {undefined}
     */
    fillSingleSample: function(vectorContext, index) {
      throw GSP.createError('fillSingleSample not Implemented');
    },
    /**
     * Returns the geometry of the sample at the specified index
     * Optional
     *
     * @param {Object} vectorContext
     * @param {type} index
     * @returns {undefined}
     */

    //getGeomForSample: function(vectorContext, index) {
    //  throw GSP.createError("getGeomForSample not Implemented");
    //},
    /**
     * gets the current geomBounds of the vector
     *
     * @param {Object} vectorContext
     */
    getGeomBoundsVector: function(vectorContext) {
      return {
        left: Number.NEGATIVE_INFINITY,
        top: Number.NEGATIVE_INFINITY,
        right: Number.POSITIVE_INFINITY,
        bottom: Number.POSITIVE_INFINITY,
      };
    },

    /**
     * Performs a hit test on the entire set of samples
     *
     * @param {Object} vectorContext
     * @param {Object} rect
     * @returns {Boolean}
     */
    hitTestVector: function(vectorContext, rect) {
      throw GSP.createError('hitTestVector not Implemented');
    },
    getVectorRenderingLayer: function(vectorContext) {
      throw GSP.createError('getVectorRenderingLayer not Implemented');
    },
    /**
     *
     * @param {Object} vectorContext
     * @param {Number} index
     * @returns {undefined}
     */

    renderVector: function(
      drawContext,
      drawRefCon,
      renderArgs,
      vectorContext,
      parentProperties
    ) {
      throw GSP.createError('renderVector not Implemented');
    },
    prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
      throw GSP.createError('prepareVectorRendering not Implemented');
    },
    cleanupVectorRendering: function(drawContext, drawRefCon) {
      throw GSP.createError('cleanupVectorRendering not Implemented');
    },
    /**
     * Some vectors can be treated as paths, and as such, must implement the
     * following path utilities as appropriate for their path.
     */

    positionToPathValueForVector: function(vectorContext, iPosition) {
      GSP.signalErrorWithMessage('path API called on a non-path object vector');
    },
    pathLengthForVector: function(vectorContext) {
      GSP.signalErrorWithMessage('path API called on a non-path object vector');
    },
  };

  /**
   * @fileOverview pointVector is a mixin used by samplers who want to
   * draw a sampled set of points as a continuous line.  This includes continuous
   * point loci and function plots.
   *
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2013.
   */

  GSP.mixins.pointVector = GSP.makeClass(GSP.mixins.vector, {
    doc: {},
    isPathSampleGObj: true,
    createVectorContext: function(numSamples, parentSampler, colorize) {
      return {
        numSamples: numSamples,
        samples: GSP.createFloatVector(numSamples * 2),
        colors: colorize ? [] : null,
        lineWidth: parentSampler.style.width,
        radius: parentSampler.style.radius || 4, //This fixes a bug that was released in version 3.0.0
        endpointRadius: parentSampler.style.endpointRadius,
        arrowheadRadius: parentSampler.style.arrowheadRadius,
        closedPath: parentSampler.closedPath,
        isContinuous: true,
        isDiscrete:
          parentSampler.kind === 'IterateImage'
            ? true
            : parentSampler.isDiscrete,

        //A non-falsy value in discontinuities[i] means that sample i is
        //discontinuous with its previous sample. The possible true values in a
        //given item are "nonexisting" and "discontinuous."  For closed paths,
        //the item at index nunSamples specifies the continuity of the
        //wraparound segment (going from last to first)rather than the item at
        //index 0.
        discontinuities: [],
      };
    },
    fillSingleSample: function(vectorContext, index) {
      var base = 2 * index;

      vectorContext.filledSampleCount++;

      if (this.state.exists) {
        vectorContext.samples[base] = this.geom.loc.x;
        vectorContext.samples[base + 1] = this.geom.loc.y;
        if (vectorContext.colors) {
          vectorContext.colors[index] = this.style.color;
        }

        vectorContext.geomBounds = GSP.Geom.unionRectPoint(
          vectorContext.geomBounds,
          this.geom.loc
        );
      } else {
        vectorContext.samples[base] = undefined;
        vectorContext.samples[base + 1] = undefined;
      }
    },
    getGeomForSample: function(vectorContext, index) {
      var base = 2 * index;

      return {
        loc: GSP.GeometricPoint(
          vectorContext.samples[base],
          vectorContext.samples[base + 1]
        ),
      };
    },
    getGeomBoundsVector: function(vectorContext) {
      var amtToExtend = 0;

      if (vectorContext.geomBounds) {
        if (vectorContext.lineWidth) {
          amtToExtend = Math.max(amtToExtend, vectorContext.lineWidth / 2);
        }

        if (vectorContext.radius) {
          amtToExtend = Math.max(amtToExtend, vectorContext.radius);
        }

        if (vectorContext.endpointRadius) {
          amtToExtend = Math.max(amtToExtend, vectorContext.endpointRadius);
        }

        if (vectorContext.arrowheadRadius) {
          amtToExtend = Math.max(amtToExtend, vectorContext.arrowheadRadius);
        }

        return GSP.Geom.insetRect(vectorContext.geomBounds, -amtToExtend);
      }
    },
    hitTestVector: function(vectorContext, rect) {
      function hitTestDiscrete() {
        var i,
          numSamples = vectorContext.filledSampleCount,
          sampleSize = 2,
          samples = vectorContext.samples,
          radius = vectorContext.radius || vectorContext.lineWidth / 2;

        for (i = 0; i < numSamples; i++) {
          var box = {
            left: samples[i * sampleSize] - radius,
            right: samples[i * sampleSize] + radius,
            top: samples[i * sampleSize + 1] - radius,
            bottom: samples[i * sampleSize + 1] + radius,
          };

          if (
            !(
              box.right < rect.left || // box to the left of rect
              box.left > rect.right || // box to the right of rect
              box.bottom < rect.top || // box above rect
              box.top > rect.bottom
            )
          ) {
            // box below rect)

            return true;
          }
        }
        return false;
      }

      function hitTestContinuous() {
        var i,
          numItems = vectorContext.filledSampleCount * 2,
          sampleNum,
          samples = vectorContext.samples,
          firstPoint = GSP.GeometricPoint(samples[0], samples[1]),
          discontinuities = vectorContext.discontinuities,
          ptA,
          ptB;

        //start ptA at the first sample
        ptA = firstPoint;

        if (GSP.Geom.PointInRect(ptA, rect)) {
          return true;
        }

        //then, the loop starts by setting the second point
        for (i = 2, sampleNum = 1; i < numItems; i += 2, sampleNum++) {
          ptB = GSP.GeometricPoint(samples[i], samples[i + 1]);

          if (GSP.Geom.PointInRect(ptB, rect)) {
            return true;
          }

          if (
            !discontinuities[sampleNum] &&
            ptA.isFinite() &&
            ptB.isFinite() &&
            GSP.Geom.SegmentSectsRect(rect, ptA, ptB)
          ) {
            return true;
          }

          ptA = ptB;
        }

        if (
          vectorContext.closedPath &&
          !discontinuities[sampleNum] &&
          ptA.isFinite() &&
          firstPoint.isFinite() &&
          GSP.Geom.SegmentSectsRect(rect, ptA, firstPoint)
        ) {
          return true;
        }

        //Still need to think about singularities,
      }

      if (vectorContext.isDiscrete) {
        return hitTestDiscrete();
      } else {
        return hitTestContinuous();
      }
    },
    getVectorRenderingLayer: function(vectorContext) {
      if (vectorContext.isDiscrete) {
        return 'DiscretePointVectors';
      } else {
        return 'LinesCurves';
      }
    },
    prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
      if (vectorContext.isDiscrete) {
        return drawContext.prepareDiscretePointVector(renderArgs);
      } else {
        return drawContext.prepareContinuousPointVector(renderArgs);
      }
    },
    renderVector: function(
      drawContext,
      drawRefCon,
      renderArgs,
      vectorContext,
      parentProperties
    ) {
      var props = $.extend(true, {}, parentProperties);
      props.samples = vectorContext.samples;
      props.colors = props.suppressParametricColor
        ? undefined
        : vectorContext.colors;
      props.numSamples = vectorContext.filledSampleCount;
      props.radius = vectorContext.radius;

      if (vectorContext.isDiscrete) {
        return drawContext.drawDiscretePointVector(drawRefCon, props);
      } else {
        props.discontinuities = vectorContext.discontinuities;
        props.closedPath = vectorContext.closedPath;
        //ensure width is defined
        props.width = parentProperties.width || 1;
        return drawContext.drawContinuousPointVector(drawRefCon, props);
      }
    },
    cleanupVectorRendering: function(drawContext, drawRefCon, vectorContext) {
      if (vectorContext.isDiscrete) {
        return drawContext.cleanupDiscretePointVector(drawRefCon);
      } else {
        return drawContext.cleanupContinuousPointVector(drawRefCon);
      }
    },
    positionToPathValueForVector: function(iVectorContext, iPosition) {
      var samples = iVectorContext.samples,
        numSamples = iVectorContext.numSamples,
        closedPath = iVectorContext.closedPath,
        numSegments = closedPath ? numSamples : numSamples - 1,
        closestPointInfo,
        ret;

      //relies on closures:
      // numSamples
      // samples
      // iPosition
      function findClosestSampledPoint() {
        var i, distSquared, smallestDist, xDelta, yDelta, indexOfSmallest;

        for (i = 0; i < numSamples; i++) {
          if (
            !(
              GSP.math.isFiniteScalar(samples[i * 2]) &&
              GSP.math.isFiniteScalar(samples[i * 2 + 1])
            )
          ) {
            continue;
          }

          xDelta = samples[i * 2] - iPosition.x;
          yDelta = samples[i * 2 + 1] - iPosition.y;

          distSquared = xDelta * xDelta + yDelta * yDelta;

          if (smallestDist === undefined || distSquared < smallestDist) {
            smallestDist = distSquared;
            indexOfSmallest = i;
          }
        }

        return {
          point: GSP.GeometricPoint(
            samples[indexOfSmallest * 2],
            samples[indexOfSmallest * 2 + 1]
          ),
          index: indexOfSmallest,
        };
      }

      function squaredDistBetweenPts(pt1, pt2) {
        var dx = pt1.getX() - pt2.getX(),
          dy = pt1.getY() - pt2.getY();

        return dx * dx + dy * dy;
      }

      //relies on closures:
      // numSamples
      // foo
      // closestPointInfo
      // samples
      function getInterpolationAmt(iPt) {
        var closestSampledPoint = closestPointInfo.point,
          index = closestPointInfo.index,
          discontinuities = iVectorContext.discontinuities,
          singleStepParamAmt = 1 / numSegments,
          prevSampleBase,
          nextSampleBase,
          prevPt,
          nextPt,
          interpolateNext,
          interpolatePrev,
          testPt,
          tmpDist,
          discontinuityIndex,
          ret;

        testPt = iPosition.subtract(iPt);
        //Now create two vectors - one for the previous sample, normalized to
        //the position of the current one, and one for the next sample.
        if (index > 0) {
          prevSampleBase = (index - 1) * 2;
          discontinuityIndex = index;
        } else if (closedPath) {
          prevSampleBase = (numSamples - 1) * 2;
          discontinuityIndex = iVectorContext.numSamples;
        }

        if (
          prevSampleBase !== undefined &&
          !discontinuities[discontinuityIndex]
        ) {
          prevPt = GSP.GeometricPoint(
            samples[prevSampleBase],
            samples[prevSampleBase + 1]
          );

          if (prevPt.isFinite()) {
            prevPt = prevPt.subtract(closestSampledPoint);
          } else {
            prevPt = undefined;
          }
        }

        if (index < numSamples - 1) {
          nextSampleBase = (index + 1) * 2;
          discontinuityIndex = index + 1;
        } else if (closedPath) {
          nextSampleBase = 0;
          discontinuityIndex = numSamples;
        }

        if (
          nextSampleBase !== undefined &&
          !discontinuities[discontinuityIndex]
        ) {
          nextPt = GSP.GeometricPoint(
            samples[nextSampleBase],
            samples[nextSampleBase + 1]
          );

          if (nextPt.isFinite()) {
            nextPt = nextPt.subtract(closestSampledPoint);
          } else {
            nextPt = undefined;
          }
        }

        if (nextPt && prevPt) {
          //if we have both, then use the closer one
          if (
            squaredDistBetweenPts(nextPt, testPt) <
            squaredDistBetweenPts(prevPt, testPt)
          ) {
            interpolateNext = true;
          } else {
            interpolatePrev = true;
          }
          //otherwise we just use the one we have
        } else if (nextPt) {
          interpolateNext = true;
        } else if (prevPt) {
          interpolatePrev = true;
        }

        //Now interpoiate the distance
        if (interpolateNext) {
          tmpDist = nextPt.vLength2();

          if (tmpDist) {
            ret = nextPt.dot(testPt) / nextPt.vLength2();
            ret = Math.min(Math.max(0, ret), 1);
          }
        } else if (interpolatePrev) {
          tmpDist = prevPt.vLength2();

          if (tmpDist) {
            //negative since we're going to interpolate toward the previous sample
            ret = -prevPt.dot(testPt) / prevPt.vLength2();
            ret = Math.min(Math.max(-1, ret), 0);
          }
        }

        //convert falsy rets into 0
        ret = ret ? ret : 0;

        return ret * singleStepParamAmt;
      }

      //first find the closest sample
      closestPointInfo = findClosestSampledPoint();

      ret =
        closestPointInfo.index / numSegments +
        getInterpolationAmt(closestPointInfo.point);

      if (ret < 0) {
        ret += 1;
      }

      return ret;
    },
    pathLengthForVector: function(iVectorContext) {
      var total = 0,
        i,
        samples = iVectorContext.samples,
        numSamples = iVectorContext.numSamples,
        thisSampleX,
        thisSampleY,
        prevSampleX = samples[0],
        prevSampleY = samples[1],
        dx,
        dy;

      for (i = 1; i < numSamples; i++) {
        thisSampleX = samples[2 * i];
        thisSampleY = samples[2 * i + 1];

        if (
          !(
            GSP.math.isFiniteScalar(thisSampleX) &&
            GSP.math.isFiniteScalar(thisSampleY)
          )
        ) {
          continue;
        }
        dx = thisSampleX - prevSampleX;
        dy = thisSampleY - prevSampleY;

        total += Math.sqrt(dx * dx + dy * dy);

        prevSampleX = thisSampleX;
        prevSampleY = thisSampleY;
      }

      return total;
    },
    /**
        Returns true if there appears to be a discontinuity at the given
        point, false otherwise. Currently uses the GSP5 discontinuity
        detection algorithm.
        @param    {Number}  dx -- the change in x since the previous point (delta x)
        @param    {Number}  dy -- the change in y since the previous point (delta y)
        @param    {Number}  dxPrev -- the previous point's delta x
        @param    {Number}  dyPrev -- the previous point's delta y
        @returns  {Boolean} True if a discontinuity is detected at the current point
       */
    isDiscontinuous: function(dx, dy, dxPrev, dyPrev) {
      var adx = dx < 0 ? -dx : dx,
        ady = dy < 0 ? -dy : dy,
        adxPrev = dxPrev < 0 ? -dxPrev : dxPrev,
        adyPrev = dyPrev < 0 ? -dyPrev : dyPrev,
        CONST_TOLERANCE = 25;

      //The following tests come from the SAMPLE_IS_NOT_CONTINUOUS_TO_PREVIOUS()
      //macro that preceded the call to NonContinuous().  Some of the tests are
      //close to being redundant.  The idea behind this code in the desktop is to
      //do some quick, cheap tests first to find the majority of the 'clearly'
      //continuous samples.  To port this logic, we reverse the polarity of the test
      //and return false if the test fails
      if (
        !(
          (adx > CONST_TOLERANCE &&
            ((dx > 0 && dxPrev <= 0) ||
              (dx < 0 && dxPrev >= 0) ||
              (adxPrev > 0 && adxPrev * 8 < adx))) ||
          (ady > CONST_TOLERANCE &&
            ((dy > 0 && dyPrev <= 0) ||
              (dy < 0 && dyPrev >= 0) ||
              (adyPrev > 0 && adyPrev * 8 < ady)))
        )
      ) {
        return false;
      }

      // If either the x or y delta is 10 times the previous value,
      // the current big jump is almost certainly a discontinuity.
      if (
        (adxPrev !== 0 && adx > 10 * adxPrev) ||
        (adyPrev !== 0 && ady > 10 * adyPrev)
      ) {
        return true;
      }
      // If the previous deltaX and deltaY were both zero,
      // the current big jump is almost certainly a discontinuity.
      if (adxPrev === 0 && adyPrev === 0) {
        return true;
      }
      // Treat sharp angles between neighboring segments as discontinuous.
      // See discussion in the NonContinuous function in locus.c.
      var xDist = dx * dxPrev + dy * dyPrev,
        yDist = dy * dxPrev - dx * dyPrev;
      yDist = yDist < 0 ? -yDist : yDist;
      return xDist < 0 || 3 * yDist > 5 * xDist;
    },
    /**
     * returns an array of booleans to denote discontinuities
     * based on iVectorContext's samples.  If samples[i] is discontinuous with
     * its previous sample, then discontinuities[i] = true.  Otherwise, it's false.
     *
     * See PostProcessPointsThreadProc() in locus.c for the original algorithm.
     *
     */
    recomputeDiscontinuities: function(iVectorContext) {
      if (iVectorContext.isDiscrete) {
        //Only continuous point vectors need to compute this
        return;
      }

      var samples = iVectorContext.samples,
        numSamples = iVectorContext.numSamples,
        discontinuities = [],
        x,
        y,
        dx,
        dy,
        xPrev,
        yPrev,
        dxPrev,
        dyPrev,
        ix,
        isDefined,
        prevWasDefined = false;

      for (ix = 0; ix < numSamples; ++ix) {
        x = samples[2 * ix];
        y = samples[2 * ix + 1];

        isDefined = !(isNaN(x) || isNaN(y));

        if (isDefined) {
          if (prevWasDefined) {
            dx = x - xPrev;
            dy = y - yPrev;

            if (this.isDiscontinuous(dx, dy, dxPrev, dyPrev)) {
              discontinuities[ix] = 'discontinuous';
            } else {
              discontinuities[ix] = false;
              if (
                discontinuities[ix - 1] !== 'nonexisting' &&
                !this.isDiscontinuous(dxPrev, dyPrev, dx, dy)
              ) {
                discontinuities[ix - 1] = false;
              } else {
                discontinuities[ix - 1] = 'discontinuous';
              }
            }
            dxPrev = dx;
            dyPrev = dy;
          } else {
            dxPrev = 0;
            dyPrev = 0;
          }
          prevWasDefined = true;
          xPrev = x;
          yPrev = y;
        } else {
          discontinuities[ix] = 'nonexisting';
          prevWasDefined = false;
          dxPrev = 0;
          dyPrev = 0;
        }
      }

      if (iVectorContext.closedPath) {
        x = samples[0];
        y = samples[1];

        if (!(isNaN(x) || isNaN(y)) && prevWasDefined) {
          dx = x - xPrev;
          dy = y - yPrev;
          discontinuities[ix] = this.isDiscontinuous(dx, dy, dxPrev, dyPrev);
        }
      }

      iVectorContext.discontinuities = discontinuities;
    },
  });

  /**
   * @fileOverview circleVector is a mixin used by both circle and circle interior
   * vector kinds.
   *
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2013.
   */

  GSP.mixins.circleVector = GSP.makeClass(GSP.mixins.vector, {
    doc: {},
    createVectorContext: function(numSamples, parentSampler, colorize) {
      var isInterior = this.kind === 'CircleInterior';

      return {
        numSamples: numSamples,
        samples: GSP.createFloatVector(numSamples * 3),
        colors: colorize ? [] : null,
        isInterior: isInterior,
        lineWidth: isInterior ? undefined : parentSampler.style.width,
      };
    },
    fillSingleSample: function(vectorContext, index) {
      var base = 3 * index;

      vectorContext.filledSampleCount++;

      vectorContext.samples[base] = this.geom.c.x;
      vectorContext.samples[base + 1] = this.geom.c.y;
      vectorContext.samples[base + 2] = this.geom.r;

      if (vectorContext.colors) {
        vectorContext.colors[index] = this.style.color;
      }
      vectorContext.geomBounds = GSP.Geom.unionRects(
        vectorContext.geomBounds,
        GSP.Geom.insetRect(
          {
            left: this.geom.c.x,
            top: this.geom.c.y,
            right: this.geom.c.x,
            bottom: this.geom.c.y,
          },
          -this.geom.r
        )
      );
    },
    getGeomBoundsVector: function(vectorContext) {
      var amtToExtend = 0;
      if (vectorContext.geomBounds) {
        if (vectorContext.lineWidth) {
          amtToExtend = vectorContext.lineWidth / 2;
        }

        return GSP.Geom.insetRect(vectorContext.geomBounds, -amtToExtend);
      }
    },
    hitTestVector: function(vectorContext, rect) {
      var i,
        stride = 3,
        samples = vectorContext.samples,
        numSamples = vectorContext.filledSampleCount,
        isInterior = vectorContext.isInterior,
        base,
        c,
        centerX,
        centerY,
        radius;

      for (i = 0; i < numSamples; i++) {
        base = i * stride;
        centerX = samples[base];
        centerY = samples[base + 1];
        radius = samples[base + 2];
        c = GSP.GeometricPoint(centerX, centerY);

        if (
          GSP.Geom.RectIntersectsCurve(rect, {
            type: isInterior ? 'circleInterior' : 'circle',
            curve: GSP.GeometricArc.FromCenterAndRadius(c, radius),
          })
        ) {
          return true;
        }
      }

      return false;
    },
    getVectorRenderingLayer: function(vectorContext) {
      return vectorContext.isInterior
        ? 'ExternalImagesAndInteriors'
        : 'LineLoci';
    },

    prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
      return drawContext.prepareCircleVector(renderArgs);
    },
    renderVector: function(
      drawContext,
      drawRefCon,
      renderArgs,
      vectorContext,
      parentProperties
    ) {
      var props = $.extend(true, {}, parentProperties);
      props.samples = vectorContext.samples;
      props.colors = vectorContext.colors;
      props.isInterior = vectorContext.isInterior;
      props.numSamples = vectorContext.filledSampleCount;

      return drawContext.drawCircleVector(drawRefCon, props);
    },
    cleanupVectorRendering: function(drawContext, drawRefCon) {
      return drawContext.cleanupCircleVector(drawRefCon);
    },
  });

  /**
   * @fileOverview arcVector is a mixin used by both arc and arc interior
   * vector kinds.
   *
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2013.
   */

  GSP.mixins.arcVector = GSP.makeClass(GSP.mixins.vector, {
    doc: {},
    createVectorContext: function(numSamples, parentSampler, colorize) {
      var type;

      switch (this.genus) {
        case 'SimpleArc':
          type = 'arc';
          break;
        case 'ArcSector':
          type = 'arcSector';
          break;
        case 'ArcSegment':
          type = 'arcSegment';
          break;
      }

      return {
        numSamples: numSamples,
        samples: GSP.createFloatVector(
          numSamples * GSP.GeometricArc.packedSampleSize
        ),
        colors: colorize ? [] : null,
        lineWidth: parentSampler.style.width,
        isInterior: this.genus !== 'SimpleArc',
        type: type,
      };
    },
    fillSingleSample: function(vectorContext, index) {
      var arc = this.geom.arc;

      arc.packIntoSampleArray(vectorContext.samples, index);

      vectorContext.filledSampleCount++;

      if (vectorContext.colors) {
        vectorContext.colors[index] = this.style.color;
      }
      vectorContext.geomBounds = GSP.Geom.unionRects(
        vectorContext.geomBounds,
        this.getGeomBounds()
      );
    },
    getGeomBoundsVector: function(vectorContext) {
      var amtToExtend = 1.5; //start with a modest slop factor

      if (vectorContext.geomBounds) {
        if (vectorContext.lineWidth) {
          amtToExtend += vectorContext.lineWidth / 2;
        }

        return GSP.Geom.insetRect(vectorContext.geomBounds, -amtToExtend);
      }
    },
    hitTestVector: function(vectorContext, rect) {
      var i,
        arc,
        samples = vectorContext.samples,
        numSamples = vectorContext.filledSampleCount,
        type = vectorContext.type;

      for (i = 0; i < numSamples; i++) {
        arc = GSP.GeometricArc.FromPackedSampleArray(samples, i);
        if (GSP.Geom.RectIntersectsCurve(rect, { type: type, curve: arc })) {
          return true;
        }
      }

      return false;
    },
    getVectorRenderingLayer: function(vectorContext) {
      return vectorContext.isInterior
        ? 'ExternalImagesAndInteriors'
        : 'LineLoci';
    },

    prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
      return drawContext.prepareArcVector(renderArgs);
    },
    renderVector: function(
      drawContext,
      drawRefCon,
      renderArgs,
      vectorContext,
      parentProperties
    ) {
      var props = $.extend(true, {}, parentProperties);
      props.samples = vectorContext.samples;
      props.colors = vectorContext.colors;
      props.arcType = vectorContext.type;
      props.numSamples = vectorContext.filledSampleCount;

      return drawContext.drawArcVector(drawRefCon, props);
    },
    cleanupVectorRendering: function(drawContext, drawRefCon) {
      return drawContext.cleanupArcVector(drawRefCon);
    },
  });

  /**
   * @fileOverview abstract base class for touch trackers
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  /*
   * TouchManager provides mechanism for tracking touches in a sketch.  A touch
   * gets paired with a touch tracker, using its id as a key.
   */
  GSP.TouchManager = (function() {
    var knownTouches = {};

    return {
      /* Register the touch with the given id with the passed in tracker
       *
       * @param {type} id - touch identifier
       * @returns {undefined}
       */
      registerTouchWithTracker: function(id, tracker) {
        knownTouches[id] = tracker;
      },

      /* Returns the tracker for the specified touch.  Returns undefined if there
       * is no tracker or the touch is unknown to the touchManager
       *
       * @param {type} id
       * @returns {Boolean} true if the touch is registered
       */
      trackerForTouch: function(id) {
        return knownTouches[id];
      },
      /* Remove this touch from the set of known touches.
       *
       * @param {type} id
       * @returns {unresolved}
       */
      deregisterTouch: function(id) {
        knownTouches[id] = undefined;
      },
    };
  })();

  /**
   * @fileOverview abstract base class for touch regimes
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  /*
   * A touch regime is an abstract class/protocol whose job it is is to generate
   * an appropriate TouchTracker object for a given touch at a given position.
   * An implementer of a touch regime is responsible for harvesting all of the state
   * needed to make this decision when the regime is created (note: creation
   * of the regime is not specified in this class)
   */
  GSP.TouchRegime = (function() {
    return {
      /**
       * When a touch regime is popped by the sketch, if it has a delegate, the delegate will
       * be sent the following optional notification:
       * -regimeDidPop(regime)
       *
       * This gives a client a way of knowing when the regime will be dismissed and cleaning itself up.
       */
      delegate: null,

      /**
       * when isPushed is true, this regime has been added to the touch regime stack.
       *
       * Read-only - should only be set by the regime manager (currently the Sketch)
       */
      isPushed: false,

      blocksOtherButtons: function() {
        return false;
      },

      /*
       * Returns a tracker for the given touch/position.  Can return undefined if
       * no tracker is appropriate for the given touch.
       */
      createTracker: function(touch, position) {
        throw GSP.createError('Unimplemented required method: createTracker');
      },
      /*
       * Given a touch event, determine a decent amount of slop to use
       * for hit testing.
       */
      hitSlopForTouch: function(touch) {
        // If there's a mouse event, we can use less slop.
        return touch.mouseEvent !== undefined ? 5 : 15;
      },
    };
  })();

  /**
   * @fileOverview abstract base class for touch trackers
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  /*
   * A touch tracker is an object that handles a touch throughout the life of the touch.
   */
  GSP.TouchTracker = {
    touchBegan: function(pos, touch) {},
    touchMoved: function(pos, touch) {},
    touchEnded: function(pos, touch) {},
    //TODO: Currently this is unused, but probably should be
    touchCancelled: function(pos, touch) {},
  };

  (function() {
    // For taps, keep track of two special cases: double taps on an object, and repeated taps to cycle through overlapping objects of the same kind
    var firstTap = null, // The first tap of a possible double-tap: report it as a double-tap if it's on the same object and close enough in time.
      prevTap = null, // The previous tap: if it includes both the same object as the current tap and other overlapping objects of the same kind, cycle through those objects.
      // A double tap on overlapping objects results in all three interpretations: isTap() and isDoubleTap() both return true, and the object returned is the next one of the overlapped objects.
      /**
       * The maximum length of time a touch can remain down and still be
       * a tap gesture
       */
      tapTouchTime = 500,
      /**
       * The maximum period of time between two taps for them to
       * be considered part of a double tap gesture
       */
      betweenTapsTime = 500;

    GSP.TapTracker = {
      startTime: null,
      endTime: null,
      kMaxTapMovement: 5, // Max distance a tap can stray in any direction
      tapState: '',

      checkTapState: function(pos) {
        // it's rejected if it moved too far or stayed down too long
        // it's confirmed if it didn't move too far and came up
        var expired = Date.now() - this.startTime > tapTouchTime,
          tooFar = this.distanceMoved(pos) > this.kMaxTapMovement;
        if (this.tapState === 'potential') {
          if (expired || tooFar) {
            this.tapState = 'rejected';
          } else if (
            this.endTime &&
            this.endTime - this.startTime <= tapTouchTime
          ) {
            this.tapState = 'confirmed';
          }
        }
        return this.tapState;
      },

      isTap: function(pos) {
        if (this.tapState === 'potential') {
          this.checkTapState(pos);
        }
        return this.tapState === 'confirmed';
      },

      registerAsPossibleDoubleTap: function() {
        // Consider whether this might be the second tap of a double
        if (
          firstTap &&
          firstTap.endTime &&
          !firstTap.maybeDouble &&
          firstTap.isTap() &&
          this.startTime - firstTap.endTime < betweenTapsTime
        ) {
          this.maybeDouble = true;
        }
        firstTap = this;
      },
      isDoubleTap: function(pos) {
        if (this.maybeDouble && this.isTap(pos)) {
          firstTap = null;
          return true;
        }
        return false;
      },

      currentOverlapChoice: function(theGobjArr) {
        // Allows a dragTracker to drag the most recently designated object in the overlap group.
        if (
          prevTap &&
          prevTap.gobj &&
          theGobjArr.indexOf(prevTap.gobj) >= 0 &&
          prevTap.gobj.kind === theGobjArr[0].kind
        )
          return prevTap.gobj;
        else return theGobjArr[0];
      },

      checkForOverlapCycleTap: function(pos) {
        // Called in touchEnded() to see if this might be a tap or drag on overlapping objects that we ought to cycle through
        var ix,
          gobjKind = this.gobjArr[0].kind;
        this.gobj = this.gobjArr[0]; // default choice if nothing else works
        if (
          prevTap &&
          (ix = this.gobjArr.indexOf(prevTap.gobj)) >= 0 &&
          prevTap.gobj.kind === gobjKind
        ) {
          // is prevTap.gobj in this tap's gobjArr?
          if (this.isTap(pos)) ix += 1; // Advance the cycle only if this is a tap and the new target is the same kind
          if (ix < this.gobjArr.length && this.gobjArr[ix].kind === gobjKind)
            this.gobj = this.gobjArr[ix]; // if ix == length, the default will be gobjArr[0].
        }
        prevTap = this; // Remember this tap as the new starting place in an overlap cycle
      },
    };
  })();

  (function() {
    // If the touch wanders farther than this, it's a drag, not a long press.
    var kLongPressPixelSensitivity = 0,
      kLongPressDelay = 3000;

    // Just enough of a controller to manage a regime + undo/redo
    var Controller = function() {};

    Controller.prototype.showModal = function(sketch, gobj) {
      var regime,
        controller = this;
      controller.sketch = sketch;
      controller.preToolDelta = sketch.document.getRecentChangesDelta();
      regime = GSP.LabelRegime.createForGObject(sketch, gobj);
      regime.delegate = controller;
      sketch.pushTouchRegime(regime);
      sketch.document.changedUIMode();
      regime.confirmActiveTool(function(sketchWasModified) {
        if (sketchWasModified) {
          sketch.document.pushConfirmedSketchOpDelta(controller.preToolDelta);
        }
        // invokes controller.regimeDidPop
        sketch.popAllTouchRegimesIncluding(regime);
      });
    };

    Controller.prototype.regimeDidPop = function(regime) {
      this.sketch.document.changedUIMode();
    };

    GSP.LongPressTracker = {
      // If this is set to false, then the touch is done. Communicates
      // between long press and drag machinery.
      touchIsInProgress: true,
      // max displacement of the current touch from its origin
      maxDisplacement: 0,

      trackMaxDisplacement: function() {
        var dist = Math.max(
          Math.abs(this.lastX - this.origX),
          Math.abs(this.lastY - this.origY)
        );
        this.maxDisplacement = Math.max(this.maxDisplacement, dist);
      },

      startLongPressJob: function() {
        var gobj = this.gobj,
          sketch = this.sketch,
          self = this;

        if (
          !gobj.canEditLabel() ||
          !sketch.getAuthorPreference('enablelabelediting')
        )
          return; // wait forever for a drag

        function checkForLongPress() {
          if (
            !self.touchIsInProgress ||
            self.maxDisplacement > kLongPressPixelSensitivity
          )
            return;

          // It's a long press!
          self.touchIsInProgress = false;
          new Controller().showModal(sketch, gobj);
        }

        sketch.jobScheduler.addJob(checkForLongPress, {
          delay: kLongPressDelay,
        });
      },
    };
  })();

  /**
   * Click Tracker is a general purpose tracker for tracking a click on a html element, analogous to
   * the dom event 'click' handler, but works within our touch tracking/regime framework.
   * Trying to attach new dom events handlers to elements within the sketch canvas outside of the
   * regime framework can cause event handling chaos.
   *
   * Clients create one with an element and a handler to be executed when the click completes.
   * It is assumed by the module that the touch went down on the element when the tracker was created,
   * but if different behavior is desired, clients can override touchBegan() or touchMoved()
   */
  (function() {
    var hitElementTrackerProto = GSP.makeClass([GSP.TouchTracker], {
      touchEnded: function(pos) {
        if (GSP.positionInElement(pos, this.element)) {
          if (this.clickHandler) this.clickHandler(pos);
        }
      },
    });

    GSP.ClickTracker = {
      createOnElement: function(element, clickHandler) {
        var tracker = Object.create(hitElementTrackerProto);
        tracker.element = element;
        tracker.clickHandler = clickHandler;
        return tracker;
      },
    };
  })();

  /**
   * A HotTextTracker tracks a touch as it interacts with with DOM-element
   * of a caption. It handles highlighting as the touch drifts over a "hot"
   * reference to another gobject, and triggering the correct feedback / actions
   * elsewhere in the sketch.
   */

  (function() {
    var hotTextTrackerProto = GSP.makeClass([GSP.TouchTracker], {
      setDriftRenderState: function(pos, turnOn) {
        var hitGObj;
        var sQ = this.sQ();

        // First, hit test the refs, setting their state, and track the hit
        this.hotTextRefs.each(function() {
          var id = $(this).data('wsp-mfs-reference-id');
          var isHit = false;
          if (!hitGObj && GSP.positionInElement(pos, $(this))) {
            isHit = true;
            hitGObj = sQ.get(id);
          }
          $(this).toggleClass('wsp-mfs-reference-hot', isHit && turnOn);
        });

        // Now make sure the actual gobjects have the right render-state.
        this.hotTextRefs.each(function() {
          var id = $(this).data('wsp-mfs-reference-id');
          var gobj = sQ.get(id);
          var renderState = turnOn && gobj === hitGObj ? 'hotTarget' : 'none';
          if (gobj.state.renderState !== renderState) {
            gobj.setRenderState(renderState);
          }
        });

        return hitGObj;
      },
      touchBegan: function(pos) {
        this.element.toggleClass('wsp-mfs-reference-tracking', true);
        this.setDriftRenderState(pos, true);
      },
      touchMoved: function(pos) {
        this.setDriftRenderState(pos, true);
      },
      touchEnded: function(pos) {
        var gobj = this.setDriftRenderState(pos, false);
        this.element.toggleClass('wsp-mfs-reference-tracking', false);
        if (gobj && gobj.press) {
          gobj.press(this.sQ.sketch);
        }
      },
    });

    GSP.HotTextTracker = {
      /* Which reference did we hit? */
      referenceIsHit: function(pos, hotTextRefs) {
        var hitRef;
        hotTextRefs.each(function() {
          if (GSP.positionInElement(pos, $(this))) {
            hitRef = $(this);
            return false;
          }
        });
        return hitRef;
      },
      /* Build a tracker on an element, set of DOM ref children, and an sQuery instance */
      createOnElement: function(element, hotTextRefs, sQ) {
        var tracker = Object.create(hotTextTrackerProto);
        tracker.element = element;
        tracker.hotTextRefs = hotTextRefs;
        tracker.sQ = sQ;
        return tracker;
      },
    };
  })();

  (function() {
    GSP.AbstractToolTracker = GSP.makeClass(GSP.TouchTracker, {
      regime: null,
      dragTracker: null,
      possibleTargets: null,

      shouldSnap: function() {
        throw GSP.createError('shouldSnap not implemented');
      },

      findToolTarget: function(sketch, pos) {
        var perimetersOnly =
            !this.matchedGiven || this.matchedGiven.given.kind === 'Point',
          newToolTarget,
          snapCoordSys;

        // snap to grid happens later (in
        // motionmanager:ApplyTransformToControlList()), so we need to
        // be ready. If there's a merge candidate right here, then
        // cancel that future snap.
        newToolTarget = this.regime.findHitGObj(
          sketch,
          this.possibleTargets,
          pos,
          this.hitSlop,
          { interiorsPerimeterOnly: perimetersOnly }
        ).hitGObj;
        if (newToolTarget) {
          this.dragTracker.snappingPoints = false;
        } else {
          this.dragTracker.snappingPoints = true;
          if (
            this.shouldSnap() &&
            sketch.preferences.snapToGrid &&
            (snapCoordSys = sketch.findExistingCoordSys()) &&
            snapCoordSys.state.exists
          ) {
            // We will be snapping, so we want to look for merge
            // candidates where the matchedGiven will end up rather than
            // the current touch position.
            snapCoordSys.snapPoint(pos);
          }

          newToolTarget = this.regime.findHitGObj(
            sketch,
            this.possibleTargets,
            pos,
            this.hitSlop,
            { interiorsPerimeterOnly: perimetersOnly }
          ).hitGObj;
        }
        return newToolTarget;
      },
    });
  })();
  /**
   * NumpadEditRegime is the regime in place while a numpad is up, editing a parameter.
   * It's only function is to move the cursor within the edit box, or pop out of number edit
   * if a touch goes down elsewhere in the sketch.
   *
   * This module it pretty tighly coupled with knowledge of parameter expression kinds and their
   * dom structure.
   */
  (function() {
    var editSessionTrackerProto = GSP.makeClass([GSP.TouchTracker], {
      //It would be easy to improve edit box selection behavior by handling
      //touchBegan and touchMoved, and perhaps handling doubleClick, etc.
      touchEnded: function(pos, touch) {
        this.controller.click(touch, this.gobj);
      },
    });

    var numpadRegimeProto = GSP.makeClass(GSP.TouchRegime, {
      createTracker: function(touch, pos) {
        var tracker;
        var sketch = this.gobj.sQuery.sketch;

        if (this.gobj.positionInEditBox(pos)) {
          tracker = Object.create(editSessionTrackerProto);
          tracker.gobj = this.gobj;
          tracker.controller = this.controller;
        } else {
          //Outside of edit box - pop the regime and let the touch die.
          sketch.popAllTouchRegimesIncluding(this);
          GSP.blurDocumentActiveElement(sketch.baseNode);
          tracker = undefined;
        }

        return tracker;
      },
    });

    GSP.NumpadEditRegime = {
      createWithGObj: function(gobj) {
        var element = gobj.sQuery.sketch.getDisplayObjForGObj(gobj).element;
        var controller = $('.mfs-input', element).data('wsp-numfield-ctl');
        var regime = Object.create(numpadRegimeProto);

        regime.controller = controller;
        regime.gobj = gobj;

        return regime;
      },
    };
  })();

  /**
   * @fileOverview Main sketch interaction (Arrow tool) regime for handling touches
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  /*
   * The Display regime is roughly equivalent to the arrow tool in desktop sketchpad
   * Clicks on objects drag them.  Clicks in whitespace scroll, and clicks on certain
   * objects (buttons, parameter edit boxes, etc) have custom behavior.
   */
  GSP.DisplayRegime = (function() {
    var proto = GSP.makeClass(GSP.TouchRegime, {
      sketch: null,
      name: 'DisplayRegime',
      // unselectableTap: false,  // if true, report taps on unselectable objects
      // REMOVE THIS FROM PROTO; IT WILL BE CREATED IN THE INSTANCE.

      allowUnselectableTap: function(active) {
        this.unselectableTap = active;
      },

      createTracker: function(touch, pos) {
        var hitSlop,
          hitTest,
          gobjs,
          topGobj,
          sloppyRect,
          tidyRect, // rects for gobj, label hit testing
          kMaxResults = 1000, // max # of hittable GObjs
          labelDraggingEnabled,
          labeledGobj,
          options;

        labelDraggingEnabled = this.sketch.getAuthorPreference(
          'enableLabelDragging'
        );
        hitSlop = this.hitSlopForTouch(touch);
        sloppyRect = {
          left: pos.x - hitSlop,
          top: pos.y - hitSlop,
          bottom: pos.y + hitSlop,
          right: pos.x + hitSlop,
        };
        tidyRect = { left: pos.x, top: pos.y, bottom: pos.y, right: pos.x };

        hitTest = this.sketch.hitGObj(sloppyRect, {
          hotSpot: pos,
          maxResults: kMaxResults,
          unselectableTapOK: this.unselectableTap,
        });
        gobjs = hitTest.hitArray;
        // Prevent a hit on a draggable label if there's a point, a button, or a parameter on top of the label.
        if (
          gobjs.length > 0 &&
          labelDraggingEnabled &&
          GSP.Geom.isIntersectRects(tidyRect, gobjs[0].getGeomBounds()) &&
          (gobjs[0].kind === 'Point' ||
            gobjs[0].kind === 'Button' ||
            gobjs[0].isOfKind('Measure'))
        )
          topGobj = gobjs[0]; // A topGobj takes precedence over a label

        GSP.blurDocumentActiveElement(this.sketch.baseNode);

        /*	Test for a label hit first, but make sure the hit is a tight
         *  match. Avoids an ugly situation on mobile where the user
         *  can't drag a label, because the point or whatever is grabbing
         *  the touch. This is still not perfect, though, because
         *  sometimes, if the label is close to the gobj, the label gets
         *  hit, even though the touch is closer to the gobj than to the
         *  label. This can usually (always?) be remedied by moving the
         *  touch a bit.
         */

        /*
      SS: Not "always", and not even possible in the case of a label that
      overlaps a point or that underlies the full extent of a button or parameter.
      In such cases the point becomes undraggable, the button cannot be pressed,
      and the parameter cannot be dragged or edited.
      Though larger objects like buttons or parameters are unlikely to be
      commpletely blocked by a label, they sit on top of labels,
      so the user finds it very confusing to have the label hit
      instead of the button or parameter.
      For this reason we give points, buttons, and measures
      (using measures rather than testing explicitly for parameters)
      precedence over labels.
  */

        labeledGobj = labelDraggingEnabled && this.sketch.hitLabel(tidyRect);
        if (labeledGobj && !topGobj)
          return GSP.LabelDragTracker.create(labeledGobj);
        else {
          if (gobjs.length) {
            options = this.unselectableTap
              ? { unselectableTap: this.unselectableTap }
              : {};
            return (
              hitTest.customTracker ||
              GSP.DragTracker.createPotentialLongPress(gobjs, options)
            );
          }
          // Returns a scroll tracker, or undefined if there's no tracker to
          // be had.
          return this.sketch.getAuthorPreference('disableScrolling')
            ? undefined
            : this.sketch.Scroll.createTracker();
        }
      },
    });

    return {
      createInSketch: function(sketch) {
        var newInstance = Object.create(proto);
        newInstance.sketch = sketch;
        return newInstance;
      },
    };
  })();

  /* A DragMergeTracker keeps track of a normal drag and determines whether the drag is an attempt
   * to merge the dragged object to another sketch object.
   * A dragMergeTracker is active only during a drag of an independent point or a parameter.
   * It's a state machine with 5 states, two of which are terminal.Here are the states and their transitions:
   * Probe: the user is dragging an eligible gobj. (This is the initial state.)
   *    touchEnded: transition to Drop Gobj
   *    touch Candidate: transition to Pause
   * Pause: the user has moved over a candidate. (Timeout occurs after about 0.5sec.)
   *    touchEnded: transition to Drop Gobj.
   *    moved: transition to Probe
   *    timed out: transition to Pre-Merge
   * Pre-Merge: the dragged gobj glows to show it's ready to be merged
   *    touchEnded: transition to Merge
   *    moved: transition to Probe
   *    timed out: transition to Probe
   * Drop Gobj (terminal): The touch has ended, so drop the gobj in its current location
   * Merge Gobj (terminal): Merge the gobj to the current candidate.
   */

  (function() {
    // Private variables and functions here
    var kPauseTime = 1500, // The Pause state times out after this many milliseconds.
      kPreMergeTime = 3000; // The Pre-Merge state timeout.

    GSP.DragMergeTracker = {
      // Track this touch for a possible drag-merge operation.

      //showDebugInfo: function (text, hit) {  // Debugging only, to support console.log calls
      //
      //  function info (gobj) {
      //    var retVal = " ";
      //    if (gobj) {
      //      retVal += gobj.constraint + " " + (gobj.label ? gobj.label : "") + "#" + gobj.id;
      //    } else {
      //      retVal += gobj;
      //    }
      //    return retVal;
      //  }
      //
      //  if (!hit)
      //    text += " " + hit;
      //  else if (hit.id)
      //    text += info (hit);
      //  else if (hit.constraint.match (/intersection/i)) {
      //    text += "Intersection of" + info (hit.path1) + info (hit.path2);
      //  } else {
      //    text += " unknown";
      //  }
      //  console.log (text);
      //},

      setHighlights: function(turnOn) {
        var lighting = turnOn ? 'targetHighlit' : 'none',
          target = this.dmCurProxy;
        if (target) {
          this.gobj.setRenderState(turnOn ? 'unmatchedGiven' : 'none'); // turn glowing on/off
          if (target.style)
            // is target a gobj?
            target.setRenderState(lighting);
          if (target.path1) {
            target.path1.setRenderState(lighting);
            target.path2.setRenderState(lighting);
          }
        }
      },

      clearTimers: function() {
        if (this.dmTimer1) {
          clearTimeout(this.dmTimer1);
          //console.log ("Pause timer cleared.");
        }
        this.dmTimer1 = undefined;
        if (this.dmTimer2) {
          clearTimeout(this.dmTimer2);
          //console.log ("PreMerge timer cleared.");
        }
        this.dmTimer2 = undefined;
      },

      registerAsPossibleMerge: function(touch) {
        // this.gobj is the object to be mwerged (only free points and parameters are allowed)
        // dmCandidates is an array of possible candidates; each item has a candidate and a proxy.
        // For a point gobj candidates, the proxy is the candidate.
        // For a parameter gobj's candidates, include any object that references an eligible value.
        // Thus a parameter may appear to be merged to a composite text proxy, while the actual merge
        // takes place (behind the scenes) to the value referenced by the text (the actual candidate).
        var self = this,
          kind = this.gobj.kind,
          arr = [],
          canUndo = this.sketch.anchorNode
            .parent()
            .find('.wsp-undo-button')
            .is(':visible');

        function pushCandidate(candidate, proxy) {
          arr.push({ candidate: candidate, proxy: proxy });
        }

        function addGobjs(gobjs) {
          gobjs.each(function() {
            pushCandidate(this, this); // Proxy and candidate are the same.
          });
        }

        function addPaths(sq) {
          sq('*').each(function() {
            if (this.isAPath()) pushCandidate(this, this);
          });
        }

        function addValues(gobj) {
          gobj.sQuery('*').each(function() {
            var candidate = gobj.getLegalMatchForParam(this);
            if (candidate) pushCandidate(candidate, this);
          });
        }

        function prune(gobj, arr) {
          // prune hiddens, gobj and its descendants from arr
          var ix;
          for (ix = 0; ix < arr.length; ix++) {
            // remove gobj and hiddens
            if (arr[ix].proxy.style.hidden || arr[ix].candidate === gobj) {
              arr.splice(ix, 1);
              ix--;
            }
          }
          gobj.eachDescendant(function(i, g) {
            // check gobj and each descendant of gobj
            for (ix = 0; ix < arr.length; ix++) {
              // if it's a candidate, remove it.
              if (arr[ix].candidate === g) arr.splice(ix, 1);
            }
          });
        }

        // Drag merging is allowed ONLY its pref is true (the default) AND it can be undone
        if (
          !(this.sketch.getAuthorPreference('enableDragMerging') && canUndo)
        ) {
          return false;
        }

        this.dmState = 'Probe'; // the array of possible candidates
        this.dmCandidates = []; // Candidates to which the gobj can be merged. Each item has a proxy and
        // its candidate. Proxies are unique (and parallel to dmProxies);
        // different proxies may link to the same candidate.
        this.dmProxies = []; // e.g., composite text with a value parent to which gobj can be merged.
        // Composite text qualifies as a proxy only (1) if its units match the candidate and
        // (2) it refers to only a single matching candidate.
        // For a point gobj, the proxy is always the candidate (point or path) itself.
        arr = this.dmCandidates;
        this.dmCurProxy = null;
        this.dmTimer1 = undefined;
        this.dmTimer2 = undefined;
        this.dmHitSlop = null;
        this.dmPreDelta = null;
        if (
          this.gobj.constraint !== 'Free' ||
          this.sketch.currentTouchRegime().name !== 'DisplayRegime'
        ) {
          return false;
        }
        if (kind === 'Point') {
          // hitGObj runs this array in reverse, so prefer points by putting them last
          addPaths(this.gobj.sQuery, arr);
          addGobjs(this.gobj.sQuery(kind), arr);
        } else if (this.gobj.isParameter && this.gobj.isParameter()) {
          addValues(this.gobj, arr);
        } else {
          // console.log ("#", this.gobj.id, " is ineligible: neither a point nor a parameter.");
          return false;
        }
        prune(this.gobj, arr);
        if (arr.length === 0) {
          return false;
        }
        // this.gobj is eligible to be merged, and there are candidates available
        this.dmHitSlop = this.sketch
          .currentTouchRegime()
          .hitSlopForTouch(touch);
        this.dmPreDelta = this.sketch.document.getRecentChangesDelta(); // get this pre-drag in case there's a merge
        this.dmCandidates = arr;
        arr.forEach(function(item) {
          self.dmProxies.push(item); // this array of proxies will be sent to sketch.hitGObj.
        });
        //console.log ("#", this.gobj.id, " is eligible. Candidates: ", this.dmCandidates);
        return true;
      },

      getCandidateFromProxy: function(proxy) {
        // The returned candidate could be an identified candidate gobj or an intersection.
        var ix;
        for (ix = 0; ix < this.dmCandidates.length; ix++) {
          if (this.dmCandidates[ix].proxy === proxy)
            return this.dmCandidates[ix].candidate;
        }
        if (proxy.constraint.match(/intersection/i)) {
          return proxy;
        }
        console.log("getCandidateFromProxy couldn't find proxy: ", proxy);
      },

      /*
       * touchMoved () handles a move for that might lead to a drag merge, merging this.gobj
       * to one of this.dmCandidates. On entry, we find all hits on potential proxies for candidates.
       * Proxies differ from candidates in two respects:
       * If this.gobj is a point, proxies include not only eligible points and paths (which are
       * themselves candidates) and intersections of eligible paths (which need to be constructed).
       * If this.gobj is a parameter, proxies include not only eligible value objects (measurements
       * and parameters, which are themselves candidates) but also text objects that refer
       * to eligible value objects.
       * If the current move doesn't hit a proxy, the state machine is put in the Probe state.
       * If the current move generates a hit on a new proxy, the proxy is highlighted and timers
       * are started for the Pause-PreMerge sequence of states.
       * If the current move hits an already-targeted proxy, no action is needed; timers continue to run.
       * On exit, touchMoved sets this.dmCurProxy to the current proxy (or null if none exists),
       * so that the next invocation of touchMoved can detect whether or not the hit has changed.
       * (The value of dmCurProxy is also needed by touchEnded to effectuate the actual merge.)
       */
      touchMoved: function(touchPos, touch) {
        var self = this,
          perimetersOnly = this.gobj.kind === 'Point',
          pos = GSP.GeometricPoint(touchPos.x, touchPos.y),
          slop = this.dmHitSlop,
          hitRect = {
            left: pos.x - slop,
            top: pos.y - slop,
            bottom: pos.y + slop,
            right: pos.x + slop,
          },
          hitInfo,
          intersectInfo,
          hits; // hits are set on entry to touchMoved and include all proxies hit by touchPos

        function sameCandidate(a, b) {
          // A candidate is either a gobj or an intersection of path1 and path2
          if (a === b) return true; // works if a and b are the same gobj
          if (
            a &&
            b &&
            a.constraint &&
            b.constraint &&
            a.path1 &&
            b.path1 &&
            a.path2 &&
            b.path2
          )
            return (
              a.constraint === b.constraint &&
              a.path1 === b.path1 &&
              a.path2 === b.path2
            );
          return false;
        }

        function hitIndexForProxy(proxy) {
          // return the index of proxy in dmProxies
          return self.dmProxies.indexOf(proxy);
        }

        function setProxy(newProxy) {
          var curProxy = self.dmCurProxy;
          if (!sameCandidate(newProxy, curProxy)) {
            // Changing the proxy and candidate clears the timers and highlights
            self.clearTimers();
            self.setHighlights(false);
            //self.showDebugInfo ("Old Proxy:", curProxy);
            //self.showDebugInfo ("New Candidate:", newProxy);
            self.dmCurProxy = newProxy;
          }
          return self.dmCurProxy;
        }

        function setNextProxy() {
          var index = hitIndexForProxy(self.dmCurProxy) + 1;
          if (index >= hits.length) index = 0;
          return setProxy(hits[index]);
        }

        function transitionToProbe() {
          if (self.dmState !== 'Probe') {
            self.setHighlights(false);
            self.clearTimers();
            self.dmState = 'Probe';
            //console.log ("Probing");
          }
        }

        function transitionToPause() {
          function pauseEnded() {
            //console.log ("Pause timer timed out.");
            self.dmTimer1 = undefined;
            if (self.dmCurProxy) {
              //self.showDebugInfo ("Pause ended for ", self.dmCurProxy);
              transitionToPreMerge();
            } else {
              transitionToProbe();
            }
          }

          if (self.state !== 'Pause') {
            self.setHighlights(false);
            //if (self.dmTimer2) console.log ("ERROR: starting Pause with PreMerge timer running.");
            if (!self.dmTimer1) {
              // start the timer only if it's not already running.
              self.dmTimer1 = setTimeout(pauseEnded, kPauseTime);
              //self.showDebugInfo ("Pause timer started for ", self.dmCurProxy);
            }
            self.dmState = 'Pause';
            //console.log ("Pausing");
          }
        }

        function transitionToPreMerge() {
          function preMergeEnded() {
            // We only get here if PreMerge ended without a touchEnd
            //console.log ("PreMerge timer timed out.");
            self.dmTimer2 = undefined;
            if (setNextProxy()) {
              transitionToPause();
            } else {
              transitionToProbe();
            }
          }

          if (!self.dmCurProxy) {
            //console.log ("ERROR: Transition to PreMerge has no proxy.");
            return;
          }
          //if (self.dmTimer1) console.log ("ERROR: starting PreMerge with Pause timer running.");
          if (!self.dmTimer2) {
            // start the timer only if it's not already running.
            self.dmTimer2 = setTimeout(preMergeEnded, kPreMergeTime);
            //self.showDebugInfo ("PreMerge timer starting: ", self.dmCurProxy);
            self.setHighlights(true);
          }
          self.dmState = 'PreMerge';
          //console.log ("PreMerging");
        }

        function processCurrentHits() {
          // To match a hit on a point, prefer existing points, then intersections.
          // Include path objects only if there are no intersections.
          // No processing is needed for parameters
          if (self.gobj.kind === 'Point') {
            intersectInfo = self.sketch.findIntersections(
              hitInfo.hitArray,
              pos,
              self.dmHitSlop
            );
            if (intersectInfo) {
              // Add the intersections to the array of potential hits.
              hits = hits.filter(function(hit) {
                // if there's an intersection, remove any paths
                return !hit.isAPath || !hit.isAPath();
              });
              hits = hits.concat(intersectInfo);
              // Add any new intersections to the candidates
              hits.sort(function(a, b) {
                // existing points first (0), then intersections (1), and paths last of all(2)
                function val(gobj) {
                  if (gobj.kind === 'Point') return 0;
                  if (gobj.constraint.match(/Intersection/i)) return 1;
                  if (gobj.isAPath && gobj.isAPath()) return 2;
                  //console.log ("drag-merge unexpected gobj: ", gobj);
                }
                return val(a) - val(b);
              });
            }
          }
        }

        function getHitInfo() {
          var options,
            gobjArray = [];
          self.dmProxies.forEach(function(item) {
            gobjArray.push(item.proxy);
          });
          options = { gobjArray: gobjArray, maxResults: 100 };
          if (perimetersOnly) {
            options.gobjHitTestOptions = { interiorsPerimeterOnly: true };
          }
          options.hotSpot = touch;
          hitInfo = self.sketch.hitGObj(hitRect, options) || { hitArray: [] };
          return hitInfo;
        }

        // Body of touchMoved
        // Remain targeted to the same candidate if we're still over it.
        // Otherwise choose a new candidate.
        hitInfo = getHitInfo();
        hits = hitInfo.hitArray;
        if (hits.length === 0) {
          setProxy(null);
          transitionToProbe();
          return;
        } else {
          // there is a hit
          processCurrentHits(); // add intersections and sort
          // console.log ("Moved! ", pos, "  Hits:", hits);

          // For points, see if the previous hit (point or intersection) is still present. If so,
          // stick with it until the PreMerge timer ends.
          // For parameters, see if the previous hit (proxy) is the same as this one. If so,
          // stick with it until PreMerge ends.
          if (hits.indexOf(self.dmCurProxy) < 0) {
            // dmCurProxy is gone
            transitionToProbe(); // shut off timers and highlighting
            if (setProxy(hits[0])) transitionToPause();
            // there is a hit, so start the clock
            else transitionToProbe(); // there is no hit, so keep looking
          }
        }
      },

      touchEnded: function(pos, touch) {
        var mergeCandidate =
            this.dmState === 'PreMerge' && this.dmCurProxy
              ? this.getCandidateFromProxy(this.dmCurProxy)
              : null,
          doc = this.sketch.document,
          attr = { gobjId: this.gobj.id },
          newGobj; // the replacement gobj and id if the id changed
        this.setHighlights(false);
        this.clearTimers();
        if (!mergeCandidate) {
          return false;
        }
        // mergeCandidate is either a gobj or an intersection
        if (
          this.gobj.kind === 'Point' &&
          mergeCandidate.isAPath &&
          mergeCandidate.isAPath()
        ) {
          // merge gobj to path
          attr.pathValue = mergeCandidate.mapPositionToPathValue(
            this.gobj.geom.loc
          );
          attr.pathId = mergeCandidate.id;
          newGobj = this.sketch.putGivenOnPath(
            this.gobj,
            mergeCandidate,
            attr.pathValue
          );
        } else if (mergeCandidate.path1) {
          // merge gobj to newly created intersection
          attr.path1Id = mergeCandidate.path1.id;
          attr.path2Id = mergeCandidate.path2.id;
          newGobj = this.sketch.putGivenOnIntersection(
            this.gobj,
            mergeCandidate
          );
        } else {
          // merge gobj to an existing object of the same kind
          newGobj = this.sketch.mergeGobjToCandidate(
            this.gobj,
            mergeCandidate,
            { skipDescendantUpdate: true }
          );
          attr.mergeToId = mergeCandidate.id;
        }
        attr.delta = doc.pushConfirmedSketchOpDelta(this.dmPreDelta);
        if (newGobj) {
          attr.newId = newGobj.id;
        }
        doc.changedUIMode();
        // Add a sketch event here, similar to the ToolPlayed event posted by the toolController.
        // Three options for attr; all include gobjId.
        // point-point or param-value: mergeToId
        // point-path: pathId & pathValue
        // point-intersection: path1Id & path2Id
        this.sketch.event(
          'MergeGobjs',
          {
            gobj: this.gobj,
            mergeInfo: mergeCandidate,
          },
          attr
        );
        return true;
      },
    };
  })();

  /**
   * @fileOverview abstract base class for touch trackers
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  GSP.DragTracker = (function() {
    // Worker function for drag motions - makes the points move.
    // the 'this' object here refers to the drag motion, which has
    // a controlList
    function applyDragMotion(refCon) {
      var transform,
        controlList = this.controlList,
        sketch = this.tracker.sketch,
        motionId = this.tracker.motionId;

      if (refCon) {
        transform = new GSP.AffineTransform({
          m00: 1,
          m11: 1,
          m20: refCon.transform.dx,
          m21: refCon.transform.dy,
        });

        sketch.MotionManager.ApplyTransformToControlList(
          sketch,
          transform,
          controlList,
          {
            snapPoints: this.tracker.snappingPoints,
            onPathTracksIdealLoc: true,
          }
        );

        sketch.MotionManager.UpdateRefCon(motionId, null);
      }
    }

    // Worker function for drag motion - cleanup for gobjects being changed.
    function completeDragMotion() {
      var that = this;

      $.each(this.controlList, function(index, item) {
        if (item.isController) {
          item.gobj.transformComplete(item.gobj.sQuery.sketch, that.tracker);
          item.gobj.sQuery.sketch.invalidateGeom(item.gobj);
        }
      });
    }

    var proto = GSP.makeClass(
      [
        GSP.TouchTracker,
        GSP.TapTracker,
        GSP.LongPressTracker,
        GSP.DragMergeTracker,
      ],
      {
        gobj: null,
        origX: null,
        origY: null,
        lastX: null,
        lastY: null,
        sketch: null,
        motionId: null,
        snappingPoints: true,
        possibleMerge: false,
        dragMergeBaseIndex: 3, // give DragMergeTracker access to touchMoved() and touchEnded()

        //  Initialize the drag motion, which may be called from touchBegan or from touchMoved.
        //  A call from touchMoved occurs only if the original touchBegan is on an unselectable object
        //  but it turned out not to be a tap. In this case, if there is an alternate hit gobj,
        //  we need to switch this touch to the alternate and restart the tracker.

        touchBegan: function(pos, touch) {
          this.origX = this.lastX = pos.x;
          this.origY = this.lastY = pos.y;
          this.tapState = 'potential';
          /* A tap has three possible tapStates: potential (the initial state at touchBegan),
           * confirmed (if the touchEnded is within the time and distance limits),
           * and rejected (if touchMoved exceeds either time or distance limit).
           */

          this.registerAsPossibleDoubleTap();
          this.possibleMerge =
            this.sketch.currentTouchRegime().name === 'DisplayRegime' &&
            this.registerAsPossibleMerge(touch);
          if (!this.gobj.style.selectable) return; // this can't be a drag if gobj is unselectable

          var controlList = this.bap.createControlList([this.gobj]);
          var motion = {
            applyMotion: applyDragMotion,
            completeMotion: completeDragMotion,
            controlList: controlList,
            tracker: this,
          };

          this.motionId = this.motionManager.StartMotion(motion);

          if (this.sendTouchEvents) {
            this.sketch.event('StartDrag', {
              gobj: this.gobj,
              position: pos,
              touch: touch,
            });
          }

          this.gobj.dragDidStart();
        },
        touchMoved: function(pos, touch) {
          var self = this,
            alternateGobj;
          // Have we already been handled as a long press?
          if (!this.touchIsInProgress) return;
          // We may be listening for a tap on an unselectable object.
          // If gobj is unselectable, the tap has timed out or moved too far,
          // and there's a secondary choice, let the user drag the secondary object.
          if (
            this.options.unselectableTap &&
            !this.gobj.style.selectable &&
            (!this.isTap(pos) || this.distanceMoved(pos) > this.kMaxTapMovement)
          ) {
            //  It's not a tap, so look for a secondary gobj
            $.each(this.gobjArr, function() {
              if (this.style.selectable && this !== self.gobj) {
                alternateGobj = this;
                return false; // found one, so stop looking.
              }
            });
            if (alternateGobj) {
              this.gobj = alternateGobj;
              this.touchBegan({ x: this.origX, y: this.origY });
              this.touchMoved(pos, touch);
              return;
            }
          }
          // We send the StartDragConfirmed event just once, as soon as we know it's a drag
          // If tapState is rejected, this must be a drag
          if (!this.dragConfirmed && this.checkTapState() === 'rejected') {
            this.dragConfirmed = true;
            if (this.sendTouchEvents) {
              this.sketch.event('StartDragConfirmed', {
                gobj: this.gobj,
                position: pos,
                touch: touch,
              });
            }
          }

          var refCon = {
              transform: {
                dx: pos.x - this.lastX,
                dy: pos.y - this.lastY,
              },
              x: pos.x,
              y: pos.y,
            },
            motionId = this.motionId,
            unprocessedRefCon = this.motionManager.GetRefCon(motionId);

          if (unprocessedRefCon) {
            refCon.transform.dx += unprocessedRefCon.transform.dx;
            refCon.transform.dy += unprocessedRefCon.transform.dy;
          }

          this.trackMaxDisplacement();
          this.motionManager.UpdateRefCon(motionId, refCon);
          if (this.possibleMerge) {
            // When in DisplayRegime, let DragMergeTracker know about touchMoved events
            (
              this.touchMoved.base[this.dragMergeBaseIndex] ||
              arguments.callee.base
            ).call(this, pos, touch);
          }

          if (this.sendTouchEvents) {
            this.sketch.event('MoveDrag', {
              gobj: this.gobj,
              position: pos,
              touch: touch,
            });
          }

          this.lastX = pos.x;
          this.lastY = pos.y;
        },
        distanceMoved: function(pos) {
          return Math.max(
            Math.abs(this.lastX - this.origX),
            Math.abs(this.lastY - this.origY)
          );
        },

        touchEnded: function(pos, touch) {
          var isTap =
              this.isTap(pos) && this.distanceMoved(pos) < this.kMaxTapMovement,
            didMerge;
          if (this.gobj.style.selectable) {
            this.motionManager.ApplyCurrent();
            this.motionManager.EndMotion(this.motionId);
            this.sketch.invalidateGeom(this.gobj);
            this.gobj.dragDidEnd();
            // When in DisplayRegime, let DragMergeTracker know about touchEnded events
            if (this.sendTouchEvents) {
              // The drag can end with a MergeGobjs event (in dragMergeTracker) or with an EndDrag event here
              if (this.possibleMerge) {
                didMerge = (
                  this.touchEnded.base[this.dragMergeBaseIndex] ||
                  arguments.callee.base
                ).call(this, pos, touch);
              }
              if (!didMerge && !isTap) {
                // No MergeGobjs event, no Tap event, so send EndDrag.
                this.sketch.event('EndDrag', {
                  gobj: this.gobj,
                  position: pos,
                  touch: touch,
                });
              }
            }
          }
          this.checkForOverlapCycleTap(pos);
          if (this.isDoubleTap(pos)) {
            this.gobj.doubleClicked(touch);
          }
          // Note: A tap event fires on each tap of a double tap.
          if (this.sendTouchEvents && isTap) {
            this.sketch.event('Tap', {
              gobj: this.gobj,
              position: pos,
              gobjArr: this.gobjArr, // SS: Older code passed this array (with gobj removed) as "secondaries." I don't believe any client used this.
              touch: touch,
            });
          }

          // Tell the longPress job we are done and gone.
          this.touchIsInProgress = false;
        }, // touchEnded
      }
    );

    return {
      create: function(gobjs, options) {
        var instance = Object.create(proto);
        var gobj = instance.currentOverlapChoice(gobjs); // Old code removed first object from gobjs, and preserved the resulting array as "secondaries," which was unused.
        var sketch = gobj.sQuery.sketch;

        options = options || {};
        // send Touch events by default
        instance.sendTouchEvents =
          options.sendTouchEvents === false ? false : true;

        instance.gobj = gobj;
        instance.gobjArr = gobjs;
        instance.sketch = sketch;
        instance.bap = sketch.Bap;
        instance.motionManager = sketch.MotionManager;
        instance.options = options;

        return instance;
      },
      // Could be a drag, double tap, long press, or tap
      createPotentialLongPress: function(gobjs, options) {
        var instance = this.create(gobjs, options);
        instance.startLongPressJob();
        return instance;
      },
    };
  })();

  GSP.KeyTracker = (function() {
    // Worker function for drag motions - makes the points move.
    // the 'this' object here refers to the drag motion, which has
    // a controlList
    function applyDragMotion(refCon) {
      var transform,
        controlList = this.controlList,
        sketch = this.tracker.sketch,
        motionId = this.tracker.motionId;

      if (refCon) {
        transform = new GSP.AffineTransform({
          m00: 1,
          m11: 1,
          m20: refCon.transform.dx,
          m21: refCon.transform.dy,
        });

        sketch.MotionManager.ApplyTransformToControlList(
          sketch,
          transform,
          controlList,
          {
            snapPoints: this.tracker.snappingPoints,
            onPathTracksIdealLoc: true,
          }
        );

        sketch.MotionManager.UpdateRefCon(motionId, null);
      }
    }

    // Worker function for drag motion - cleanup for gobjects being changed.
    function completeDragMotion() {
      var self = this;

      $.each(this.controlList, function(index, item) {
        if (item.isController) {
          item.gobj.transformComplete(item.gobj.sQuery.sketch, self.tracker);
          item.gobj.sQuery.sketch.invalidateGeom(item.gobj);
        }
      });
    }

    var proto = GSP.makeClass([], {
      gobj: null,
      sketch: null,
      motionId: null,
      bap: null,
      motionManager: null,
      options: null,
      motionStarted: false,
      snappingPoints: true,

      //  Initialize the drag motion, which may be called from touchBegan or from touchMoved.
      //  A call from touchMoved occurs only if the original touchBegan is on an unselectable object
      //  but it turned out not to be a tap. In this case, if there is an alternate hit gobj,
      //  we need to switch this touch to the alternate and restart the tracker.

      addEvents: function() {
        var self = this;

        if (this.gobj.htmlNode) {
          this.gobj.htmlNode.keydown(function(event) {
            self.keyDown(event);
          });

          this.gobj.htmlNode.keyup(function(event) {
            self.keyUp(event);
          });

          this.gobj.htmlNode.focusin(function(event) {
            self.sketch.focusedGobj = self.gobj;
            self.gobj.setRenderState('targetOnFocus');
            self.gobj.handleFocusIn(event, self.sketch);
          });

          this.gobj.htmlNode.focusout(function(event) {
            self.sketch.setGobjPositionInDocumentBound();
            self.sketch.focusedGobj = '';

            if (self.gobj.kind !== 'Button')
              self.gobj.htmlNode.attr('aria-pressed', 'false');

            // self.toggleSelectedText(self.gobj.htmlNode, false);
            self.gobj.setRenderState('none');
            self.gobj.handleFocusOut(event, this.sketch);
          });

          this.gobj.htmlNode.on('click', function(event) {
            if (self.sketch.focusedGobj) {
              if (
                self.sketch.focusedGobj &&
                self.sketch.focusedGobj.htmlNode &&
                self.gobj.htmlNode
              ) {
                if (
                  !self.gobj.htmlNode[0].isSameNode(
                    self.sketch.focusedGobj.htmlNode[0]
                  )
                ) {
                  self.gobj.htmlNode.focus();
                }
              }
            } else {
              if (self.gobj.htmlNode) {
                self.gobj.htmlNode.focus();
              }
            }

            if (self.gobj.kind !== 'Button')
              self.gobj.htmlNode.attr('aria-pressed', 'true');

            // self.toggleSelectedText(self.gobj.htmlNode, true);
            self.gobj.handleClick(event, self.sketch);
          });
        }
      },

      toggleSelectedText: function(node, add) {
        var text = node.text();
        if (add) {
          if (text.lastIndexOf(' selected') === -1) {
            node.text(text + ' selected');
          }
        } else {
          if (text.lastIndexOf(' selected') !== -1) {
            node.text(text.slice(0, -9));
          }
        }
      },

      keyDown: function(event) {
        var snapCoordSys = '';
        if (this.sketch.preferences.snapToGrid) {
          snapCoordSys = this.sketch.findExistingCoordSys();
        }

        this.sketch.toggleKeyPressClass(true);

        var arrowsKeyCode = [37, 38, 39, 40];

        if (arrowsKeyCode.indexOf(event.keyCode) !== -1) {
          if (!this.gobj.style.selectable) return; // this can't be a drag if gobj is unselectable

          event.preventDefault();
          var controlList = this.bap.createControlList([this.gobj]);
          var transform = this.distanceMoved(event, snapCoordSys);

          if (!this.motionStarted) {
            var motion = {
              applyMotion: applyDragMotion,
              completeMotion: completeDragMotion,
              controlList: controlList,
              tracker: this,
            };
            this.motionId = this.motionManager.StartMotion(motion, {
              transform: transform,
            });
          } else {
            this.motionManager.UpdateRefCon(this.motionId, {
              transform: transform,
            });
          }

          this.sketch.gObjectUpdate = true;
          this.motionStarted = true;
        }

        if (this.sendTouchEvents) {
          this.sketch.event('KeyDown', {
            gobj: this.gobj,
            event: event,
          });
        }

        this.gobj.handleKeyDown(event, this.sketch);
      },
      distanceMoved: function(event, snapCoordSys) {
        var transform = {
          dx: 0,
          dy: 0,
        };

        var translate =
          event.ctrlKey || event.metaKey ? 100 : event.shiftKey ? 10 : 1;
        if (snapCoordSys && this.gobj.genus !== 'UnitPoint') {
          if (event.keyCode === 38 || event.keyCode === 40) {
            translate = snapCoordSys.geom.gridSpacing.y;
          } else {
            translate = snapCoordSys.geom.gridSpacing.x;
          }
        }

        switch (event.keyCode) {
          case 38: //top
            transform.dy = -1 * translate;
            break;

          case 37: //left
            transform.dx = -1 * translate;
            break;

          case 40: //bottom
            transform.dy = translate;
            break;

          case 39: //right
            transform.dx = translate;
            break;

          default:
            break;
        }

        return transform;
      },
      keyUp: function(event) {
        var self = this;
        if (this.sendTouchEvents) {
          this.sketch.event('KeyUp', {
            gobj: this.gobj,
            event: event,
          });
        }

        if (this.motionId !== null) {
          this.motionStarted = false;
          this.motionManager.ApplyCurrent();
          this.motionManager.EndMotion(this.motionId);
          this.sketch.invalidateGeom(this.gobj);
          this.motionId = null;
          this.sketch.gObjectUpdate = false;
          var timeout = setTimeout(function() {
            self.sketch.updateSpeakableText();
            clearTimeout(timeout);
          }, 300);
        }

        this.gobj.handleKeyUp(event, this.sketch);
      },
    });

    return {
      create: function(gobj, options) {
        var instance = Object.create(proto);
        var sketch = gobj.sQuery().sketch;

        options = options || {};

        instance.gobj = gobj;
        instance.sketch = sketch;
        instance.bap = sketch.Bap;
        instance.motionManager = sketch.MotionManager;
        instance.options = options;

        instance.addEvents();

        return instance;
      },
    };
  })();

  /**
   * @preserve (C) KCP Technologies, 2014.
   */

  GSP.LabelDragTracker = (function() {
    var proto = GSP.makeClass([GSP.TouchTracker, GSP.TapTracker], {
      gobj: null,
      sketch: null,
      labelCornerDelta: null,
      //origX: null, // why are these in the proto?
      //origY: null,
      //startTime: null,
      //endTime: null,
      touchBegan: function(pos, touch) {
        // Remember the delta between the touch and the labelTopLeft
        this.labelCornerDelta = this.gobj.getLabelCornerDelta(pos);
        this.origX = pos.x;
        this.origY = pos.y;
        this.tapState = 'potential'; // can be potential, confirmed, or rejected
      },
      touchMoved: function(touchPos, touch) {
        this.gobj.setLabelPosition(
          GSP.GeometricPoint(touchPos.x, touchPos.y),
          this.labelCornerDelta
        );
        this.sketch.invalidateAppearance(this.gobj);
      },

      distanceMoved: function(pos) {
        return Math.max(
          Math.abs(pos.x - this.origX),
          Math.abs(pos.y - this.origY)
        );
      },
      touchEnded: function(pos, touch) {
        if (this.isTap(pos) && this.distanceMoved(pos) < this.kMaxTapMovement) {
          this.sketch.event('Tap', {
            gobj: this.gobj,
            position: pos,
            gobjArr: this.gobjArr, // SS: Older code passed this array (with gobj removed) as "secondaries." I don't believe any client used this.
            touch: touch,
            isLabelTap: true,
          });
        } else {
          this.sketch.event(
            'EndLabelDrag',
            {
              gobj: this.gobj,
            },
            {
              newPos: GSP.GeometricPoint(pos.x, pos.y),
              cornerDelta: this.labelCornerDelta,
              action: 'Dragged', // Label event actions have " label of point A" appended.
            }
          );
        }

        // Tell the longPress job we are done and gone.
        this.touchIsInProgress = false;
      },
    });

    return {
      create: function(gobj, element) {
        var instance = Object.create(proto);
        var sketch = gobj.sQuery.sketch;

        instance.gobj = gobj;
        instance.sketch = sketch;

        return instance;
      },
    };
  })();

  (function() {
    GSP.AbstractToolRegime = GSP.makeClass(GSP.TouchRegime, {
      findHitGObj: function(sketch, candidates, pos, hitSlop, gobjOptions) {
        var options = {
          hotSpot: pos,
          assumeArrowSelectable: true,
          gobjArray: candidates,
          gobjHitTestOptions: { interiorsPerimeterOnly: false },
        };

        if (gobjOptions) {
          $.extend(options.gobjHitTestOptions, gobjOptions);
        }

        return (
          sketch.hitGObj(
            {
              left: pos.x - hitSlop,
              top: pos.y - hitSlop,
              bottom: pos.y + hitSlop,
              right: pos.x + hitSlop,
            },
            options
          ) || {}
        );
      },
    });
  })();
  /**
   * @fileOverview Regime for playing tools in a sketch
   * @author <a href="mailto:jbrooks@kcptech.com">Jon Brooks</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  GSP.ToolRegime = (function() {
    /*  GSP.ToolRegime
     *  Defines:
     *    var trackerProto = GSP.makeClass([GSP.AbstractToolTracker, GSP.TapTracker]
     *      touchBegan: function (pos)
     *      findNewMergeCandidate: function (pos)
     *      touchMoved: function (pos)
     *      touchEnded: function (pos, touch)
     *      shouldSnap: function()
     *    var regimeProto = GSP.makeClass(GSP.AbstractToolRegime,
     *      _addGObjAsMatchedGiven: function(gobj)
     *      _matchedGivenAndTrackerForTouch: function (touch, pos)
     *      decomposeConstructibleGiven: function (tapped, doShift)
     *      recomposeConstructibleGiven: function (matchedGiven)
     *      unsnapConstructibleGiven: function (matchedGiven)
     *      createTracker: function (touch, position)
     *      forgetGivenParents: function (constructible)
     *      animatePathSnap: function (matchedGiven)
     *      startChasing: function (matchedGiven, touchPos)
     *      clearAnimations: function ()
     *      confirmToolWhenReady: function (force)
     *      confirmActiveTool: function (sketchWasModifiedCallback)
     *      doCleanup: function()
     *    function positionsForGivens(givenArray, sketch)
     *    function actOnSingleGiven(givenGObj, sketch)
     *    function compareGivens(given0, given1)
     *  Returns:
     *    createWithTool: function(sketch, tool)  // Creates the tool session as well as the regime
     *
     */

    var trackerProto = GSP.makeClass(
      [GSP.AbstractToolTracker, GSP.TapTracker],
      {
        touchBegan: function(evt) {
          var matchedGiven = this.matchedGiven,
            given = matchedGiven.given,
            regime = this.regime,
            touchPos = GSP.GeometricPoint(evt.x, evt.y),
            gLoc,
            sloppyRect;
          if (matchedGiven) {
            regime.touchesDownOnGivens++;
          }
          //If there is no given, we're done
          if (!matchedGiven) return;
          this.registerAsPossibleDoubleTap();
          this.possibleTargets = this.session.getLegalMatchesForGiven(
            given,
            this.possibleTargets
          );
          //For points, we snap the drag position to the position of the point for ease of merging.
          if (given.kind === 'Point') {
            this.isPointMatchedGiven = true;
            gLoc = given.geom.loc;
            sloppyRect = GSP.Geom.insetRect(
              { left: gLoc.x, right: gLoc.x, top: gLoc.y, bottom: gLoc.y },
              -this.hitSlop
            );
            if (GSP.Geom.PointInRect(touchPos, sloppyRect)) {
              touchPos = matchedGiven.updateDeltaToGiven(touchPos);
            }
          } else {
            touchPos = matchedGiven.updateDeltaToGiven(touchPos);
          }
          this.dragTracker = GSP.DragTracker.create([matchedGiven.given], {
            sendTouchEvents: false,
          });
          // The toolTracker (this) has its own dragTracker, but don't start it up till after the initial chase.
          this.adjustChaseTarget = regime.startChasing(matchedGiven, touchPos);
          this.touchMoved(touchPos);
        },

        findNewMergeCandidate: function(touchPos) {
          // Returns true if the mergeCandidate has changed, even if the new is undefined
          // Starts an animation if this.matchedGiven hasn't already been animated.
          var intersectInfo,
            self = this,
            sketch = this.session.sketch,
            matchedGiven = this.matchedGiven,
            given = matchedGiven.given,
            newMergeCandidate = this.findToolTarget(sketch, touchPos),
            prevMergeCandidate = matchedGiven.mergeCandidate,
            proxy, // If there's a proxy, highlight it in the UI, but merge to the ancestor it represents
            isPathMatch,
            newLoc,
            retVal;

          // findNewMergeCandidate and touchMoved keep track of whether the user is unsnapping from some previous candidate.
          // If so, don't return that candidate. But if the touch doesn't generate a candidate, it's time to forget
          // the unsnappingFrom candidate, allowing the user to move off a candidate and then back onto it.

          function adjustUnsnapPos() {
            // find the motion item for the drag tracker, resetting idealLocation
            // to center the unsnapped given (point or text) on the pointer.
            var ix,
              mMgr,
              mSet,
              item,
              tracker = self.dragTracker;
            if (given.geom.loc) {
              mMgr = tracker.motionManager;
              try {
                for (ix = 0; ix < mMgr.motionList.length; ix++) {
                  // motionList has indices into motionSet.
                  mSet = mMgr.motionSet[mMgr.motionList[ix]];
                  item = mSet.motion.controlList[0]; // a dragged given must be at the head of its control list
                  if (mSet.state === 'active' && item.gobj === given) {
                    if (item.idealLocation)
                      item.idealLocation.loc = GSP.GeometricPoint(
                        tracker.lastX,
                        tracker.lastY
                      );
                    else
                      throw GSP.createError(
                        "adjustUnsnapPos() couldn't find given in controlList, "
                      );
                  }
                }
              } catch (e) {
                throw GSP.createError(
                  'findMergeCandidate() failed to clear idealLocation, ',
                  e
                );
              }
            }
          }

          if (newMergeCandidate && given.genus.includes('Parameter')) {
            // Parameters can match to Pegged or CompositeText objects...
            proxy = newMergeCandidate;
            newMergeCandidate = given.getLegalMatchForParam(newMergeCandidate);
            if (proxy === newMergeCandidate) {
              proxy = null;
            }
          }
          if (
            newMergeCandidate &&
            newMergeCandidate === matchedGiven.unsnappingFrom
          ) {
            newMergeCandidate = undefined;
          } else if (!newMergeCandidate && matchedGiven.unsnappingFrom) {
            delete matchedGiven.unsnappingFrom;
          }
          isPathMatch =
            newMergeCandidate && given.isAPath() && newMergeCandidate.isAPath();
          retVal =
            (newMergeCandidate || prevMergeCandidate) &&
            newMergeCandidate !== prevMergeCandidate;
          if (retVal && prevMergeCandidate) {
            newLoc = GSP.GeometricPoint(
              this.dragTracker.lastX,
              this.dragTracker.lastY
            );
            matchedGiven.unsnapFromCandidate(newLoc);
            // After unsnapping, center the dragTracker.
            adjustUnsnapPos();
          }
          if (
            newMergeCandidate &&
            newMergeCandidate.isAPath() &&
            given.kind === 'Point'
          ) {
            intersectInfo = sketch.findPotentialIntersection(
              newMergeCandidate,
              this.possibleTargets,
              touchPos,
              this.hitSlop
            );
          }
          if (intersectInfo) {
            matchedGiven.setIntersectInfo(intersectInfo);
          } else {
            matchedGiven.clearIntersectInfo();
          }
          if (retVal && !intersectInfo && newMergeCandidate) {
            // There's a new candidate
            matchedGiven.setMergeCandidate(newMergeCandidate, proxy);
            //  If isPathMatch, each givenParent must have its own target, so start an animatePathSnap (which aborts any chase).
            //  Otherwise, if matchedGiven.chase is active, the given will snap either when the chase ends or is aborted by touchEnded.
            //  If the chase is finished and there's no need for an animatePathSnap, but the mergeCandidate has changed,
            //  then we need to snap or unsnap the given as appropriate.
            if (isPathMatch) {
              this.regime.animatePathSnap(matchedGiven);
            } else if (matchedGiven.chase !== 'active') {
              if (matchedGiven.chase === 'paused') {
                this.adjustChaseTarget = this.regime.startChasing(
                  matchedGiven,
                  touchPos
                ); // resume a paused chase till it catches the mouse
              } else {
                matchedGiven.snapToCandidate(touchPos); // not chasing, so snap to new candidate
              }
            }
          }
          return retVal;
        },

        touchMoved: function(evt) {
          var matchedGiven = this.matchedGiven,
            touchPos = GSP.GeometricPoint(evt.x, evt.y),
            regime = this.regime,
            given = matchedGiven.given;
          if (!matchedGiven)
            throw GSP.createError("touchMoved doesn't have a matched given");
          if (matchedGiven.chase === 'active' && this.adjustChaseTarget) {
            this.adjustChaseTarget(touchPos);
          }
          if (matchedGiven.delayed) {
            if (!GSP.Geom.PointInRect(touchPos, matchedGiven.dragRect)) {
              // User has dragged outside the dragRect, so this is an intentional drag of a constructible given or parent
              if (
                given.toolRole === 'givenParent' ||
                (given.toolRole === 'constructibleGiven' &&
                  matchedGiven.mergeCandidate)
              ) {
                //  given has already been matched, so unsnap it. unsnapConstructibleGiven() handles either constructible or a constructible parent.
                this.matchedGiven = regime.unsnapConstructibleGiven(
                  matchedGiven
                ); // NOTE: this changes the matchedGiven!
                matchedGiven = this.matchedGiven;
              } else if (given.toolRole === 'constructibleGiven') {
                //  The constructible isn't matched yet, but some parents may be, so recompose it for dragging.
                this.matchedGiven = regime.recomposeConstructibleGiven(
                  matchedGiven
                );
              } else if (given.toolRole === 'given') {
                // User is dragging a given (not the sequential one), so allow it to be dragged
                // CHECK: IF THIS GIVEN IS MATCHED, IT NEEDS TO BE UNSNAPPED, DOESN'T IT????
                this.matchedGiven = regime._confirmDelayedMatchedGiven(
                  matchedGiven
                );
              }
            }
          } else if (!this.findNewMergeCandidate(touchPos)) {
            // not a delayed match; can we find a new candidate?
            if (matchedGiven.mergeCandidate) {
              // not delayed, no new candidate
              if (given.isAPath() && matchedGiven.mergeCandidate.isAPath()) {
                return; // don't disturb matched paths till the user drags farther away.
              } else if (given.geom.loc) {
                given.geom.loc = matchedGiven.getSnappedPosition(touchPos);
                given.invalidateGeom();
                return; // don't pass a snapped point or text object to the dragTracker
              }
            }
          }
          if (!matchedGiven.isSnapping && matchedGiven.chase !== 'active') {
            if (!this.dragTracker.started) {
              this.dragTracker.touchBegan(touchPos);
              this.dragTracker.started = true;
            }
            this.dragTracker.touchMoved(touchPos);
          }
        },

        shouldSnap: function() {
          return this.isPointMatchedGiven;
        },

        rejectDelayedMatchedGiven: function(pos) {
          // The user released without dragging, so reject the delayed match.
          // Instead return a matchedGiven for the next unmatched given, if it exists
          var given = this.unmatchedGivens[0];
          if (!given) return; // return undefined if there's no unmatched given to match.
          //  The tracker's possibleTargets were generated for a different given, so regenerate them for this given.
          this.possibleTargets = this.regime.sharedMergeCandidateList;
          this.possibleTargets = this.session.getLegalMatchesForGiven(
            given,
            this.possibleTargets
          );
          this.matchedGiven = this.regime._addGObjAsMatchedGiven(given);
          this.regime.snapGivenToPos(
            this.matchedGiven,
            GSP.GeometricPoint(pos.x, pos.y)
          );
          this.findNewMergeCandidate(pos);
          this.dragTracker.touchEnded();
          //  Can't we just set this.dragTracker to null? what does it do in touchEnded?
          this.dragTracker = GSP.DragTracker.create([given], {
            sendTouchEvents: false,
          });
          this.dragTracker.touchBegan(pos);
        },

        touchEnded: function(pos, touch) {
          var gobj,
            candidate,
            touchPos = GSP.GeometricPoint(pos.x, pos.y),
            regime = this.regime;
          if (!this.matchedGiven) return;
          if (this.matchedGiven.delayed) {
            // User hasn't dragged far enough: forget this match and create a new one
            this.rejectDelayedMatchedGiven(touchPos);
          }
          gobj = this.matchedGiven.given;
          candidate = this.matchedGiven.mergeCandidate;
          if (this.dragTracker.started) {
            this.dragTracker.touchEnded();
          }
          this.matchedGiven.completeMatch(touchPos);
          if (gobj.isAPath()) {
            regime.forgetGivenParents(this.matchedGiven.given);
          }
          this.matchedGiven.deltaToGiven = undefined;
          regime.touchesDownOnGivens--;
          // Don't halt toolplay until all touches are removed from givens.
          if (!regime.confirmToolWhenReady()) {
            // Allow an ongoing animation to finish...
            if (regime.sequentialSnapping && this.unmatchedGivens.length > 0) {
              this.unmatchedGivens[0].setRenderState('unmatchedGiven');
            }
          }
          if (this.isDoubleTap(pos)) {
            if (candidate) {
              candidate.doubleClicked(touch);
            } else if (gobj) {
              gobj.doubleClicked(touch);
            }
          }
        },
      }
    );

    var regimeProto = GSP.makeClass(GSP.AbstractToolRegime, {
      name: 'ToolRegime',

      /*
       *  A constructible given can be matched by itself or by its parents, but not both.
       *  If the constructible has a candidate, the constructible's givenParents are matched to the candidate's parents.
       *  If the touch is on a constructibleGiven, it and its givenParents are added as matched givens and removed from the unmatched list.
       *  When it snaps to a candidate, the givenParents are animated and matched (to a point or a path as appropriate) when the animation ends.
       *  When toolplay ends (in confirmActiveTool), if the constructibleGiven is matched to an actual candidate, the givenParents are deleted;
       *  if the constructibleGiven is not matched to an actual candidate, the givenParents are matched instead.
       *  Thus there are only two states: the constructibleGiven has a mergeCandidate and none of the givenParents has a mergeCandidate, or
       *  at least one of the givenParents has a mergeCandidate and the constructibleGiven does not.
       *  Unsnapping and dragging the constructibleGiven brings all the givenParents along (as they don't have mergeCandidates).
       *  Unsnapping and dragging a givenParent moves only that parent and the constructibleGiven; other givenParents are unaffected.
       */
      hitSlopForTouch: function(touch) {
        // Use more slop than TouchRegime to allow for target highlighting
        // ToolRegime hitSlop of "15 : 20" has seemed too loose in actual practice,
        // so tentatively try it the same as TouchRegime: "5 : 15".
        // The need for more slop in ToolRegime is questionable, since the user can
        // adjust the touch until the desired gobj is target highlit.
        return touch.mouseEvent !== undefined ? 5 : 15;
      },

      /**
       * Private utility to add this gobj as a matchedGiven
       * to the toolplay session, and prune it from the
       * set of unmatchedGivens.
       */
      _addGObjAsMatchedGiven: function(gobj) {
        var unmatched = this.sharedUnmatchedGivens,
          index;
        index = unmatched.indexOf(gobj);
        if (index === -1)
          throw GSP.createError('Tool regime adding an unknown matched given');
        var matchedGiven = this.toolplaySession.addGObjAsMatchedGiven(gobj);
        unmatched.splice(index, 1);
        return matchedGiven;
      },

      getConstructibleChild: function(parent) {
        var i, child, constructible;
        for (i = 0; i < parent.children.length; i++) {
          child = parent.children[i];
          if (child.toolRole === 'constructibleGiven') {
            constructible = child;
            break;
          }
        }
        if (!constructible || parent.toolRole !== 'givenParent')
          throw GSP.createError('Asssumptions wrong in getConstructibleChild');
        return constructible;
      },

      snapGivenToPos: function(matchedGiven, pos) {
        var givenPos,
          delta,
          given = matchedGiven.given;
        if (given.toolRole === 'given' || given.toolRole === 'givenParent') {
          given.geom.loc = pos;
          given.invalidateGeom();
        } else if (given.toolRole === 'constructibleGiven') {
          // shift givenParents by delta
          givenPos = given.mapPositionToPathPosition(pos);
          delta = GSP.GeometricPoint(pos.x - givenPos.x, pos.y - givenPos.y);
          given.parentsList.forEach(function(parent) {
            if (parent.toolRole !== 'givenParent') {
              throw GSP.createError('unrecognized parent in snapGivenToPos');
            } else {
              parent.geom.loc.x += delta.x;
              parent.geom.loc.y += delta.y;
              parent.invalidateGeom();
            }
          });
        } else {
          throw GSP.createError('unrecognized toolRole in snapGivenToPos');
        }
      },

      _addGObjAsDelayedMatchedGiven: function(gobj, pos, slop) {
        /*
         * If the user taps on a matched givenParent, a matched constructibleGiven,
         * or some other already-matched gobj, she may (1) want to match the next
         * unmatched given object, or (2) want to modify the existing match.
         * We try to guess her desire by her subsequent behavior.
         * In case (1) she will likely tap and release.
         * In case (2) she will likely drag, separating the match from its candidate.
         * Here we return a matchedGiven that can be put to later use.
         */
        var matchedGiven = this.toolplaySession.existingMatchedGivenForGObj(
          gobj
        );
        if (!matchedGiven) {
          matchedGiven = GSP.Tool.createMatchedGiven(
            gobj,
            this.toolplaySession
          );
        }
        matchedGiven.delayed = true;
        matchedGiven.toolRole = gobj.toolRole ? gobj.toolRole : 'none';
        matchedGiven.pos = pos;
        matchedGiven.dragRect = {
          left: pos.x - slop,
          right: pos.x + slop,
          top: pos.y - slop,
          bottom: pos.y + slop,
        };
        return matchedGiven;
      },

      _confirmDelayedMatchedGiven: function(match) {
        // The delayed match should be confirmed.
        // It's already unsnapped from any previous match.
        var gobj = match.given,
          candidate = match.mergeCandidate,
          unmatched = this.sharedUnmatchedGivens,
          index = unmatched.indexOf(gobj);
        if (candidate) {
          // turn off target highlighting for the existing target, away from which it's being dragged.
          candidate.state.renderState = 'none';
        }
        if (index < 0) {
          unmatched.unshift(gobj);
        }
        return this._addGObjAsMatchedGiven(gobj);
      },

      /**
       *
       * @param touch
       * @param pos
       * @returns {{matchedGiven: *, customTracker: (*|ret.customTracker)}}
       */
      _matchedGivenAndTrackerForTouch: function(touch, pos) {
        var session = this.toolplaySession,
          self = this,
          sketch = session.sketch,
          hitSlop = this.hitSlopForTouch(touch),
          unmatched = this.sharedUnmatchedGivens,
          hitGObjInfo,
          hitGObj,
          matchedGiven;

        function constructibleHasCandidate(gobj, session) {
          var ix = session.matchedGivens.findIndex(function(element) {
            return element.given.id === gobj.id;
          });
          return ix >= 0 && session.matchedGivens[ix].mergeCandidate;
        }

        function constructibleChildHasCandidate(parent, session) {
          // is the givenParent's constructible matched to a candidate? If so, return the candidate
          var constructible = self.getConstructibleChild(parent);
          return constructibleHasCandidate(constructible, session);
        }

        function paramEditCallback(result) {
          // no need to check the result; it's either "changesAccepted" or "changesNotAccepted"
          if (unmatched.length) {
            // The regime will go on to the next unmatched given, so it should glow
            unmatched[0].setRenderState('unmatchedGiven');
          } else {
            // No more givens to match, so confirm this tool
            sketch.toolController.confirmActiveTool();
          }
        }

        function checkGivenParents() {
          // A tap on a constructible's cached parent, IF DRAGGED, should unmerge the constructibleGiven
          // IF RELEASED WITHOUT DRAGGING, make it the mergeCandidate for the current sharedUnmatchedGivens[0]
          if (self.cachedGivenParents) {
            hitGObjInfo = self.findHitGObj(
              sketch,
              self.cachedGivenParents,
              pos,
              hitSlop
            );
            hitGObj = hitGObjInfo.hitGObj;
            if (hitGObj) {
              if (constructibleChildHasCandidate(hitGObj, session)) {
                // If its constructibleGiven is snapped to a candidate, don't unmerge and match unless dragged
                matchedGiven = self._addGObjAsDelayedMatchedGiven(
                  hitGObj,
                  pos,
                  hitSlop
                );
              } else {
                self.decomposeConstructibleGiven(hitGObj);
                matchedGiven = self._addGObjAsMatchedGiven(hitGObj);
              }
            }
          }
        }

        function checkUnmatchedGivens() {
          hitGObjInfo = self.findHitGObj(sketch, unmatched, pos, hitSlop, {
            onCompleteUI: paramEditCallback,
          });
          hitGObj = hitGObjInfo.hitGObj;
          if (hitGObj) {
            if (self.sequentialSnapping && hitGObj !== unmatched[0]) {
              //  Touch is NOT on the current sequential given, so use it only if this is a drag.
              //  But if it's a tap, the delayed match will be ignored and the current sequential
              //  given will be matched to the tapped position.
              matchedGiven = self._addGObjAsDelayedMatchedGiven(
                hitGObj,
                pos,
                hitSlop
              );
            } else {
              //  User has touched a given and it's either the sequential given or sequential snapping is off.
              //  In this case the touched given is the match, for either tap or drag.
              matchedGiven = self._addGObjAsMatchedGiven(hitGObj);
            }
          }
        }

        function checkMatchedGivens() {
          // matchedGivens are already inflated, so use small hitSlop (3) to avoid a false hit.
          // Noted problems with this involve large matchedGivens (e.g., text objects), so
          // an improvement would be to allow slop for hitting a small object, but not a large one.
          hitGObjInfo = self.findHitGObj(
            sketch,
            session.arrayOfMatchedGivenGObjs(),
            pos,
            3
          );
          hitGObj = hitGObjInfo.hitGObj;
          if (hitGObj) {
            if (
              (hitGObj.toolRole === 'givenParent' &&
                constructibleChildHasCandidate(hitGObj, session)) ||
              (hitGObj.toolRole === 'constructibleGiven' &&
                constructibleHasCandidate(hitGObj, session))
            ) {
              matchedGiven = self._addGObjAsDelayedMatchedGiven(
                hitGObj,
                pos,
                hitSlop
              );
            } else {
              if (hitGObj.toolRole === 'givenParent') {
                self.decomposeConstructibleGiven(hitGObj);
              }
              matchedGiven = session.existingMatchedGivenForGObj(hitGObj);
            }
          }
        }

        function checkConstructibleGivens() {
          // Check for a constructible that's already been decomposed.
          hitGObjInfo = self.findHitGObj(
            sketch,
            self.cachedConstructibles,
            pos,
            hitSlop
          );
          hitGObj = hitGObjInfo.hitGObj;
          if (hitGObj && hitGObj.toolRole === 'constructibleGiven') {
            matchedGiven = self._addGObjAsDelayedMatchedGiven(
              hitGObj,
              pos,
              hitSlop
            );
          }
        }

        // _matchedGivenAndTrackerForTouch body
        checkGivenParents(); // Look for givenParents, even before unmatched givens.
        if (!matchedGiven) {
          checkUnmatchedGivens();
        }
        if (!matchedGiven) {
          checkMatchedGivens();
        }
        if (!matchedGiven) {
          checkConstructibleGivens();
        }
        if (!matchedGiven && self.sequentialSnapping && unmatched.length) {
          hitGObj = unmatched[0];
          matchedGiven = self._addGObjAsMatchedGiven(hitGObj);
        }
        if (
          unmatched.length &&
          unmatched[0] !== hitGObj &&
          self.sequentialSnapping
        ) {
          unmatched[0].setRenderState('matchedGiven');
        }
        return {
          matchedGiven: matchedGiven,
          customTracker: hitGObjInfo.customTracker,
        };
      }, //  _matchedGivenAndTrackerForTouch

      // A constructibleGiven can be matched either as one object or by its givenParents.
      // Initially it's a single object; decomposeConstructibleGiven switches it to match by givenParents.
      // This transition is one-way; once decomposed to be defined by parents, it cannot be recomposed.
      // This function is called in three situations:
      // 1. At the start of toolplay, the user drags a givenParent rather than the constructibleGiven.
      // 2. The user matches the constructibleGiven and then drags a givenParent, separating it from its match.
      // 3. The user places the constructibleGiven in empty space and then drags a givenParent.
      // Once decomposed, the constructibleGiven can't be dragged during toolplay, so it's removed
      // from the unmatchedGivens or matchedGivens lists.
      // If the constructible has a merge candidate, shift the parents (except for tapped) away from any previous match.
      decomposeConstructibleGiven: function(tapped, doShift) {
        var ix,
          i,
          match,
          parent,
          constructible = this.getConstructibleChild(tapped),
          unmatched = this.sharedUnmatchedGivens,
          parents = constructible.parentsList,
          parentArr = [];

        function removeIfPresent(item, arr) {
          ix = arr.indexOf(item);
          if (ix >= 0) arr.splice(ix, 1);
        }

        if (this.cachedConstructibles.indexOf(constructible) !== -1) return; // no op if already decomposed.
        this.cachedConstructibles.push(constructible); // Mark it decomposed
        constructible.setRenderState('none');
        // If the constructible is either an unmatched or matched given, remove it in favor of givenParents
        removeIfPresent(constructible, unmatched);
        match = this.toolplaySession.existingMatchedGivenForGObj(constructible);
        doShift = doShift || (match && match.candidate);
        removeIfPresent(match, this.toolplaySession.matchedGivens);
        if (unmatched[0]) {
          unmatched[0].setRenderState(
            this.sequentialSnapping ? 'matchedGiven' : 'unmatchedGiven'
          );
        }
        for (i = 0; i < parents.length; i++) {
          // Put the parents in a separate array, to sort them
          // before putting them at the beginning of the unmatched array.
          parent = parents[i];
          ix = this.cachedGivenParents.indexOf(parent); // Remove them from the givenParents array
          if (ix !== -1) {
            this.cachedGivenParents.splice(ix, 1);
          }
          parentArr.push(parent);
        }
        parentArr.sort(compareGivens); // get the parents in the author-designated order
        for (i = parentArr.length - 1; i >= 0; i--) {
          parent = parentArr[i];
          ix = unmatched.indexOf(parent); // And add them to the unmatched array
          if (ix > -1) {
            unmatched.splice(ix, 1);
          }
          unmatched.unshift(parent);
          if (parent !== tapped) {
            parent.setRenderState(
              this.sequentialSnapping ? 'matchedGiven' : 'unmatchedGiven'
            );
            if (parent.kind === 'Point' && doShift) {
              parent.geom.loc.x += 10;
              parent.geom.loc.y += 10;
              parent.invalidateGeom();
            } else if (parent.kind !== 'Point')
              throw GSP.createError(
                "decomposeConstructibleGiven can't handle non-point given parents."
              );
          }
        }
      },

      //  The tapped constructible given has been dragged, and must be separated from its match
      recomposeConstructibleGiven: function(matchedGiven) {
        var tapped = matchedGiven.given,
          index = this.cachedConstructibles.indexOf(tapped),
          i,
          parent,
          match,
          candidate;
        if (tapped.toolRole !== 'constructibleGiven')
          throw GSP.createError('Wrong role in recomposeConstructibleGiven.');
        if (index !== -1) {
          // given needs to be recomposed
          this.cachedConstructibles.splice(index, 1);
          for (i = tapped.parentsList.length - 1; i >= 0; i--) {
            parent = tapped.parentsList[i];
            parent.setRenderState(
              this.sequentialSnapping ? 'matchedGiven' : 'unmatchedGiven'
            );
            match = this.toolplaySession.existingMatchedGivenForGObj(parent);
            index = this.toolplaySession.matchedGivens.indexOf(match);
            if (index >= 0) {
              candidate = this.toolplaySession.matchedGivens[index]
                .mergeCandidate;
              if (candidate) {
                candidate.setRenderState('none');
              }
              match.unsnapFromCandidate();
              this.toolplaySession.matchedGivens.splice(index, 1);
            }
            index = this.cachedGivenParents.indexOf(parent);
            if (index < 0) {
              this.cachedGivenParents.unshift(parent);
            }
          }
        }
        return this._confirmDelayedMatchedGiven(matchedGiven);
      },

      unsnapConstructibleGiven: function(matchedGiven) {
        // User is dragging a matched constructibleGiven
        // or the givenParent of a matched constructibleGiven. The match is delayed, because only a drag (not a tap) unsnaps it.
        // If constructible is matched, remove it from matchedGivens and use the transaction to restore its original state.
        // Insert its givenParents at the beginning of regime.sharedUnmatchedGivens
        // Shift all its parents down and right 10 pixels, skipping tapped if tapped was a parent.
        // tapped should be the first gobj in the sharedUnmatchedGivens; If tapped was the constructibleGiven, put it also into sharedUnmatchedGivens, as
        var tapped = matchedGiven.given,
          session = this.toolplaySession,
          matchedArr = session.matchedGivens,
          oldCandidate = matchedGiven.mergeCandidate,
          constructible,
          i,
          constructibleGiven,
          newMatchedGiven;
        constructible =
          tapped.toolRole === 'constructibleGiven'
            ? tapped
            : this.getConstructibleChild(tapped);
        if (
          !constructible.toolRole ||
          constructible.toolRole !== 'constructibleGiven' ||
          !matchedGiven.delayed
        )
          throw GSP.createError('Wrong role in unsnapConstructibleGiven');
        i = matchedArr.findIndex(function(element) {
          return element.given.id === constructible.id;
        });
        if (i < 0) {
          // constructible isn't matched
          if (constructible === tapped) {
            // constructible must be matched by its parents, so recompose it.
            return this.recomposeConstructibleGiven(matchedGiven);
          } else {
            i = matchedArr.findIndex(function(element) {
              return element.given.id === tapped.id;
            });
            matchedArr.splice(i, 1);
            return matchedGiven; // Nothing more to do here...
          }
        }
        constructibleGiven = matchedArr.splice(i, 1)[0];
        constructibleGiven.unsnapFromCandidate(); // Restore the original state before snapping took place
        if (this.sequentialSnapping && this.sharedUnmatchedGivens.length > 0) {
          // Turn off any glowing unmatched given
          this.sharedUnmatchedGivens[0].setRenderState('none');
        }
        if (constructible === tapped) {
          // if the unmatch results from dragging the constructibleGiven...
          this.sharedUnmatchedGivens.unshift(constructible); // let user match the constructible
        } else {
          // if the unmatch results from dragging a givenParent...
          this.decomposeConstructibleGiven(
            tapped,
            constructibleGiven.mergeCandidate
          );
        }
        newMatchedGiven = this._confirmDelayedMatchedGiven(matchedGiven);
        newMatchedGiven.unsnappingFrom = oldCandidate;
        return newMatchedGiven;
      },

      createTracker: function(touch, position) {
        var session = this.toolplaySession,
          ret,
          regime = this,
          trackerForMatchedCandidate;

        // Returns a custom click tracker if the user hits the input box
        // of an already matched parameter candidate (as opposed to the
        // given it matches).
        function shouldEditCandidate(matchedGiven) {
          var hitCandidate;
          if (
            !matchedGiven ||
            !matchedGiven.mergeCandidate ||
            !GSP.isParameter(matchedGiven.mergeCandidate)
          ) {
            return false;
          }

          hitCandidate = regime.findHitGObj(
            session.sketch,
            [matchedGiven.mergeCandidate],
            position,
            regime.hitSlopForTouch(touch)
          );
          if (hitCandidate.customTracker) {
            // Ok, get ready to show the Numpad.
            return GSP.ClickTracker.createOnElement(
              hitCandidate.hitGObj.getEditBoxElement(),
              function() {
                hitCandidate.hitGObj.presentUI();
              }
            );
          }
          return false;
        }
        GSP.blurDocumentActiveElement(session.sketch.baseNode);
        /*
        if (this.clearAnimations) {
          this.clearAnimations ();
        }
        */
        //Sniff the current regime to make sure we are still the active regime.
        //The act of blurring the active element, or of clearing animations, could have cancelled our touch
        //regime (eg. Numpad)
        var curRegime = session.sketch.currentTouchRegime();
        if (curRegime !== this) {
          //In that case, just let the current regime create the tracker for this touch,
          if (curRegime.name === 'ToolRegime') {
            // first making sure the tool objects are ready for the tracker
            curRegime.toolplaySession.sketch.constrainAndRedraw();
          }
          ret = curRegime.createTracker(touch, position);
        } else {
          //First, hit test to see what gobj we hit.  We may need to return a gobj's custom
          //tracker instead of a standard toolplay tracker
          var matchInfo = this._matchedGivenAndTrackerForTouch(touch, position);
          if (matchInfo.customTracker) {
            //If the gobj has a custom tracker, just use that
            ret = matchInfo.customTracker;
          } else {
            // If we hit the edit box of an already matched parameter
            // candidate, track it as a potential click-to-edit.  We need to create
            // a fresh click tracker here: no custom tracker exists yet
            // because the matched given is invisible (cf
            // expression:positionInEditBox), and we aren't editing that
            // gobj anyway.
            trackerForMatchedCandidate = shouldEditCandidate(
              matchInfo.matchedGiven
            );
            if (trackerForMatchedCandidate) return trackerForMatchedCandidate;
            //Otherwise, we create a toolplay tracker
            ret = Object.create(trackerProto);
            ret.session = session;
            ret.regime = this;
            ret.unmatchedGivens = this.sharedUnmatchedGivens;
            ret.givenParents = this.cachedGivenParents;
            ret.possibleTargets = this.sharedMergeCandidateList;
            ret.hitSlop = this.hitSlopForTouch(touch);
            ret.matchedGiven = matchInfo.matchedGiven;
          }
        }
        return ret;
      },

      pointInRegion: function(pt, region) {
        var slop = 3;
        return (
          region.isOfGenus('Interior') &&
          region.hitTest(
            {
              left: pt.x - slop,
              right: pt.x + slop,
              top: pt.y - slop,
              bottom: pt.y + slop,
            },
            pt
          )
        );
      },

      //  Constructible has been matched, so remove its givenParents from sharedUnmatchedGivens.
      forgetGivenParents: function(constructible) {
        var unmatched = this.sharedUnmatchedGivens;
        constructible.parentsList.forEach(function(gobj) {
          var ix = unmatched.indexOf(gobj);
          if (ix > -1) {
            unmatched.splice(ix, 1);
          }
        });
      },

      animatePathSnap: function(matchedGiven) {
        // The matchedGiven.given is a constructibleGiven. Animate its givenParents to the correct locations on the candidate.
        var parents = [], // objects to move
          pLocs = [], // parent locations
          tLocs = [], // target locations
          regime = this,
          session = regime.toolplaySession,
          sketch = session.sketch,
          given = matchedGiven.given,
          candidate = matchedGiven.mergeCandidate,
          oldRenderState = given.state.renderState,
          duration = 1000,
          startTime,
          r;

        function dist2(p1, p2) {
          // Square of the distance
          var dx = p2.x - p1.x,
            dy = p2.y - p1.y;
          return dx * dx + dy * dy;
        }

        function frame() {
          if (matchedGiven.mergeCandidate !== candidate) {
            return false; // mergeCandidate has changed, so abort
          }
          var r1,
            now = Date.now();
          r = Math.min((now - startTime) / duration, 1);
          r1 = 1 - r;
          switch (given.kind) {
            case 'Straight':
            case 'Polygon':
            case 'Circle':
            case 'Arc':
              parents.forEach(function(par, ix) {
                var p = pLocs[ix],
                  t = tLocs[ix];
                if (p && t) {
                  // guard against an overlapping call to animatePathSnap having removed the array contents
                  par.geom.loc.x = r1 * p.x + r * t.x;
                  par.geom.loc.y = r1 * p.y + r * t.y;
                  par.invalidateGeom();
                }
              });
              break;
          }
          return r !== 1;
        }

        function finished() {
          regime.pathAnimationJob = null;
          matchedGiven.isSnapping = false;
          duration = 1;
          frame();
          matchedGiven.snapToCandidate(); // Snap the candidate once the animation finishes.
          regime.confirmToolWhenReady(); // The tool may be ready to finish, holding off until the animation ends.
        }

        function doMatchAnimation() {
          duration = 1000;
          startTime = Date.now();
          r = 0;
          regime.pathAnimationJob = sketch.jobScheduler.addJob(frame, {
            done: finished,
            delay: 50,
            repeat: true,
          });
        }

        // Body of animatePathSnap()
        regime.clearAnimations(); // abort any existing animation
        if (
          !given.isAPath() ||
          given.toolRole !== 'constructibleGiven' ||
          candidate.parentsList.length !== given.parentsList.length
        ) {
          return;
        }
        // Launch an animation job to snap the given parents to the candidate parents.
        given.parentsList.forEach(function(parent) {
          if (parent.toolRole === 'givenParent') parents.push(parent);
        });
        switch (candidate.kind) {
          case 'Straight':
          case 'Axis':
            if (parents.length !== 2)
              throw GSP.createError(
                'incorrect # of givenParent objects for a straight match.'
              );
            pLocs.push(given.geom.p0);
            pLocs.push(given.geom.p1);
            tLocs.push(candidate.geom.p0);
            tLocs.push(candidate.geom.p1);
            if (!given.isOfGenus('Ray') || !candidate.isOfGenus('Ray')) {
              // Only two rays must match order
              if (
                dist2(pLocs[0], tLocs[0]) + dist2(pLocs[1], tLocs[1]) >
                dist2(pLocs[0], tLocs[1]) + dist2(pLocs[1], tLocs[0])
              ) {
                tLocs.reverse();
              }
            }
            break;
          case 'Circle':
            if (candidate.constraint === 'CircleFromTwoPoints') {
              pLocs.push(given.parents.p0.geom.loc);
              pLocs.push(given.parents.p1.geom.loc);
              tLocs.push(candidate.parents.p0.geom.loc);
              tLocs.push(candidate.parents.p1.geom.loc);
            } else {
              // use the candidate geometry to scale the given radius point with respect to the given center
              pLocs.push(given.parents.p0.geom.loc); // center point of parent
              pLocs.push(given.parents.p1.geom.loc); // radius point of parent
              tLocs.push(candidate.geom.c); // target center point
              tLocs.push(
                tLocs[0].add(
                  pLocs[1]
                    .subtract(pLocs[0])
                    .multiply(candidate.geom.r / given.geom.r)
                )
              );
            }
            break;
          case 'Polygon':
            if (given.parentsList.length !== candidate.parentsList.length)
              throw GSP.createError(
                'incompatible polygons in doMatchAnimation().'
              );
            given.geom.points.forEach(function(element, ix) {
              pLocs.push(element);
              tLocs.push(candidate.geom.points[ix]);
            });
            break;
          case 'Arc':
            var a = candidate.geom.arc,
              dist,
              delta;
            if (given.constraint !== 'Arc3Points')
              throw GSP.createError('animatePathSnap: wrong arc constraint.');
            pLocs.push(given.parents.p0.geom.loc);
            pLocs.push(given.parents.p1.geom.loc);
            pLocs.push(given.parents.p2.geom.loc);
            tLocs.push(a.finalPoint); // Yes, the elements of geom.arc are labeled backwards!
            tLocs.push(a.middlePoint);
            dist = a.center.distance(a.initialPoint); // initialPoint (actually the final point) may not lie on the circle
            delta = a.initialPoint.subtract(a.center).multiply(a.radius / dist); // scale the distance to put it there
            tLocs.push(a.center.add(delta));
            break;
          default:
            throw GSP.createError('Unrecognized constructibleGiven');
        }
        given.setRenderState('matchedGiven');
        matchedGiven.isSnapping = true;
        doMatchAnimation();
        given.setRenderState(oldRenderState);
      }, // animatePathSnap

      startChasing: function(matchedGiven, touchPos) {
        // There's no mergeCandidate, so animate the given to touchPos
        // Returns adjustTargetPos() if chasing begins, or undefined otherwise
        // For a simple given, (point or param) just translate one point, the given.geom.loc.
        // For a constructibleGiven, touchDelta is the vector from touchPos to the corresponding point on the constructible path
        var regime = this,
          given = matchedGiven.given,
          constructible = given.toolRole === 'constructibleGiven',
          session = regime.toolplaySession,
          sketch = session.sketch,
          gobjArr = [], // One element for point or param. For constructible, first element is null, followed by givenParents.
          gLoc = [],
          tLoc = [], // The current and target locations for each gobj in gobjArr
          duration = 1000,
          kMinAnimDist = 10, // don't animate less than this distance
          maxDist,
          startTime,
          r,
          adjustedLoc,
          touchDelta,
          bounds,
          midPoint,
          retVal;

        function curLoc(g, t) {
          return g.multiply(1 - r).add(t.multiply(r));
        }

        function setTargetLocs() {
          var delta;
          if (constructible) {
            delta = adjustedLoc.subtract(tLoc[0]);
            tLoc[0] = adjustedLoc;
            gobjArr.forEach(function(gobj, ix) {
              tLoc[ix] = tLoc[ix].add(delta);
            });
          } else {
            // adjustedLoc is the new target for the animated point
            if (touchDelta) {
              tLoc[0] = adjustedLoc.add(touchDelta);
            } else {
              tLoc[0] = adjustedLoc;
            }
          }
          adjustedLoc = null;
        }

        function frame() {
          if (adjustedLoc) {
            setTargetLocs();
          }
          r = Math.min((Date.now() - startTime) / duration, 1);
          gobjArr.forEach(function(gobj, ix) {
            if (gobj) {
              // skips element 0 if constructible
              gobj.geom.loc = curLoc(gLoc[ix], tLoc[ix]);
              gobj.invalidateGeom();
            }
          });
          return r < 1;
        }

        function finished() {
          regime.chaseAnimationJob = null;
          if (r < 1) {
            matchedGiven.chase = 'paused';
            // Need to distinguish whether this pause comes about because the current matchedGiven has a new candidate,
            // or because there's a new touch, leaving the current matchedGiven short of its goal.
            // In the first case we do nothing; in the second we jump to the end frame.
          } else {
            frame();
            matchedGiven.chase = 'finished';
            if (matchedGiven.mergeCandidate) {
              matchedGiven.snapToCandidate();
            }
          }
          regime.confirmToolWhenReady(); // The tool may be ready to finish, holding off until the animation ends.
        }

        function doChaseAnimation() {
          matchedGiven.chase = 'active';
          matchedGiven.deltaToGiven = GSP.GeometricPoint(0, 0);
          duration = regime.animateMatching ? 1000 : 1;
          startTime = Date.now();
          r = 0;
          regime.chaseAnimationJob = sketch.jobScheduler.addJob(frame, {
            done: finished,
            delay: 20,
            repeat: true,
          });
        }

        function adjustTargetPos(newLoc) {
          adjustedLoc = newLoc;
        }

        // Body of startChasing
        // The given chases the touch only if the touch isn't already on the given.
        if (constructible) {
          if (!this.pointInRegion(touchPos, given))
            touchDelta = touchPos.subtract(
              given.mapPositionToPathPosition(touchPos)
            );
        } else {
          bounds = given.getGeomBounds();
          if (!GSP.Geom.PointInRect(touchPos, bounds)) {
            midPoint = GSP.GeometricPoint(
              (bounds.left + bounds.right) / 2,
              (bounds.top + bounds.bottom) / 2
            );
            touchDelta = given.geom.loc.subtract(midPoint);
          }
        }
        if (touchDelta) {
          // touch is off the given, so the given should chase it.
          if (constructible) {
            tLoc[0] = touchPos;
            gLoc[0] = touchPos.add(touchDelta);
            given.parentsList.forEach(function(parent, ix) {
              gobjArr[ix + 1] = parent;
              gLoc[ix + 1] = parent.geom.loc;
              tLoc[ix + 1] = gLoc[ix + 1].add(touchDelta);
            });
          } else {
            tLoc[0] = touchPos.add(touchDelta);
            gobjArr[0] = given;
            gLoc[0] = GSP.GeometricPoint(given.geom.loc.x, given.geom.loc.y);
          }
          maxDist = Math.max(
            Math.abs(gLoc[0].x - tLoc[0].x),
            Math.abs(gLoc[0].y - tLoc[0].y)
          );
          if (maxDist > kMinAnimDist) {
            doChaseAnimation();
            retVal = adjustTargetPos;
          }
        }
        return retVal;
      }, // startChasing

      clearAnimations: function() {
        if (this.pathAnimationJob) {
          // abort any existing animation
          this.toolplaySession.sketch.jobScheduler.clearJob(
            this.pathAnimationJob
          );
          this.pathAnimationJob = null;
        }
        if (this.chaseAnimationJob) {
          this.toolplaySession.sketch.jobScheduler.clearJob(
            this.chaseAnimationJob
          );
          this.chaseAnimationJob = null;
        }
        this.confirmToolWhenReady(); // clearing an animation might confirm the tool
      },

      confirmToolWhenReady: function() {
        var toolDone =
          this.sharedUnmatchedGivens.length === 0 &&
          this.touchesDownOnGivens === 0;
        if (toolDone && this.toolplaySession) {
          if (!this.pathAnimationJob && !this.chaseAnimationJob) {
            this.toolplaySession.sketch.toolController.confirmActiveTool();
          }
        }
        return toolDone;
      },

      confirmActiveTool: function(sketchWasModifiedCallback) {
        var calcPresent; // Look for a blank calculation that needs the Calculator displayed
        this.sharedUnmatchedGivens.every(function(given) {
          if (given.constraint === 'Calculation' && given.expression === '') {
            calcPresent = given;
          }
          return !calcPresent;
        });
        if (!calcPresent) {
          // It appears the intent here was to show the Calculator when a blank calculation in the tool
          // is merged to a non-blank existing calculation in the sketch. But this never happens,
          // because by the time this code is implemented the given calc has been snapped to the
          // candidate, so they both have the same expression. The result is that this code shows
          // the Calculator only if the match candidate already in the sketch is blank.
          // It's not clear what function this serves.
          this.toolplaySession.matchedGivens.every(function(match) {
            var given = match.given,
              candidate = match.mergeCandidate;
            if (given.constraint === 'Calculation' && given.expression === '') {
              calcPresent = given;
              if (candidate && candidate.constraint === 'Calculation') {
                calcPresent = candidate;
              }
            }
            return !calcPresent;
          });
        }
        this.toolplaySession.confirmPlayback(calcPresent);
        this.toolplaySession = null;
        sketchWasModifiedCallback(true);
      },

      doCleanup: function() {
        //If we still have a toolplay session, we need to abort and clean it up
        if (this.toolplaySession) {
          this.sharedUnmatchedGivens.forEach(function(given) {
            given.setRenderState('none'); // cancel pulse job
          });
          this.sharedUnmatchedGivens = null;
          this.toolplaySession.abortPlayback();
          this.toolplaySession = null;
          this.sharedMergeCandidateList = null;
        }
      },
    }); // regimeProto

    /**
     * Given an array of givens (in spec form), determine positions for
     * all point givens in the passed in sketch.
     *
     * @param givenArray
     * @param sketch
     * @returns {Object} where key is the given id and value is the position
     */
    function positionsForGivens(givenArray, sketch) {
      //First filter to just point givens.  Others are autoplaced
      var pointGivens = givenArray.filter(function(given) {
        return given.kind === 'Point';
      });
      var sketchRect = sketch.metadata.sketchRect;
      //then extract the locations into their own array, copied so we
      //don't pollute the original tool spec
      var locs = pointGivens.map(function(given) {
        var loc = {
          x: given.geom.loc.x + sketchRect.left,
          y: given.geom.loc.y + sketchRect.top,
        };
        return loc;
      });

      //Bounding rect is the rect encompassing all givens.  We will
      //ensure all givens are always placed on the screen.
      var boundingRect = GSP.Geom.boundingRect(locs);

      var existingPointPositionHash = {};

      //utility for collapsing a loc into a hash
      function locHash(loc) {
        return '' + loc.x + '+' + loc.y;
      }

      //Now, build a hash table of all existing points in the sketch keyed
      //by locHash
      sketch.eachGObj(function(index, gobj) {
        if (gobj.kind === 'Point' && !gobj.style.hidden) {
          existingPointPositionHash[locHash(gobj.geom.loc)] = true;
        }
      });

      function locIsAvailable(loc) {
        return existingPointPositionHash[locHash(loc)] === undefined;
      }

      //Constants:
      var kShiftAmt = 25;
      var kBorder = 10;

      var sketchRectWidth = sketchRect.right - sketchRect.left;
      var sketchRectHeight = sketchRect.bottom - sketchRect.top;
      var boundingRectWidth = boundingRect.right - boundingRect.left;
      var boundingRectHeight = boundingRect.bottom - boundingRect.top;

      //If we wrap more than twice in both directions - we give up
      var xWrapCount = 0;
      var yWrapCount = 0;

      //Utility responsible for actually shifting the locs and the bounding rect.
      //It also updates the x and y wrap count variables via closure.
      function shiftLocs(locs) {
        var shiftX = kShiftAmt;
        var shiftY = kShiftAmt;

        if (boundingRect.right + shiftX + kBorder > sketchRect.right) {
          shiftX -= sketchRectWidth - (boundingRectWidth + kBorder * 2);
          xWrapCount++;
        }

        if (boundingRect.bottom + shiftY + kBorder > sketchRect.bottom) {
          shiftY -= sketchRectHeight - (boundingRectHeight + kBorder * 2);
          yWrapCount++;
        }

        boundingRect.left += shiftX;
        boundingRect.right += shiftX;
        boundingRect.top += shiftY;
        boundingRect.bottom += shiftY;

        locs.forEach(function(loc) {
          loc.x += shiftX;
          loc.y += shiftY;
        });
      }

      var found = false;

      //Actual algorithm: If every given's location is available, we're
      //done.  Otherwise, shift and try again.  Keep trying until we've
      //wrapped too many times.
      while (!found) {
        found = locs.every(locIsAvailable);

        if (xWrapCount >= 2 && yWrapCount >= 2) {
          break;
        }
        if (!found) {
          shiftLocs(locs);
        }
      }

      //If we gave up - we'll just shift by a random amt and call it good
      if (!found) {
        var randomX = Math.random() * kShiftAmt;
        var randomY = Math.random() * kShiftAmt;
        locs.forEach(function(loc) {
          loc.x += randomX;
          loc.y += randomY;
        });
      }
      var ret = {};
      //Now build an object keyed by id of the results
      for (var i = 0; i < pointGivens.length; ++i) {
        ret[pointGivens[i].id] = locs[i];
      }
      return ret;
    }

    function actOnSingleGiven(givenGObj, sketch) {
      givenGObj.presentUI(function(result) {
        if (result === 'changesAccepted') {
          sketch.toolController.confirmActiveTool();
        } else {
          sketch.toolController.abortActiveTool();
        }
      });
    }

    // For sorting
    function compareGivens(given0, given1) {
      var firstHasSortOrder = GSP.isNumber(given0.givenSortOrder),
        secondHasSortOrder = GSP.isNumber(given1.givenSortOrder);

      if (firstHasSortOrder && secondHasSortOrder) {
        return GSP.compare(given0.givenSortOrder, given1.givenSortOrder);
      } else if (firstHasSortOrder) {
        return -1;
      } else if (secondHasSortOrder) {
        return 1;
      }
      // No explicit sort order, so order the givens into a sequence based on their labels.
      // Instead of lexical, use a "natural sort" so that given2 comes before given10.
      var label0 = given0.label === undefined ? '' : given0.label,
        label1 = given1.label === undefined ? '' : given1.label;
      return GSP.naturalSortCaseInsensitive(label0, label1);
    }

    return {
      createWithTool: function(sketch, tool) {
        // Play the tool objects into the sketch, positioned appropriately.
        // Sort the tool objects into four categories: unmatchedGivens that the user needs to match,
        // cachedParents of constructibles, constructibles, and cachedConstructibles
        var session = tool.createSession(sketch),
          mergeCandidateList = [],
          given,
          givenInSketch,
          unmatchedGivens = [],
          cachedParents = [],
          constructibles = [],
          cachedConstructibles = [],
          givenArray = session.givenArray,
          ret = Object.create(regimeProto),
          shouldPresentEditUI =
            givenArray.length === 1 && session.objectGraph.length === 1;
        session.playAssumeds();
        ret.sequentialSnapping = sketch.getAuthorPreference(
          'sequentialSnapping'
        );
        ret.animateMatching = sketch.getAuthorPreference('animateToolMatching');
        sketch.gobjList.renderList.forEach(function(item) {
          var order = item.style.layerOrder;
          if (!item.style.hidden) {
            // Hidden gobjs are not merge candidates
            mergeCandidateList.push(item);
          }
          if (order && order >= session.nextLayerOrder) {
            session.nextLayerOrder = order + 1; // track highest value to put tool interiors/images in front
          }
        });
        var positions = positionsForGivens(givenArray, sketch); // a constructible given must be constrained by its givenParent objects, as it's played into the sketch
        var pos;
        given = session.getNextGiven();
        while (given) {
          // Assemble an array of unmatched givens, including cachedParents and constructibleGivens
          if (given.toolRole === 'constructibleGiven') {
            givenInSketch = sketch.gobjList.gobjects[given.id];
          } else {
            pos = positions[
              given.id
            ] || // Remember the initial position of non-point givens, for relative positioning.
            { x: given.geom.loc.x, y: given.geom.loc.y };
            givenInSketch = session.playGiven(given, pos, true);
          }
          unmatchedGivens.push(givenInSketch);
          givenInSketch.setRenderState(
            ret.sequentialSnapping ? 'matchedGiven' : 'unmatchedGiven'
          );
          given = session.getNextGiven();
        }
        unmatchedGivens.sort(compareGivens);
        //  For each constructibleGiven, remove either its givenParents (to cachedGivenParents)
        //  or the constructibleGiven (to cachedConstructibles). Base the decision on the givenSortOrder
        //  values of these objects. If none have givenSortOrder values, keep the constructible.
        constructibles = unmatchedGivens.filter(function(gobj) {
          return gobj.toolRole === 'constructibleGiven';
        });
        constructibles.forEach(function(cGobj) {
          // check one constructible (c) and its parents (p).
          var cIx = unmatchedGivens.indexOf(cGobj),
            cSort = cGobj.givenSortOrder,
            cKeep = true, // the default unless a parent has a lower givenSortOrder
            pSort;
          cSort = cSort ? cSort : Infinity;
          cGobj.parentsList.forEach(function(pGobj) {
            pSort = pGobj.givenSortOrder;
            if (pSort && pSort < cSort) {
              cKeep = false;
              return;
            }
          });
          if (cKeep) {
            // cache the parents
            cGobj.parentsList.forEach(function(pGobj) {
              var pIx = unmatchedGivens.indexOf(pGobj);
              cachedParents.push(pGobj);
              unmatchedGivens.splice(pIx, 1);
            });
          } else {
            cachedConstructibles.push(cGobj);
            unmatchedGivens.splice(cIx, 1);
          }
        });
        session.setRelativePositions();
        if (ret.sequentialSnapping) {
          unmatchedGivens.sort(compareGivens);
          if (unmatchedGivens[0]) {
            unmatchedGivens[0].setRenderState('unmatchedGiven');
          }
        }
        ret.toolplaySession = session;
        ret.sharedUnmatchedGivens = unmatchedGivens;
        ret.cachedGivenParents = cachedParents;
        ret.cachedConstructibles = cachedConstructibles;
        ret.sharedMergeCandidateList = mergeCandidateList;
        ret.touchesDownOnGivens = 0;
        // when shouldPresentEditUI, givenInSketch will be the only given.
        if (shouldPresentEditUI) actOnSingleGiven(givenInSketch, sketch);
        return ret;
      },
    };
  })(); // GSP.ToolRegime

  /**
   * @preserve (C) KCP Technologies, 2014.
   */

  GSP.LabelRegime = (function() {
    var trackerProto = GSP.makeClass([GSP.AbstractToolTracker], {
      // We are not placing a given, so no need to snap to coordsys grid.
      shouldSnap: function() {
        return false;
      },

      touchBegan: function(pos) {
        var dragPos = GSP.GeometricPoint(pos.x, pos.y);

        this.possibleTargets = this.sketch.gobjList.renderList.filter(function(
          g
        ) {
          return g.canEditLabel();
        });

        this.dragTracker = GSP.DragTracker.create([this.labelIcon]);
        this.dragTracker.touchBegan(dragPos);
        this.touchMoved(pos);
      },
      touchMoved: function(pos) {
        var snappedPos,
          geomPos = GSP.GeometricPoint(pos.x, pos.y);

        this.setToolTarget(this.findToolTarget(this.sketch, pos));

        snappedPos = this.getSnappedPosition(geomPos);

        if (snappedPos) {
          this.dragTracker.touchMoved(snappedPos);
        }
      },
      touchEnded: function(pos, touch) {
        if (this.dragTracker) {
          this.dragTracker.touchEnded();
        }

        if (!this.toolTarget) return;

        this.toolTarget.setRenderState('none');

        this.regime.toolTarget = this.toolTarget;
        this.sketch.toolController.confirmActiveTool();
      },
      clearToolTarget: function() {
        if (this.toolTarget) {
          this.toolTarget.setRenderState('none');
          this.toolTarget = null;
        }
      },
      setToolTarget: function(toolTarget) {
        if (toolTarget === this.toolTarget) return;
        this.clearToolTarget();
        if (toolTarget) {
          this.toolTarget = toolTarget;
          toolTarget.setRenderState('targetHighlit');
        }
      },
      getSnappedPosition: function(geomPos) {
        return this.toolTarget ? this.toolTarget.geom.loc : geomPos;
      },
    });

    var regimeProto = GSP.makeClass(GSP.AbstractToolRegime, {
      name: 'LabelRegime',

      blocksOtherButtons: function() {
        return !!this.inModalDialog;
      },

      createTracker: function(touch, position) {
        var sketch = this.sketch,
          ret;

        // Disable all touches if we've gone modal.
        if (this.inModalDialog) return null;

        GSP.blurDocumentActiveElement(sketch.baseNode);

        ret = Object.create(trackerProto);

        ret.sketch = sketch;
        ret.labelIcon = this.labelIcon;
        ret.hitSlop = this.hitSlopForTouch(touch);
        ret.regime = this;

        if (this.sequentialSnapping) {
          ret.labelIcon.geom.loc = GSP.GeometricPoint(position.x, position.y);
          ret.labelIcon.invalidateGeom();
        }

        return ret;
      },

      addInputModal: function(options) {
        var $canvasParent = this.sketch.canvasNode.parent(),
          regime = this,
          target = options.target,
          onAccept = options.onAccept,
          onCancel = options.onCancel;

        function wrapperElt() {
          return $('.wsp-label-edit', $canvasParent);
        }
        function okElt() {
          return $('.wsp-label-edit-ok', wrapperElt());
        }
        function cancelElt() {
          return $('.wsp-label-edit-cancel', wrapperElt());
        }
        function inputElt() {
          return $('.wsp-label-edit-text', wrapperElt());
        }

        function showLabelElt() {
          return $('input[type="checkbox"]', wrapperElt());
        }

        // If we are adding a new label to an object for the first time,
        // go ahead and check the "Show Label" checkbox. Otherwise, the
        // checkbox reflects the current showLabel preference.
        function showLabelShouldBeChecked() {
          return (
            !target.labelExists() ||
            (target.style.label && target.style.label.showLabel)
          );
        }

        function addElement() {
          var $wrapper, $input, $ok, $cancel, $bottom;

          if (wrapperElt().length !== 0) return;

          $wrapper = $('<div class="wsp-label-edit"></div>').css({
            position: 'absolute',
            left: '20px',
            top: '10px',
          });
          $ok = $('<button class="wsp-label-edit-ok">ok</button>');
          $cancel = $('<button class="wsp-label-edit-cancel">cancel</button>');
          $input = $('<input class="wsp-label-edit-text"></input>').css({
            width: '300px',
          });
          $input.appendTo(
            $('<div><span>Label: </span></div>').appendTo($wrapper)
          );
          $bottom = $('<div/>');
          $('<label><input type="checkbox"/>Show Label</label>').appendTo(
            $bottom
          );
          // Insert Ok before cancel, so it floats all the way to the right.
          $ok.appendTo($bottom);
          $cancel.appendTo($bottom);
          $bottom.appendTo($wrapper);
          $wrapper.appendTo($canvasParent);
          GSP.FastClick.attach($wrapper[0]);
          $wrapper.hide();
        }

        function cleanUp() {
          wrapperElt().hide();
          okElt().off();
          cancelElt().off();
          inputElt().off();
          inputElt().blur();
        }

        function accept() {
          cleanUp();
          onAccept(inputElt().val(), showLabelElt().prop('checked'));
          // Make label pool ready for next label
          regime.sketch.labelPool.forgetSavedState();
        }

        function cancel() {
          cleanUp();
          onCancel();
          // Reset label pool to how it was before label editor
          regime.sketch.labelPool.restoreSavedState();
        }

        function showEditor() {
          regime.inModalDialog = true; // Never becomes false because
          // the regime goes away when the
          // editor is dismissed.
          wrapperElt().show();
          showLabelElt().prop('checked', showLabelShouldBeChecked());
          okElt().on('click', accept);
          cancelElt().on('click', cancel);
          regime.sketch.labelPool.saveState();
          inputElt().val(
            target.label ||
              regime.sketch.labelPool.generateLabel(target.kind, target.genus)
          );
          inputElt().focus();
          // select() doesn't select text in ios, so we use setSelectionRange.
          // See http://stackoverflow.com/a/7436574
          inputElt()[0].setSelectionRange(0, inputElt().val().length);

          inputElt().on('keyup', function(e) {
            if (e.keyCode === 13) {
              accept();
            }
            // Before I put this in, the soft keyboard on ios was losing focus after typing.
            e.stopPropagation();
          });

          // modal prevents blurs - keep focus this way
          inputElt().on('blur', function() {
            inputElt().focus();
            return false;
          });
        }

        addElement();
        showEditor();
      },

      // Invoked by controller when regime is popped. No need to call it elsewhere!
      doCleanup: function() {
        if (this.toolTarget) this.toolTarget.setRenderState('none');
        var removeThis = {};
        removeThis[this.labelIcon.id] = this.labelIcon;
        this.sketch.gobjList.removeGObjects(removeThis, this.sketch);
      },

      confirmActiveTool: function(sketchWasModifiedCallback) {
        var target = this.toolTarget,
          regime = this;

        function done(sketchWasModified) {
          sketchWasModifiedCallback(sketchWasModified);
        }

        function showModalLabelEditor() {
          regime.addInputModal({
            target: target,
            onCancel: function() {
              done(false);
            },
            onAccept: function(newLabel, showLabel) {
              if (newLabel === '') {
                // Never set a label to the empty string, because this
                // can confuse children who depend on the label. Just hide it.
                target.hideExistingLabel();
              } else {
                target.setLabel(newLabel, {
                  show: showLabel,
                  wasUserInitiated: true,
                });
              }

              done(true);
            },
          });
        }

        if (target) {
          if (!target.canEditLabel())
            throw GSP.createError('invalid label target');
          showModalLabelEditor();
        } else {
          done(false);
        }
      },

      confirmToolWhenReady: function() {
        return false;
      },
    });

    return {
      createWithTool: function(sketch, tool) {
        function createIcon() {
          var spec = {
            kind: 'Text',
            genus: 'Caption',
            constraint: 'Free',
            geom: {
              loc: {},
            },
            textMFS: "<VL<T'A'>>",
            style: {
              'font-size': 24,
              'font-weight': 'bold',
              'font-family': 'Times New Roman',
              'font-style': 'normal',
              'text-decoration': 'none',
              'letter-spacing': 'none',
              color: '#2052f3',
            },
          };
          var sketchCenter = sketch.getCenterPoint();
          var sketchGraph = sketch.gobjList.constraintList;
          var nextIndex = '' + GSP.ObjectGraph.getNextFreeIdNumber(sketchGraph);
          var theGivenToAdd = {},
            icon = null;
          spec.geom.loc.x = sketchCenter.x;
          spec.geom.loc.y = sketchCenter.y;
          theGivenToAdd[nextIndex] = spec;
          icon = sketch.constructGObjects(theGivenToAdd, {
            forceConstrain: true,
          })[nextIndex];
          icon.setRenderState('fancyPulse');
          return icon;
        }

        var ret = Object.create(regimeProto);
        ret.sketch = sketch;
        ret.labelIcon = createIcon();
        ret.sequentialSnapping = sketch.getAuthorPreference(
          'sequentialSnapping'
        );
        return ret;
      },
      createForGObject: function(sketch, gobj) {
        var ret = Object.create(regimeProto);
        ret.sketch = sketch;
        ret.toolTarget = gobj;
        ret.inModalDialog = true; // Immediately blocks other buttons
        return ret;
      },
    };
  })();

  /**
   * @fileOverview Regime for clicking parent expressions to add to
   * child expressions.
   * @author <a href="mailto:lyn.headley@mheducation.com">Lyn Headley</a>
   * @version 0.0
   *
   * @preserve (C) KCP Technologies, 2014.
   */

  GSP.BackClickRegime = (function() {
    function hasSingleCandidateParent(gobj) {
      var i, parent, candidate;
      for (i = 0; i < gobj.parentsList.length; i++) {
        parent = gobj.parentsList[i];
        if (validBackClickGObj(parent)) {
          if (candidate) return false;
          else candidate = parent;
        }
      }
      return candidate;
    }

    function validBackClickGObj(gobj) {
      // returns the valid gobj, or null if invalid
      var retVal = null;
      if (gobj) {
        if (
          (gobj.isOfKind('Measure') || gobj.isOfKind('Expression')) &&
          // Avoid invisibles: If the gobj is invisible, then we are in
          // toolplay, and it is a given matched to a preexisting merge
          // candidate. Never permit backClicking on these, because they
          // are either a kind of self-reference (in case we are editing
          // the matched candidate -- WSP-2016), or else they are not,
          // and we can just hit the different, visible candidate.
          gobj.state.renderState !== 'invisible'
        ) {
          retVal = gobj;
        } else if (
          gobj.constraint === 'CompositeText' &&
          hasSingleCandidateParent(gobj)
        ) {
          // Even if more parents, if only one is a measure, the composite works.
          retVal = hasSingleCandidateParent(gobj);
        } else if (
          gobj.constraint === 'Pegged' &&
          gobj.parentsList.length === 2 &&
          gobj.parents.text
        ) {
          retVal = validBackClickGObj(gobj.parents.text);
        }
      }
      return retVal;
    }

    /**
     * Find a valid hit for the calculator
     *
     * @param {Object} sketch
     * @param {Object} underEdit: The object being edited
     * @param {Object} pos: The location of the hit
     * @param {Integer} hitSlop: The half-width of the square to be checked
     * @returns {Object}: {gobj (the object actually hit), valid (the object to be used in the calculation)}
     * Two objects are returned, which are in most cases the same object.
     * We return both because a CompositeText object displaying a single value can be hit.
     * In this case we return the value parent for use in actual calculations,
     * and the CompositeText gobj because it may have text parents that are not parents
     * of the value parent, but that need to be displayed in the calculation.
     */
    function findHitParent(sketch, underEdit, pos, hitSlop) {
      var hitTest,
        options = {
          hotSpot: pos,
          /*
           * This is a touch hit filter that ignores the touch if
           * parent is identical to underEdit or parent is a descendant of
           * underEdit.
           *
           * @param {Object} parent - a candidate parent of underEdit.
           */
          filter: function canBeParent(parent) {
            var given;
            function checkDescendants(childDescendant) {
              var i;
              if (parent === childDescendant) {
                return false;
              }
              if (
                childDescendant.children === undefined ||
                childDescendant.children.length === 0
              ) {
                return true;
              }
              for (i = 0; i < childDescendant.children.length; i++) {
                if (!checkDescendants(childDescendant.children[i])) {
                  return false;
                }
              }
              return true;
            }
            if (!validBackClickGObj(parent)) {
              return false;
            }
            if (!checkDescendants(underEdit)) return false;
            // Are we in toolplay, editing a matched given? If so,
            // underEdit is the preexisting gobj, but we need to
            // disallow backclicking on the given's children, too.
            given = sketch.getGivenMatchedToCandidate(underEdit);
            if (given) {
              return checkDescendants(given);
            }
            return true;
          },
        };

      hitTest = sketch.hitGObj(
        {
          left: pos.x - hitSlop,
          top: pos.y - hitSlop,
          bottom: pos.y + hitSlop,
          right: pos.x + hitSlop,
        },
        options
      );
      // In case the hitGObj and valid gobj are different, return both.
      return hitTest
        ? {
            labelGObj: hitTest.hitGObj,
            valueGObj: validBackClickGObj(hitTest.hitGObj),
          }
        : null;
    }

    var trackerProto = GSP.makeClass(GSP.TouchTracker, {
      /*
       * This implements back-clicking logic. If a suitable candidate
       * parent is hit, we ask the currently focused editor to insert it
       * into its expression.
       *
       * @param {Object} pos - A touch position.
       */
      touchBegan: function(pos) {
        var sketch = this.regime.sketch,
          child = this.regime.editor.gobj,
          editor = this.regime.editor,
          hit = findHitParent(sketch, child, pos, this.hitSlop), //handle both the actual gobj and valid hit.
          hitParent = (this.hitParent = hit.valueGObj);

        if (hitParent) {
          editor.insertParent(hitParent);
          if (hit.labelGObj !== hit.valueGObj) {
            // hit.gobj may have needed label parents.
            if (editor.labelParents.indexOf(hit) < 0) {
              editor.labelParents.push(hit);
            }
          }
          this.lastRenderState = hitParent.state.renderState;
          hitParent.setRenderState('targetHighlit');
          hitParent.invalidateAppearance();
        }
      },
      touchMoved: function(pos) {},
      touchEnded: function() {
        var hitParent = this.hitParent,
          tracker = this;

        if (hitParent) {
          this.regime.sketch.jobScheduler.addJob(
            function() {
              hitParent.setRenderState(tracker.lastRenderState);
            },
            { delay: 90 }
          );
        }
      },
    });

    var regimeProto = GSP.makeClass(GSP.TouchRegime, {
      name: 'BackClickRegime',
      createTracker: function(touch /*, position */) {
        var ret = Object.create(trackerProto);
        ret.regime = this;
        ret.hitSlop = this.hitSlopForTouch(touch);
        return ret;
      },
      blocksOtherButtons: function() {
        return true;
      },
    });

    return {
      createWithEditor: function(editor) {
        var ret = Object.create(regimeProto);
        ret.editor = editor;
        ret.sketch = editor.gobj.sQuery.sketch;
        return ret;
      },
    };
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A kind is a primitive object type in Web Sketchpad.
   * @class kind
   * Instances can be loaded
   * from a sketch specification. These are model elements. Some subclasses of
   * this class describe geometric primitives, such as points, circles, and
   * straight lines. Some are numeric primitives and some algebraic. Still others
   * function to document the sketch and some are control elements such as toggles
   * and buttons.
   *
   * Kind subclasses exist independently of their representation in the UI.
   * Instances of kind are combined with constraints to form gobjects.
   */
  GSP.gObjects.Kind = {
    doc: {
      description: 'All Kinds have the following properties.',
      refspec: {},
      supported: true,
      properties: {
        kind: {
          description: 'Kind of GObject.',
          required: true,
          type: 'Name',
        },
        constraint: {
          description: 'Name of constraint governing geometry of the GObject.',
          required: true,
          type: 'Name',
        },
        genus: {
          description: 'Genus of GObject',
          required: true,
          type: 'Name',
        },
        toolRole: {
          description:
            "If this object is part of a tool, it may have a special role during playback(such as 'given' or 'assumed').",
          required: false,
          type: 'String',
        },
        label: {
          description:
            'Text that may be used to name an object. Not required to be unique.',
          required: false,
          type: 'String',
        },
        shouldAutogenerateLabel: {
          description: 'Whether the object should autogenerate its label',
          default: false,
          type: 'Boolean',
        },
        latentVisibility: {
          description:
            'True if this object might become visibile, even if currently hidden. The standard export process will set this if the object has a show (or show/hide) button that might show it.',
          required: false,
          type: 'Boolean',
        },
        style: {
          description:
            'Properties that influence the appearance of a GObject. Generally, these properties do not affect the placement of the object in the plane, nor the placement of other, dependent, objects.',
          properties: {
            color: {
              description: 'Foreground color of the GObject.',
              type: 'Color',
              required: false,
            },
            hidden: {
              description: 'Whether the GObject is hidden.',
              type: 'Boolean',
            },
            selectable: {
              description: 'Whether the GObject is draggable.',
              type: 'Boolean',
            },
            'text-align': {
              description:
                "The basis alignment (left, center, right) with respect to the text's bounding box for the text in this GObject.",
              type: 'TextAlign',
            },
            traced: {
              description: 'Whether the GObject should be traced.',
              type: 'Boolean',
              required: false,
            },
          },
        },
        description: {
          description:
            'a description of the role of the gobject in the sketch.',
          required: false,
          type: 'String',
        },
      },
    },

    shouldAutogenerateLabel: false,

    /**
      Called before the object is to be serialized.
      Derived classes may override to perform any required synchronization.
     */
    prepareToSerialize: function() {},

    /**
     * Flattens the current form of the gobject into a simple
     * spec object.  Uses documentation as a guide for what properties
     * to export.  Also styles that match the default style are skipped.
     *
     * @returns {Object}
     */
    toSpecObj: function() {
      var self = this;

      function makeParents(parents) {
        var newObj = {};
        $.each(parents, function(k, v) {
          newObj[k] = v.id;
        });
        return newObj;
      }
      //Given an object and a base object, create an object that contains
      //new or changed values from the base one.
      function unextend(object, baseObject) {
        var ret = {};

        $.each(object, function(key, value) {
          if (baseObject[key] !== value) {
            if (typeof value === 'object') {
              ret[key] = $.extend(true, {}, value);
            } else {
              ret[key] = value;
            }
          }
        });
        return ret;
      }

      function makeStyle(style, props) {
        var defaultStyle = self.createDefaultStyle(),
          ret;

        ret = unextend(style, defaultStyle);

        //Prune properties that are explicitly defined as suppressed in the gobj
        //(In a perfect world, we could just rely on whether they are documented,
        //but styles are historically very poorly documented (and there are also
        //tricky situations around generic kind/constraints that depend on their
        //parents, eg iterated images which make documentation a challenge), so
        //we only search for and remove explicitly suppressed style properties)
        $.each(ret, function(key /*, value */) {
          var prop;
          if (props.hasOwnProperty(key)) {
            prop = props[key];

            if (prop.suppressed) {
              delete ret[key];
            }
          }
        });

        if (style.label) {
          ret.label = unextend(style.label, defaultStyle.label);
          if ($.isEmptyObject(ret.label)) {
            delete ret.label;
          }
        }

        if ($.isEmptyObject(ret)) {
          //Don't return an empty object
          return;
        }

        return ret;
      }

      function makeObj(o, props) {
        var jprops = {};
        $.each(o, function(key, value) {
          var prop;
          if (props.hasOwnProperty(key)) {
            prop = props[key];

            if (prop.suppressed) {
              //This property should be ignored
              return;
            }

            if (prop['default'] !== undefined && prop['default'] === value) {
              //The value equals the documented default value - don't write it out
              return;
            }

            // initialized parent keys in the original document
            // have been replaced by object references. Restore the
            // keys
            if (key === 'parents') {
              jprops[key] = makeParents(value);
            } else if (key === 'style') {
              jprops[key] = makeStyle(value, prop.properties);
            } else if (key === 'autostart') {
              // autostart property is disabled.
              jprops[key] = false;
            } else if (prop.properties) {
              // recurse into subobjects
              jprops[key] = makeObj(value, prop.properties);
            } else if (typeof value === 'string') {
              jprops[key] = value;
            } else if (typeof value === 'number') {
              jprops[key] = value;
            } else if (typeof value === 'boolean') {
              jprops[key] = value;
            } else if (prop.type === 'Array') {
              jprops[key] = value.slice();
            } else {
              GSP.log('Omitted ' + key);
            }
          }
        });
        return jprops;
      }
      this.prepareToSerialize();
      return makeObj(this, this.doc.properties);
    },
    toString: function() {
      function makeJSON(o, props) {
        var jprops = [],
          key,
          keyString,
          value,
          prop;
        for (key in o) {
          if (o.hasOwnProperty(key)) {
            prop = props[key];
            value = o[key];
            if (typeof prop !== 'undefined') {
              keyString = '"' + key + '":';
              if (prop.properties) {
                jprops.push(keyString + makeJSON(value, prop.properties));
              } else if (typeof value === 'string') {
                jprops.push(keyString + '"' + value + '"');
              } else if (typeof value === 'number') {
                jprops.push(keyString + value);
              } else if (typeof value === 'boolean') {
                jprops.push(keyString + value);
              }
            }
          }
        }
        return '{' + jprops.join() + '}';
      }
      return makeJSON(this, this.doc.properties);
    },
    /**
     * The kind of gobject we are.
     * @type {string}
     */
    kind: 'kind',
    constraint: 'constraint',
    /**
     * The genus of gobject we are.
     * @type {string}
     */
    genus: 'genus',
    /**
     * Associative array of properties affecting the appearance of the object.
     * @type {object}
     */
    style: {
      hidden: false,
      selectable: true,
      'text-align': 'center',
    },
    /**
     * Transient properties of the object
     * @type {object}
     */
    state: {
      exists: true,
      // selectable: true,  // SS: my search of the code could find no use of this key-value pair; all it does is introduce potential confusion with style.selectable.
      constraintFrame: 0, // constraintFrame at last GObject constraint request.
      supported: true /* false if this gobj or a parental ancestor is not supported */,
    },
    /**
     * Whether this object kind can be annotated with a label.
     */
    hasLabel: false,

    /** The current geometry of the object. */
    children: [],
    geom: {},
    labelSpec: {},

    htmlNode: '',

    /**
     * Returns the state of the math italicization preference.
     * May return undefined if the preference does not exist.
     *  @returns  {Boolean}
     */
    getMathItalicization: function() {
      var prefs = this.sQuery.sketch.preferences,
        textPrefs = prefs && prefs.text,
        mathItalicization = textPrefs && textPrefs.mathItalicization;
      return mathItalicization;
    },

    // Tables use their colorableComponent's "color" property to mean
    // border-color. This is a hook for transforming the property name
    // of that property into "border-color" as we set up the Gobject's
    // style property.
    createDefaultColorStyle: function(colorableComponentPrefs) {
      return colorableComponentPrefs;
    },

    /**
     * Create a default style for the object
     * Generally this uses the gobjects colorable component
     * and / or its textType to construct the style from preferences.
     */
    createDefaultStyle: function() {
      var colorableComponent = this.getColorableComponent(),
        textType = this.getTextType(),
        prefs = this.sQuery.sketch.preferences,
        style;

      //Start with the original style found in this gobj's prototype
      style = $.extend(
        true,
        {},
        GSP.gobjPrototype(this.kind, this.constraint).style
      );

      // First set the basic color from colorableComponents
      if (colorableComponent) {
        $.extend(
          true,
          style,
          this.createDefaultColorStyle(
            prefs.colorableComponents[colorableComponent]
          )
        );
      }

      // if label, start with the default label style
      if (this.hasLabel) {
        if (!style.label) {
          style.label = {};
        }
        $.extend(true, style.label, prefs.text.textTypes.Label);
      }

      // Then overlay any text properties with textType
      // (which can override the color and/or label)
      if (textType) {
        $.extend(true, style, prefs.text.textTypes[textType]);
      }

      return style;
    },

    /**
     * Instantiate the gobject after it's been deserialized from JSON spec.
     * Here is where dumb data can be turned into javascript objects (e.g. GeometricPoint)
     */
    doPostReadFromSpec: function doPostReadFromSpec() {
      var defaultStyle = this.createDefaultStyle();

      //Override default style from spec
      this.style = $.extend(true, defaultStyle, this.style);
    },
    /**
     * Used in determining support for a given spec obj in cases where the kind is supported in general, but certain
     * spec objects within that kind may not be supported.  Should be overridden in that case to return an appropriate value
     * given the specObj
     *
     * @param specObj
     * @param specObjects - the rest of the objects in the spec - may be required to inspect parents
     */
    kindSupportsSpecObj: function(/*specObj, specObjects*/) {
      return true;
    },
    /**
     * Initializes the object.
     * Called once in the lifetime of an object. Parental gobjects should exist
     * at this point.
     * In general, clients should override initKind(), updateConstraintAncestry(),
     * and the like, rather than init()
     */
    init: function init() {
      this.initKind();
      this.initConstraint();
      this.updateConstraintAncestry();
      this.updateLabel({ init: true }); // With new label functionality, updateLabel() needs to know who's calling
    },
    /**
     * Kind specific gobject initialization.
     */
    initKind: function initKind() {
      this.needsRenderInit = true;
    },

    /**
     * Update the text of the your label.
     * This will be called when something happens that
     * might change your parents (e.g. in a merge your parents might be different),
     * or their labels. updateLabel will be called after initKind, and also as part of object merge.
     *
     * Note that this is distinct from constrainLabel(), which is where you
     * will change the locations (and possibly text) of your label as part
     * of the normal constraint process.
     *
     * WARNING: Since this is called by init, implementors cannot depend on the
     * sketch having a renderRefCon if option.init is true. In this case you cannot
     * invalidate geom or appearance.
     */
    updateLabel: function(option) {
      if (this.state.updatingLabel) return; // prevent recursion
      // (A call to setLabel could call labelHasChanged and lead to a recursive call)
      this.state.updatingLabel = true;
      option = option || { create: true }; // Use create.true if option is undefined, so parental labels will be created
      this.updateLabelForKind(option);
      this.updateLabelForConstraint(option);
      if (this.state.labelParent) {
        this.label = this.makeParentalLabel(this.style.nameOrigin, option);
      }
      if (this.state.updatingLabel) {
        delete this.state.updatingLabel;
      }
    },

    /**
     * Gobject initialization for the appearance - mfs name, precision, etc.
     *
     */
    updateLabelForKind: function updateLabelForKind() {},

    /**
     * Called whenever a gobjects ancestral graph has changed.
     *
     */
    graphHasChanged: function(option) {
      this.updateConstraintAncestry();
      this.updateLabel(option);
      this.invalidateGeom();
    },

    descendantGraphHasChanged: function(option) {
      // Update the ancestry and geometry of this subgraph
      this.graphHasChanged(option);
      this.eachDescendant(function() {
        this.graphHasChanged(option);
      });
    },

    labelHasChanged: function() {
      // Note that this is called not only for labeled objects but also for text objects like measurements
      var oldLabel = this.label,
        bounds;
      if (!this.hasLabel) {
        this.state.forceDomParse = true;
      }
      this.updateLabel();
      if (this.hasLabel && oldLabel === this.label) return false;
      if (this.parsedMFS && this.label !== oldLabel) {
        this.parsedMFS = null;
        this.state.labelPreRenderJITPrepareDone = false;
        this.needsRenderInit = true;
      }
      if (this.getLabelBounds) {
        bounds = this.getLabelBounds();
        bounds.right = Infinity; // extend the rect to make sure it's big enough for the new label.
        bounds.bottom = Infinity;
      }
      this.invalidateAppearance();
    },

    descendantLabelGraphHasChanged: function() {
      // Update the labels (NOT geometry) of this gobj and its subgraph

      function labelChildrenHaveChanged(gobj) {
        gobj.state.labelChildren.forEach(function(child) {
          child.labelHasChanged();
          if (child.state.labelChildren) {
            labelChildrenHaveChanged(child);
          }
        });
      }

      this.labelHasChanged();
      this.eachDescendant(function() {
        this.labelHasChanged();
      });
      if (this.state.labelChildren) {
        labelChildrenHaveChanged(this);
      }
    },

    /**
     * Initialization of Accessibility Controls.
     */

    initKindAccessibility: function(sketch) {
      // this.createKindHTML(sketch);
    },

    updateKindHTMLStyle: function() {
      if (this.htmlNode) {
        if (!this.isRenderable()) {
          this.htmlNode.hide();
        } else {
          this.htmlNode.show();
        }
      } else {
        if (
          !this.style.selectable ||
          this.kind === 'Map' ||
          this.kind === 'IterateImage'
        )
          return;

        this.createKindHTML();
      }

      if (this.parsedMFS && this.label) {
        if (this.parsedMFS !== this.oldParsedMFS) {
          var elementText =
            GSP.mfs.updatedGenus[this.genus] +
            ' ' +
            GSP.mfs.makeSpeakableTextFromMFSParseTree(this.parsedMFS);
          this.htmlNode.attr('aria-label', elementText);
          this.oldParsedMFS = this.parsedMFS;
        }
      }
    },
    /**
     * Create DOM elements for each gobject.
     * This will be called when sketch is completely loaded.
     * Adding events for focusIn, focusOut and Arrow keys.
     */
    createKindHTML: function() {
      var elementSelection =
        this.isGobjInsideDocumentBound() === false
          ? 'aria-hidden="true"'
          : 'tabindex="0"';
      var elementText =
        GSP.mfs.updatedGenus[this.genus] + (this.label ? ' ' + this.label : '');

      this.htmlNode = $(
        '<button aria-pressed="false" type="button" wsp-id="' +
          this.id +
          '" class="wsp-accessible wsp-' +
          this.kind +
          ' wsp-sr-only" role="button" ' +
          elementSelection +
          '>' +
          '</button>'
      );
      this.htmlNode.text(elementText);
      if (!this.isRenderable()) this.htmlNode.hide();
      this.sQuery.sketch.gobjAddKeyEvents(this);

      $('.wsp-text-layer').append(this.htmlNode);
    },

    /**
     * Called once, after the entire sketch has been constructed and
     * constrained, but before the normal frame-rate render cycle has begun.
     * Return undefined.
     *
     * Also it will initiate Accessibility and will start creation of accessible DOM elements for the canvas elemnts.
     * This will not create accessible elements for the follwoing kinds: Text, Measure, Table & Expression.
     *
     * @param sketch The sketch, of which this gObject is a part.
     * @param mode is "pageSwitch", "undoRedo", or "toolDone"
     */
    onLoad: function(sketch, mode) {
      // Accessibility code below breaks match of a straight given to an axis.
      // The matched given has already been identified as an axis, but doesn't have
      // getZeroPoint() and getUnitPoint() methods, resulting in a crash kn isGobjInsideDocumentBound().
      // Tentative fix is below, but we likely don't even need to adjust this.htmlNode,
      // because this matched straight object (and its htmlNode) will go away anyway when the tool givens are cleaned up.
      var possibleMatchToAxis = mode === 'toolDone' && this.kind === 'Axis';
      this.updateKindHTMLStyle();
      if (
        this.htmlNode &&
        (possibleMatchToAxis || this.isGobjInsideDocumentBound() === false)
      ) {
        this.htmlNode.attr('aria-hidden', 'true');
        this.htmlNode.removeAttr('tabindex');
      }
    },

    /**
     * Called after the sketch has been stopped, but before it has been cleaned
     * up.
     *
     * @param sketch
     */
    onUnload: function(sketch) {},

    doubleClicked: function(/*touch*/) {},

    isOfKind: function(iKind) {
      return (
        iKind === this.kind ||
        (this.baseKinds && this.baseKinds.indexOf(iKind) >= 0)
      );
    },

    isOfGenus: function(iGenus) {
      return (
        iGenus === this.genus ||
        (this.baseGenera && this.baseGenera.indexOf(iGenus) >= 0)
      );
    },
    isAPath: function() {
      //The question of whether a gobj is a path is not always straightforward.  Almost all kinds
      // can answer the question by saying whether they inherit from the Path genus, but there are
      //kinds (actually just Sampler) which inherits from Path but are not always paths.  Really, it
      //boils down to a limitation in our Kinds/Constraint/Genus hierarchy.  Sampler shouldn't inherit
      //from Path if it is not always a Path.  Only point locus should inherit from Path, but there
      //is no Kind or Constraint at that level.
      //The workaround is to define a method isAPath() that kinds can override when they need to.
      return this.isOfGenus('Path');
    },

    /*
     * During toolplay, this answers the question: can an assumed given be merged to me?
     */
    matchesAssumedSpec: function(assumedSpec) {
      return (
        this.isOfKind(assumedSpec.kind) && this.isOfGenus(assumedSpec.genus)
      );
    },

    /**
     * Iterate through gobject parents, in Desktop Sketchpad order
     *
     * @param callback callback(index, parentGObject)
     *  callback context is the parentGObject. Return false to terminate iteration.
     * @param reverse (bool)
     *  (optional) if true, iterates last to first
     * @return (GSP.GObject) this
     */
    eachParent: function(callback, reverse) {
      var i, parentGObj, ret;

      if (this.numParents() === 0) {
        return this;
      }

      if (reverse) {
        for (i = this.numParents() - 1; i >= 0; i--) {
          parentGObj = this.parentsList[i];

          ret = callback.call(parentGObj, i, parentGObj);
          if (ret === false) {
            break;
          }
        }
      } else {
        for (i = 0; i < this.numParents(); i++) {
          parentGObj = this.parentsList[i];

          ret = callback.call(parentGObj, i, parentGObj);
          if (ret === false) {
            break;
          }
        }
      }

      return this;
    },
    numParents: function() {
      return this.parentsList ? this.parentsList.length : 0;
    },
    /**
     * Iterate through gobject children, in Desktop Sketchpad order
     *
     * @param callback callback(index, childGObject)
     *  callback context is the childGObject. Return false to terminate iteration.
     * @param reverse (bool)
     *  (optional) if true, iterates last to first
     * @return (GSP.GObject) this
     */
    eachChild: function(callback, reverse) {
      var i, childGObject, ret;

      if (!this.children || !this.children.length) {
        return this;
      }

      if (reverse) {
        for (i = this.children.length - 1; i >= 0; i--) {
          childGObject = this.children[i];

          ret = callback.call(childGObject, i, childGObject);
          if (ret === false) {
            break;
          }
        }
      } else {
        for (i = 0; i < this.children.length; i++) {
          childGObject = this.children[i];

          ret = callback.call(childGObject, i, childGObject);
          if (ret === false) {
            break;
          }
        }
      }

      return this;
    },

    /**
    * Iterate through gobject descendants, in Desktop Sketchpad order
    * Doesn't include the calling gobj - descendants are proper.
    *
    * @param callback callback(index, descendantGObject)
    *  callback context is the descendantGObject. Return false to terminate iteration.
  
    * @return (GSP.GObject) this
    */
    eachDescendant: function(callback) {
      var descendantIDs = {},
        gobjList,
        gobj,
        i,
        ret;

      function markGObjAsDescendant() {
        descendantIDs[this.id] = true;
      }

      gobjList = this.sQuery.sketch.gobjList;
      if (!gobjList) return false;
      gobjList = gobjList.constraintList;
      // Seed the children.
      this.eachChild(markGObjAsDescendant);

      // Now go in topological order,
      // processing, updating as we go.
      for (i = 0; i < gobjList.length; i++) {
        gobj = gobjList[i];

        if (descendantIDs[gobj.id]) {
          // Do this gobj
          ret = callback.call(gobj, i, gobj);
          if (ret === false) {
            break;
          }
          // And each of its children too.
          gobj.eachChild(markGObjAsDescendant);
        }
      }

      return this;
    },
    /**
      Return true if the given gobj is a descendant of this gobj,
      false otherwise.
     */
    hasDescendant: function(gobj) {
      var foundDescendant = false;
      this.eachDescendant(function(g) {
        if (g === gobj) {
          foundDescendant = true;
          return false;
        }
      });

      return foundDescendant;
    },

    /**
     * Check that sufficient of an object's parents exist for constraining to
     * occur. If this method returns false, then the object will not be
     * constrained.
     * This method returns false if any parent does not exist. GObject kinds can
     * override this behavior, if needed.
     * This method marks, provisionally, the state of this object to be the result
     * of this function. If the result is true, the constraint method is responsible
     * for evaluating the existence of this object.
     * SS: Presumably overrides should also mark the object state to agree with the result.
     * @return whether the parents exist. If the object has no parents, returns true.
     */
    checkParentsExist: function() {
      var i,
        parentGObj,
        result = true;

      for (i = 0; i < this.numParents(); i++) {
        parentGObj = this.parentsList[i];
        if (parentGObj.state && !parentGObj.state.exists) {
          result = false;
          break;
        }
      }

      this.state.exists = result;

      return result;
    },
    // Utility for use by overrides of checkParentsExist, several of which need to load a named parent
    namedParentExists: function(name) {
      var par = this.getParent(name);
      return par && par.state && par.state.exists ? true : false;
    },

    /**
     * This method should be called on clones (objects who have been created
     * with another existing, initialized object as their prototype) after the
     * clone's parentage has been finalized.  This method is responsible for
     * doing any intitialization to geometry, state or other fields
     * in the clone, and may be overridden as needed.
     *
     * See discussion in sketch.cloneGObjects()
     *
     * @param {Object} originalObject - For efficiency, the object
     * this was cloned from.  If none provided, it is determined by
     * looking up the original by object id.
     *
     * @returns {undefined}
     */
    initializeClone: function(originalObject) {
      if (!originalObject) {
        originalObject = this.sQuery().get(this.id);
      }

      // Clones have a deep copy of their geom
      if (originalObject.geom) {
        this.geom = {};
        GSP.GeomTransformer.copyGeom(originalObject.geom, this.geom);
      }

      // We'll allow a shallow copy of style, to allow
      // changing visibility and color
      if (originalObject.style) {
        this.style = Object.create(originalObject.style);
      }

      // State scratch-pad are also is available to the clone,
      // but for most objects, we don't need to copy that.  Free
      // constraints need to be marked as existing, because they will
      // never be reconstrained.  It may be that select kinds of objects
      // will need some additional portion of their state copied.  If
      // we see a need for that, we can consider adding a constraint or
      // kind level cloneState() method as optional overrides for objects
      // to implement.
      this.state = {};
      this.state.exists = originalObject.state.exists;
      this.state.supported = originalObject.state.supported;
    },
    invalidateAppearance: function() {
      this.sQuery.sketch.invalidateAppearance(this);
    },
    invalidateGeom: function(source) {
      this.sQuery.sketch.invalidateGeom(this, source);
    },
    /*
     * GObjects may return a colorable component, which serves
     * as an index into colorableComponents preference, and is
     * used for seeding a default color.
     */
    getColorableComponent: function() {
      return undefined;
    },
    /*
     * Gobjects may return a textType, which serves
     * as an index into textTypes preference, and is
     * used for seeding a default style. In general, color
     * specified via the textTypes overrides that set
     * in the colerableComponent.
     */
    getTextType: function() {
      return undefined;
    },
    /**
     * Examines the style and state of an object and determines whether
     * the object is renderable. If the object is not renderable, its display
     * should be suppressed. Renderability may change during the course of
     * interaction with the sketch.
     * @return {boolean}
     */
    isRenderable: function() {
      return !this.style.hidden && this.state.exists;
    },
    /**
     * Reports on whether this object is in a state to be considered for
     * hit testing.  (This function does not actually do hit testing, but
     * simply determines if this object is eligible to be considered.)
     * @return {boolean}
     */
    isHittable: function() {
      return this.style.selectable && this.isRenderable();
    },
    getDocument: function() {
      return this.sQuery().sketch.document;
    },
    /**
     * Prepare to render this object. This gives vector based rendering apis the
     * opportunity to construct objects that will be used later.
     * @param {DrawContex} drawContext The context of the operation.
     * @param {Object} renderArgs An associative array of arguments. Currently, the
     *                      only possible parameter is the boolean, 'drag',
     *                      indicating that the object is being dragged.
     */
    renderPrepare: function(drawContext, renderArgs) {
      return undefined;
    },
    /**
     * Renders this object to the display surface.
     * Called in response to changes to the sketch at up to frame rates.
     * @param {DrawContex} drawContext The context of the operation.
     * @param {Object} drawRefCon The context of the operation.
     * @param {Object} drawArgs An associative array of arguments. Currently, the
     *                      only possible parameter is the boolean, 'drag',
     *                      indicating that the object is being dragged.
     */
    render: function(drawContext, drawRefCon, renderArgs) {
      throw GSP.createError(
        'Capability not implemented(render): id=' + this.id
      );
    },
    renderCleanup: function(drawContext, drawRefCon) {},

    /**
     * Opacity from fade effect
     */
    calculateFadeOpacity: function() {
      var opacity = 1;

      if (this.state.fade !== undefined) {
        opacity *= 1 - this.state.fade;
      }

      return opacity;
    },

    /**
     * Calculate the current opacity for the gobject.
     * This will combine opacity from gobject.style,
     * and any dynamic fading currently in effect.
     */
    calculateOpacity: function() {
      var opacity = this.style.opacity;

      if (undefined === opacity) {
        opacity = 1;
      }

      opacity *= this.calculateFadeOpacity();

      return opacity;
    },
    /**
     * Returns the geometric bounds of an object. Will return the bounds
     * iff the gobject 'exists' at the
     * moment of the call. If the object does not exist, will return undefined.
     * The gobject may or may not be hidden. If the caller needs bounds
     * only for non-hidden objects, it is the responsibility of the caller to
     * filter out hidden objects.
     *
     * The returned object has plain object structure as follows:
     *      {
     *         left: (num),
     *         top: (num),
     *         right: (num),
     *         bottom: (num)
     *      }
     * All component values are denominated in pixels.
     *
     * @param {Object} optRefCon - display refCon used by some objects for calculating
     *      their screen representation (eg. html-layer text objects).
     *
     */
    getGeomBounds: function() {
      if (this.state.exists) {
        return {
          left: Number.NEGATIVE_INFINITY,
          top: Number.NEGATIVE_INFINITY,
          right: Number.POSITIVE_INFINITY,
          bottom: Number.POSITIVE_INFINITY,
        };
      }
    },
    /*
     * Returns the significant bounds - the bounds of interest - of the obj.
     * Generally, this is the geomBounds of the object, but is less for 'infinite'
     * objects.
     * @param {Object} optRefCon - display refCon used by some objects for calculating
     *      their screen representation (eg. html-layer text objects).
     * @returns {unresolved}
     */
    getSignificantBounds: function(optRefCon) {
      var ret = this.getGeomBounds(optRefCon);

      if (!GSP.Geom.isFiniteRect(ret)) {
        ret = null;
      }
      return ret;
    },
    /**
     * Returns whether this object lies within the specified rectangle.
     * Called upon the initiation of a touch.
     * Valid return values are:
     * true - a hit on that can drag the gobj.
     * "system" - a hit, but one that will be handled by system event processing.
     * false - not hit at all
     *
     * @param {{left:number,right:number,top:number,bottom:number}} rect
     * @param {{x:number,y:number}} hotSpot
     * @return {object}
     */
    hitTest: function(rect, hotSpot) {
      throw GSP.createError(
        'Capability not implemented(hitTest): id=' + this.id
      );
    },
    /**
     * Responds to a touch down event.
     * This is in the scope of the DOM event, rather than in animationFrame
     * time as in transformComplete(), which can matter for clients opening
     * browser windows - responding to the event is more trusted than random
     * later times.
     *
     */
    dragDidStart: function() {
      this.state.isDragging = true;
    },
    /**
     * Responds to a touch up event.
     * This is in the scope of the DOM event, rather than in animationFrame
     * time as in transformComplete(), which can matter for clients opening
     * browser windows - responding to the event is more trusted than random
     * later times.
     *
     */
    dragDidEnd: function() {
      this.state.isDragging = false;
    },
    /**
     * Responds to a drag movement.
     * @param {GSP.sketch} sketch The current sketch of which this object is a
     *                            part.
     * @param {{geom:object,dx:number,dy:number}} trans      The drag data.
     */
    transform: function(sketch, trans) {
      throw GSP.createError(
        'Capability not implemented(transform): id=' + this.id
      );
    },
    /**
     * Responds to a drag completion event.
     * @param {GSP.sketch} sketch The current sketch of which this object is a
     *                            part.
     * @param {Object} motion  Information about the motion that is concluding.
     */
    transformComplete: function(sketch, motion) {},
    /* Create a transformer object that transforms this kind's geom to a transformed
     * geom. Duck typing is in effect here. We're given a destination object, which will
     * conform to the contract of GSP.mixins.transformable,
     * and we return an object with functions:
     * transformGeom: function(sourceGeom, destGeom)
     * getAffineTransform: function()
     *   conforming to the semantics of GeomTransformer.transformGeom.
     *
     * Basically, this object knows it's own geometry, but the transforming object knows
     * how to transform points, distances, affineTransforms. Here is where we put together that
     * knowledge in one package.
     *
     * The default implementation uses the GSP.GeomTransformer object, which knows how to transform
     * arbitraty geom's. Derived classes can, if they choose, be more clever.
     */
    createTransformer: function(destination) {
      return new GSP.GeomTransformer({
        distance: destination.getScalarTransform(),
        point: destination.getTransform(),
      });
    },
    /**
     * Perform any cleanup required.  Note: Parents and/or children are not valid at this point: they may have either been
     * removed are in the process of being deleted, and should not be relied on.
     */
    destroy: function() {
      if (this.htmlNode) this.htmlNode.remove();
    },
    /**
     * As of May 2020 there are three possible values for style.hidden:
     * true for objects that are hidden in a source GSP sketch or hidden by toolplay
     * false for objects that are visible
     * byUser for objects that are hidden by the user (presumably, but not necessarily, via Visibility widget)
     * This value is used by the Visibility widget to determine what objects are eligible to be shown.
     */
    hide: function(option) {
      if (option && option === 'byUser') this.style.hidden = 'byUser';
      else this.style.hidden = true;
      //Must invalidate geom rather than just appearance because a downstream
      //button might need to change its name
      if (this.updateKindHTMLStyle) {
        this.updateKindHTMLStyle();
      }
      this.invalidateGeom();
    },
    show: function() {
      this.style.hidden = false;
      if (this.isOfKind('Text') && !this.parsedMFS) {
        this.updateLabel(); // No MFS yet, so generate it
      }
      if (this.updateKindHTMLStyle) {
        this.updateKindHTMLStyle();
      }
      //Must invalidate geom rather than just appearance because a downstream
      //button might need to change its name
      this.invalidateGeom();
    },
    toggleDisplay: function() {
      this.style.hidden = !this.style.hidden;
      //Must invalidate geom rather than just appearance because a downstream
      //button might need to change its name
      if (this.updateKindHTMLStyle) {
        this.updateKindHTMLStyle();
      }
      this.invalidateGeom();
    },

    /**
     * Render callback for object animation.
     *
     * @callback animationRenderCallback
     * @param {number} x: [0,1] representing where you are in the animation.
     */

    /**
     * Create a job for an animated effect on a gobject.
     *
     *
     * @param {animationRenderCallback} renderFunc: Does the rendering (no need to invalidate in it)
     * @param {function} cleanupFunc: cleanup any garbage (no invalidate neeed)
     * @param {object} easing: various parameters reflecting the easing function for the animation.
     */
    addAnimationJob: function(renderFunc, cleanupFunc, easing) {
      var frequencyInMs = easing.frequencyInMs,
        steepness = easing.steepness,
        offset = easing.offset || 0,
        twoToPowerOfSteepness = Math.pow(2, steepness),
        self = this,
        startTime = offset + Date.now();

      function doRender(x) {
        renderFunc(x);
        self.invalidateAppearance();
      }

      function doCleanup() {
        cleanupFunc();
        self.invalidateAppearance();
      }

      return self.sQuery.sketch.jobScheduler.addJob(
        function() {
          var now = Date.now(),
            x = (now - startTime) / frequencyInMs,
            growth =
              Math.pow(Math.sin(GSP.math.TWO_PI * x) + 1, steepness) /
              twoToPowerOfSteepness;

          doRender(growth);
        },
        {
          repeat: true,
          done: doCleanup,
        }
      );
    },

    //  With major commonality between points and paths, we unify the implementation of addJobForRenderState().
    addJobForRenderState: function(renderState) {
      var self = this,
        renderStateJob,
        style = self.style,
        isPath = this.isAPath(),
        isInterior = this.isOfGenus('Interior'),
        isText = this.isOfKind('Text'),
        wasHidden,
        frequencyInMs,
        offset,
        kSteepness,
        baseValue,
        kGrowthAmt,
        oldValue;

      if (renderState === 'hotTarget' || renderState === 'fadeInOut') {
        offset = 0;
        wasHidden = this.style.hidden;
        if (renderState === 'fadeInOut') {
          kSteepness = 0.4;
          frequencyInMs = 800.0;
        } else {
          kSteepness = 1;
          this.style.hidden = false;
          frequencyInMs = 1000.0;
        }
        renderStateJob = self.addAnimationJob(
          function(x) {
            self.state.fade = 1 - x;
          },
          function() {
            self.state.fade = undefined;
            self.style.hidden = wasHidden;
          },
          {
            frequencyInMs: frequencyInMs,
            offset: offset,
            steepness: kSteepness,
          }
        );
      } else if (renderState === 'unmatchedGiven') {
        kGrowthAmt = isPath ? 6 : 4; // pixels to grow when highlighted
        if (isText) {
          baseValue = 0.3;
          kGrowthAmt = 0.7;
        } else if (isInterior) {
          kGrowthAmt = 0.6;
          oldValue = style.opacity;
          // The basevalue must be between 0 and 1-kGrowthAmt, ideally centered on oldValue.
          baseValue = Math.max(
            0,
            Math.min(1, oldValue + kGrowthAmt / 2) - kGrowthAmt
          );
        } else {
          // Points, Straights, Circles
          kGrowthAmt = style['drag-expansion'] || kGrowthAmt;
          oldValue = style.width || style.radius;
          baseValue = oldValue;
        }
        if (renderState === 'unmatchedGiven') {
          // THIS TEST APPEARS TO BE REDUNDANT
          kSteepness = 5; //higher number is more pronounced pulse
          frequencyInMs = self.getAuthorPreference('sequentialSnapping')
            ? 500.0
            : 3000.0;
        } else {
          // THIS ELSE BLOCK SEEMS UNREACHABLE
          kSteepness = 3; //higher number is more pronounced pulse
          frequencyInMs = isText ? 750 : 1500;
        }
        offset = Math.random() * frequencyInMs;
        kGrowthAmt = style['drag-expansion'] || kGrowthAmt;

        renderStateJob = self.addAnimationJob(
          function(x) {
            var newValue = baseValue + x * kGrowthAmt;
            if (self.style.opacity) {
              self.style.opacity = newValue;
            } else if (self.style.width) self.style.width = newValue;
            else if (self.style.radius) {
              self.style.radius = newValue;
            } else {
              self.state.fade = newValue;
            }
          },
          function() {
            if (self.style.opacity) {
              self.style.opacity = oldValue;
            } else if (self.style.width) {
              self.style.width = oldValue;
            } else if (self.style.radius) {
              self.style.radius = oldValue;
            } else if (self.state.fade) {
              self.state.fade = undefined;
            } else GSP.createError('Unknown kind for renderStateJob()');
          },
          {
            frequencyInMs: frequencyInMs,
            offset: offset,
            steepness: kSteepness,
          }
        );
      }
      return renderStateJob;
    },

    renderStateWillChange: function(oldRenderState) {
      if (this.state.renderStateJob && this.state.renderStateJob.isActive) {
        this.sQuery.sketch.jobScheduler.clearJob(this.state.renderStateJob);
        this.state.renderStateJob = null;
      }
    },
    renderStateDidChange: function(newRenderState) {
      this.state.renderStateJob = this.addJobForRenderState(newRenderState);
      this.invalidateAppearance();
    },
    setRenderState: function(renderState) {
      this.renderStateWillChange(this.state.renderState);
      this.state.renderState = renderState;
      this.renderStateDidChange(renderState);
    },
    getAuthorPreference: function(prefName) {
      return this.sQuery.sketch.getAuthorPreference(prefName);
    },
    modifyRenderAttrsForCurrentState: function(attrs) {
      var state = this.state.renderState;
      switch (state) {
        case 'hotTarget':
          if (GSP.isNumber(this.state.fade) && this.state.fade < 0.3) {
            state = 'targetHighlit';
          }
          break;
      }
      this.doModifyRenderAttrsForState(attrs, state);
    },
    doModifyRenderAttrsForState: function(attrs, state) {
      switch (state) {
        case 'speculative':
          attrs.color = GSP.speculativeColor;
          attrs.suppressParametricColor = true;
          break;
        case 'targetHighlit':
          attrs.color = GSP.targetHighlightColor;
          attrs.suppressParametricColor = true;

          if (this.isAPath()) {
            attrs.width += GSP.targetHighlightPathBolding;
          }
          break;
        // matchedGiven & unmatchedGiven aren't limited to points and params, so shouldn't be logged here.
        case 'unmatchedGiven':
        case 'matchedGiven':
        case 'none':
        case undefined:
          //No change
          break;
        case 'targetOnFocus': // This case will be triggered when gobject get focus.
          attrs.isFocusable = true;
          if (this.kind === 'PathMarker') {
            attrs.rect = this.sQuery.sketch.getGObjGeomBounds(this);
            attrs.borderColor = GSP.targetFocusColor;
            attrs.borderWidth = 1 + GSP.targetFocusPathBolding;
          } else {
            attrs.color = GSP.targetFocusColor;
            if (this.isAPath()) {
              attrs.width += GSP.targetFocusPathBolding;
            }
          }
          break;
        default:
          GSP.log(
            'Unexpected render state: ' +
              this.state.renderState +
              ' for kind: ' +
              this.kind
          );
          break;
      }
    },
    /**
     * For gobjs that have associated UI (eg parameters, functions, and calculation),
     * presents the gobjs ui in the sketch.  If the gobj has no ui, this is a no-op.
     *
     * completionCallback is an optional callback that will be executed when the
     * user dismisses the gobj ui.  It should provide a string argument describing the
     * result of the ui edit session:
     * - changesAccepted
     * - changesNotAccepted
     *
     * @param completionCallback
     */
    presentUI: function(completionCallback) {},
    /**
     * For objects that support autoplacement, returns a metrics object as defined by the GSP.AutoplacementMetrics object.
     * A Kind typically selects an autoplacement rule by setting its autoplacementType string.  If it doesn't support
     * autoplacement, it can just leave the property undefined.  There is typically no need for this method to be overridden.
     *
     * @returns {Object}
     */
    getAutoplacementMetrics: function() {
      if (this.supportsAutoplacement()) {
        return GSP.AutoplacementMetrics[this.autoplacementType];
      }
    },
    /**
     * Gets a appearance of the object in the specified variant.  Should be
     * overridden by subclasses who want to support more variants, or change
     * behavior of a particular variant.  Default implementation just returns
     * the name of the object (possibly in a label context).
     *
     * @param {type} variant
     * @returns {Object} MFS tree or null if the gobj is non existing and
     *    the requested variant does not support an appearance when nonexisting.
     */
    getMFSAppearanceForVariant: function(variant, option) {
      option = option || {};
      return variant === 'byLabel'
        ? this.getNameMFSForLabel(option)
        : this.getNameMFS(option);
    },

    /**
     * In rare cases we want the name mfs in a label to look
     * differently from the name mfs in a nonlabel context, such as the
     * default context of composite or pegged text. Subclasses should
     * override this function in that case.
     *
     * @returns {Object} MFS tree or null
     */
    getNameMFSForLabel: function(option) {
      return this.getNameMFS(option);
    },

    /**
     * A wrapper around getMFSAppearanceForVariant that strips out font
     * size and font family from all subelements, so they don't override
     * the child Text.
     *
     * @param {type} variant
     * @returns {Object} MFS tree or null (see getMFSAppearanceForVariant).
     */
    getStrippedMFSAppearanceForVariant: function(variant, option) {
      var newMFSValue = this.getMFSAppearanceForVariant(variant, option);
      if (newMFSValue === null) {
        return null;
      }

      GSP.mfs.walkNode(newMFSValue, 'style', function strip(node) {
        node.value = node.value.filter(function(value) {
          // Note that value may be any mfs element, OR a "stylespec"
          // subexpression. (mfs.pegjs). We only strip out the
          // latter. Also see desktop:
          // StripFontStyles_MFSStreamOutFilter
          return value.code !== 'fontFamily' && value.code !== 'fontSize';
        });
      });

      return newMFSValue;
    },

    /**
     *
     * @returns {string} the label mfs as a string or null of the object is unlabeled
     */
    getLabelMFS: function(option) {
      var mathItalicization = this.getMathItalicization(),
        retVal = null,
        label = this.label;
      option = option || {};
      if (label && option.show && this.getLabel) {
        // if getLabel exists,
        label = this.getLabel(option); // show the label
      }
      if (label) {
        if (this.kind === 'Button') {
          // mathItalicization applies to mathematical objects, not buttons.
          mathItalicization = false;
        }
        retVal = GSP.labels.parseLabelExpression(label, mathItalicization);
      }
      if (
        !retVal &&
        this.style &&
        this.style.label &&
        this.style.label.text !== undefined
      ) {
        retVal = GSP.labels.parseLabelExpression(
          this.style.label.text,
          mathItalicization
        );
      }
      if (!retVal && this.getParentalNameMFS && this.parentsList.length) {
        retVal = this.getParentalNameMFS(option);
      }
      if (!retVal && !option.init) {
        retVal = GSP.labels.parseLabelExpression(
          this.getLabel(option),
          mathItalicization
        );
      }
      return retVal;
    },
    /*
     * Every object has a name suitable for display. This function returns
     * a short name as an MFS clause, that is both suitable for display and
     * suitable for composition in the names of other objects.
     */
    getNameMFS: function(option) {
      // If the mfs is specified, use that: this will happen
      // when (e.g. in toolplay merge appearance) we want to temporarily
      //override the name of the gobject.
      if (this.nameMFSOverride) {
        return this.nameMFSOverride.mfs;
      }

      return this.generateNameMFS(option);
    },
    /*
     * Worker function for getNameMFS. Generate (or find) the
     * MFS clause
     */
    generateNameMFS: function(option) {
      return this.getLabelMFS(option) || this.getParentalNameMFS(option);
    },
    /**
     * Get the specified GObj reference from its ID.
     * @param {String} iRefObjID -- the ID of the referenced object
     * @return {Object} the referenced object
     */
    getGObjRef: function(iRefObjID) {
      return this.sQuery.sketch.gobjList.gobjects[iRefObjID];
    },
    /**
     * Get the specified parent of the gobj.
     * @param {String} parent -- the id of the parent
     * @return {Object} the parent object
     */
    getParent: function(iParentID) {
      return this.parents[iParentID];
    },

    testConsistency: function(iName, iActual, iExpected) {
      // Try the simple test first
      var isEqual =
        iActual === iExpected || (iActual == null && iExpected == null); //treat null and undefined as equal

      // If we fail the simple test, use a numeric tolerance test if appropriate
      if (
        !isEqual &&
        typeof iActual === 'number' && typeof iExpected === 'number'
      ) {
        isEqual = GSP.math.expect(iActual, iExpected);
      }

      return !isEqual
        ? iName +
            ': <span class="error">' +
            iActual +
            '</span> (<span class="expected">' +
            iExpected +
            '</span>)'
        : '';
    },
    /**
     * If a particular kind wants to be auto-constructable (eg. when a sketch doesn't have a required assumed object)
     * it should implement this method.  Given a sketch, this method produces a spec that describes a default version
     * of an object of this kind positioned in relative coordinates appropriately for the sketch's window.
     *
     * This method should be treated as a class method - eg - don't assume that this object has been added to a sketch
     * itself.  Assume the method is being called on the prototype instance itself rather than on a separate instance, so
     * any properties on the this object should be purely read-only.
     *
     * If the kind is not auto-constructable it is safe to leave this method undefined.
     *
     * @param sketch - the sketch to be played into
     * @param props - a set of properties to configure the spec.  Kind-specific.  In general, this would be the spec of the
     *   automatch object itself, but in some cases (CoordSys), it's a custom set of properties.
     *
     *  @return Object - the spec
     */
    //createDefaultSpec: function (sketch, props) {}

    /*
     * A debug HTML utterance, comparing the current constrained
     * state of the GObject with expected values. Should be the
     * empty string if there's nothing amis, otherwise a HTML
     * utterance. Use class="error" for red-style css, class="expected"
     * for green style.
     */
    verificationString: function(expected, args) {
      var msg = '';

      msg += this.testConsistency('exists', this.state.exists, expected.exists);

      if (this.constraintVerificationString) {
        msg += this.constraintVerificationString(expected);
      }

      function controlListBapCheck(gobj) {
        var controlList,
          bapCheck = '',
          givenList = '',
          calculatedList = '';
        if (gobj.debug && gobj.debug.controlList) {
          controlList = gobj.sQuery.sketch.Bap.createControlList([gobj]);

          givenList = GSP.ControlList.toString(gobj.debug.controlList);
          calculatedList = GSP.ControlList.toString(controlList);
        }

        if (givenList !== calculatedList) {
          bapCheck +=
            'bapCheck: <div class="error">' +
            calculatedList +
            '</div>(<div class="expected">' +
            givenList +
            '</div>)';
        }
        return bapCheck;
      }

      if (this.debug && this.debug.pathPositions) {
        if (this.pathValidationString) {
          msg += this.pathValidationString(this.debug.pathPositions);
        } else {
          GSP.signalErrorWithMessage('GObj verification expects a path object');
        }
      }

      msg += controlListBapCheck(this);

      return msg;
    },

    labelExists: function() {
      // Any string means the label exists. An empty string should never occur.
      if (this.label === '')
        GSP.log('Object has empty string label: ' + this.id);
      return GSP.isString(this.label);
    },

    canEditLabel: function() {
      return this.label || this.hasLabel || this.style.nameOrigin;
    },

    hasLabelOffset: function() {
      var labelStyle = this.style.label;
      return (
        GSP.isNumber(labelStyle.labelOffsetY) &&
        GSP.isNumber(labelStyle.labelOffsetX)
      );
    },
    /*
     See labels.c: Label_SetDefaultOffset
  
     The algorithm is as follows: We make a small circle about
     iCenterPoint, and find the intersection points of various GObjs
     with this circle.  This divides the circle into arcs - the middle
     of each arc is a possible direction to place the label.  We look
     for the largest arc, with a small factor tending to prefer
     directions towards the lower right.
  
     The GObjs considered for intersection are the given GObj, its
     children, and its parents.
  
     This gives us a direction away from iCenterPoint. We place the
     center of the label along this ray, far enough away so that it
     doesn't cover iCenterPoint.
     */
    initLabelOffset: function(size) {
      var self = this;
      function getIntersectionAngles() {
        var intersectionAngles = [],
          center = self.getLabelOrigin(),
          circle = GSP.GeometricArc.FromCenterAndRadius(center, 2);

        function accumulateAngle(gobj) {
          var intersections = [],
            theseIntersections,
            angles,
            vertices,
            v,
            straight,
            isLast,
            MAX_LABEL_ANGLES_PER_OBJECT = 3;

          if (
            gobj.isOfKind('Straight') ||
            gobj.isOfKind('Circle') || // Desktop checks for "curves" here.
            gobj.isOfKind('Arc')
          ) {
            intersections = GSP.getIntersectionPoints(circle, gobj);
          } else if (gobj.isOfKind('Polygon')) {
            vertices = gobj.getVertices();

            /* We might have > 2 intersections - don't overrun MAX_LABEL_ANGLES_PER_OBJECT. */
            for (
              v = 0;
              v < vertices.length &&
              intersections.length < MAX_LABEL_ANGLES_PER_OBJECT;
              v++
            ) {
              isLast = v === vertices.length - 1;
              straight = GSP.GeometricArc.FromStraightEndpoints(
                vertices[v],
                vertices[isLast ? 0 : v + 1]
              );
              theseIntersections = GSP.Geom.CircleStraightIntersection(
                circle,
                straight
              );
              intersections = intersections.concat(theseIntersections);
            }
          }
          if (intersections) {
            angles = intersections.map(function(point) {
              var delta = point.subtract(center);
              return Math.atan2(delta.y, delta.x);
            });
            intersectionAngles = intersectionAngles.concat(angles);
          }
        }

        accumulateAngle(self);
        for (var i = 0; i < self.numParents(); i++) {
          accumulateAngle(self.parentsList[i]);
        }
        self.eachChild(function(i, child) {
          accumulateAngle(child);
        });
        return intersectionAngles;
      }
      function calculateOffset(intersectionAngles) {
        var kAttractionToLowerRight = 0.001,
          // How much to prefer lower-right angles relative to large arcs:
          // roughly the extra arc reward for a lower right angle.

          //  Upper left in a coordinate system where down increases y.
          kUpperLeftAngle = -3.0 * (Math.PI / 4.0),
          i,
          bestAngleMetric = 0.0,
          bestAngle = 0.0,
          hSemiAxis = size.width / 2,
          vSemiAxis = size.height / 2,
          LABEL_SLOP_X = 8,
          LABEL_SLOP_Y = 5,
          arcLen,
          angle,
          angleMetric,
          lowerRightPreference;

        if (intersectionAngles.length > 0) {
          /* Sort the intersection angles, and make the entry at the end = first + TWO_PI,
           for convenience of further calculations.
           */
          intersectionAngles.sort(GSP.compare);
          intersectionAngles.push(intersectionAngles[0] + Math.PI * 2);

          /* Find the largest gap */
          for (i = 0; i < intersectionAngles.length; i++) {
            arcLen = intersectionAngles[i + 1] - intersectionAngles[i];
            angle = (intersectionAngles[i + 1] + intersectionAngles[i]) / 2.0;

            /* The angle metric will essentialy be the arc length. We will also add a small factor
             proportional to the distance from the upper left (i.e. a preference for the lower right).
             This will break ties in favor of the lower right, which is the default label position.
             */
            angleMetric = arcLen;

            lowerRightPreference = angle - kUpperLeftAngle;
            lowerRightPreference = Math.min(
              Math.abs(lowerRightPreference),
              Math.abs(Math.PI * 2 - lowerRightPreference)
            );
            angleMetric += kAttractionToLowerRight * lowerRightPreference;

            if (angleMetric > bestAngleMetric) {
              bestAngleMetric = angleMetric;
              bestAngle = angle;
            }
          }

          return {
            x: (hSemiAxis + LABEL_SLOP_X) * Math.cos(bestAngle) - hSemiAxis,
            y: (vSemiAxis + LABEL_SLOP_Y) * Math.sin(bestAngle) - vSemiAxis,
          };
        } else {
          return { x: LABEL_SLOP_X, y: LABEL_SLOP_Y };
        }
      }
      var offset = calculateOffset(getIntersectionAngles());
      var labelStyle = this.style.label;
      labelStyle.labelOffsetX = offset.x;
      labelStyle.labelOffsetY = offset.y;
    },

    /**
     * Add method to handle the key down event.
     */
    handleKeyDown: function(event, sketch) {},

    /**
     * Add method to handle the key up event.
     */
    handleKeyUp: function(event, sketch) {},

    handleClick: function(event, sketch) {},

    handleFocusIn: function(event, sketch) {},

    handleFocusOut: function(event, sketch) {},

    isWSPSaysExist: function() {
      return this.sQuery.sketch.wspSaysAndTabsObjects.wspSaysExist;
    },

    isGobjInsideDocumentBound: function() {
      var sketchRect = this.sQuery.sketch.metadata.sketchRect;
      var gobjRect = this.getGeomBounds();

      if (gobjRect) {
        if (
          gobjRect.left < sketchRect.left &&
          gobjRect.right < sketchRect.left
        ) {
          return false;
        }

        if (
          gobjRect.left > sketchRect.right &&
          gobjRect.right > sketchRect.right
        ) {
          return false;
        }

        if (gobjRect.top < sketchRect.top && gobjRect.bottom < sketchRect.top) {
          return false;
        }

        if (
          gobjRect.top > sketchRect.bottom &&
          gobjRect.bottom > sketchRect.bottom
        ) {
          return false;
        }
      }

      return true;
    },
  };

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class Placeholder for an unknown kind.
   */

  /**
   *  @class Unknown
   *  @augments GSP.gObjects.Kind
   */

  GSP.gObjects.Unknown = GSP.makeClass(
    /** @lends GSP.gObjects.Unknown */ [GSP.gObjects.Kind, GSP.Genus],
    {
      doc: {
        description:
          'An unknown object generated as a result of some translation process. Will not be displayed.',
        inherits: 'Kind',
        refspec: {
          msg: 'A convenience of the design. No reference specification.',
        },
        properties: {
          kind: {
            description: 'Kind of GObject.',
            required: true,
            type: 'Name',
          },
        },
      },
      kind: 'Unknown',

      hitTest: function(rect, hotSpot) {
        return false;
      },

      render: function(drawContext, drawRefCon, renderArgs) {},

      transform: function(sketch, trans) {},
    }
  );

  /*
   * @version 0.0
   *
   * Sampler describes a Sketchpad object that samples a parent object across a
   * range of values or positions, creating a single object that represents a
   * collection of the sampled values.  An example is a point locus which traces
   * out a path of a point as another point moves along a specified path.
   *
   * Constraints that declare themselves of Kind sampler have the following requirements:
   * - They must initialize and maintain a vectorContext in the sampler gobj,
   *   which will be used when making calls to the GSP.mixin.vector API.
   * - They must implement the method sampleGObj() which returns an implementor of
   *   the  GSP.mixin.vector API.
   * - They can optionally implement  initSamplerConstraint() which allows them a
   *   chance to do any initialization.
   * - If the sampler object can be treated as a path, it also must implement
   *   the following path utilities:
   *   samplerPathValueToPosition()
   *   samplerPositionToPathValue()
   *   samplerPathLength()
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class Sampler.
   * @augments GSP.gObjects.Kind
   */
  GSP.gObjects.Sampler = (function() {
    //Currently this is written only for functionPlot, but could eventually be
    //generalized for other loci endpoint dragging, which isn't currently supported
    var EndPointDragTracker = (function() {
      var proto = GSP.makeClass(GSP.TouchTracker, {
        functionPlot: null,
        dragWhichPoint: '', // "high" or "low"

        // Actually update the function plot's domain, at the endpoint
        // being dragged
        updateDriverDomain: function(domainVal) {
          this.functionPlot.driverDomain[this.dragWhichPoint] = domainVal;
          this.functionPlot.rawSamples = null;
          this.functionPlot.invalidateGeom();
        },
        swap: function() {
          var dd = this.functionPlot.driverDomain,
            temp = dd.low;
          dd.low = dd.high;
          dd.high = temp;
          this.dragWhichPoint = this.dragWhichPoint === 'low' ? 'high' : 'low';
        },
        // Are we dragging one endpoint beyond the other?
        shouldSwap: function(domainVal) {
          var dd = this.functionPlot.driverDomain;
          return (
            (this.dragWhichPoint === 'low' && domainVal > dd.high) ||
            (this.dragWhichPoint === 'high' && domainVal < dd.low)
          );
        },
        getAnchorNode: function() {
          return this.functionPlot.sQuery.sketch.anchorNode;
        },
        touchBegan: function() {
          if (this.functionPlot.getFunctionType() === 'XofY_FunctionExprType') {
            this.getAnchorNode().css({ cursor: 'ns-resize' });
          } else {
            this.getAnchorNode().css({ cursor: 'ew-resize' });
          }
        },
        touchEnded: function() {
          this.getAnchorNode().css({ cursor: 'default' });
        },
        touchMoved: function(pos) {
          var coordSys = this.functionPlot.getParent('coordSys');
          var coordPoint = coordSys.locatePoint(
            GSP.GeometricPoint(pos.x, pos.y)
          );

          // For x of y functions, we track the movement of the y axis,
          // but for all others we track the movement of the x
          // axis.
          var xOrY =
            this.functionPlot.getFunctionType() === 'XofY_FunctionExprType'
              ? 'y'
              : 'x';
          if (this.shouldSwap(coordPoint[xOrY])) {
            this.swap();
          }
          this.updateDriverDomain(coordPoint[xOrY]);
        },
      });
      return {
        create: function(functionPlot, dragWhichPoint) {
          var instance = Object.create(proto);

          instance.functionPlot = functionPlot;
          instance.dragWhichPoint = dragWhichPoint;
          return instance;
        },
      };
    })();

    return GSP.makeClass(
      /** @lends GSP.gObjects.Picture */ [
        GSP.gObjects.Kind,
        GSP.mixins.label,
        GSP.genera.Path,
      ],
      {
        doc: {
          description:
            'A collection made by sampling some geometric or numeric function',
          inherits: 'Kind',
          refspec: {
            gspKindRef: 'SamplerKind',
          },
          usage: {},
          supported: true,
          properties: {
            numSamples: {
              description: 'The number of samples of the underlying object',
              type: 'Number',
            },
            driverDomain: {
              description:
                'The lower bound when sampling with a numeric driver',
              properties: {
                low: {
                  description: 'The lower bound of the domain when sampling',
                  type: 'Number',
                },
                high: {
                  description: 'The upper bound of the domain when sampling',
                  type: 'Number',
                },
              },
            },
            isDiscrete: {
              description:
                'For a point-based sampler, whether or not to connect the samples as a continuous path.',
              type: 'Boolean',
            },
            showEndpoints: {
              description:
                'Whether to display endpoints/arrowheads of the locus',
              type: 'Boolean',
            },
            style: {
              description:
                'Properties that influence the appearance of a GObject. ' +
                "Accepts style properties appropriate for the 'drivenObject' as well.",
              properties: {
                endpointRadius: {
                  description: '',
                  type: 'Number',
                  required: false,
                },
                arrowheadRadius: {
                  description: '',
                  type: 'Number',
                  required: false,
                },
              },
              // Accepts style properties appropriate for the 'drivenObject'.
              // Until we have a means to pull style docs from another object, we
              // simply disable verification of style properties by accepting all.
              regex: /^[a-zA-Z0-9-_]+$/,
            },
          },
        },
        kind: 'Sampler',
        hasLabel: true,
        state: {},
        renderPrepare: function(drawContext, renderArgs) {
          renderArgs.kind = this.kind;
          renderArgs.id = this.id;

          if (this.sampleGObj().prepareVectorRendering) {
            return this.sampleGObj().prepareVectorRendering(
              drawContext,
              this.vectorContext,
              renderArgs
            );
          }
        },
        renderCleanup: function(drawContext, drawRefCon) {
          if (this.sampleGObj().cleanupVectorRendering) {
            return this.sampleGObj().cleanupVectorRendering(
              drawContext,
              drawRefCon,
              this.vectorContext
            );
          }
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var path,
            props = {
              leftEndpoint: null,
              rightEndpoint: null,
              radius: this.style.radius,
              renderable: this.isRenderable(),
              opacity: this.calculateOpacity(),
            };

          if (this.state.mergeTarget) {
            props.width = this.style.width + GSP.targetHighlightPathBolding;
            props.color = GSP.targetHighlightColor;
            props.suppressParametricColor = true;
          } else {
            props.width = this.style.width;
            props.color = this.style.color;
          }

          if (this.showEndpoints) {
            path = this.getParent('domainObject');

            //closed paths get no endpoints regardless of preference
            if (path && !path.closedPath) {
              switch (path.genus) {
                case 'Segment':
                case 'SimpleArc':
                  props.leftEndpoint = 'endpoint';
                  props.rightEndpoint = 'endpoint';
                  props.endpointRadius = this.style.endpointRadius;
                  break;
                case 'Ray':
                case 'Bisector':
                  props.leftEndpoint = 'endpoint';
                  props.rightEndpoint = 'arrowhead';
                  props.endpointRadius = this.style.endpointRadius;
                  props.arrowheadRadius = this.style.arrowheadRadius;
                  break;
                default:
                  props.leftEndpoint = 'arrowhead';
                  props.rightEndpoint = 'arrowhead';
                  props.arrowheadRadius = this.style.arrowheadRadius;
              }
            }

            if (!path) {
              //samplers without a path get arrowheads by default
              props.leftEndpoint = 'arrowhead';
              props.rightEndpoint = 'arrowhead';
              props.arrowheadRadius = this.style.arrowheadRadius;
            }
          }

          this.modifyRenderAttrsForCurrentState(props);
          this.setLineDash(props);

          if (this.sampleGObj().renderVector) {
            this.updateKindHTMLStyle();
            return this.sampleGObj().renderVector(
              drawContext,
              drawRefCon,
              renderArgs,
              this.vectorContext,
              props
            );
          }
        },
        getColorableComponent: function() {
          switch (this.constraint) {
            case 'ParametricPolarCurvePlot':
            case 'ParametricCartesianCurvePlot':
            case 'FunctionPlot':
              return 'Plot';
            default:
              return 'PointLocus'; //Not quite right; this could be any kind of locus,
            //but this is the only preference for any locus
          }
        },
        getGeomBounds: function() {
          if (this.sampleGObj().getGeomBoundsVector) {
            return this.sampleGObj().getGeomBoundsVector(this.vectorContext);
          }
        },
        hitTest: function(rect /*, hotSpot*/) {
          var self = this;

          function endpointHitTest() {
            var functionPlot = self;
            function hitEndPoint(whichPoint) {
              var endPoint = functionPlot.samplerPathValueToPosition(
                functionPlot.driverDomain[whichPoint]
              );

              if (GSP.Geom.PointInRect(endPoint, rect)) {
                return EndPointDragTracker.create(functionPlot, whichPoint);
              } else {
                return false;
              }
            }

            if (functionPlot.plottingInfo.polar) {
              // We don't yet support endpoint dragging for polar coordinate systems
              return false;
            } else {
              // Either they hit an endpoint or they hit the whole gobj.
              return hitEndPoint('high') || hitEndPoint('low') || false;
            }
          }

          function hitTheSampler() {
            if (self.sampleGObj().hitTestVector) {
              return self.sampleGObj().hitTestVector(self.vectorContext, rect);
            }
          }

          if (this.constraint === 'FunctionPlot') {
            return endpointHitTest() || hitTheSampler();
          } else {
            return hitTheSampler();
          }
        },
        transform: function(sketch, trans) {
          //unused
        },
        /**
         *  returns the appropriate layer to render into
         */
        getRenderingLayer: function() {
          var sampleGObj = this.sampleGObj && this.sampleGObj();
          return sampleGObj && sampleGObj.getVectorRenderingLayer
            ? sampleGObj.getVectorRenderingLayer(this.vectorContext)
            : 'NeverVisible';
        },
        initializeClone: function initializeClone(originalObject) {
          (initializeClone.base || arguments.callee.base).call(
            this,
            originalObject
          );
          this.init();
        },

        isAPath: function() {
          var sampleGObj = this.sampleGObj && this.sampleGObj();

          return (sampleGObj && sampleGObj.isPathSampleGObj) || false;
        },

        /* ----- Path API Implementation ----- * */
        /* Most sampler paths are in the range of [0-1] regardless of the range of
         * the parental drive path.  (Most drive paths are also in the parametric range
         * of 0-1, but there are a few exceptions: ray and line being notable ones.
         * Any samplers that are exceptions (function plot, parameteric locus) should implement:
         * -samplerConstrainRange()
         * -samplerIsValueInBounds()
         * -samplerPathValueToPosition()
         * -samplerPositionToPathValue()
         */
        mapPathValueToPosition: function mapPathValueToPosition(
          iPathValue,
          output
        ) {
          if (this.samplerPathValueToPosition) {
            return this.samplerPathValueToPosition(iPathValue, output);
          }
          GSP.signalErrorWithMessage(
            'This sampler constraint does not implement the path API'
          );
        },
        mapPositionToPathValue: function mapPositionToPathValue(iPosition) {
          if (this.samplerPositionToPathValue) {
            return this.samplerPositionToPathValue(iPosition);
          }
          GSP.signalErrorWithMessage(
            'This sampler constraint does not implement the path API'
          );
        },
        constrainRange: function(v) {
          if (this.samplerConstrainRange) {
            return this.samplerConstrainRange(v);
          }

          var result = v,
            low = 0,
            high = 1;

          if (v > high) {
            result = high;
          }

          if (v < low) {
            result = low;
          }

          return result;
        },
        isValueInBounds: function(v) {
          if (this.samplerIsValueInBounds) {
            return this.samplerIsValueInBounds(v);
          }

          return v >= 0 && v <= 1;
        },
        constrainLabel: function constrainLabel() {
          //Path implementation is sufficient if we're a point vector.
          //Label positioning for non-point vectors is TBW
          (constrainLabel.base || arguments.callee.base).call(this);
        },
        pathLength: function() {
          if (this.samplerPathLength) {
            return this.samplerPathLength();
          }
        },
        getDefaultLabelPathParam: function() {
          return 0.5;
        },
        getAnimationRange: function getAnimationRange() {
          var ret;

          if (this.driverDomain) {
            ret = { min: this.driverDomain.low, max: this.driverDomain.high };
          } else {
            ret = (getAnimationRange.base || arguments.callee.base).call(this);
          }

          return ret;
        },
        verificationString: function verificationString(expected, args) {
          var msg = verificationString.base.call(this, expected, args),
            sampleGObj = this.sampleGObj();

          if (
            this.state.exists &&
            expected.exists &&
            sampleGObj.getGeomForSample
          ) {
            var firstSampleGeom = sampleGObj.getGeomForSample(
                this.vectorContext,
                0
              ),
              lastSampleGeom = sampleGObj.getGeomForSample(
                this.vectorContext,
                this.numSamples - 1
              ),
              firstSampleExpect,
              lastSampleExpect;

            //Here, we assume getGeomForSample returns the geom of a point,
            //which has a loc.x and loc.y value.  This may be a reasonable requirement
            //of getGeomForSample, or we may want to support more kinds of geometry.
            //We defer that for now until we have official support for such objects.
            //Getting the exporter to export the geometry of a particular sample of
            //arbitrary type is quite a lot of work.  Saying a sample has a debug
            //'position' represented by a single point may be more desirable.
            if (expected.firstSamplePoint !== 'nonexisting') {
              firstSampleExpect = GSP.GeometricPoint(
                expected.firstSamplePoint.x,
                expected.firstSamplePoint.y
              );

              if (
                !GSP.GeometricPoint.expect(
                  firstSampleGeom.loc,
                  firstSampleExpect
                )
              ) {
                msg +=
                  'firstSample: <span class="error">' +
                  firstSampleGeom.loc +
                  '</span>(<span class="expected">' +
                  firstSampleExpect +
                  '</span>)';
              }
            }

            if (expected.lastSamplePoint !== 'nonexisting') {
              lastSampleExpect = GSP.GeometricPoint(
                expected.lastSamplePoint.x,
                expected.lastSamplePoint.y
              );
              if (
                !GSP.GeometricPoint.expect(lastSampleGeom.loc, lastSampleExpect)
              ) {
                msg +=
                  'lastSample: <span class="error">' +
                  lastSampleGeom.loc +
                  '</span>(<span class="expected">' +
                  lastSampleExpect +
                  '</span>)';
              }
            }
          }

          return msg;
        },
      }
    );
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class A Map Object is in essence a virtual workhorse for IteratedImage's
   * Each iterated image represents a piece of the whole iteration. But because
   * you need to calculate the whole iteration in order to know the geometry of
   * each subset, we create this class to compute complete iterated geometry in
   * its constraint. Then each IteratedImage can then be a child, and can query
   * its parent for geometry - its constrain() can be a no-op.
   *
   * This technique mirrors the desktop's, but in fact is an implementation detail.
   * From the user point of view, the IteratedImage's are the real sketchpad objects.
   * An alternate implementation might just cache the same geometrical information
   * in a central location accesible to the IteratedImages.
   *
   */

  /**
   *  @class Map
   *  @augments GSP.gObjects.Kind
   */

  GSP.gObjects.Map = GSP.makeClass(
    /** @lends GSP.gObjects.Map */ [GSP.gObjects.Kind, GSP.Genus],
    {
      doc: {
        description: 'A Map.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'MapKind',
        },
        supported: true,
        usage: {},
        properties: {
          rerandomizePointsOnPaths: {
            description: '',
            required: false,
            type: 'Boolean',
          },
          finalIterationOnly: {
            description: '',
            required: false,
            type: 'Boolean',
          },
        },
      },
      kind: 'Map',
      style: {},

      state: {},
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: false,

      initializeClone: function initializeClone(originalObject) {
        (initializeClone.base || arguments.callee.base).call(
          this,
          originalObject
        );
        this.init();
      },

      geom: {},

      getGeomBounds: function() {
        //Maps have no geom bounds
        return;
      },
      getColorableComponent: function() {
        return '';
      },
      isHittable: function() {
        return false;
      },
      hitTest: function(rect, hotSpot) {
        //hit test does nothing of its own
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        //Map does no rendering of its own
      },
      getRenderingLayer: function() {
        return 'NeverVisible';
      },
      testConsistency: function testConsistency(iName, iActual, iExpected) {
        //Desktop sets the existence of all iterate maps to false, but WSP
        //has a more standard view of map existence.  Therefore, skip existence
        //comparisons.
        return iName === 'exists'
          ? ''
          : (testConsistency.base || arguments.callee.base).call(this);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  GSP.gObjects.IterateImage = GSP.makeClass(
    /** @lends GSP.gObjects.IterateImage */ [GSP.gObjects.Kind, GSP.Genus],
    {
      doc: {
        description: '',
        refspec: {
          gspRef: 'IterateImageKind',
        },
        supported: true,
        properties: {
          description: {
            description:
              'a description of the role of the gobject in the sketch.',
            required: false,
            type: 'String',
          },
          style: {
            description:
              'Properties that influence the appearance of a GObject. ' +
              "Accepts style properties appropriate for the 'source' as well.",
            // Accepts style properties appropriate for the 'source'.
            // Until we have a means to pull style docs from another object, we
            // simply disable verification of style properties by accepting all.
            regex: /^[a-zA-Z0-9-_]+$/,
          },
        },
      },
      kind: 'IterateImage',
      clonedGObj: undefined,
      initializeSampleBuffer: function() {
        var map = this.getParent('map'),
          clonedGObj = this.clonedGObj,
          numSamples = 0;

        function calculateNumSamples(depth, numMaps) {
          var addend, d, ret;

          if (numMaps === 1) {
            return depth;
          } else {
            ret = 0;
            addend = numMaps;
            for (d = 0; d < depth; d++) {
              ret += addend;
              addend *= numMaps;
            }
          }

          return ret;
        }

        if (map.currentDepth) {
          numSamples = map.finalIterationOnly
            ? Math.pow(map.numMaps, map.currentDepth)
            : calculateNumSamples(map.currentDepth, map.numMaps);
        }

        try {
          this.vectorContext = clonedGObj.createVectorContext(
            numSamples,
            this,
            clonedGObj.constraintChangesColor
          );
        } catch (error) {
          GSP.log(
            'Object ' +
              clonedGObj.id +
              ' failed to create vector context: ' +
              error
          );
          this.state.exists = false;
        }

        this.numSamples = numSamples;
      },

      generateNameMFS: function generateNameMFS(option) {
        var mfs = (generateNameMFS.base || arguments.callee.base).call(
          this,
          option
        );
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('Iterated Image '),
          mfs
        );
      },

      initializeClone: function initializeClone(originalObject) {
        (initializeClone.base || arguments.callee.base).call(
          this,
          originalObject
        );
        this.init();
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        if (this.clonedGObj.prepareVectorRendering) {
          return this.clonedGObj.prepareVectorRendering(
            drawContext,
            this.vectorContext,
            renderArgs
          );
        }
      },
      renderCleanup: function(drawContext, drawRefCon) {
        if (this.clonedGObj.cleanupVectorRendering) {
          return this.clonedGObj.cleanupVectorRendering(
            drawContext,
            drawRefCon,
            this.vectorContext
          );
        }
      },

      render: function(drawContext, drawRefCon, renderArgs) {
        var props = {
          hidden: this.style.hidden,
          width: this.style.width,
          color: this.style.color,
          radius: this.style.radius,
          opacity: this.calculateOpacity(),
          renderable: true,
          constraintFrame: this.state.constraintFrame,
          // Even if the sampleGobj doesn't currently exist, we must
          // render the vector because some samples may still exist,
          // and they must be rendered to erase themselves.
        };
        if (this.style['line-style']) {
          GSP.modifyRenderAttrsForLineStyle(this.style['line-style'], props);
        }
        this.modifyRenderAttrsForCurrentState(props);
        if (this.clonedGObj.renderVector) {
          this.updateKindHTMLStyle();
          return this.clonedGObj.renderVector(
            drawContext,
            drawRefCon,
            renderArgs,
            this.vectorContext,
            props
          );
        }
      },

      getGeomBounds: function() {
        if (this.clonedGObj.getGeomBoundsVector) {
          return this.clonedGObj.getGeomBoundsVector(this.vectorContext);
        }
      },
      hitTest: function(rect /*, hotSpot*/) {
        if (this.clonedGObj.hitTestVector) {
          return this.clonedGObj.hitTestVector(this.vectorContext, rect);
        }
      },
      transform: function(sketch, trans) {
        //not needed
      },
      curSampleNum: 0,
      clearSamples: function() {
        this.curSampleNum = 0;
        this.terminalSampleIndex = undefined;

        if (this.clonedGObj.resetVectorSamples) {
          this.clonedGObj.resetVectorSamples(this.vectorContext);
        }
      },
      sampleCountChanged: function() {
        this.initializeSampleBuffer();
      },
      collectSample: function() {
        if (this.clonedGObj.fillSingleSample && this.clonedGObj.state.exists) {
          this.clonedGObj.fillSingleSample(
            this.vectorContext,
            this.curSampleNum
          );
          this.curSampleNum++;
        }
      },
      stampTerminalSample: function() {
        this.terminalSampleIndex = this.curSampleNum - 1;
      },
      getRenderingLayer: function() {
        var clonedGObj = this.clonedGObj;

        return clonedGObj.getVectorRenderingLayer
          ? clonedGObj.getVectorRenderingLayer(this.vectorContext)
          : 'NeverVisible';
      },
      getTerminalGeom: function() {
        var finalSampleIndex = this.curSampleNum - 1;
        var source = this.getParent('source');
        var copiedGeom = {};

        //Special case where the image doesn't exist because we're at 0 iterations.
        //Here the terminal point should exist, so we must use its source's geom,
        //provided it's existing.
        if (source.state.exists && this.terminalSampleIndex === -1) {
          GSP.GeomTransformer.copyGeom(source.geom, copiedGeom);
          return copiedGeom;
        }

        //The basic case - terminal sample is the last one we've sampled
        if (
          this.clonedGObj.getGeomForSample &&
          this.terminalSampleIndex === finalSampleIndex
        ) {
          return this.clonedGObj.getGeomForSample(
            this.vectorContext,
            this.terminalSampleIndex
          );
        }

        //Otherwise, terminal geom is non-existing
        return null;
      },
      verificationString: function(expected, args) {
        var msg = '';

        //TBD

        return msg;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class A Button is an action control.
   * It is represented on the sketch display as an HTML input button.
   * A button is draggable, unless style.select is set to false.
   * Buttons take an action parameter, where the value of this parameter
   * is a bit of javascript that will be executed when the button is
   * pressed.
   * @augments GSP.gObjects.Kind
   */
  GSP.gObjects.Button = GSP.makeClass(
    /** @lends GSP.gObjects.Button */ [GSP.gObjects.Kind, GSP.mixins.labelBase],
    (function() {
      var ButtonPressTracker = GSP.makeClass(GSP.TouchTracker, {
        sketch: null,
        button: null,
        touchBegan: function(/*pos*/) {
          this.button.state.inClick = ++this.button.state.inClick || 1;
          this.sketch.invalidateGeom(this.button);
        },
        touchEnded: function() {
          this.button.state.inClick = --this.button.state.inClick;
          this.sketch.invalidateGeom(this.button);
          if (this.button.state.inClick < 0) {
            throw GSP.createError(
              'ButtonPressTracker: press count went negative!  Should be impossible'
            );
          }

          if (this.button.state.inClick === 0) {
            this.button.press(this.sketch, 'touchEnded');
            // Delay sending this event until the button is active. Otherwise an event handler has
            // no way to test whether the button has finished.
            this.sketch.event(
              'PressButton',
              { gobj: this.button },
              { buttonType: this.button.constraint }
            );
          }
        },
      });

      function createButtonPressTracker(button) {
        var instance = Object.create(ButtonPressTracker);
        instance.sketch = button.sQuery.sketch;
        instance.button = button;

        return instance;
      }

      return {
        doc: {
          description: 'A control that initiates some action.',
          inherits: 'Kind',
          refspec: {
            gspKindRef: 'ActionKind',
            msg:
              'Buttons have the appearance defined by their host browser. The appearance of buttons is meant to be familiar to browser users.',
          },
          defaultConstraint: 'ActionButton',
          existenceRule: 'Exists regardless of existence of parent.',
          usage: {},
          properties: {
            geom: {
              description: 'The basic geometry of the GObject',
              properties: {
                loc: {
                  description: 'The position of the GObject',
                  properties: {
                    x: {
                      description:
                        'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                    y: {
                      description:
                        'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                      type: 'Number',
                    },
                  },
                },
              },
            },
            style: {
              description: '',
              properties: {
                autostart: {
                  description:
                    'Whether the button should be executed at sketch start time.',
                  type: 'Boolean',
                },
                color: {
                  description:
                    'The background color. Text color is described by the label.color property.',
                  type: 'Color',
                },
                'highlight-color': {
                  description: '',
                  type: 'Color',
                  required: false,
                },
                label: {
                  // most label properties inherrited from GSP.mixins.labelBase
                  properties: {
                    showLabel: {
                      description:
                        "The label for a button is the text on the button. It's always shown, so the value of showLabel is ignored.",
                      required: false,
                    },
                  },
                },
              },
            },
            state: {
              isActive: {
                description: 'Whether the button is in currently active',
                type: 'Boolean',
              },
              pressedDown: {
                description:
                  "Button's appearance indicates it's currently under the user's touch",
                type: 'Boolean',
              },
              pressedUp: {
                description:
                  "Button's appearance indicates it's pressed, but not currently under the user's touch",
                type: 'Boolean',
              },
            },
          },
        },
        kind: 'Button',
        style: {
          autostart: false,
        },

        state: {
          isActive: false,
          pressedDown: false,
          pressedUp: false,
        },
        autoplacementType: 'Button',

        createDefaultStyle: function createDefaultStyle() {
          var colorableComponent = this.getColorableComponent(),
            prefs = this.sQuery.sketch.preferences,
            style = (createDefaultStyle.base || arguments.callee.base).call(
              this
            );

          if (
            colorableComponent &&
            prefs.colorableComponents[colorableComponent].color
          ) {
            style.color = prefs.colorableComponents[colorableComponent].color;
          }

          return style;
        },
        doPostReadFromSpec: function doPostReadFromSpec() {
          (doPostReadFromSpec.base || arguments.callee.base).call(this);
          this.geom.loc = GSP.GeometricPoint(this.geom.loc.x, this.geom.loc.y);
        },
        // @param {String} mode is "pageSwitch", "undoRedo", "toolDone", or undefined
        onLoad: function(sketch, mode) {
          if (this.style.autostart && mode !== 'undoRedo') {
            // Don't autostart during undo/redo
            this.press(sketch);
            if (mode === 'toolDone') {
              delete this.style.autostart; // autostart tool buttons fire once, not on subsequent page switches
            }
          }
          this.state.firstTime = false;

          if (this.htmlNode && this.isGobjInsideDocumentBound() === false) {
            this.htmlNode.attr('aria-hidden', 'true');
            this.htmlNode.removeAttr('tabindex');
          }
        },
        getColorableComponent: function() {
          return 'ActionButton';
        },
        getTextType: function() {
          return 'Action';
        },
        doModifyRenderAttrsForState: function(attrs, state) {
          switch (state) {
            case 'speculative':
              attrs.opacity = GSP.speculativeOpacity;
              break;
            case 'none':
            case undefined:
              //No change
              break;
            default:
              GSP.log(
                'Unexpected render state: ' +
                  this.state.renderState +
                  ' for kind: ' +
                  this.kind
              );
              break;
          }
        },
        renderPrepare: function(drawContext, renderArgs) {
          var labelStyle = this.style.label || {},
            fontFamily = GSP.getFontFamilyFromStyle(labelStyle, this.sQuery());
          renderArgs.id = this.id;
          renderArgs.kind = this.kind;
          renderArgs.color = labelStyle.color || this.style.color;
          renderArgs['background-color'] = this.style.color;
          renderArgs['font-family'] = fontFamily;
          renderArgs['font-style'] = labelStyle['font-style'];
          renderArgs['font-weight'] = labelStyle['font-weight'];
          renderArgs['font-size'] = labelStyle['font-size'];
          renderArgs['text-decoration'] = labelStyle['text-decoration'];
          renderArgs['text-align'] = 'left';
          renderArgs['vertical-align'] = 'top';
          renderArgs['highlight-color'] = this.style['highlight-color'];

          return drawContext.prepareButton(renderArgs);
        },
        renderCleanup: function(drawContext, drawRefCon) {
          drawContext.cleanupButton(drawRefCon);
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var x = 0,
            y = 0,
            renderable = this.isRenderable(),
            visibility = renderable ? 'visible' : 'hidden',
            displayObject = drawRefCon,
            attrs = {
              visibility: visibility,
              constraintFrame: this.state.constraintFrame,
              zIndex: renderArgs.zIndex,
            };
          this.updateButtonSpeakableText(this.oldText, this.label);

          if (renderable) {
            x = this.geom.loc.getX();
            if (isNaN(x)) {
              x = 0;
            }
            y = this.geom.loc.getY();
            if (isNaN(y)) {
              y = 0;
            }
            attrs.x = x;
            attrs.y = y;
            if (this.oldText !== this.label) {
              try {
                this.parsedMFS = GSP.labels.parseLabelExpression(
                  this.label,
                  false
                );
              } catch (ex) {
                ex.message = 'On Button ' + this.id + ': ' + ex.message;
                GSP.signalCaughtError(ex);
              }
              attrs.text = this.label;
              attrs.parsedMFS = this.parsedMFS;
              this.oldText = this.label;
              attrs.forceDomParse = true;
            }

            attrs.isHighlight = this.state.isActive;
            attrs.inClick = this.state.inClick;
            attrs.isDragging = this.state.isDragging;
            attrs.selectable = this.style.selectable;
            attrs['handle-color'] = this.style.color;
            attrs.opacity = this.calculateOpacity();
          }
          this.modifyRenderAttrsForCurrentState(attrs);

          drawContext.drawButton(displayObject, attrs);

          this.updateKindHTMLStyle();
        },
        /*
         * @override kind.checkParentsExist
         * As far as is known, buttons always exist, even if parents do not.
         */
        checkParentsExist: function() {
          return true;
        },
        /*
         * @override kind.isHittable
         * non-selectable buttons should still be hittable.
         */

        isHittable: function() {
          return this.isRenderable();
        },

        hitTest: function(rect, hotSpot) {
          var displayObj = this.sQuery.sketch.getDisplayObjForGObj(this),
            dims,
            rect1,
            intersection,
            hitObject = false,
            hitHandle = false;

          if (displayObj) {
            dims = {
              left: this.geom.loc.getX(),
              top: this.geom.loc.getY(),
              width: displayObj.width(),
              height: displayObj.height(),
            };
            rect1 = {
              left: dims.left,
              right: dims.left + dims.width,
              top: dims.top,
              bottom: dims.top + dims.height,
            };

            if (hotSpot) {
              hitObject =
                hotSpot.x >= rect1.left &&
                hotSpot.x <= rect1.right &&
                hotSpot.y >= rect1.top &&
                hotSpot.y <= rect1.bottom;
              if (hitObject) {
                rect1.right = dims.left + displayObj.dragHandleWidth();
                hitHandle = hotSpot.x <= rect1.right;
              }
            } else {
              intersection = {
                left: Math.max(rect.left, rect1.left),
                right: Math.min(rect.right, rect1.right),
                top: Math.max(rect.top, rect1.top),
                bottom: Math.min(rect.bottom, rect1.bottom),
              };

              hitObject =
                intersection.left < intersection.right &&
                intersection.top < intersection.bottom;
            }
          }

          if (hitHandle && this.style.selectable) {
            return true; //we want a default drag tracker
          }

          if (hitObject) {
            //We've hit the button, and not its handle.  We want the custom
            //button tracker
            return createButtonPressTracker(this);
          }

          return false;
        },
        getGeomBounds: function() {
          //TODO: getRectFromDisplayObject is duplicated code from text kind, which
          //is not a super class of button kind.  It also duplicates a lot of
          //the code in the hit test method above.... How to common source all of this...
          var self = this;

          function getRectFromDisplayObject(displayObj, originPoint) {
            var width,
              height,
              left,
              top,
              attrs = displayObj.attrs;
            if (!displayObj || !displayObj.element) {
              return;
            }
            if (!originPoint) originPoint = self.geom.loc;
            width = displayObj.width();
            height = displayObj.height();
            left = originPoint.getX();
            top = originPoint.getY();
            if (attrs['text-align'] === 'center') {
              left -= width / 2;
            }
            if (attrs['vertical-align'] === 'middle') {
              top -= height / 2;
            }
            return {
              left: left,
              right: left + width,
              top: top,
              bottom: top + height,
            };
          }

          var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this);

          return displayObject && getRectFromDisplayObject(displayObject);
        },
        transform: function(sketch, trans) {
          this.geom.loc = trans.geom.loc.copy();
          trans.affine.transform(this.geom.loc);
        },
        handleClick: function(event, sketch) {
          this.press(sketch);
        },

        activate: function(newState, source) {
          if (newState !== this.state.isActive) {
            this.state.isActive = newState;
            this.pressSource = newState ? source : undefined;
            this.sQuery.sketch.event(
              'ActivateButton',
              { gobj: this },
              { isActive: newState, buttonType: this.constraint }
            );
          }
        },

        updateKindHTMLStyle: function() {
          var sketch = this.sQuery.sketch;
          if (!this.htmlNode) {
            var displayObjForGObj = sketch.getDisplayObjForGObj(this);
            if ('element' in displayObjForGObj && displayObjForGObj.element) {
              this.htmlNode = displayObjForGObj.element;
              sketch.gobjAddKeyEvents(this);
            }
          }

          if (!this.oldLabel) this.oldLabel = this.label;
        },

        updateButtonSpeakableText: function() {
          var sketch = this.sQuery.sketch;

          if (this.state.pressedDown || this.state.pressedUp) {
            if (
              sketch.focusedGobj &&
              !this.htmlNode[0].isSameNode(sketch.focusedGobj.htmlNode[0])
            ) {
              sketch.setSpeakabletext('');
              return;
            }

            if (
              this.state.pressedDown &&
              this.isGobjExistInWSPSays('wspButtonDownSaysGobjId')
            ) {
              this.state.pressedDown = false;
              sketch.updateWSPButtonDownSpeakableText(this);
              return;
            }

            if (
              this.state.pressedUp &&
              this.isGobjExistInWSPSays('wspButtonUpSaysGobjId')
            ) {
              this.state.pressedUp = false;
              sketch.updateWSPButtonUpSpeakableText(this);
              return;
            }

            this.state.pressedDown = false;
            this.state.pressedUp = false;
            var speakabletext = '';

            if (
              this.constraint === 'ActionButtonLinkURL' ||
              this.constraint === 'ActionButtonLinkPage'
            ) {
              speakabletext = 'Switching Page';
              sketch.setSpeakabletext(speakabletext);
              return;
            }

            if (this.constraint === 'ActionButtonScroll') {
              speakabletext = 'Done Scrolling';
              sketch.setSpeakabletext(speakabletext);
              return;
            }

            if (
              this.constraint === 'ActionButtonShow' ||
              this.constraint === 'ActionButtonHide' ||
              this.constraint === 'ActionButtonToggleHideShow'
            ) {
              if (this.oldLabel === this.label) {
                speakabletext =
                  'Done. Press again to repeat the action ' + this.label;
                sketch.setSpeakabletext(speakabletext);
                return;
              }
            }

            if (this.oldLabel !== this.label) {
              speakabletext = 'Done. Press button again to ' + this.label;
              this.oldLabel = this.label;
            } else {
              if (this.state.isActive) {
                speakabletext =
                  'Started. Press again to stop the action ' + this.label;
              } else {
                speakabletext =
                  'Stopped. Press again to restart the action ' + this.label;
              }
            }

            sketch.setSpeakabletext(speakabletext);
          }
        },

        isGobjExistInWSPSays: function(key) {
          return this.sQuery.sketch.wspSaysAndTabsObjects[key][this.id]
            ? true
            : false;
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class Circle
   *  @augments GSP.gObjects.Kind
   *  @augments GSP.genera.Path
   */
  GSP.gObjects.Circle = GSP.makeClass(
    /** @lends GSP.gObjects.Circle */ [
      GSP.gObjects.Kind,
      GSP.mixins.label,
      GSP.mixins.circleVector,
      GSP.genera.Path,
    ],
    {
      doc: {
        description: 'The curve describing the limits of a circle.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'CircleKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              'line-style': {
                description: "Type of line: 'solid', 'dotted', 'dashed'",
                type: 'String',
                required: false,
              },
              width: {
                description: 'The width of the curve line in pixels.',
                type: 'Number',
              },
            },
          },
        },
      },
      kind: 'Circle',

      style: {
        hidden: false,
        width: 3,
        selectable: true,
      },
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: true,
      geom: {},
      getGeometricArc: function() {
        if (!this.state.constraintCache) {
          this.state.constraintCache = {};
        }

        if (!this.state.constraintCache.arc) {
          this.state.constraintCache.arc = GSP.GeometricArc.FromCenterAndRadius(
            this.geom.c,
            this.geom.r
          );
        }

        return this.state.constraintCache.arc;
      },
      doPostReadFromSpec: function doPostReadFromSpec() {
        (doPostReadFromSpec.base || arguments.callee.base).call(this);
        this.geom.c = GSP.GeometricPoint.ORIGIN;
        this.geom.r = 0;
      },
      getColorableComponent: function() {
        return 'Curves';
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.prepareCircle(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupCircle(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        var renderable = this.isRenderable();
        var cx = -100,
          cy = -100,
          r = -100;

        if (renderable) {
          cx = Number(this.geom.c.x);
          if (isNaN(cx)) {
            cx = 0;
          }
          cy = Number(this.geom.c.y);
          if (isNaN(cy)) {
            cy = 0;
          }
          r = Number(this.geom.r);
          if (isNaN(r)) {
            r = 0;
          }
        }

        var attrs = {
          renderable: renderable,
          cx: cx,
          cy: cy,
          r: r,
          color: this.style.color,
          width: this.style.width,
          opacity: this.calculateOpacity(),
        };

        this.modifyRenderAttrsForCurrentState(attrs);
        this.setLineDash(attrs);

        drawContext.drawCircle(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },

      getGeomBounds: function() {
        var bounds,
          exp = this.style.width / 2 || 1.5;
        if (this.state.exists) {
          bounds = GSP.Geom.insetRect(
            {
              left: this.geom.c.x,
              top: this.geom.c.y,
              right: this.geom.c.x,
              bottom: this.geom.c.y, //,
              //width: 0,
              //height: 0
            },
            -this.geom.r - exp
          );
        }
        return bounds;
      },
      hitTest: function(rect, hotSpot) {
        return GSP.Geom.RectIntersectsCurve(rect, {
          type: 'circle',
          curve: GSP.GeometricArc.FromCenterAndRadius(this.geom.c, this.geom.r),
        });
      },

      transform: function(sketch, trans) {},
      createTransformer: function(destination) {
        var pointTransformer = destination.getTransform(),
          distTransformer = destination.getScalarTransform();
        return {
          getAffineTransform: function() {
            return GSP.AffineTransform.fromPointTransform(pointTransformer);
          },
          transformGeom: function(sourceGeom, destGeom) {
            destGeom.c = pointTransformer(sourceGeom.c);
            destGeom.r = distTransformer(sourceGeom.r);
          },
        };
      },
      /**
       * A path value on a circle is its radial coordinate. That is, its
       * angle in radians. Path values are normalized to a range of 0 to 1.
       */
      mapPositionToPathValue: function(pointVector) {
        var p = pointVector.subtract(this.geom.c);
        var r = Math.atan2(-p.getY(), p.getX());
        var ret = r / (2 * Math.PI);

        if (ret < 0) {
          ret += 1;
        }

        return ret;
      },
      mapPathValueToPosition: function(value, output) {
        var twoPIv = value * 2 * Math.PI,
          v = GSP.GeometricPoint(
            this.geom.r * Math.cos(twoPIv),
            -this.geom.r * Math.sin(twoPIv)
          );
        if (output) {
          output.derivative = GSP.GeometricPoint(v.y, -v.x);
        }
        return this.geom.c.add(v);
      },
      getAnimationRange: function() {
        //For closed paths we return a value just less than 1, since a value
        //of 1 should wrap around as a value of 0
        return { min: 0, max: 1.0 - 10e-8 };
      },
      /**
       * Returns the area of the circle.
       */
      area: function() {
        return Math.PI * this.geom.r * this.geom.r;
      },
      /**
       * Returns the circumference of the circle.
       */
      circumference: function() {
        return 2 * Math.PI * this.geom.r;
      },
      /**
       * Returns the circumference of the circle.
       */
      pathLength: function() {
        return this.circumference();
      },
      /**
       * Returns the radius of the circle.
       */
      radius: function() {
        return this.geom.r;
      },
      getDefaultLabelPathParam: function() {
        return 0.875;
      },
      closedPath: true,
      verificationString: function verificationString(expected, args) {
        var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          ),
          c,
          r;

        if (msg === '' && this.state.exists) {
          c = GSP.GeometricPoint(expected.c.x, expected.c.y);
          r = expected.r;
          if (!GSP.GeometricPoint.expect(c, this.geom.c)) {
            msg +=
              'center: <span class="error">' +
              this.geom.c +
              '</span>(<span class="expected">' +
              c +
              '</span>)';
          }
          if (!GSP.math.expect(r, this.geom.r)) {
            msg +=
              'radius: <span class="error">' +
              this.geom.r +
              '</span>(<span class="expected">' +
              r +
              '</span>)';
          }
        }
        return msg;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class A Picture.
   * @augments GSP.gObjects.Kind
   */
  GSP.gObjects.Picture = GSP.makeClass(
    /** @lends GSP.gObjects.Picture */ [
      GSP.gObjects.Kind,
      GSP.Genus,
      GSP.mixins.vector,
    ],
    (function() {
      function hitTestRectWithPic(rect, pic, transform, optClipPoly) {
        var a, b, c, ret;

        a = transform.transform(GSP.GeometricPoint(0, pic.height));
        b = transform.transform(GSP.GeometricPoint(0, 0));
        c = transform.transform(GSP.GeometricPoint(pic.width, 0));

        ret = GSP.Geom.ParallelogramSectsRect(rect, a, b, c);

        if (ret && optClipPoly) {
          ret = GSP.Geom.RectSectsPolygon(rect, optClipPoly);
        }

        return ret;
      }

      return {
        doc: {
          description: 'An Image.',
          inherits: 'Kind',
          refspec: {
            gspKindRef: 'PictureKind',
            msg: 'An embedded picture',
          },
          usage: {},
          properties: {
            image: {
              description: 'The source image of the picture',
              required: false,
              type: 'Image',
            },
            style: {
              description: '',
              properties: {
                layerOrder: {
                  description: 'z-index within the set of Interiors and Images',
                  type: 'Number',
                },
                opacity: {
                  description: '0 (transparent) to 1 (fully opaque)',
                  default: '0.5',
                  type: 'Number',
                },
              },
            },
          },
        },
        kind: 'Picture',
        style: {
          opacity: 0.5,
        },

        state: {},
        doPostReadFromSpec: function doPostReadFromSpec() {
          (doPostReadFromSpec.base || arguments.callee.base).call(this);
          if (this.geom.transform) {
            this.geom.transform = GSP.AffineTransform(this.geom.transform);
          }
        },
        getColorableComponent: function() {
          return 'Picture';
        },
        doModifyRenderAttrsForState: function(attrs, state) {
          switch (state) {
            case 'speculative':
              attrs.opacity = GSP.speculativeOpacity;
              break;
            case 'none':
            case undefined:
              //No change
              break;
            case 'targetOnFocus': // This case will be triggered when gobject get focus.
              attrs.isFocusable = true;
              attrs.color = GSP.targetFocusColor;
              attrs.width = 3 + GSP.targetFocusPathBolding;
              break;
            default:
              GSP.log(
                'Unexpected render state: ' +
                  this.state.renderState +
                  ' for kind: ' +
                  this.kind
              );
              break;
          }
        },
        renderPrepare: function(drawContext, renderArgs) {
          renderArgs.kind = this.kind;
          renderArgs.id = this.id;
          renderArgs.image = this.getImage();
          renderArgs.onStateChange = (function(gobj) {
            return function() {
              gobj.sQuery().invalidateGeom(gobj);
              //GSP.log('Picture: invalidating ' + gobj.id);
            };
          })(this);
          renderArgs.pictureCache = this.getDocument().pictureCache;

          return drawContext.preparePicture(renderArgs);
        },
        renderCleanup: function(drawContext, drawRefCon) {
          return drawContext.cleanupPicture(drawRefCon);
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var attrs = {
            renderable: this.isRenderable(),
            transform: this.geom.transform,
            opacity: this.calculateOpacity(),
            clipPolygon: this.geom.clipVertices,
          };

          this.modifyRenderAttrsForCurrentState(attrs);

          drawContext.drawPicture(drawRefCon, attrs);

          this.updateKindHTMLStyle();
        },
        getGeomBounds: function() {
          var img,
            pts = [],
            t,
            bounds = {};
          if (!this.state.exists) {
            return;
          }
          img = this.getImage();
          if (!img) {
            return;
          }
          t = this.geom.transform;
          pts.push(t.transform(GSP.GeometricPoint(0, img.height)));
          pts.push(t.transform(GSP.GeometricPoint(0, 0)));
          pts.push(t.transform(GSP.GeometricPoint(img.width, 0)));
          pts.push(t.transform(GSP.GeometricPoint(img.width, img.height)));
          $.each(pts, function(k, v) {
            if (bounds.left === undefined || v.x < bounds.left) {
              bounds.left = v.x;
            }
            if (bounds.right === undefined || v.x > bounds.right) {
              bounds.right = v.x;
            }
            if (bounds.top === undefined || v.y < bounds.top) {
              bounds.top = v.y;
            }
            if (bounds.bottom === undefined || v.y > bounds.bottom) {
              bounds.bottom = v.y;
            }
          });
          //bounds.width = right - bounds.left;
          //bounds.height = bottom - bounds.top;
          return GSP.Geom.insetRect(bounds, -1);
        },
        hitTest: function(rect /*, hotSpot*/) {
          var img = this.getImage();

          return hitTestRectWithPic(
            rect,
            img,
            this.geom.transform,
            this.geom.clipVertices
          );
        },
        transform: function(sketch, trans) {
          this.geom.transform = trans.geom.transform.compose(trans.affine);
        },
        constrainLabel: function() {},
        /*
        Find our source image.
       */
        getImage: function() {
          // if we don't have the image, our source parent may (i.e.
          // we're a transformation).
          if (this.image == null && this.parents && this.parents.source) {
            return this.getParent('source').getImage();
          }
          return typeof this.image === 'number'
            ? this.sQuery().getResource('pictures', this.image)
            : this.image;
        },
        verificationString: function verificationString(expected, args) {
          var msg = (verificationString.base || arguments.callee.base).call(
              this,
              expected,
              args
            ),
            self = this;

          if (msg === '' && this.state.exists) {
            $.each(GSP.AffineTransform.KeyNames, function() {
              if (
                undefined !== expected[this] &&
                !GSP.math.expect(self.geom.transform[this], expected[this])
              ) {
                msg +=
                  this +
                  ': <span class="error">' +
                  self.geom.transform[this] +
                  '</span>(<span class="expected">' +
                  expected[this] +
                  '</span>)';
              }
            });

            //p0 = GSP.GeometricPoint(expected.loc.x, expected.loc.y);
            //if( !GSP.GeometricPoint.expect(p0, this.geom.loc)) {
            //  msg += 'loc: <span class="error">' + this.geom.loc + '</span>(<span class="expected">' + p0 + "</span>)";
            //}
          }
          return msg;
        },
        /************ Vector API Implementation *********/
        createVectorContext: function(numSamples, parentSampler, colorize) {
          var ret = {
            numSamples: numSamples,
            parentSampler: parentSampler,
            samples: GSP.createFloatVector(
              numSamples * GSP.AffineTransform.packedSampleSize
            ),
          };

          if (this.geom.clipVertices) {
            ret.clipVerticesArray = [];
          }

          return ret;
        },
        fillSingleSample: function(vectorContext, index) {
          var theTransform = this.geom.transform;

          vectorContext.filledSampleCount++;
          theTransform.packIntoSampleArray(vectorContext.samples, index);

          if (this.geom.clipVertices) {
            vectorContext.clipVerticesArray[index] = this.geom.clipVertices;
          }

          vectorContext.geomBounds = GSP.Geom.unionRects(
            vectorContext.geomBounds,
            this.getGeomBounds()
          );
        },
        generateNameMFS: function generateNameMFS() {
          var name = (generateNameMFS.base || arguments.callee.base).call(this);
          var prepend = this.genus === 'Drawing' ? 'Drawing ' : 'Picture ';
          return GSP.mfs.makeHorizontalMFS(GSP.mfs.makeTextMFS(prepend), name);
        },
        getGeomBoundsVector: function(vectorContext) {
          return vectorContext.geomBounds;
        },
        hitTestVector: function(vectorContext, rect) {
          var img = this.getImage(),
            transform,
            clipVertices,
            samples = vectorContext.samples,
            numSamples = vectorContext.filledSampleCount;

          for (var i = 0; i < numSamples; ++i) {
            transform = GSP.AffineTransform.fromPackedSampleArray(samples, i);
            clipVertices =
              vectorContext.clipVerticesArray &&
              vectorContext.clipVerticesArray[i];
            if (hitTestRectWithPic(rect, img, transform, clipVertices)) {
              return true;
            }
          }

          return false;
        },
        getVectorRenderingLayer: function(vectorContext) {
          return 'ExternalImagesAndInteriors';
        },

        prepareVectorRendering: function(
          drawContext,
          vectorContext,
          renderArgs
        ) {
          renderArgs.kind = this.kind;
          renderArgs.id = this.id;
          renderArgs.image = this.getImage();
          renderArgs.onStateChange = (function(gobj) {
            return function() {
              gobj.sQuery().invalidateGeom(gobj);
            };
          })(vectorContext.parentSampler);
          renderArgs.pictureCache = this.getDocument().pictureCache;

          return drawContext.preparePictureVector(renderArgs);
        },
        renderVector: function(
          drawContext,
          drawRefCon,
          renderArgs,
          vectorContext,
          parentProperties
        ) {
          var attrs = $.extend(true, {}, parentProperties);

          attrs.transformSamples = vectorContext.samples;
          attrs.clipPolygons = vectorContext.clipVerticesArray;
          attrs.numSamples = vectorContext.filledSampleCount;
          attrs.renderable = true;

          drawContext.drawPictureVector(drawRefCon, attrs);
        },
        cleanupVectorRendering: function(drawContext, drawRefCon) {
          return drawContext.cleanupPictureVector(drawRefCon);
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class A geometric point.
   * A point is defined by a location in a cartesian plane. It does not have width
   * or height, although its representation may.
   * @property style object How to decorate a point. The style parameters: width
   * (a number, in pixels, defaults to 5), color (in css color designators,
   * defaults to "#ff0000"), drag-expansion (a
   * number, in pixels, defaults to 5), hidden (a boolean; defaults fo false),
   * selectable: (a boolean; defaults to
   * true.)
   * @protected {object} state Current state of object.
   * @protected geom
   * @method init undefined Initializes the point: read the initial geometry, if it is defined
   * and constructs geom.loc, a GeometricPoint.
   */

  /**
   *  @class Point
   *  @augments GSP.gObjects.Kind
   */
  GSP.gObjects.Point = GSP.makeClass(
    /** @lends GSP.gObjects.Point */
    [GSP.gObjects.Kind, GSP.mixins.label, GSP.mixins.pointVector, GSP.Genus],
    {
      doc: {
        description: 'A location in the Euclidean plane.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'PointKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              color: {
                description: 'Foreground color of the Point.',
                type: 'Color',
              },
              'drag-expansion': {
                description:
                  'The Point expands by this number of pixels when dragged.',
                type: 'Number',
              },
              radius: {
                description:
                  'The radius of the filled circle that represents the Point.',
                type: 'Number',
              },
              traced: {
                description: 'Whether the point should be traced.',
                type: 'Boolean',
              },
              tracedStyle: {
                description: 'Style overrides for traced appearance.',
                required: false,
                properties: {
                  color: {
                    description: 'Foreground color of the traced GObject.',
                    type: 'Color',
                  },
                  radius: {
                    description: '.',
                    type: 'Number',
                  },
                },
              },
            },
          },
        },
      },
      kind: 'Point',
      style: {
        'drag-expansion': 5,
        hidden: false,
        label: {
          showLabel: false,
        },
        radius: 4,
        selectable: true,
        traced: false,
      },

      state: {},
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: true,

      doModifyRenderAttrsForState: function(attrs, state) {
        switch (state) {
          case 'speculative':
            attrs.color = GSP.speculativeColor;
            break;
          case 'hotTarget':
            attrs.radius = this.style.radius + this.style['drag-expansion'];
            break;
          case 'matchedGiven':
          case 'targetHighlit':
            attrs.dropShadow = true;
            attrs.radius = this.style.radius + this.style['drag-expansion'];
            break;
          case 'unmatchedGiven':
            attrs.dropShadow = true;
            break;
          case 'invisible':
          case 'none':
          case undefined:
            //No change
            break;
          case 'targetOnFocus': // This case will be triggered when gobject get focus.
            attrs.isFocusable = true;
            attrs.color = GSP.targetFocusColor;
            attrs.radius = this.style.radius + GSP.radiusExpansionOnFocus;
            break;
          default:
            GSP.log(
              'Unexpected render state: ' +
                this.state.renderState +
                ' for kind: ' +
                this.kind
            );
            break;
        }
      },

      geom: {
        loc: {
          x: 0,
          y: 0,
        },
      },

      doPostReadFromSpec: function doPostReadFromSpec() {
        (doPostReadFromSpec.base || arguments.callee.base).call(this);
        this.geom.loc = GSP.GeometricPoint(this.geom.loc.x, this.geom.loc.y);
      },
      getColorableComponent: function() {
        return 'Points';
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.preparePoint(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupPoint(drawRefCon);
      },

      /* This is a temporary stopgap until we implement the full genera hierarchy (WSP-1378). */
      matchesAssumedSpec: function matchesAssumedSpec(assumedSpec) {
        return assumedSpec.kind === 'Point';
      },

      render: function(drawContext, drawRefCon, renderArgs) {
        var renderable,
          radius,
          color,
          dragExp,
          cx,
          cy,
          attrs,
          traced = renderArgs.traced ? true : false,
          lineWidth = 1,
          opacity = this.calculateOpacity(),
          style = this.style;

        if (this.state.renderState === 'invisible') {
          return;
        }

        radius = style.radius;
        color = style.color;
        dragExp = style['drag-expansion'];
        renderable = this.isRenderable();

        if (renderable) {
          cx = this.geom.loc.getX();
          if (isNaN(cx)) {
            cx = 0;
          }
          cy = this.geom.loc.getY();
          if (isNaN(cy)) {
            cy = 0;
          }
        } else {
          cx = cy = -100;
        }

        if (renderArgs.drag) {
          radius += dragExp;
        }

        if (traced) {
          radius *= 0.75;
          opacity *= 0.5;
          lineWidth = 0;
          style = style.tracedStyle;
          if (style) {
            if (undefined !== style.radius) {
              radius = style.radius;
            }
            if (undefined !== style.color) {
              color = style.color;
            }
          }
        }

        attrs = {
          renderable: renderable,
          cx: cx,
          cy: cy,
          radius: radius,
          color: color,
          lineWidth: lineWidth,
          opacity: opacity,
        };

        this.modifyRenderAttrsForCurrentState(attrs);

        drawContext.drawPoint(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },

      getGeomBounds: function() {
        var bounds,
          exp = this.style.radius + this.style['drag-expansion'],
          attrs = {};

        //To determine if we need to expand for drop-shadow, we modify an empty attrs object
        //and then check for presence of a dropShadow property
        this.modifyRenderAttrsForCurrentState(attrs);
        if (attrs.dropShadow) {
          exp += 10; //see canvasEngine for reference: shadowOffset of 3 + shadowBlur of 7
        }

        if (this.state.exists) {
          bounds = GSP.Geom.insetRect(
            {
              left: this.geom.loc.x,
              top: this.geom.loc.y,
              right: this.geom.loc.x,
              bottom: this.geom.loc.y, //,
              //width: 0,
              //height: 0
            },
            -exp
          );
        }
        return bounds;
      },
      constrainLabel: function() {
        this.labelSpec.location = this.geom.loc;
      },

      hitTest: function(rect, hotSpot) {
        var x = this.geom.loc.getX(),
          y = this.geom.loc.getY(),
          r = this.style.radius,
          box = {
            left: x - r,
            right: x + r,
            top: y - r,
            bottom: y + r,
          };

        // if box entirely to the right, to the left, above, or below rect
        // then box and rect don't intersect, otherwise they do
        return !(
          box.right < rect.left || // box to the left of rect
          box.left > rect.right || // box to the right of rect
          box.bottom < rect.top || // box above rect
          box.top > rect.bottom
        ); // box below rect
      },

      transform: function(sketch, trans) {
        this.geom.loc = trans.geom.loc.copy();
        trans.affine.transform(this.geom.loc);
      },
      createTransformer: function(destination) {
        var pointTransformer = destination.getTransform();
        return {
          getAffineTransform: function() {
            return GSP.AffineTransform.fromPointTransform(pointTransformer);
          },
          transformGeom: function(sourceGeom, destGeom) {
            destGeom.loc = pointTransformer(sourceGeom.loc);
          },
        };
      },
      createDefaultSpec: function(sketch, props) {
        var locX =
          (sketch.metadata.sketchRect.right - sketch.metadata.sketchRect.left) /
          2;
        var locY =
          (sketch.metadata.sketchRect.bottom - sketch.metadata.sketchRect.top) /
          2;
        var style = (props && props.style) || {};
        var label = (props && props.label) || '';

        if (props && props.geom && props.geom.loc) {
          // Grab its location, which will be relative to a (0,0) origin.
          locX = sketch.metadata.sketchRect.left + props.geom.loc.x;
          locY = sketch.metadata.sketchRect.top + props.geom.loc.y;
        }

        return {
          '1': {
            kind: 'Point',
            genus: 'Point',
            constraint: 'Free',
            style: style,
            label: label,
            geom: {
              loc: {
                x: locX,
                y: locY,
              },
            },
          },
        };
      },
      verificationString: function verificationString(expected, args) {
        var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          ),
          p0;

        if (msg === '' && this.state.exists) {
          p0 = GSP.GeometricPoint(expected.loc.x, expected.loc.y);
          if (!GSP.GeometricPoint.expect(p0, this.geom.loc)) {
            msg +=
              'loc: <span class="error">' +
              this.geom.loc +
              '</span>(<span class="expected">' +
              p0 +
              '</span>)';
          }
        }
        return msg;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class Polygon
   *  @augments GSP.gObjects.Kind
   */

  GSP.gObjects.Polygon = GSP.makeClass(
    /** @lends GSP.gObjects.Polygon */ [
      GSP.gObjects.Kind,
      GSP.mixins.label,
      GSP.mixins.vector,
      GSP.genera.Path,
      GSP.genera.Interior,
    ],
    {
      doc: {
        description:
          'The planar area bound by connecting a series of points by straight line segments.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'PolygonKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              'line-style': {
                description: "Type of line: 'solid', 'dotted', 'dashed'",
                type: 'String',
                required: false,
              },
              width: {
                description: 'Width of the strokes in pixels',
                type: 'Number',
                required: false,
              },
              opacity: {
                description: '0 (transparent) to 1 (fully opaque)',
                type: 'Number',
              },
              layerOrder: {
                description: 'z-index within the set of Interiors and Images',
                type: 'Number',
              },
              framePerimeter: {
                description: 'Display with a frame that shows the perimeter',
                type: 'Boolean',
                required: false,
              },
            },
          },
        },
      },
      kind: 'Polygon',

      style: {
        hidden: false,
        framePerimeter: false,
        width: 3,
        opacity: 0.5,
      },

      state: {},
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: true,

      getColorableComponent: function() {
        return 'Interior';
      },
      doModifyRenderAttrsForState: function(attrs, state) {
        this.modifyRenderAttrsForInterior(attrs, state);
      },
      renderPrepare: function(drawContext, renderArgs) {
        return drawContext.preparePolygon({});
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupPolygon(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        var renderable = this.isRenderable(),
          attrs = {
            renderable: renderable,
            points: this.geom.points,
            opacity: this.calculateOpacity(),
            color: this.style.color,
          };

        if (this.style.framePerimeter) {
          attrs.drawBorder = true;
          attrs.borderColor = this.style.color;
          attrs.borderWidth = this.style.width;
          attrs.fadeOpacity = this.calculateFadeOpacity();
        }

        this.modifyRenderAttrsForCurrentState(attrs);

        drawContext.drawPolygon(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },
      getNumVertices: function() {
        var theBasePolygon = this;

        while (
          theBasePolygon &&
          theBasePolygon.parents &&
          theBasePolygon.parents.source !== undefined
        ) {
          theBasePolygon = theBasePolygon.parents.source;
        }

        return theBasePolygon.numParents();
      },

      getGeomBounds: function() {
        var bounds = {},
          left,
          right,
          top,
          bottom,
          ext = this.style.width || 0;
        if (!this.state.exists) {
          return;
        }
        $.each(this.geom.points, function(ix, p) {
          if (p.x !== undefined && p.y !== undefined) {
            if (left === undefined || p.x < left) {
              left = p.x;
            }
            if (top === undefined || p.y < top) {
              top = p.y;
            }
            if (right === undefined || p.x > right) {
              right = p.x;
            }
            if (bottom === undefined || p.y > bottom) {
              bottom = p.y;
            }
          }
        });
        if (bounds.left + bounds.top === undefined) {
          return;
        }
        bounds.left = left;
        bounds.top = top;
        bounds.right = right;
        bounds.bottom = bottom;
        //bounds.width = right - left;
        //bounds.height = bottom - top;
        return GSP.Geom.insetRect(bounds, -ext);
      },

      hitTest: function(rect, hotSpot, options) {
        var points = this.geom.points,
          perimeterOnly = options && options.interiorsPerimeterOnly;

        return perimeterOnly
          ? GSP.Geom.RectSectsPolygonPerimeter(rect, points)
          : GSP.Geom.RectSectsPolygon(rect, points);
      },

      transform: function(sketch, trans) {
        trans.affine.transform(this.geom.points);
      },
      createTransformer: function(destination) {
        var pointTransformer = destination.getTransform();
        return {
          getAffineTransform: function() {
            return GSP.AffineTransform.fromPointTransform(pointTransformer);
          },
          transformGeom: function(sourceGeom, destGeom) {
            var i;
            if (!destGeom.points) {
              destGeom.points = [];
            }
            for (i = 0; i < sourceGeom.points.length; i++) {
              destGeom.points[i] = pointTransformer(sourceGeom.points[i]);
            }
          },
        };
      },
      /**
       * A path value on a polygon is its position on the perimeter,
       * normalized to [0,1]
       */
      mapPositionToPathValue: function(pointVector) {
        var bestDistance2 = Infinity,
          value = 0;
        var head, tail, delta, distance, ix, p, d;
        var points = this.geom.points;
        var sum = 0;

        for (ix = 0; ix < points.length; ix += 1) {
          tail = points[ix];
          head = points[(ix + 1) % points.length];
          delta = tail.subtract(head);
          distance = delta.vLength();
          p = GSP.GeometricPoint.mapPointToLine(tail, head, pointVector, {
            returnPoint: true,
            clampP0: true,
            clampP1: true,
          });
          d = p.point.subtract(pointVector).vLength2();
          if (d < bestDistance2) {
            value = sum + p.param * distance;
            bestDistance2 = d;
          }
          sum += distance;
        }

        return value / sum;
      },
      mapPathValueToPosition: function(value, output) {
        var perimeter = this.perimeter();
        var head, tail, delta, distance, ix;
        var points = this.geom.points;
        var sum = 0;

        if (!this.isValueInBounds(value)) {
          return GSP.GeometricPoint.UNDEFINED;
        }

        value = value - Math.floor(value);
        value *= perimeter;

        for (ix = 0; ix < points.length; ix += 1) {
          tail = points[ix];
          head = points[(ix + 1) % points.length];
          delta = head.subtract(tail);
          distance = delta.vLength();
          if (value <= sum + distance) {
            if (output) {
              output.derivative = GSP.GeometricPoint(
                delta.x / (distance / perimeter),
                delta.y / (distance / perimeter)
              );
            }
            return tail.add(delta.multiply((value - sum) / distance));
          }
          sum += distance;
        }

        if (output) {
          output.derivative = GSP.GeometricPoint(
            delta.x / (distance / perimeter),
            delta.y / (distance / perimeter)
          );
        }
        return tail;
      },
      mapPathValueToCharacteristic: function(value) {
        var perimeter = this.perimeter();
        var head, tail, delta, distance, ix;
        var points = this.geom.points;
        var sum = 0;

        value *= perimeter;

        for (ix = 0; ix < points.length; ix += 1) {
          tail = points[ix];
          head = points[(ix + 1) % points.length];
          delta = head.subtract(tail);
          distance = delta.vLength();
          if (value < sum + distance) {
            return { baseVertex: ix, baseValue: (value - sum) / distance };
          }
          sum += distance;
        }
        return { baseVertex: 0, baseValue: 1.0 };
      },

      /**
       * Returns the perimeter of the polygon in pixel units.
       */
      perimeter: function() {
        var head, tail, distance, ix;
        var points = this.geom.points;
        var sum = 0;
        for (ix = 0; ix < points.length; ix += 1) {
          tail = points[ix];
          head = points[(ix + 1) % points.length];
          distance = head.subtract(tail).vLength();
          sum += distance;
        }
        return sum;
      },
      pathLength: function() {
        return this.perimeter();
      },
      getAnimationRange: function() {
        //For closed paths we return a value just less than 1, since a value
        //of 1 should wrap around as a value of 0
        return { min: 0, max: 1.0 - 10e-8 };
      },
      /**
       * Returns the area of the polygon in pixel units.
       */
      area: function() {
        var head, tail, xproduct, ix;
        var points = this.geom.points;
        var area2 = 0;
        for (ix = 0; ix < points.length; ix += 1) {
          tail = points[ix];
          head = points[(ix + 1) % points.length];
          xproduct = tail.x * head.y - tail.y * head.x;
          area2 += xproduct;
        }
        return Math.abs(area2 / 2);
      },
      closedPath: true,
      getVertices: function() {
        //Client assumes this.geom.points is immutable.  If we ever mutate this in-place
        //we should return a copy here.
        return this.geom.points;
      },
      /******* Vector API Implementation *********/
      createVectorContext: function(numSamples, parentSampler, colorize) {
        var numVertices = this.getNumVertices();

        return {
          numSamples: numSamples,
          samples: GSP.createFloatVector(numSamples * 2 * numVertices),
          numVertices: numVertices,
          colors: colorize ? [] : null,
        };
      },
      fillSingleSample: function(vectorContext, index) {
        var i,
          numVertices = vectorContext.numVertices,
          samples = vectorContext.samples,
          base = 2 * index * numVertices;

        vectorContext.filledSampleCount++;

        for (i = 0; i < numVertices; ++i) {
          samples[base + i * 2] = this.geom.points[i].x;
          samples[base + i * 2 + 1] = this.geom.points[i].y;
        }

        if (vectorContext.colors) {
          vectorContext.colors[index] = this.style.color;
        }
        vectorContext.geomBounds = GSP.Geom.unionRects(
          vectorContext.geomBounds,
          this.getGeomBounds()
        );
      },
      getGeomBoundsVector: function(vectorContext) {
        var amtToExtend = 0;
        if (vectorContext.geomBounds) {
          if (vectorContext.lineWidth) {
            amtToExtend = vectorContext.lineWidth / 2;
          }

          return GSP.Geom.insetRect(vectorContext.geomBounds, -amtToExtend);
        }
      },
      hitTestVector: function(vectorContext, rect) {
        //We could unroll the algorithm of Geom.RectSectsPolygon() to test all top-lefts
        //first before diving into testing polygon segment intersections, but for now,
        //we leave the code simple until profiling reveals this to be a problem.
        var polygonPoints = [],
          i = 0,
          samples = vectorContext.samples,
          curSample,
          curVertex,
          numSamples = vectorContext.filledSampleCount,
          numVertices = vectorContext.numVertices;

        //build an array of polygon vertices for hit testing
        for (curSample = 0; curSample < numSamples; ++curSample) {
          polygonPoints = [];
          for (curVertex = 0; curVertex < numVertices; ++curVertex) {
            polygonPoints.push(GSP.GeometricPoint(samples[i], samples[i + 1]));
            i += 2;
          }

          if (GSP.Geom.RectSectsPolygon(rect, polygonPoints)) {
            return true;
          }
        }

        return false;
      },
      getVectorRenderingLayer: function(vectorContext) {
        return 'ExternalImagesAndInteriors';
      },

      prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
        return drawContext.preparePolygonVector(renderArgs);
      },
      renderVector: function(
        drawContext,
        drawRefCon,
        renderArgs,
        vectorContext,
        parentProperties
      ) {
        var props = $.extend(true, {}, parentProperties);
        props.samples = vectorContext.samples;
        props.colors = vectorContext.colors;
        props.numVertices = vectorContext.numVertices;
        props.numSamples = vectorContext.filledSampleCount;

        return drawContext.drawPolygonVector(drawRefCon, props);
      },
      cleanupVectorRendering: function(drawContext, drawRefCon) {
        return drawContext.cleanupPolygonVector(drawRefCon);
      },
    }
  );

  /**
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  The family of straight objects: lines, segments, and arrays.
   *  @class Straight
   *  @augments GSP.gObjects.Kind
   */
  GSP.gObjects.Straight = GSP.makeClass(
    /** @lends GSP.gObjects.Straight */ [
      GSP.gObjects.Kind,
      GSP.mixins.label,
      GSP.genera.Path,
      GSP.mixins.vector,
    ],
    {
      doc: {
        description:
          'Any of the family of straight geometric figures: rays, segments, or lines.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'StraightKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              color: {
                type: 'Color',
              },
              width: {
                description: 'Width of the strokes in pixels',
                type: 'Number',
              },
              'line-style': {
                description: "Type of line: 'solid', 'dotted', 'dashed'",
                type: 'String',
                required: false,
              },
            },
          },
          debug: {
            properties: {
              p0: {
                description: 'The first reference point defining the straight.',
                required: false,
                properties: {
                  x: {
                    description:
                      'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                    required: true,
                    type: 'Number',
                  },
                  y: {
                    description:
                      'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                    required: true,
                    type: 'Number',
                  },
                },
              },
              p1: {
                description: 'The second reference point.',
                required: false,
                properties: {
                  x: {
                    description:
                      'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                    required: true,
                    type: 'Number',
                  },
                  y: {
                    description:
                      'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                    required: true,
                    type: 'Number',
                  },
                },
              },
            },
          },
        },
      },
      kind: 'Straight',

      style: {
        hidden: false,
        width: 3,
        'line-style': 'solid',
      },
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: true,
      geom: {},

      straightGenus: function() {
        // returns Segment, Ray, or Line
        // Once genus is properly implemented, this function can be removed.
        var genera = ['Segment', 'Ray', 'Line'],
          ix = genera.indexOf(this.genus),
          retVal;
        if (ix >= 0) {
          // Handle transformed imnages of straights
          retVal = genera[ix];
        } else {
          retVal = 'Line'; // default
          switch (this.constraint) {
            case 'Segment':
              retVal = 'Segment';
              break;
            case 'Ray':
            case 'AngleBisector':
              retVal = 'Ray';
              break;
          }
        }
        return retVal;
      },

      constrainRange: function(v) {
        var result = v;
        switch (this.straightGenus()) {
          case 'Segment':
            if (v > 1) {
              result = 1;
            }
            if (v < 0) {
              result = 0;
            }
            break;
          case 'Ray':
            if (v < 0) {
              result = 0;
            }
            break;
          default:
        }
        return result;
      },
      doPostReadFromSpec: function doPostReadFromSpec() {
        (doPostReadFromSpec.base || arguments.callee.base).call(this);
        this.geom.p0 = GSP.GeometricPoint.ORIGIN;
        this.geom.p1 = GSP.GeometricPoint.ORIGIN;
      },
      collapseDoubledParent: function(parent) {
        // If there are two point parents collapsed into one, delete the straight
        // after merging any midpoint or point-on-path child to the merged parent.
        var sketch = this.sQuery.sketch;
        this.children.forEach(function(child) {
          if (
            child.constraint === 'Midpoint' ||
            child.constraint === 'PointOnPath'
          ) {
            sketch.mergeGobjToCandidate(child, parent);
          }
        });
        sketch.gobjList.removeGObjAndDescendants(this);
      },
      getColorableComponent: function() {
        return 'Straights';
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.prepareSegment(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupSegment(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        function getNum(n) {
          var rtn = Number(n);
          if (isNaN(n)) {
            rtn = 0;
          }
          return rtn;
        }
        var renderable = this.isRenderable(),
          p0x,
          p0y,
          p1x,
          p1y,
          renderAttrs;

        if (renderable) {
          p0x = getNum(this.geom.xp0.x);
          p0y = getNum(this.geom.xp0.y);
          p1x = getNum(this.geom.xp1.x);
          p1y = getNum(this.geom.xp1.y);
        }

        renderAttrs = {
          renderable: renderable,
          p0x: p0x,
          p0y: p0y,
          p1x: p1x,
          p1y: p1y,
          width: this.style.width,
          color: this.style.color,
          opacity: this.calculateOpacity(),
        };

        this.modifyRenderAttrsForCurrentState(renderAttrs);
        this.setLineDash(renderAttrs);

        drawContext.drawSegment(drawRefCon, renderAttrs);

        this.updateKindHTMLStyle();
      },
      getGeomBounds: function() {
        var bounds,
          p0,
          p1,
          ext = this.style.width,
          left,
          right,
          top,
          bottom;

        if (this.state.exists) {
          p0 = this.mapPathValueToPosition(
            this.constrainRange(Number.NEGATIVE_INFINITY)
          );
          p1 = this.mapPathValueToPosition(
            this.constrainRange(Number.POSITIVE_INFINITY)
          );

          // if the straight is axis aligned, this may result in some
          // values being computed as NaN. Resolve to 0.
          p0.x = !isNaN(p0.x) ? p0.x : this.geom.p0.x;
          p0.y = !isNaN(p0.y) ? p0.y : this.geom.p0.y;
          p1.x = !isNaN(p1.x) ? p1.x : this.geom.p1.x;
          p1.y = !isNaN(p1.y) ? p1.y : this.geom.p1.y;

          left = Math.min(p0.x, p1.x);
          right = Math.max(p0.x, p1.x);
          top = Math.min(p0.y, p1.y);
          bottom = Math.max(p0.y, p1.y);
          bounds = GSP.Geom.insetRect(
            {
              left: left,
              top: top,
              right: right,
              bottom: bottom,
            },
            -ext
          );
          if (!GSP.Geom.isValidRect(bounds)) return;
        }

        return bounds;
      },

      hitTest: function(rect, hotSpot) {
        return GSP.Geom.SegmentSectsRect(rect, this.geom.xp0, this.geom.xp1);
      },
      getSignificantBounds: function() {
        var ret = null,
          p0,
          p1,
          ext = this.style.width,
          left,
          right,
          top,
          bottom;

        if (this.state.exists) {
          p0 = this.geom.p0;
          p1 = this.geom.p1;

          left = Math.min(p0.x, p1.x);
          right = Math.max(p0.x, p1.x);
          top = Math.min(p0.y, p1.y);
          bottom = Math.max(p0.y, p1.y);
          ret = GSP.Geom.insetRect(
            {
              left: left,
              top: top,
              right: right,
              bottom: bottom,
            },
            -ext
          );
        }

        return ret;
      },
      transform: function(sketch, trans) {},
      createTransformer: function(destination) {
        var pointTransformer = destination.getTransform();
        return {
          getAffineTransform: function() {
            return GSP.AffineTransform.fromPointTransform(pointTransformer);
          },
          transformGeom: function(sourceGeom, destGeom) {
            destGeom.p0 = pointTransformer(sourceGeom.p0);
            destGeom.p1 = pointTransformer(sourceGeom.p1);
            destGeom.xp0 = pointTransformer(sourceGeom.xp0);
            destGeom.xp1 = pointTransformer(sourceGeom.xp1);
          },
        };
      },
      /*
       * Control Point accessor API's.
       * There are two sets of control points:
       * The Zero and Unit point, which correspond to path values 0 and 1
       * and the P0 and P1 control points, which correspond to points determining
       * the significant bounds of the straight.
       *
       * In general, these are the same pairs, but axes, for example have a different
       * (unit, zero) and (p0, p1).
       *
       * Note also that these accessors are convenience functions - it's valid
       * to just go down to geom.p0 etc. Some clients, however, may wish to use
       * these accessors - that way they can accept other classes (like geometricArc)
       * which implement them.
       */
      getZeroPoint: function() {
        return this.geom.p0;
      },
      getUnitPoint: function() {
        return this.geom.p1;
      },
      getP0: function() {
        return this.geom.p0;
      },
      getP1: function() {
        return this.geom.p1;
      },
      /**
       * Finds the closest point on a path and returns a number which can be used
       * to locate the point on the path.  The value returned is a valid value
       * on the path (in the range [0, 1] for segment and >= 0 for ray, and any value
       * for line)
       * @param position Expects a GeometricPoint object.
       * @return a number
       */
      mapPositionToPathValue: function(position) {
        return this.constrainRange(
          this.mapPositionToExtendedPathValue(position)
        );
      },
      /**
       * Identical to mapPositionToPathValue, but treats the path as a straight
       * line, not clamping the value to the path.
       * @param position Expects a GeometricPoint object.
       * @return a number
       */

      mapPositionToExtendedPathValue: function(position) {
        return GSP.GeometricPoint.mapPointToLine(
          this.getZeroPoint(),
          this.getUnitPoint(),
          position
        ).param;
      },
      mapPathValueToPosition: function(pv, output) {
        var p0 = this.getZeroPoint(),
          p1 = this.getUnitPoint(),
          unitVector = p1.subtract(p0);

        if (output) {
          // Derivatives run P0, P1
          output.derivative = this.getP1().subtract(this.getP0());
        }

        return unitVector.multiply(pv).add(p0);
      },
      mapVectorPathValuesToPositions: function(pathValues) {
        var p0 = this.getZeroPoint(),
          p1 = this.getUnitPoint(),
          unitVector = p1.subtract(p0),
          i,
          arrayLength = pathValues.length,
          ret = [];

        for (i = 0; i < arrayLength; i++) {
          ret[i] = unitVector.multiply(pathValues[i]).add(p0);
        }

        return ret;
      },

      getAnimationRange: function() {
        var sketch,
          sketchRect,
          intersections,
          min,
          max,
          val1,
          val2,
          straightGenus = this.straightGenus(),
          isRay = straightGenus === 'Ray';

        if (straightGenus === 'Segment') {
          return { min: 0, max: 1 };
        }

        sketch = this.sQuery.sketch;
        sketchRect = sketch.sketchRect();
        intersections = GSP.Geom.IntersectionsOfRectAndSegment(
          sketchRect,
          this.geom.xp0,
          this.geom.xp1
        );

        if (intersections.length > 0) {
          val1 = this.mapPositionToPathValue(intersections[0]);
        }

        if (intersections.length === 2) {
          val2 = this.mapPositionToPathValue(intersections[1]);
        }

        if (intersections.length === 1 && isRay) {
          min = 0;
          max = val1;
        } else if (intersections.length === 2) {
          min = Math.min(val1, val2);
          max = Math.max(val1, val2);
        } else {
          //There are no intersections - we are completely off the screen, we choose
          //an arbitrary range of [-1, 2] to animate on, rather than make an
          //empty interval.  cf. FullLinearPath_getInitialLocusDomainBounds() for
          //this logic in desktop.  From its comments: [if it's outside the window
          //bounds] "we return the range centered on the "source segment" of the
          //line and three times its size."
          min = isRay ? 0 : -1;
          max = 2;
        }

        return { min: min, max: max };
      },
      /**
       * Returns the length of the straight between the two reference points in
       * screen coordinates.
       */

      unitLength: function() {
        return this.getUnitPoint()
          .subtract(this.getZeroPoint())
          .vLength();
      },
      /**
       * Returns the length of the animatable path.  For segments, this is simply
       * the distance between the reference points, but for lines or rays it is
       * determined by where the line/ray intersects the screen bounds.
       */

      pathLength: function() {
        var minAndMax = this.getAnimationRange(),
          pathStart = this.mapPathValueToPosition(minAndMax.min),
          pathEnd = this.mapPathValueToPosition(minAndMax.max);

        return pathEnd.subtract(pathStart).vLength();
      },
      /**
       * Returns the nearest point on the path.
       */
      getPointOnPath: function(path, distance) {
        return this.getPointOnLine(path, distance);
      },
      /**
       * Returns the nearest point on a line.
       * @param {object} line - contains two vectors, p0, and p1, defining the
       *                        reference points for the line.
       * @param {number} distance - the distance along the line
       */
      getPointOnLine: function(line, distance) {
        var translatedP1, lineLength;
        translatedP1 = line.p1.subtract(line.p0);
        lineLength = translatedP1.vLength();
        return translatedP1.multiply(distance / lineLength).add(line.p0);
      },
      getPointOnRay: function(ray, distance) {
        var translatedP1, lineLength;
        if (distance <= 0) {
          return ray.p0;
        } else {
          translatedP1 = ray.p1.subtract(ray.p0);
          lineLength = translatedP1.vLength();
          return translatedP1.multiply(distance / lineLength).add(ray.p0);
        }
      },
      getPointOnSegment: function(seg, distance) {
        var normalizedP1, lineLength;
        if (distance <= 0) {
          return seg.p0;
        } else {
          normalizedP1 = seg.p1.subtract(seg.p0);
          lineLength = normalizedP1.vLength();
          if (lineLength <= distance) {
            return seg.p1;
          } else {
            return normalizedP1.multiply(distance / lineLength).add(seg.p0);
          }
        }
      },
      getClosestPointOnLine: function(line, point) {
        var normalizedPoint, normalizedEnd, u, result;
        normalizedPoint = point.subtract(line.p0);
        normalizedEnd = line.p1.subtract(line.p0);
        if (!normalizedEnd.isZeroLength()) {
          u =
            normalizedPoint.dot(normalizedEnd) /
            normalizedEnd.dot(normalizedEnd);
          result = normalizedEnd.multiply(u).add(line.p0);
        } else {
          result = line.p0;
        }
        return result;
      },

      /**
       * Whether the point is within the bounds of the path when mapped
       * to a position on the path.
       */
      pointIsInBounds: function(pointVector, optEndpointToleranceSquared) {
        /* First, we'll check the endpoints to see if they are close to
           pointVector. If they are, we've got a hit. Otherwise, continue
           on to test parameter position */
        var straightGenus = this.straightGenus(),
          distanceSquared,
          tol2 =
            optEndpointToleranceSquared === undefined
              ? 1.5e-21
              : optEndpointToleranceSquared;
        /* c.f. gobjgeom.c:Geom_IntersectStraights_UTIL */

        /* Test first endpoint */
        if (straightGenus === 'Segment' || straightGenus === 'Ray') {
          distanceSquared = pointVector.subtract(this.getP0()).vLength2();
          if (distanceSquared < tol2) {
            return true;
          }
        }

        /* Test second endpoint */
        if (straightGenus === 'Segment') {
          distanceSquared = pointVector.subtract(this.getP1()).vLength2();
          if (distanceSquared < tol2) {
            return true;
          }
        }

        return this.isValueInBounds(
          this.mapPositionToExtendedPathValue(pointVector)
        );
      },

      /** Whether the value assumed to be on the line is within bounds of the line.
       *  @param {Number} value A numeric value to be interpreted as a position on the path.
       *  @return {boolean}
       */
      isValueInBoundsLineGenus: function(value) {
        return true;
      },

      /** Whether the value assumed to be on the line containing this segment
       *  is within bounds of the segment.
       *  @param {Number} value A numeric value to be interpreted as a position on the path.
       *  @return {boolean}
       */
      isValueInBoundsSegmentGenus: function(value) {
        // GSP uses a tolerance of 5e-16.
        // With that value, WSP has a false negative with one of the canon documents.
        // With a tolerance of 1e-15, WSP has a false positive with a different document.
        // We choose an intermediate value that allows all existing canon documents to
        // pass, but recognize that there is some instability here.
        var kHighTolerance = 1.000000000000002,
          kLowTolerance = -0.000000000000002;

        return value >= kLowTolerance && value <= kHighTolerance;
      },

      /** Whether the value assumed to be on the line containing this ray
       *  is within bounds of the ray.
       *  @param {Number} value A numeric value to be interpreted as a position on the path.
       *  @return {boolean}
       */
      isValueInBoundsRayGenus: function(value) {
        // Uses same tolerance as isValueInBoundsSegmentGenus() above
        var kLowTolerance = -0.000000000000002;
        return value >= kLowTolerance;
      },

      /**
       * Whether the value assumed to be on the line containing this path
       * is within bounds of the path.
       */
      isValueInBounds: function(value) {
        var straightGenus = this.straightGenus(),
          fn = {
            Line: this.isValueInBoundsLineGenus,
            Ray: this.isValueInBoundsRayGenus,
            Segment: this.isValueInBoundsSegmentGenus,
          }[straightGenus];
        return GSP.math.isFiniteScalar(value) && fn
          ? fn.call(this, value)
          : false;
      },
      /************ Vector API Implementation *********/
      createVectorContext: function(numSamples, parentSampler, colorize) {
        return {
          numSamples: numSamples,
          samples: GSP.createFloatVector(numSamples * 4),
          colors: colorize ? [] : null,
          lineWidth: parentSampler.style.width,
        };
      },
      fillSingleSample: function(vectorContext, index) {
        var base = 4 * index;

        vectorContext.filledSampleCount++;

        vectorContext.samples[base] = this.geom.xp0.x;
        vectorContext.samples[base + 1] = this.geom.xp0.y;
        vectorContext.samples[base + 2] = this.geom.xp1.x;
        vectorContext.samples[base + 3] = this.geom.xp1.y;

        if (vectorContext.colors) {
          vectorContext.colors[index] = this.style.color;
        }
        vectorContext.geomBounds = GSP.Geom.unionRectPoint(
          vectorContext.geomBounds,
          this.geom.xp0
        );
        vectorContext.geomBounds = GSP.Geom.unionRectPoint(
          vectorContext.geomBounds,
          this.geom.xp1
        );
      },
      getGeomBoundsVector: function(vectorContext) {
        var amtToExtend = 0;

        if (vectorContext.geomBounds) {
          if (vectorContext.lineWidth) {
            amtToExtend = vectorContext.lineWidth / 2;
          }

          return GSP.Geom.insetRect(vectorContext.geomBounds, -amtToExtend);
        }
      },
      hitTestVector: function(vectorContext, rect) {
        var i,
          p0,
          p1,
          numSamples = vectorContext.filledSampleCount,
          samples = vectorContext.samples,
          stride = 4,
          base;

        for (i = 0; i < numSamples; i++) {
          base = stride * i;
          p0 = GSP.GeometricPoint(samples[base], samples[base + 1]);

          p1 = GSP.GeometricPoint(samples[base + 2], samples[base + 3]);

          if (GSP.Geom.SegmentSectsRect(rect, p0, p1)) {
            return true;
          }
        }

        return false;
      },
      getVectorRenderingLayer: function(vectorContext) {
        return 'LineLoci';
      },

      prepareVectorRendering: function(drawContext, vectorContext, renderArgs) {
        return drawContext.prepareSegmentVector(renderArgs);
      },
      renderVector: function(
        drawContext,
        drawRefCon,
        renderArgs,
        vectorContext,
        parentProperties
      ) {
        var props = $.extend(true, {}, parentProperties);
        props.samples = vectorContext.samples;
        props.colors = vectorContext.colors;
        props.numSamples = vectorContext.filledSampleCount;

        return drawContext.drawSegmentVector(drawRefCon, props);
      },
      cleanupVectorRendering: function(drawContext, drawRefCon) {
        return drawContext.cleanupSegmentVector(drawRefCon);
      },
      closedPath: false,
      verificationString: function verificationString(expected, args) {
        var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          ),
          p0,
          p1;

        if (msg === '' && this.state.exists) {
          p0 = GSP.GeometricPoint(expected.p0.x, expected.p0.y);
          p1 = GSP.GeometricPoint(expected.p1.x, expected.p1.y);
          if (
            !GSP.GeometricPoint.expect(p0, this.getP0()) ||
            !GSP.GeometricPoint.expect(p1, this.getP1())
          ) {
            msg +=
              'geom: <span class="error">' +
              this.getP0() +
              ' -> ' +
              this.getP1() +
              '</span>(<span class="expected">' +
              p0 +
              ' -> ' +
              p1 +
              '</span>)';
          }
        }
        return msg;
      },
    }
  );

  /**
   * Common base class for kinds, such as Text and Table, that are
   * represented as rectangular DOM elements containing text.
   *
   * This class handles hit testing, transformation, and some
   * initialization work.
   */

  GSP.gObjects.DOMKind = GSP.makeClass([GSP.gObjects.Kind], {
    doc: {
      description:
        'Common base class for kinds, such as Text and Table, that are represented as rectangular DOM elements containing text.',
      inherits: 'Kind',
      properties: {
        geom: {
          description: 'The basic geometry of the GObject',
          properties: {
            loc: {
              description: 'The position of the GObject',
              properties: {
                x: {
                  description:
                    'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                  type: 'Number',
                },
                y: {
                  description:
                    'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                  type: 'Number',
                },
              },
            },
          },
        },
        style: {
          description: '',
          properties: {
            color: {
              description: 'Foreground color of the traced GObject.',
              type: 'Color',
            },
            'font-family': {
              description:
                'The basis font family for text in this GObject. See GSP.getFontFamilyFromStyle() for supported formats',
              type: 'FontFamily',
            },
            'font-size': {
              description: 'The basis font size for text in this GObject',
              type: 'FontSize',
            },
            'font-style': {
              description:
                'The basis font style (slant) for text in this GObject',
              type: 'FontStyle',
            },
            'font-weight': {
              description:
                'The basis font weight (boldness) for text in this GObject',
              type: 'FontWeight',
            },
            'text-decoration': {
              description:
                'line-through, underlines, and other variations on the label text',
              type: 'TextDecoration',
            },
          },
        },
      },
    },

    kind: 'DOMKind',

    geom: { loc: { x: 0, y: 0 } },

    /**
     * Given a display object as created by the Html engine's
     * prepareText() method, returns a rect representing the
     * object's bounding box.
     *
     * @param {GeometricPoint} originPoint (or this.geom.loc if omitted)
     * @param {Object} displayObject
     * @returns {Rect}
     */
    getRectFromDisplayObject: function(displayObj, originPoint) {
      var width,
        height,
        left,
        top,
        attrs = displayObj.attrs;
      if (!displayObj || !displayObj.element) {
        return;
      }
      if (!originPoint) originPoint = this.geom.loc;
      width = displayObj.width();
      height = displayObj.height();
      left = originPoint.getX();
      top = originPoint.getY();
      if (attrs['text-align'] === 'center') {
        left -= width / 2;
      }
      if (attrs['vertical-align'] === 'middle') {
        top -= height / 2;
      }
      return {
        left: left,
        right: left + width,
        top: top,
        bottom: top + height,
      };
    },

    // Sets common style properties when preparing to render
    prepareToRenderStyles: function(renderArgs) {
      var fontFamily = GSP.getFontFamilyFromStyle(this.style, this.sQuery()),
        sketch = this.sQuery().getSketch(),
        fontTable =
          sketch.document.resources.fontList || this.sQuery().prefs().fontList; //backwards compatibility

      renderArgs.color = this.style.color;
      renderArgs.fontTable = fontTable;
      renderArgs['font-family'] = fontFamily;
      renderArgs['font-style'] = this.style['font-style'];
      renderArgs['font-weight'] = this.style['font-weight'];
      renderArgs['font-size'] = this.style['font-size'];
      renderArgs['text-decoration'] = this.style['text-decoration'];
      GSP.mfs.normalizeFont(fontFamily, function(styleKey, styleVal) {
        renderArgs[styleKey] = styleVal;
      });
    },

    doPostReadFromSpec: function doPostReadFromSpec() {
      (doPostReadFromSpec.base || doPostReadFromSpec.callee.base).call(this);

      this.geom.loc = GSP.GeometricPoint(this.geom.loc.x, this.geom.loc.y);
    },

    hitTest: function(rect /*, hotSpot*/) {
      var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this);
      var bounds = this.getRectFromDisplayObject(displayObject);

      return GSP.Geom.isIntersectRects(bounds, rect);
    },

    transform: function(sketch, trans) {
      this.geom.loc = trans.geom.loc.copy();
      trans.affine.transform(this.geom.loc);
    },

    getGeomBounds: function() {
      var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this);
      return displayObject && this.getRectFromDisplayObject(displayObject);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class A message rendered in to a sketch canvas.
   * @augments GSP.gObjects.Point
   */

  GSP.gObjects.Text = GSP.makeClass(
    /** @lends GSP.gObjects.Text */ [
      GSP.gObjects.DOMKind,
      GSP.Genus,
      GSP.mixins.vector,
    ],
    (function() {
      /**
       * TextRenderContext is an API internal to text kind that serves as a utility
       * for creating drawing refCons and vectors of them, and managing/updating
       * the vectors of them as vectorContexts change.
       */
      var TextRenderContext = {
        _prepareCommon: function(gobj, renderArgs) {
          gobj.prepareToRenderStyles(renderArgs);
          renderArgs.kind = gobj.kind;
          renderArgs['text-align'] = gobj.style['text-align'];
          renderArgs['vertical-align'] = gobj.style['vertical-align'];
          renderArgs.padding = gobj.style.padding;
          renderArgs.selectable = gobj.style.selectable;
          renderArgs.genus = gobj.genus;
          var lineHeight = GSP.mfs.getLineHeight(
            renderArgs['font-family'],
            renderArgs['font-size']
          );
          if (lineHeight) {
            renderArgs['line-height'] = lineHeight;
          }
        },
        create: function(gobj, drawContext, renderArgs) {
          this._prepareCommon(gobj, renderArgs);

          renderArgs.id = gobj.id;
          renderArgs.wspSays = gobj.isGobjExistInWSPSays();
          renderArgs.isParameter = gobj.isParameter && gobj.isParameter();
          renderArgs.isCompositeText = gobj.isCompositeText();

          return drawContext.prepareText(renderArgs);
        },
        createVector: function(gobj, vectorContext, drawContext, renderArgs) {
          var ret = {},
            aSampleRefCon,
            aSampleArgs;

          this._prepareCommon(gobj, renderArgs);

          ret.initialArgs = $.extend(true, {}, renderArgs);
          ret.sampleRefCons = [];
          ret.parentId = gobj.id;

          for (var i = 0; i < vectorContext.numSamples; i++) {
            aSampleRefCon = {};
            aSampleArgs = $.extend(true, {}, renderArgs);
            aSampleArgs.id = ret.parentId + 'vector' + i;

            aSampleRefCon.object = drawContext.prepareText(aSampleArgs);
            aSampleRefCon.visible = true;

            ret.sampleRefCons[i] = aSampleRefCon;
          }
          return ret;
        },
        updateVector: function(vectorContext, drawContext, renderContext) {
          var newSampleRefCon,
            newSampleArgs,
            i,
            numRefCons = renderContext.sampleRefCons.length,
            numSamples = vectorContext.filledSampleCount;

          //first walk the existing refCons, updating visibility
          for (i = 0; i < numRefCons; ++i) {
            renderContext.sampleRefCons[i].visible = i < numSamples;
          }

          //Now add new ones if needed
          for (i = numRefCons; i < numSamples; ++i) {
            //create a new one
            newSampleRefCon = {};
            newSampleArgs = $.extend(true, {}, renderContext.initialArgs);
            newSampleArgs.id = renderContext.parentId + 'vector' + i;
            newSampleArgs.parsedMFS = vectorContext.parsedMFSValues[i];

            newSampleRefCon.object = drawContext.prepareText(newSampleArgs);
            newSampleRefCon.visible = true;
            renderContext.sampleRefCons[i] = newSampleRefCon;
          }
        },
        cleanupVector: function(drawContext, renderContext) {
          var i,
            numRefCons =
              renderContext && renderContext.sampleRefCons
                ? renderContext.sampleRefCons.length
                : 0;

          for (i = 0; i < numRefCons; ++i) {
            drawContext.cleanupText(renderContext.sampleRefCons[i].object);
          }
        },
      };

      return {
        doc: {
          description: 'A displayable message.',
          inherits: 'DOMKind',
          refspec: {
            gspKindRef: 'TextKind',
          },
          usage: {},
          properties: {
            style: {
              description: '',
              properties: {
                'letter-spacing': {
                  description:
                    'The basis font letter spacing for text in this GObject',
                  type: 'LetterSpacing',
                },
              },
            },
            text: {
              description: 'The message.',
              required: false,
              type: 'String',
            },
            textMFS: {
              description: 'The message formatted as an MFS string.',
              required: false,
              type: 'String',
            },
          },
        },
        kind: 'Text',
        style: {
          'text-align': 'left',
          'vertical-align': 'top',
        },

        state: {},
        //Text kinds obey measurement autoplacement metrics
        //This is for historical reasons, and to match the names in the original
        //GSP C codebase
        autoplacementType: 'Measurement',
        updateLabelForKind: function updateLabelForKind() {
          (updateLabelForKind.base || updateLabelForKind.callee.base).call(
            this
          );

          if (this.textMFS) {
            this.parsedMFS = GSP.mfsParser.parse(this.textMFS);
          } else if (this.text) {
            this.parsedMFS = GSP.mfs.makeTextMFS(this.text);
          }
        },
        getColorableComponent: function() {
          return 'TextGObject_BackgroundContrast';
        },
        getTextType: function() {
          return 'Caption';
        },
        doModifyRenderAttrsForState: function(attrs, state) {
          switch (state) {
            case 'speculative':
              attrs.opacity = GSP.speculativeOpacity;
              break;
            case 'targetHighlit':
            case 'matchedGiven':
              attrs.targetHighlight = true;
              break;
            case 'invisible':
              attrs.opacity = 0.0;
              break;
            case 'unmatchedGiven':
              attrs.unmatchedGiven = true;
              break;
            case 'fancyPulse':
              attrs.fancyPulse = true;
              break;
            case 'none':
            case undefined:
              //No change
              break;
            default:
              GSP.log(
                'Unexpected render state: ' +
                  this.state.renderState +
                  ' for kind: ' +
                  this.kind
              );
              break;
          }
        },
        renderPrepare: function(drawContext, renderArgs) {
          return TextRenderContext.create(this, drawContext, renderArgs);
        },
        renderCleanup: function(drawContext, drawRefCon) {
          drawContext.cleanupText(drawRefCon);
        },
        radiansOrScalar: function() {
          return this.unitPowers &&
            this.unitPowers.angle === 1 &&
            this.sQuery().prefs().units.angle === 'rad'
            ? 'rad'
            : 'scalar';
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var x = 0,
            y = 0,
            renderable = this.isRenderable(),
            visibility = renderable ? 'visible' : 'hidden',
            //Currently the text renderer needs to know if the units for the
            //object is radians (to the power of 1) to know whether to format it
            //in multiples of PI.  If it wanted to do formatting based on another
            //unit, we'd need to detect that case too.
            units = this.radiansOrScalar(),
            attrs = {
              visibility: visibility,
              measurable: renderable || this.latentVisibility,
              constraintFrame: this.state.constraintFrame,
              opacity: this.calculateOpacity(),
              zIndex: renderArgs.zIndex,
              wspSays: this.isGobjExistInWSPSays(),
              isParameter: this.isParameter && this.isParameter(),
              isCompositeText: this.isCompositeText(),
            };
          // attrs.measurable means the DOM element will be created
          // which we'll need not just to render, but also to measure
          // and if latentVisibility, then measuring is potentially going to happen
          // in toolplay autoplacement.

          if (this.nameMFSOverride) {
            attrs.width = this.nameMFSOverride.width;
            attrs.height = this.nameMFSOverride.height;
          }

          if (this.state.selected) {
            return;
          }

          if (attrs.measurable) {
            x = this.geom.loc.getX();
            if (isNaN(x)) {
              x = 0;
            }
            y = this.geom.loc.getY();
            if (isNaN(y)) {
              y = 0;
            }
            attrs.x = x;
            attrs.y = y;

            attrs.parsedMFS = this.parsedMFS;
            if (this.state.forceDomParse) {
              attrs.forceDomParse = true;
              this.state.forceDomParse = false;
            }

            //are we a parameter/measure with a value?
            if (typeof this.uValue !== 'undefined') {
              attrs.MFSValues = {
                value: this.formatNumberAsMFS(
                  this.uValue,
                  this.style.precision,
                  units
                ),
              };
              this.uValueLast = this.uValue;
            }

            if (this.isCompositeText()) {
              attrs.MFSValues = this.parentMFSValues;
            }

            if (this.isMultimeasure) {
              attrs.MFSValues = this.getValuesAsMFS();
            }

            if (attrs.MFSValues) {
              this.MFSValues = attrs.MFSValues;
            }
          }

          this.modifyRenderAttrsForCurrentState(attrs);

          drawContext.drawText(drawRefCon, attrs);
          if (this.postRenderFunc) {
            this.postRenderFunc();
          }
          this.updateKindHTMLStyle();
        },
        /**
         * Returns true if any of the immediate fnReference parents are blank
         * Only applicable to calculations or functions (returns false for others)
         *
         * @returns {Boolean}
         */
        determineParentalBlank: function() {
          var key,
            refs = this.parentsList;

          if (!refs) {
            return false;
          }

          //if any of our refs are blank, we are too
          for (key in refs) {
            if (refs.hasOwnProperty(key)) {
              if (refs[key].blank) {
                return true;
              }
            }
          }

          return false;
        },
        /**
         * Applies sketchpad formatting to numbers:
         *  + NaNs are converted to "undefined".
         *  + infinities are converted to the infinity symbol.
         *  + If the unitName is radians, then certain fractions of pi are
         *    converted.
         *  + large values are converted to scientific notation.
         * Returns an mfs string
         */
        formatNumberAsMFS: function(num, precision, unitName, addUnits) {
          var rslt,
            theGObj = this;
          var decimalSeparator = this.sQuery.sketch.document.formatOptions
            .decimalSeparator;

          function toFixed(num, precision) {
            var fixedNum = num.toFixed(precision);

            return fixedNum.replace('.', decimalSeparator);
          }

          /*
           * Returns whether to format a number in scientific notation.
           */
          function convertableToSciNotation(num) {
            var MAX_DIGITS = 6;
            return Math.log(Math.abs(num)) * Math.LOG10E >= MAX_DIGITS;
          }

          /*
           * Returns an HTML element representing the number in
           * scientific notation.
           * A number in scientific notation, in this case, has a leading non-zero
           * digit before the decimal point, followed by as many digits after the
           * decimal point as expressed by the argument "precision", followed by
           * 10 raised to an exponent.
           */

          function sciNotation(num, precision) {
            var absNum = Math.abs(num),
              exp = Math.floor(Math.log(absNum) * Math.LOG10E),
              div = Math.pow(10, exp),
              x = num / div,
              mfs = GSP.mfs.makeHorizontalMFS(
                GSP.mfs.makeTextMFS(toFixed(x, precision)),
                { type: 'symbol', value: 'B4' },
                {
                  type: 'super',
                  value: [GSP.mfs.makeTextMFS('10'), GSP.mfs.makeTextMFS(exp)],
                }
              );
            return mfs;
          }

          function slicesOfPi(x) {
            var rsltMFS,
              denom,
              num,
              absNum,
              numMFS,
              fraction = GSP.math.getSimplePiFraction(x);
            if (fraction) {
              num = fraction.numerator;
              denom = fraction.denominator;
              // if numerator is zero, we have seen enough
              if (num === 0) {
                rsltMFS = GSP.mfs.makeTextMFS('0');
              } else {
                absNum = Math.abs(num);
                if (absNum === 1) {
                  numMFS = { type: 'symbol', value: '70' };
                } else {
                  numMFS = GSP.mfs.makeHorizontalMFS(
                    GSP.mfs.makeTextMFS(absNum),
                    { type: 'symbol', value: '70' }
                  );
                }
                if (denom === 1) {
                  rsltMFS = numMFS;
                } else {
                  rsltMFS = {
                    type: 'fraction',
                    value: [
                      GSP.mfs.makeHorizontalMFS(numMFS),
                      GSP.mfs.makeTextMFS(denom),
                    ],
                  };
                  if (num < 0)
                    rsltMFS = GSP.mfs.makeHorizontalMFS(
                      GSP.mfs.makeTextMFS('\u2212'), // UNICODE NEGATION, not just DASH
                      rsltMFS
                    );
                }
              }
            } else {
              rsltMFS = GSP.mfs.makeTextMFS(toFixed(x, precision));
            }

            return rsltMFS;
          }

          function addUnitsToResult(numMFS) {
            var unitMFS;

            unitMFS = theGObj.getUnitsMFS && theGObj.getUnitsMFS();

            if (!unitMFS) {
              return numMFS;
            }

            return GSP.mfs.makeHorizontalMFS(numMFS, unitMFS);
          }

          if (this.blank) {
            //The space below will force a non-breaking space into the node,
            //(cf infixExpressionTools: GSP.mfs.makeHTMLFromMFSParseTree())
            //and keep it from being discarded
            rslt = GSP.mfs.makeTextMFS(' ');
          } else if (isNaN(num)) {
            // TODO: user-facing string should be localizable
            rslt = GSP.mfs.makeTextMFS('undefined');
          } else if (!isFinite(num)) {
            if (num === Number.NEGATIVE_INFINITY) {
              rslt = GSP.mfs.makeHorizontalMFS(
                { type: 'symbol', value: '103' },
                { type: 'symbol', value: 'A5' }
              );
            } else {
              rslt = { type: 'symbol', value: 'A5' };
            }
          }
          // handle fractions of pi
          else if (unitName === 'rad') {
            rslt = slicesOfPi(num);
          }
          // handle large values
          else if (convertableToSciNotation(num)) {
            rslt = sciNotation(num, precision);
          }
          // all else
          else {
            rslt = toFixed(num, precision);
            // Quash -0
            rslt = rslt.replace(/^-(0(\.0+)?)$/, '$1');
            rslt = GSP.mfs.makeTextMFS(rslt.replace('-', '\u2212')); // Unicode MINUS SIGN
          }

          if (addUnits) {
            return addUnitsToResult(rslt);
          }

          return rslt;
        },

        isCompositeText: function() {
          return this.parentMFSValues !== undefined;
        },
        isHittable: function() {
          // CompositeText might handle the touch
          return (
            (this.style.selectable || this.isCompositeText()) &&
            this.isRenderable()
          );
        },
        hitTest: function(rect, hotSpot, options) {
          var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this);
          var bounds = this.getRectFromDisplayObject(displayObject);
          var isHit = GSP.Geom.isIntersectRects(bounds, rect);
          var hotTextRefs;

          if (isHit) {
            hotTextRefs = $('.wsp-mfs-reference', $(displayObject.element));
            if (hotTextRefs.length > 0) {
              // For hot text, track any touch if we are not selectable
              // or if we are selectable, track if the touch starts in a reference.
              // Otherwise, pass control back up, which will allow the drag
              // of the caption.
              if (
                !this.style.selectable ||
                GSP.HotTextTracker.referenceIsHit(hotSpot, hotTextRefs)
              ) {
                isHit = GSP.HotTextTracker.createOnElement(
                  $(displayObject.element),
                  hotTextRefs,
                  this.sQuery
                );
              }
            } else {
              isHit = this.isCompositeText() ? this.style.selectable : true;
            }
          }

          return isHit;
        },
        getMFSAppearanceForVariant: function(/*variant*/) {
          //If we don't exist, our child shouldn't either
          if (!this.state.exists) {
            return null;
          }

          var returnedMFS = $.extend(true, {}, this.parsedMFS);

          if (this.isCompositeText()) {
            GSP.mfs.realizeParamNodes(returnedMFS, this.parentMFSValues);
          }
          if (this.isMultimeasure) {
            GSP.mfs.realizeParamNodes(returnedMFS, this.getValuesAsMFS());
          }
          //When a text node is a vertical node (typically a word-wrapped caption)
          //we flatten it to a single horizontal node.
          returnedMFS = GSP.mfs.replaceNodes(
            returnedMFS,
            'vertical',
            GSP.mfs.flattenVerticalNode
          );

          return returnedMFS;
        },
        constrainLabel: function() {},

        createTransformer: function(destination) {
          var pointTransformer = destination.getTransform();
          return {
            getAffineTransform: function() {
              return GSP.AffineTransform.fromPointTransform(pointTransformer);
            },
            transformGeom: function(sourceGeom, destGeom) {
              destGeom.loc = pointTransformer(sourceGeom.loc);
            },
          };
        },
        /************ Vector API Implementation *********/
        createVectorContext: function(numSamples, parentSampler, colorize) {
          var ret = {
            numSamples: numSamples,
            samples: GSP.createFloatVector(2 * numSamples),
            parsedMFSValues: [],
          };

          if (typeof this.uValue !== 'undefined') {
            ret.uValues = [];
          }

          return ret;
        },
        fillSingleSample: function(vectorContext, index) {
          vectorContext.filledSampleCount++;

          vectorContext.samples[index * 2] = this.geom.loc.x;
          vectorContext.samples[index * 2 + 1] = this.geom.loc.y;
          vectorContext.parsedMFSValues[index] = this.parsedMFS;
          if (typeof vectorContext.uValues !== 'undefined') {
            vectorContext.uValues[index] = this.uValue;
          }
        },
        getGeomBoundsVector: function(vectorContext) {
          if (!vectorContext.geomBounds) {
            var samples = vectorContext.samples,
              displayRefCon = this.sQuery.sketch.getDisplayObjForGObj(this),
              displayObjects = displayRefCon && displayRefCon.sampleRefCons,
              numSamples = vectorContext.filledSampleCount,
              origin,
              sampleBounds;

            if (!displayObjects || !displayObjects.length) {
              return null;
            }

            for (var i = 0; i < numSamples; ++i) {
              origin = GSP.GeometricPoint(samples[i * 2], samples[i * 2 + 1]);

              if (displayObjects[i]) {
                sampleBounds = this.getRectFromDisplayObject(
                  displayObjects[i].object,
                  origin
                );
                vectorContext.geomBounds = GSP.Geom.unionRects(
                  vectorContext.geomBounds,
                  sampleBounds
                );
              }
            }
          }

          return vectorContext.geomBounds;
        },
        hitTestVector: function(vectorContext, rect) {
          var samples = vectorContext.samples,
            displayRefCon = this.sQuery.sketch.getDisplayObjForGObj(this),
            displayObjects = displayRefCon && displayRefCon.sampleRefCons,
            numSamples = vectorContext.filledSampleCount,
            origin,
            sampleBounds;

          if (!displayObjects || !displayObjects.length) {
            return false;
          }

          for (var i = 0, l = numSamples; i < l; ++i) {
            origin = GSP.GeometricPoint(samples[i * 2], samples[i * 2 + 1]);
            sampleBounds = this.getRectFromDisplayObject(
              displayObjects[i].object,
              origin
            );

            if (GSP.Geom.isIntersectRects(sampleBounds, rect)) {
              return true;
            }
          }

          return false;
        },
        getVectorRenderingLayer: function(vectorContext) {
          return 'Text';
        },
        prepareVectorRendering: function(
          drawContext,
          vectorContext,
          renderArgs
        ) {
          return TextRenderContext.createVector(
            this,
            vectorContext,
            drawContext,
            renderArgs
          );
        },
        renderVector: function(
          drawContext,
          drawRefCon,
          renderArgs,
          vectorContext,
          parentProperties
        ) {
          var renderContext = drawRefCon,
            refCons = renderContext.sampleRefCons,
            numSamples, //must set this after updating the vector
            isVisible = !parentProperties.hidden,
            hasMFSValues = typeof vectorContext.uValues !== 'undefined',
            units = hasMFSValues ? this.radiansOrScalar() : 'scalar',
            drawAttrs = {
              constraintFrame: parentProperties.constraintFrame,
            },
            i;

          TextRenderContext.updateVector(
            vectorContext,
            drawContext,
            renderContext
          );
          //we must render all refCons because we might need to hide some
          //previously-existing samples
          numSamples = refCons ? refCons.length : 0;

          for (i = 0; i < numSamples; i++) {
            drawAttrs.visibility =
              isVisible && refCons[i].visible ? 'visible' : 'hidden';
            drawAttrs.x = vectorContext.samples[i * 2];
            drawAttrs.y = vectorContext.samples[i * 2 + 1];
            drawAttrs.parsedMFS = vectorContext.parsedMFSValues[i];
            if (hasMFSValues) {
              drawAttrs.MFSValues = {
                value: this.formatNumberAsMFS(
                  vectorContext.uValues[i],
                  this.style.precision,
                  units
                ),
              };
            }

            drawContext.drawText(refCons[i].object, drawAttrs);
          }
        },

        cleanupVectorRendering: function(drawContext, drawRefCon) {
          TextRenderContext.cleanupVector(drawContext, drawRefCon);
        },

        onLoad: function(sketch, mode) {
          // var self = this;
          // var displayObjForGObj = sketch.getDisplayObjForGObj(this);
          // if("element" in displayObjForGObj && displayObjForGObj.element) {
          //   this.htmlNode = displayObjForGObj.element;
          //   sketch.gobjAddKeyEvents(this);
          // }

          if (this.isGobjInsideDocumentBound() === false && this.htmlNode) {
            this.htmlNode
              .find('.wsp-parameter-sr-only, .mfs-param')
              .attr('aria-hidden', 'true')
              .removeAttr('tabindex');
            this.htmlNode
              .find('.mfs-input')
              .attr({ 'aria-hidden': 'true', tabindex: '-1' });
          }

          // if(this.isParameter && this.isParameter() && this.htmlNode) {
          //   $(this.htmlNode).find(".mfs-input").click(function() {
          //     self.presentUI();
          //   });
          // }

          // if (this.isCompositeText && this.isCompositeText() && this.htmlNode) {
          //   var hotTextClicked = false;
          //   $(this.htmlNode).find(".mfs-param").each(function () {
          //     var id = $(this).data('wsp-mfs-reference-id');
          //     var gobj = self.sQuery().get(id);

          //     $(this).focusin(function(e) {
          //       hotTextClicked = true;
          //       gobj.setRenderState('hotTarget');
          //       $(this).addClass('wsp-mfs-reference-hot');
          //     }).keydown(function (e) {
          //       if (e.which === 13 || e.which === 32) { // Enter Key & Space key
          //         if (gobj && gobj.press) {
          //           gobj.press(self.sQuery().sketch);
          //         }
          //       }
          //     }).blur(function () {
          //       if (hotTextClicked) {
          //         hotTextClicked = false;
          //         gobj.setRenderState('none');
          //         $(this).removeClass('wsp-mfs-reference-hot');
          //       }
          //     });
          //   });
          // }
        },

        isGobjExistInWSPSays: function() {
          return (
            this.sQuery.sketch.wspSaysAndTabsObjects.wspSaysGobjsId.indexOf(
              this.id
            ) > -1
          );
        },

        updateKindHTMLStyle: function() {
          var self = this;
          var sketch = this.sQuery.sketch;
          if (!this.htmlNode) {
            var displayObjForGObj = sketch.getDisplayObjForGObj(this);
            if ('element' in displayObjForGObj && displayObjForGObj.element) {
              this.htmlNode = displayObjForGObj.element;
              sketch.gobjAddKeyEvents(this);
            }
          }

          if (this.htmlNode && this.isParameter && this.isParameter()) {
            if (
              $(this.htmlNode).find('.mfs-input').length &&
              !this.parameterEventAttached
            ) {
              $(this.htmlNode)
                .find('.mfs-input')
                .click(function() {
                  self.presentUI();
                });
              this.parameterEventAttached = true;
            }
          }

          if (this.htmlNode && this.isCompositeText && this.isCompositeText()) {
            if (
              $(this.htmlNode).find('.mfs-param').length &&
              !this.compositeEventAttached
            ) {
              var hotTextClicked = false;
              $(this.htmlNode)
                .find('.mfs-param')
                .each(function() {
                  var id = $(this).data('wsp-mfs-reference-id');
                  var gobj = self.sQuery().get(id);

                  $(this)
                    .focusin(function(e) {
                      hotTextClicked = true;
                      gobj.setRenderState('hotTarget');
                      $(this).addClass('wsp-mfs-reference-hot');
                    })
                    .keydown(function(e) {
                      if (e.which === 13 || e.which === 32) {
                        // Enter Key & Space key
                        if (gobj && gobj.press) {
                          gobj.press(self.sQuery().sketch);
                        }
                      }
                    })
                    .blur(function() {
                      if (hotTextClicked) {
                        hotTextClicked = false;
                        gobj.setRenderState('none');
                        $(this).removeClass('wsp-mfs-reference-hot');
                      }
                    });
                });

              this.compositeEventAttached = true;
            }
          }
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gObjects.Table = GSP.makeClass([GSP.gObjects.DOMKind], {
    doc: {
      description: 'A table of rows and columns',
      inherits: 'DOMKind',
      refspec: {
        gspKindRef: 'TableKind',
      },
      usage: {},
      properties: {
        rows: {
          description: 'the rows of the table, as arrays of mfs strings',
          // Needed! Without this, toSpecObj will ignore the property and
          // page switching will break.
          type: 'Array',
          required: false, // Will still have headers and maybe a live preview row.
        },
        hasLivePreview: {
          description: 'Whether the final row updates dynamically or not',
          type: 'Boolean',
          default: true,
        },
        style: {
          description: 'Properties that influence the appearance of a GObject.',
          properties: {
            'border-color': {
              description: 'Color of the table and cell borders',
              type: 'Color',
            },
          },
        },
      },
    },
    kind: 'Table',
    autoplacementType: 'Table',
    hasLivePreview: true,
    style: {},
    /**
     * Whether this object kind can be annotated with a label.
     */
    hasLabel: false,

    headers: [],

    renderPrepare: function(drawContext, renderArgs) {
      this.prepareToRenderStyles(renderArgs);
      renderArgs['border-color'] = this.style['border-color'];

      return drawContext.prepareTable(renderArgs);
    },

    createDefaultColorStyle: function(colorableComponentPrefs) {
      return { 'border-color': colorableComponentPrefs.color };
    },

    doPostReadFromSpec: function doPostReadFromSpec() {
      (doPostReadFromSpec.base || doPostReadFromSpec.callee.base).call(this);
      var iRow, iColumn;

      this.rowsMFS = [];

      if (this.rows === undefined) return;

      for (iRow = 0; iRow < this.rows.length; iRow++) {
        this.rowsMFS.push([]);
        for (iColumn = 0; iColumn < this.rows[iRow].length; iColumn++) {
          this.rowsMFS[iRow].push(
            GSP.mfsParser.parse(this.rows[iRow][iColumn])
          );
        }
      }
    },

    // When preparing to serialize, we append all the rowsMFS rows that
    // have recently been created to the rows property.
    prepareToSerialize: function() {
      var i,
        j,
        start,
        rows,
        newRow,
        thisRow,
        shouldSaveRows = this.constraint === 'UserTabulation';

      if (!shouldSaveRows) return; // avoid spurious diffs in iterated values tables

      rows = this.rows || [];
      start = rows.length;
      for (i = start; i < this.rowsMFS.length; i++) {
        thisRow = this.rowsMFS[i];
        newRow = [];
        for (j = 0; j < thisRow.length; j++) {
          newRow.push(GSP.mfs.makeMFSFromMFSParseTree(thisRow[j]));
        }
        rows.push(newRow);
      }
      // Avoid spurious diffs: leave this.rows undefined unless rowsMFS is non-empty
      if (rows.length) this.rows = rows;
    },

    getColorableComponent: function() {
      return 'TextGObject_BackgroundContrast';
    },

    /**
     Returns the textType to use for looking up style preferences, etc.
     */
    getTextType: function() {
      return 'Table';
    },

    getColumnLabelMFS: function(parent) {
      var name,
        onlyGrandparentMeasure,
        numGrandparentMeasures = 0;

      function getColumnLabelOf(gobj) {
        if (gobj.isMultimeasure) {
          return gobj.getMultiMeasureParentLabelMFS();
        }
        name = gobj.getNameMFS();
        if (!GSP.mfs.isEmptyTextMFS(name)) {
          return name;
        }
        return gobj.getLabelMFS();
      }

      // If the parent is composite text, we can take the label from a
      // grandparent measure, if there is only one such.  Taken from
      // GSP's Table_GetColumnLabel function.
      if (parent.isCompositeText()) {
        parent.eachParent(function(i, grandParent) {
          if (grandParent.isOfKind('Measure') || grandParent.isMultimeasure) {
            numGrandparentMeasures++;
            onlyGrandparentMeasure = grandParent;
          }
        });
      }

      return getColumnLabelOf(
        numGrandparentMeasures === 1 ? onlyGrandparentMeasure : parent
      );
    },

    render: function(drawContext, drawRefCon, renderArgs) {
      var renderable = this.isRenderable(),
        visibility = renderable ? 'visible' : 'hidden',
        attrs = {
          visibility: visibility,
          constraintFrame: this.state.constraintFrame,
          opacity: this.calculateOpacity(),
          zIndex: renderArgs.zIndex,
        };
      attrs.x = this.geom.loc.getX();
      attrs.y = this.geom.loc.getY();

      attrs.headersMFS = this.headersMFS;
      attrs.rowsMFS = this.rowsMFS;
      attrs.id = this.id;
      attrs.kind = this.kind;
      attrs.genus = GSP.mfs.updatedGenus[this.genus];
      attrs.label = this.label;

      if (this.hasLivePreview) {
        attrs.finalRowMFS = this.finalRowMFS;
      }

      attrs.style = this.style;

      attrs[
        'background-color'
      ] = this.sQuery().getSketch().preferences.colorableComponents.Background.color;

      drawContext.drawTable(drawRefCon, attrs);

      this.updateKindHTMLStyle();
    },
    renderCleanup: function(drawContext, drawRefCon) {
      drawContext.cleanupTable(drawRefCon);
    },

    updateKindHTMLStyle: function() {
      if (!this.htmlNode) {
        var displayObjForGObj = this.sQuery.sketch.getDisplayObjForGObj(this);
        if ('element' in displayObjForGObj && displayObjForGObj.element) {
          this.htmlNode = displayObjForGObj.element;
          this.sQuery.sketch.gobjAddKeyEvents(this);
        }
      }
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class Arc
   *  @augments GSP.gObjects.Kind
   *  @augments GSP.genera.Path
   */
  GSP.gObjects.Arc = GSP.makeClass(
    /** @lends GSP.gObjects.Arc */ [
      GSP.gObjects.Kind,
      GSP.mixins.label,
      GSP.mixins.arcVector,
      GSP.genera.Path,
    ],
    {
      doc: {
        description: '',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'ArcKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              'line-style': {
                description: "Type of line: 'solid', 'dotted', 'dashed'",
                type: 'String',
                required: false,
              },
              width: {
                description: 'The width of the curve line in pixels.',
                type: 'Number',
              },
            },
          },
        },
      },
      kind: 'Arc',

      style: {
        hidden: false,
        width: 3,
      },
      /**
       * Whether this object kind can be annotated with a label.
       */
      hasLabel: true,
      geom: {},
      getGeometricArc: function() {
        return this.geom.arc;
      },

      radius: function() {
        return this.geom.arc.radius;
      },
      doPostReadFromSpec: function doPostReadFromSpec() {
        (doPostReadFromSpec.base || arguments.callee.base).call(this);
        this.geom.arc = GSP.GeometricArc.FromCenterAndRadius(
          GSP.GeometricPoint.ORIGIN,
          0
        ); //is this the best way?
      },
      getColorableComponent: function() {
        return 'Curves';
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.prepareArc(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupArc(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        var attrs = {
          renderable: this.isRenderable(),
          arc: this.geom.arc,
          color: this.style.color,
          width: this.style.width,
          opacity: this.calculateOpacity(),
        };

        this.modifyRenderAttrsForCurrentState(attrs);
        this.setLineDash(attrs);

        drawContext.drawArc(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },
      getArcBounds: function(arc, ext) {
        var center = arc.center,
          radius = arc.radius,
          bounds = {};

        // for each of 0, pi/2, pi, 3pi/2, find if in bounds. If so, then this
        // we can compute the right, top, left, and bottom bounds, respectively,
        // from center and radius, if not we can compute the parameter from
        // the endpoints.
        if (arc.pointIsInBounds(GSP.GeometricPoint(center.x + 1, center.y))) {
          bounds.right = center.x + radius;
        } else {
          // right is max of endpoints.x;
          bounds.right = Math.max(arc.initialPoint.x, arc.finalPoint.x);
        }
        if (arc.pointIsInBounds(GSP.GeometricPoint(center.x - 1, center.y))) {
          bounds.left = center.x - radius;
        } else {
          // left is min of endpoints.x;
          bounds.left = Math.min(arc.initialPoint.x, arc.finalPoint.x);
        }
        if (arc.pointIsInBounds(GSP.GeometricPoint(center.x, center.y - 1))) {
          bounds.top = center.y - radius;
        } else {
          // top is min of endpoints.y;
          bounds.top = Math.min(arc.initialPoint.y, arc.finalPoint.y);
        }
        if (arc.pointIsInBounds(GSP.GeometricPoint(center.x, center.y + 1))) {
          bounds.bottom = center.y + radius;
        } else {
          // bottom is max of endpoints.y;
          bounds.bottom = Math.max(arc.initialPoint.y, arc.finalPoint.y) + ext;
        }
        //bounds.width = bounds.right - bounds.left;
        //bounds.height = bounds.bottom - bounds.top;
        return GSP.Geom.insetRect(bounds, -ext);
      },
      getGeomBounds: function getGeomBounds() {
        if (!this.state.exists) {
          return;
        }
        var arc = this.geom.arc,
          ext = this.style.width;
        return this.getArcBounds(arc, ext);
      },

      hitTest: function(rect, hotSpot) {
        return GSP.Geom.RectIntersectsCurve(rect, {
          type: 'arc',
          curve: this.geom.arc,
        });
      },

      transform: function(sketch, trans) {},

      mapPositionToPathValue: function(pointVector) {
        return this.geom.arc.mapPositionToPathValue(pointVector, this.genus);
      },
      mapPathValueToPosition: function(value, output) {
        return this.geom.arc.mapPathValueToPosition(value, this.genus, output);
      },
      area: function() {
        return 0;
      },
      pathLength: function() {
        return this.geom.arc.getCache(this.genus).perimeterLength;
      },
      closedPath: false,
    }
  );

  /**
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  The family of straight objects: lines, segments, and arrays.
   *  @class Axis
   *  @augments GSP.gObjects.Straight
   */
  (function() {
    var kMajorTickLength = 5,
      kMinPixelsBetweenTicks = 3.5,
      kMaxPixelsBetweenTicks = 2.5 * kMinPixelsBetweenTicks,
      kMinPixelsBetweenLines = 27.0,
      kMaxPixelsBetweenLines = 2.5 * kMinPixelsBetweenLines,
      kPixelsBetweenTicksTrigMultiplier = 1.25,
      kGrid_PolarMinSquarePixelsBetweenLines = 500.0,
      kGrid_PolarMinAbsolutePixelsBetweenLines = 15.0,
      /*
       * Constants used in tick/grid spacing computations.
       * Taken from coordsys_complex.c.
       */
      kHorizTickMultiples = [
        {
          expansionFactor: 2.0,
          diminishmentFactor: 2.0,
          largeTickInterval: 5,
          largeIntervalsPerText: 4,
        },
        {
          expansionFactor: 2.5,
          diminishmentFactor: 2.0,
          largeTickInterval: 5,
          largeIntervalsPerText: 5,
        },
        {
          expansionFactor: 2.0,
          diminishmentFactor: 2.5,
          largeTickInterval: 2,
          largeIntervalsPerText: 10,
        },
      ],
      kVertTickMultiples = [
        {
          expansionFactor: 2.0,
          diminishmentFactor: 2.0,
          largeTickInterval: 5,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 2.5,
          diminishmentFactor: 2.0,
          largeTickInterval: 5,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 2.0,
          diminishmentFactor: 2.5,
          largeTickInterval: 2,
          largeIntervalsPerText: 5,
        },
      ],
      kTrigTickMultiples = [
        {
          expansionFactor: 2.0,
          diminishmentFactor: 2.0,
          largeTickInterval: 6,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 3.0 / 2.0,
          diminishmentFactor: 12.0 / 6.0,
          largeTickInterval: 6,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 4.0 / 3.0,
          diminishmentFactor: 6.0 / 4.0,
          largeTickInterval: 6,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 6.0 / 4.0,
          diminishmentFactor: 4.0 / 3.0,
          largeTickInterval: 6,
          largeIntervalsPerText: 2,
        },
        {
          expansionFactor: 12.0 / 6.0,
          diminishmentFactor: 3.0 / 2.0,
          largeTickInterval: 6,
          largeIntervalsPerText: 2,
        },
      ],
      /**
          Used by getTickNumberPrecisionInfo().
          cf. sPrecisionList in axis.c
         */
      labelPrecisionForFontSize = {
        '24': {
          decimal: {
            precision: 6,
            smallExponentBound: 0.00000099,
            largeExponentBound: 9999999.0,
          },
          trigonometric: {
            precision: 3,
            smallExponentBound: 0.000999,
            largeExponentBound: 9999.0,
          },
        },
        '48': {
          decimal: {
            precision: 3,
            smallExponentBound: 0.000999,
            largeExponentBound: 9999.0,
          },
          trigonometric: {
            precision: 3,
            smallExponentBound: 0.000999,
            largeExponentBound: 9999.0,
          },
        },
      },
      /**
          Utility function for returning the correct multiples
          array for the axis.
          Analogous to GetTickMultiplesForAxis() in coordsys_complex.c.
          @param  {String}  iTickNumbering -- 'decimal' | 'trigonometric'
          @param  {String}  iOrientation -- 'horizontal' | 'vertical'
          @returns  {Array of Object} Array of multiples objects
         */
      getTickMultiples = function(iTickNumbering, iOrientation) {
        if (iTickNumbering === 'trigonometric') {
          return kTrigTickMultiples;
        }
        if (iOrientation === 'vertical') {
          return kVertTickMultiples;
        }
        return kHorizTickMultiples;
      },
      /**
          Utility function for computing the appropriate spacing between
          elements, e.g. between ticks or lines.
          Patterned after PrivAdjustTicks() in coordsys_complex.c.
          Note that the placement of this code in the desktop code suggests
          that it's a coordinate system computation, but it's really an
          axis responsibility that the coordinate system makes use of.
          @param  {String}  iTickNumbering -- 'decimal' | 'trigonometric'
          @param  {String}  iOrientation -- 'horizontal' | 'vertical'
          @param  {Number}  iInitialSpacing -- Initial value (e.g. unit pixels for axis)
          @param  {Number}  iMinSpacing -- Minimum allowed spacing between elements
          @param  {Number}  iMaxSpacing -- Maximum allowed spacing between elements
          @returns  {Object}  {
                                pixelsBetweenTicks: pixels between elements
                                largeTickInterval: 
                                intervalsPerText: 
                              }
         */
      adjustSpacing = function(
        iTickNumbering,
        iOrientation,
        iInitialSpacing,
        iMinSpacing,
        iMaxSpacing
      ) {
        var multiples = getTickMultiples(iTickNumbering, iOrientation),
          spacing = iInitialSpacing,
          minSpacing = iMinSpacing,
          maxSpacing = iMaxSpacing,
          i = 0;

        if (iTickNumbering === 'trigonometric') {
          spacing *= Math.PI;
          minSpacing *= kPixelsBetweenTicksTrigMultiplier;
          maxSpacing *= kPixelsBetweenTicksTrigMultiplier;
        }

        // expand if they're too close together
        if (spacing > 0.0) {
          while (spacing < minSpacing) {
            spacing *= multiples[i].expansionFactor;
            i = (i + 1) % multiples.length;
          }
        }

        // shrink if they're too far apart
        while (spacing > maxSpacing) {
          spacing /= multiples[i].diminishmentFactor;
          if (--i < 0) {
            i = multiples.length - 1;
          }
        }

        return {
          pixelsBetweenTicks: spacing,
          largeTickInterval: multiples[i].largeTickInterval,
          largeIntervalsPerText: multiples[i].largeIntervalsPerText,
        };
      };

    GSP.gObjects.Axis = GSP.makeClass(
      /** @lends GSP.gObjects.Axis */ [GSP.gObjects.Straight],
      {
        doc: {
          description: 'A one dimensional coordinate line.',
          inherits: 'Straight',
          refspec: {
            gspKindRef: 'AxisKind',
          },
          usage: {},
          properties: {
            orientation: {
              description:
                "Orientation of the axis: 'horizontal' or 'vertical'.",
              type: 'String',
            },
            style: {
              description: '',
              properties: {
                tickNumbering: {
                  description:
                    "Tick mark numbering system: 'decimal' or 'trigonometric'.",
                  type: 'String',
                  required: false,
                },
                tickNumberStyle: {
                  description:
                    "Style of tick numbers: 'auto' for default behavior (show them), 'none' to hide them",
                  type: 'String',
                  required: false,
                },
              },
            },
          },
        },
        orientation: 'horizontal',
        kind: 'Axis',

        straightGenus: function() {
          // returns Segment, Ray, or Line
          // Once genus is properly implemented, this function can be removed.
          return 'Line';
        },

        style: {
          tickNumbering: 'decimal',
          tickNumberStyle: 'auto',
        },
        geom: {},

        getColorableComponent: function() {
          return 'Axis';
        },
        renderPrepare: function renderPrepare(drawContext, renderArgs) {
          return drawContext.prepareAxis(renderArgs);
        },
        renderCleanup: function renderCleanup(drawContext, drawRefCon) {
          return drawContext.cleanupAxis(drawRefCon);
        },
        render: function render(drawContext, drawRefCon, renderArgs) {
          var fontSize = this.style['font-size'],
            precisionInfo = this.getTickNumberPrecisionInfo(
              fontSize,
              this.style.tickNumbering
            ),
            renderAttrs = {
              renderable: this.isRenderable(),
              origin: this.geom.origin,
              orientation: this.orientation,
              unitPixels: this.getUnitPixels(),
              isPolar: this.isPolar(),
              color: this.style.color,
              'line-style': this.style['line-style'],
              tickNumbering: this.style.tickNumbering,
              tickSpacing: this.getTickSpacing(),
              majorTickLength: kMajorTickLength,
              width: this.style.width,
              tickNumberStyle: this.style.tickNumberStyle,
              'font-family': this.style['font-family'],
              'font-size': fontSize,
              precisionInfo: precisionInfo,
              sketchRect: this.sQuery.sketch.sketchRect(),
              opacity: this.calculateOpacity(),
            };

          this.modifyRenderAttrsForCurrentState(renderAttrs);
          this.setLineDash(renderAttrs);

          drawContext.drawAxis(drawRefCon, renderAttrs);

          this.updateKindHTMLStyle();
        },

        hitTest: function hitTest(rect, hotSpot) {
          return (hitTest.base || arguments.callee.base).call(
            this,
            rect,
            hotSpot
          );
        },

        transform: function transform(sketch, trans) {
          (transform.base || arguments.callee.base).call(this, sketch, trans);
        },

        /**
        Returns the origin of the axis.
       */
        getZeroPoint: function() {
          return this.geom.origin;
        },

        /**
        Returns the unit point for the axis, which defines the
        conversion between pixels and logical axis units.
       */
        getUnitPoint: function() {
          return this.geom.unit;
        },

        /**
        Returns the number of pixels in one axis unit.
        @returns  {Number}
       */
        getUnitPixels: function() {
          return this.orientation === 'horizontal'
            ? this.geom.unit.x - this.geom.origin.x
            : -(this.geom.unit.y - this.geom.origin.y);
        },

        /**
        Returns true if the axis is associated with only
        polar coordinate systems, false otherwise.
        cf. AxisKind_AssociatedWithPolarGrid_UTIL() in axis.c
        @returns  {Boolean}
       */
        isPolar: function() {
          var coordSysCount = 0,
            polarCount = 0;

          function testCoordSysChild(iGObj) {
            if (iGObj.kind === 'CoordSys') {
              ++coordSysCount;
              if (iGObj.shape && iGObj.shape === 'polar') ++polarCount;
            }
          }

          this.children.forEach(testCoordSysChild);

          return coordSysCount > 0 && coordSysCount === polarCount;
        },

        /**
        Returns the spacing parameters for ticks on this axis.
        @returns  {Object}  {
                              pixelsBetweenTicks: pixels between elements
                              largeTickInterval: 
                              largeIntervalsPerText: 
                            }
       */
        getTickSpacing: function() {
          return adjustSpacing(
            this.style.tickNumbering,
            this.orientation,
            this.getUnitPixels(),
            kMinPixelsBetweenTicks,
            kMaxPixelsBetweenTicks
          );
        },

        /**
        Returns the spacing parameters for grid lines on this axis.
        @returns  {Object}  {
                              pixelsBetweenTicks: pixels between elements
                              largeTickInterval: 
                              largeIntervalsPerText: 
                            }
       */
        getLineSpacing: function() {
          return adjustSpacing(
            this.style.tickNumbering,
            this.orientation,
            this.getUnitPixels(),
            kMinPixelsBetweenLines,
            kMaxPixelsBetweenLines
          );
        },

        /**
        Returns the spacing parameters for polar lines on this axis.
        Taken from updateCoordSysGrid_UTIL() in coordsys_complex.c.
        Note that although this code is implementing a 2D constraint,
        it does so according to the spacing parameters of a single axis.
        @returns  {Object}  {
                              pixelsBetweenTicks: pixels between elements
                              largeTickInterval: 
                              largeIntervalsPerText: 
                            }
       */
        getPolarSpacing: function(iUnitSpacing) {
          var multiples = getTickMultiples(
              this.style.tickNumbering,
              this.orientation
            ),
            gridSpacing = { x: iUnitSpacing.x, y: iUnitSpacing.y },
            i = 0; // current multiple

          if (this.style.tickNumbering === 'trigonometric') {
            gridSpacing.x *= Math.PI;
            gridSpacing.y *= Math.PI;
          }

          // shrink the grid spacing if necessary
          while (
            gridSpacing.x * gridSpacing.y >
            kGrid_PolarMinSquarePixelsBetweenLines
          ) {
            gridSpacing.x /= multiples[i].diminishmentFactor;
            gridSpacing.y /= multiples[i].diminishmentFactor;
            if (--i < 0) {
              i = multiples.length - 1;
            }
          }

          // expand the grid spacing if necessary
          if (gridSpacing.x > 0.0 && gridSpacing.y > 0.0) {
            while (
              gridSpacing.x * gridSpacing.y <
                kGrid_PolarMinSquarePixelsBetweenLines ||
              gridSpacing.x < kGrid_PolarMinAbsolutePixelsBetweenLines ||
              gridSpacing.y < kGrid_PolarMinAbsolutePixelsBetweenLines
            ) {
              gridSpacing.x *= multiples[i].expansionFactor;
              gridSpacing.y *= multiples[i].expansionFactor;
              if (++i >= multiples.length) {
                i = 0;
              }
            }
          }

          return {
            pixelsBetweenTicks: { x: gridSpacing.x, y: gridSpacing.y },
            largeTickInterval: multiples[i].largeTickInterval,
            intervalsPerText:
              multiples[i].largeTickInterval *
              multiples[i].largeIntervalsPerText,
          };
        },

        /**
        Returns the textType to use for looking up style preferences, etc.
       */
        getTextType: function() {
          return 'AxisTicksAndOptionalLabel';
        },

        /**
        Returns the number formatting precision specification for the given font size,
        which includes the number of decimal points of precision and the max/min values
        for switching to exponential notation.
        cf. AxisGObj_UpdateTextMetrics() in axis.c.
        @param  {Number}  iFontSize -- the size of the font being rendered
        @param  {String}  iTickNumbering -- 'decimal' | 'trigonometric'
        @returns  {Object}
       */
        getTickNumberPrecisionInfo: function(iFontSize, iTickNumbering) {
          var sizeKey,
            size,
            largestSize = 0,
            foundSize = 1024;
          // Choose the precision info for the smallest font size that
          // is greater than the font size we're rendering
          for (sizeKey in labelPrecisionForFontSize) {
            size = Number(sizeKey);
            if (iFontSize < size && size < foundSize) foundSize = size;
            else if (largestSize < size) largestSize = size;
          }
          if (foundSize >= 1024) foundSize = largestSize;
          var basePrecisionInfo =
              foundSize < 1024 ? labelPrecisionForFontSize[foundSize] : null,
            specificPrecisionInfo =
              basePrecisionInfo && basePrecisionInfo[iTickNumbering];
          return specificPrecisionInfo;
        },

        getGeomBounds: function getGeomBounds() {
          var kPadding = 3, // padding between tick marks and labels
            kDiminish = 0.65, // estimate of font diminishment
            kFractCharHeight = 2.5, // estimate of char heights where fractions are
            // possible
            kExpCharHeight = 2, // estimate of char heights where exponents are
            // possible
            ext = kMajorTickLength,
            fontSize = Math.round(this.style['font-size'] * kDiminish),
            horizMult =
              this.style.tickNumbering === 'trigonometric'
                ? kFractCharHeight
                : kExpCharHeight,
            precisionInfo = this.getTickNumberPrecisionInfo(
              fontSize,
              this.style.tickNumbering
            ),
            labelMargin = (2 + precisionInfo.precision) * fontSize,
            // start from the original bounds;
            bounds = (getGeomBounds.base || arguments.callee.base).call(this);
          // expand by the major ticklength
          bounds = GSP.Geom.insetRect(bounds, -ext);
          bounds.left -= labelMargin + kPadding;
          bounds.bottom += fontSize * horizMult + kPadding;
          return bounds;
        },
        /**
         * Returns the length of the segment between the reference points in
         * screen coordinates. Note that this is the length of the segment, iff,
         * the Straight has a Segment Constraint.
         */
        pathLength: function() {
          return this.geom.unit.subtract(this.geom.origin).vLength();
        },
        getDefaultLabelPathParam: function() {
          return this.orientation === 'horizontal' ? 0.05 : 0.95;
        },
        /**
         * Returns the nearest point on the path.
         */
        getPointOnPath: function getPointOnPath(path, distance) {
          return (getPointOnPath.base || arguments.callee.base).call(
            this,
            path,
            distance
          );
        },

        getClosestPointOnLine: function getClosestPointOnLine(line, point) {
          return (getClosestPointOnLine.base || arguments.callee.base).call(
            this,
            line,
            point
          );
        },
        /** Whether the point assumed to be on the line containing this line
         *  is within bounds of the line. */
        pointIsInBounds: function pointIsInBounds(pointVector) {
          return (pointIsInBounds.base || arguments.callee.base).call(
            this,
            pointVector
          );
        },
      }
    );
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class CircleInterior
   *  @augments GSP.gObjects.Circle
   */

  GSP.gObjects.CircleInterior = GSP.makeClass(
    /** @lends GSP.gObjects.CircleInterior */ [
      GSP.gObjects.Circle,
      GSP.genera.Interior,
    ],
    {
      doc: {
        description: 'The region comprising the interior of a circle.',
        inherits: 'Circle',
        refspec: {
          gspKindRef: 'CircleInteriorKind',
        },
        usage: {},
        properties: {
          style: {
            properties: {
              layerOrder: {
                description: 'z-index within the set of Interiors and Images',
                type: 'Number',
              },
              opacity: {
                description: '0 (transparent) to 1 (fully opaque)',
                default: '0.5',
                type: 'Number',
              },
            },
          },
        },
      },
      style: {
        hidden: false,
        'line-style': 'solid',
        opacity: 0.5,
        width: 1,
      },

      state: {},

      kind: 'CircleInterior',

      getColorableComponent: function() {
        return 'Interior';
      },
      doModifyRenderAttrsForState: function(attrs, state) {
        this.modifyRenderAttrsForInterior(attrs, state);
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.prepareCircleInterior(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupCircleInterior(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        var cx,
          cy,
          r,
          renderable = this.isRenderable();

        if (renderable) {
          cx = Number(this.geom.c.x);
          if (isNaN(cx)) {
            cx = 0;
          }
          cy = Number(this.geom.c.y);
          if (isNaN(cy)) {
            cy = 0;
          }
          r = Number(this.geom.r);
          if (isNaN(r)) {
            r = 0;
          }
        } else {
          cx = cy = r = -100;
        }

        var attrs = {
          renderable: renderable,
          cx: cx,
          cy: cy,
          r: r,
          color: this.style.color,
          opacity: this.calculateOpacity(),
        };

        this.modifyRenderAttrsForCurrentState(attrs);

        drawContext.drawCircleInterior(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },

      hitTest: function(rect, hotSpot, options) {
        var perimeterOnly = options && options.interiorsPerimeterOnly;

        return GSP.Geom.RectIntersectsCurve(rect, {
          type: perimeterOnly ? 'circle' : 'circleInterior',
          curve: GSP.GeometricArc.FromCenterAndRadius(this.geom.c, this.geom.r),
        });
      },

      transform: function(sketch, trans) {},
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  @class ArcInterior
   *  @augments GSP.gObjects.Arc
   */

  GSP.gObjects.ArcInterior = GSP.makeClass(
    /** @lends GSP.gObjects.ArcInterior */ [
      GSP.gObjects.Arc,
      GSP.genera.Interior,
    ],
    {
      doc: {
        description: 'The region comprising the interior of an arc.',
        inherits: 'Arc',
        refspec: {},
        usage: {},
        properties: {
          style: {
            properties: {
              layerOrder: {
                description: 'z-index within the set of Interiors and Images',
                type: 'Number',
              },
              opacity: {
                description: '0 (transparent) to 1 (fully opaque)',
                default: '0.5',
                type: 'Number',
              },
            },
          },
        },
      },
      style: {
        hidden: false,
        'line-style': 'solid',
        opacity: 0.5,
        width: 1,
      },

      state: {},

      kind: 'ArcInterior',

      perimeter: function() {
        return this.geom.arc.getCache(this.genus).perimeterLength;
      },

      area: function() {
        var arc = this.geom.arc,
          r2 = arc.radius * arc.radius,
          val = arc.arcAngle * r2;

        if ('ArcSegment' === this.genus) {
          val -= r2 * Math.sin(arc.arcAngle);
        }

        return val / 2;
      },
      getColorableComponent: function() {
        return 'Interior';
      },
      doModifyRenderAttrsForState: function(attrs, state) {
        this.modifyRenderAttrsForInterior(attrs, state);
      },
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.prepareArcInterior(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupArcInterior(drawRefCon);
      },
      render: function(drawContext, drawRefCon, renderArgs) {
        var attrs = {
          renderable: this.isRenderable(),
          arc: this.geom.arc,
          genus: this.genus,
          opacity: this.calculateOpacity(),
          color: this.style.color,
        };

        this.modifyRenderAttrsForCurrentState(attrs);
        drawContext.drawArcInterior(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },
      getGeomBounds: function getGeomBounds() {
        var bounds = (getGeomBounds.base || arguments.callee.base).call(this);
        if (bounds) {
          bounds = GSP.Geom.unionRectPoint(bounds, this.geom.arc.center);
        }
        return bounds;
      },

      hitTest: function(rect, hotSpot, options) {
        var perimeterOnly = options && options.interiorsPerimeterOnly,
          interiorType =
            this.genus === 'ArcSector' ? 'arcSector' : 'arcSegment';

        return GSP.Geom.RectIntersectsCurve(rect, {
          type: perimeterOnly ? interiorType + 'Perimeter' : interiorType,
          curve: this.geom.arc,
        });
      },

      transform: function(sketch, trans) {},
      closedPath: true,
    }
  );

  /**
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  (function() {
    /**
     *  The family of straight objects: lines, segments, and arrays.
     *  @class CoordSys
     *  @augments GSP.gObjects.Straight
     */
    GSP.gObjects.CoordSys = GSP.makeClass(
      /** @lends GSP.gObjects.Axis */ [GSP.gObjects.Kind, GSP.Genus],
      {
        doc: {
          description: 'A Coordinate System.',
          inherits: 'Kind',
          refspec: {
            gspKindRef: 'CoordSysKind',
          },
          usage: {},
          properties: {
            shape: {
              description:
                "Type or coordinate system: 'polar', 'square', or 'rectangular'.",
              type: 'String',
            },
            style: {
              description: '',
              properties: {
                grid: {
                  description:
                    "Appearance of the coordinate system grid: 'gridlines' or 'dotted'",
                  type: 'String',
                },
                width: {
                  description: "Line width for 'gridlines' coordinate systems",
                  type: 'Number',
                },
                radius: {
                  description:
                    "Radius of points for 'dotted' coordinate systems",
                  type: 'Number',
                },
              },
            },
          },
        },
        kind: 'CoordSys',

        style: {
          width: 0.5,
          radius: 1.5,
        },
        /**
         * geom has GeometricPoints:
         * origin - axis origin
         * unit0 - first unit point
         * unit1 - second unit point
         *
         */
        geom: {},

        doPostReadFromSpec: function doPostReadFromSpec() {
          (doPostReadFromSpec.base || arguments.callee.base).call(this);
          this.geom.origin = GSP.GeometricPoint.ORIGIN;
          this.geom.unit0 = GSP.GeometricPoint.ORIGIN;
          this.geom.unit1 = GSP.GeometricPoint.ORIGIN;
        },
        getColorableComponent: function() {
          return 'CoordSys';
        },
        renderPrepare: function(drawContext, renderArgs) {
          return drawContext.prepareCoordSys(renderArgs);
        },
        renderCleanup: function(drawContext, drawRefCon) {
          return drawContext.cleanupCoordSys(drawRefCon);
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var attrs = {
            renderable: this.isRenderable(),
            origin: this.geom.origin,
            shape: this.shape, // 'polar' | 'square' | 'rectangular'
            grid: this.style.grid, // 'gridlines' | 'dotted'
            gridSpacing: this.geom.gridSpacing,
            radius: this.style.radius, // dot radius for dotted grids
            opacity: this.calculateOpacity(),
            color: this.style.color,
            width: this.style.width,
            sketchRect: this.sQuery.sketch.sketchRect(),
          };

          this.modifyRenderAttrsForCurrentState(attrs);

          drawContext.drawCoordSys(drawRefCon, attrs);

          this.updateKindHTMLStyle();
        },

        hitTest: function(rect, hotSpot) {
          var rectHitRadial = function(aRect, radius) {
            // Lookup table so RenderPolarGrid can avoid using trig functions.
            // Each pair gives {cos,sin} values for 15-deg increments in Quadrant I.
            var kCosSin15Deg = [
              { cos: 1.0, sin: 0.0 }, //  0 deg
              { cos: 0.96592582628907, sin: 0.25881904510252 }, // 15 deg
              { cos: 0.86602540378444, sin: 0.5 }, // 30 deg
              { cos: 0.70710678118655, sin: 0.70710678118655 }, // 45 deg
              { cos: 0.5, sin: 0.86602540378444 }, // 60 deg
              { cos: 0.25881904510252, sin: 0.96592582628907 }, // 75 deg
              { cos: 0.0, sin: 1.0 }, // 90 deg
            ];
            var i, ptX, ptY;

            for (i = 0; i < 7; i++) {
              ptX = kCosSin15Deg[i].cos * radius;
              ptY = kCosSin15Deg[i].sin * radius;

              if (GSP.Geom.PointInRect(GSP.GeometricPoint(ptX, ptY), aRect)) {
                return true;
              }
              if (GSP.Geom.PointInRect(GSP.GeometricPoint(ptX, -ptY), aRect)) {
                return true;
              }
              if (GSP.Geom.PointInRect(GSP.GeometricPoint(-ptX, ptY), aRect)) {
                return true;
              }
              if (GSP.Geom.PointInRect(GSP.GeometricPoint(-ptX, -ptY), aRect)) {
                return true;
              }
            }
            return false;
          };

          if (this.shape === 'polar') {
            var unitSpacing = {
                x: this.geom.unit0.x - this.geom.origin.x,
                y: -(this.geom.unit1.y - this.geom.origin.y),
              },
              gridSpacing = this.getParent('axisX').getPolarSpacing(unitSpacing)
                .pixelsBetweenTicks,
              aspect = gridSpacing.y / gridSpacing.x,
              adjustedRect = {
                left: (rect.left - this.geom.origin.x) * aspect,
                right: (rect.right - this.geom.origin.x) * aspect,
                top: rect.top - this.geom.origin.y,
                bottom: rect.bottom - this.geom.origin.y,
              },
              minDist2,
              maxDist2,
              testDist,
              curRadius,
              testRadius2;

            //Note above, the test rect is transformed to account for an elliptical
            //coordinate system.  Now, we can just treat it like a pure circular coordinate
            //system.

            //test origin first
            if (GSP.Geom.PointInRect(GSP.GeometricPoint(0, 0), adjustedRect)) {
              return true;
            }

            //Now, calculate min corner and max corner, leaving the result squared
            minDist2 =
              adjustedRect.top * adjustedRect.top +
              adjustedRect.left * adjustedRect.left;
            maxDist2 = minDist2;

            testDist =
              adjustedRect.top * adjustedRect.top +
              adjustedRect.right * adjustedRect.right;
            maxDist2 = testDist > maxDist2 ? testDist : maxDist2;
            minDist2 = testDist < maxDist2 ? testDist : minDist2;

            testDist =
              adjustedRect.bottom * adjustedRect.bottom +
              adjustedRect.left * adjustedRect.left;
            maxDist2 = testDist > maxDist2 ? testDist : maxDist2;
            minDist2 = testDist < maxDist2 ? testDist : minDist2;

            testDist =
              adjustedRect.bottom * adjustedRect.bottom +
              adjustedRect.right * adjustedRect.right;
            maxDist2 = testDist > maxDist2 ? testDist : maxDist2;
            minDist2 = testDist < minDist2 ? testDist : minDist2;

            curRadius = gridSpacing.y;
            testRadius2 = curRadius * curRadius;

            //Now, walk each annulus that is within the range of our rect,
            //testing its radials:
            //increment until we're within range
            while (testRadius2 < minDist2) {
              curRadius += gridSpacing.y;
              testRadius2 = curRadius * curRadius;
            }

            //now increment and test until we're back out of range
            while (testRadius2 < maxDist2) {
              if (rectHitRadial(adjustedRect, curRadius)) {
                return true;
              }
              curRadius += gridSpacing.y;
              testRadius2 = curRadius * curRadius;
            }
            return false;
          } else {
            //square/rectangular coord systems

            //Although y is inverted (increasing y goes down), we can ignore that fact
            //since hit testing doesn't care.  However, we have to switch our notion of
            //top and bottom, so that top is greater than bottom.  Then we can work as if
            //things are in a normal cartesian coordinate system.
            var rectShiftedToCoordSys = {
              left: rect.left - this.geom.origin.getX(),
              right: rect.right - this.geom.origin.getX(),
              top: rect.bottom - this.geom.origin.getY(), //see note above
              bottom: rect.top - this.geom.origin.getY(),
            }; //see note above

            //strategy is to calculate the multiples of x grid units to shift the left edge
            //between 0 and the first grid line, then shift the right edge by that amount
            //and see if it's past the first grid line.
            //if we wanted to support rects where .left was to the right of .right, we could
            //also add (rightEdge > 0) to the test
            var xGridSpacing = this.getParent('axisX').getLineSpacing()
              .pixelsBetweenTicks;
            var xShiftAmt =
              Math.floor(rectShiftedToCoordSys.left / xGridSpacing) *
              xGridSpacing;
            var rightEdge = rectShiftedToCoordSys.right - xShiftAmt;

            if (rightEdge < xGridSpacing) {
              return false;
            }

            var yGridSpacing = this.getParent('axisY').getLineSpacing()
              .pixelsBetweenTicks;
            var yShiftAmt =
              Math.floor(rectShiftedToCoordSys.bottom / yGridSpacing) *
              yGridSpacing;
            var topEdge = rectShiftedToCoordSys.top - yShiftAmt;

            if (topEdge < yGridSpacing) {
              return false;
            }

            return true;
          }
        },
        /**
         *  Calculates the sketch-coordinate location of (x,y)
         *  on the coordinate system.
         */
        locatePlot: function(x, y) {
          var xSlope = this.geom.unit0.x - this.geom.origin.x,
            xIntercept = this.geom.origin.x,
            ySlope = this.geom.unit1.y - this.geom.origin.y,
            yIntercept = this.geom.origin.y;

          return GSP.GeometricPoint(
            x * xSlope + xIntercept,
            y * ySlope + yIntercept
          );
        },
        /**
       *  Calculates the sketch-coordinate location of (x,y)
       *  on the coordinate system.
       *  Vectorized version of locatePlot() method.
       *  @param    {Array of Number} iCoords -- Coordinates to convert to screen pixels.
                                                  Ordered as [x0, y0, x1, y1, ..., xn, yn]
       *  @returns  {Array of Number} Coordinates in screen pixels.
                                      Ordered as [x0, y0, x1, y1, ..., xn, yn]
       */
        vectorLocatePlot: function(iCoords) {
          var len = iCoords.length,
            tCoords = GSP.createFloatVector(len),
            i,
            xSlope = this.geom.unit0.x - this.geom.origin.x,
            xIntercept = this.geom.origin.x,
            ySlope = this.geom.unit1.y - this.geom.origin.y,
            yIntercept = this.geom.origin.y,
            x,
            y;
          // Make an initial copy of the coordinates.
          // Use set() for typed arrays and concat() for regular Arrays.
          if (tCoords.set) {
            tCoords.set(iCoords);
          } else {
            tCoords = iCoords.concat();
          }

          for (i = 0; i < len; i += 2) {
            x = tCoords[i];
            y = tCoords[i + 1];
            tCoords[i] = x * xSlope + xIntercept;
            tCoords[i + 1] = y * ySlope + yIntercept;
          }

          return tCoords;
        },
        /* Given a point in sketch-coordinates, calculate its position in coordinate-system coordinates */
        locatePoint: function(point) {
          var du0 = this.geom.unit0.subtract(this.geom.origin),
            du1 = this.geom.unit1.subtract(this.geom.origin),
            delta = point.subtract(this.geom.origin),
            x = delta.x / du0.x,
            y = delta.y / du1.y;

          return GSP.GeometricPoint(x, y);

          /* If we ever need to support oblique axes, use the following,
            retaining the above code for the aligned axes case, since
            it has less rounding error 
          
         return GSP.GeometricPoint(
            delta.dot(du0) / du0.vLength2(),
        delta.dot(du1) / du1.vLength2()
          );
          
          */
        },

        /**
        "Snap" the specified point to grid points that are multiples of the
        coordinate system's unit lengths.
        Based on SnapToGrid_UTIL() in coordsys.c.
        @param  {Object}  ioPoint -- the point to be snapped
                                      its 'x' and 'y' properties are modified
        @param  {Number}  iThreshold -- [Optional] Maximum allowed displacement
                                        of the point in pursuit of snapping.
                                        Defaults to 100. Pass 0 to disable check.
       */
        snapPoint: function(ioPoint, iThreshold) {
          var originX = this.geom.origin.x,
            originY = this.geom.origin.y,
            unitX = this.geom.unit0.x - this.geom.origin.x,
            unitY = this.geom.unit1.y - this.geom.origin.y,
            newX = ioPoint.x,
            newY = ioPoint.y;

          // Default from desktop PIXELS_TO_SNAP_WHILE_DRAGGING
          if (undefined === iThreshold) {
            iThreshold = 100;
          }

          /*
           * Snap to polar grid
           */
          if (this.shape === 'polar') {
            var coordX = (ioPoint.x - originX) / unitX,
              coordY = (ioPoint.y - originY) / unitY,
              radius = Math.round(Math.sqrt(coordX * coordX + coordY * coordY)),
              theta = 0.0;
            if (0.0 !== radius) {
              var FIFTEEN_DEGREES = Math.PI / 12.0;
              theta = Math.atan2(-coordY, coordX);
              theta = Math.round(theta / FIFTEEN_DEGREES) * FIFTEEN_DEGREES;
            }
            newX = originX + unitX * radius * Math.cos(theta);
            newY = originY - unitY * radius * Math.sin(theta);
          } else {

          /*
           * Snap to square/rectangular grid
           */
            newX = Math.round((ioPoint.x - originX) / unitX) * unitX + originX;
            newY = Math.round((ioPoint.y - originY) / unitY) * unitY + originY;
          }

          // If iThreshold is specified, only adjust ioPoint if the
          // displacements are within the specified threshold.
          var dx = Math.abs(newX - ioPoint.x),
            dy = Math.abs(newY - ioPoint.y);
          if (!iThreshold || (dx < iThreshold && dy < iThreshold)) {
            ioPoint.x = newX;
            ioPoint.y = newY;
          }
        },
        createDefaultSpec: function(sketch, props) {
          var originStyle = (props && props.origin && props.origin.style) || {},
            xUnitPointStyle =
              (props && props.xUnitPoint && props.xUnitPoint.style) || {},
            xAxisStyle = (props && props.xAxis && props.xAxis.style) || {},
            yUnitPointStyle =
              (props.yUnitPoint && props.yUnitPoint.style) || {},
            yAxisStyle = (props && props.yAxis && props.yAxis.style) || {},
            shape = (props && props.shape) || 'square',
            style = (props && props.style) || {},
            isRectangular = shape === 'rectangular';

          var ret = {
            '1': {
              kind: 'Point',
              genus: 'OriginPoint',
              constraint: 'Free',
              style: originStyle,
              //Geom added below
            },
            '2': {
              kind: 'Point',
              genus: 'UnitPoint',
              parents: {
                origin: '1',
              },
              value: 28.346456692913385,
              constraint: 'HorizontalUnitPoint',
              style: xUnitPointStyle,
            },
            '3': {
              kind: 'Axis',
              genus: 'Axis',
              parents: {
                origin: '1',
                unitPoint: '2',
              },
              constraint: 'AxisInternalDist',
              orientation: 'horizontal',
              label: 'x',
              style: xAxisStyle,
            },
            //This is written out as if square - rectangular case is amended below
            '4': {
              kind: 'Point',
              genus: 'UnitPoint',
              parents: {
                unitPoint: '2',
              },
              constraint: 'UnitPointInternalSquare',
              style: yUnitPointStyle,
            },
            '5': {
              kind: 'Axis',
              genus: 'Axis',
              parents: {
                origin: '1',
                unitPoint: '4',
              },
              constraint: 'AxisInternalDist',
              orientation: 'vertical',
              label: 'y',
              style: yAxisStyle,
            },
            '6': {
              kind: 'CoordSys',
              genus: 'CoordSys',
              parents: {
                axisX: '3',
                axisY: '5',
              },
              constraint: 'CoordSys',
              shape: shape,
              style: style,
            },
          };

          //Relative position
          var centerX =
            (sketch.metadata.sketchRect.right -
              sketch.metadata.sketchRect.left) /
            2;
          var centerY =
            (sketch.metadata.sketchRect.bottom -
              sketch.metadata.sketchRect.top) /
            2;

          //Origin gets the center of the screen as its geom
          ret['1'].geom = {
            loc: {
              x: centerX,
              y: centerY,
            },
          };

          if (isRectangular) {
            ret['4'].constraint = 'UnitPointInternalRectangle';
            ret['4'].unitDistance = 28.346456692913364; //This constant came out of Desktop -> exporter for default trig coord sys
          }

          return ret;
        },
      }
    );
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class A message rendered in to a sketch canvas.
   * @augments GSP.gObjects.Point
   */
  GSP.gObjects.Measure = GSP.makeClass(
    /** @lends GSP.gObjects.Measure */ [
      GSP.gObjects.Text,
      GSP.mixins.labelBase,
    ],
    {
      doc: {
        description: 'A message rendered in to a sketch canvas.',
        inherits: 'Text',
        properties: {
          label: {
            description:
              'Text that describes or identifies the value of this object.',
            type: 'String',
            required: false,
          },
          style: {
            properties: {
              precision: {
                description:
                  'The number of digits to display after the decimal point.',
                type: 'Number',
                required: false,
              },
              nameOrigin: {
                description: 'What identifying value to display.',
                type: 'NameOrigin',
                required: false, // multimeasures don't currently export it,
                // but perhaps they should.
              },
              showUnits: {
                description: 'Do we show the unit measurement?',
                required: false,
              },
            },
          },
          blank: {
            description:
              'a display property indicating that the value or result ' +
              'of the calculation should be blank',
            type: 'Boolean',
            default: false,
            required: false,
          },
          debug: {
            properties: {
              value: {
                description: 'The numeric value of a measure',
                required: false,
                type: 'Number',
              },
              defined: {
                description: 'Whether the measure is defined',
                required: false,
                type: 'Boolean',
              },
            },
          },
        },
      },
      kind: 'Measure',
      style: {
        precision: undefined,
        showUnits: true,
      },
      unitPowers: { scalar: 1 },
      initPrecision: function() {
        var measureType = 'scalar',
          hasLength = this.unitsObject.hasOwnProperty('length'),
          hasAngle = this.unitsObject.hasOwnProperty('angle'),
          val;

        if (!(hasLength && hasAngle)) {
          if (hasLength) {
            measureType = 'length';
          }
          if (hasAngle) {
            measureType = 'angle';
          }
        }

        if (this.style.precision !== undefined) {
          val = this.style.precision;
        } else {
          val = this.sQuery().prefs().precision[measureType];
        }

        return val;
      },
      /*
       * Initialize the measurement message. A measurement message is composed
       * from a name, a value, and the symbol representing the unit of measure.
       */
      initKind: function initKind() {
        (initKind.base || arguments.callee.base).call(this);
        this.initMeasure();
        this.style.precision = this.initPrecision(this.sQuery().prefs());
      },

      postInit: function(props) {
        // Measures created by tools should create and show parental labels if namedFromTemplate.
        // (The speculative prop is set only for tools.)
        if (
          !this.style.hidden &&
          props &&
          props.speculative &&
          this.style.nameOrigin === 'namedFromTemplate'
        ) {
          // As we manipulate labels, temporarily pause the normal updateLabel() process
          this.state.updatingLabel = true;
          this.eachParent(function(ix, parent) {
            parent.state.updatingLabel = true;
          });
          this.eachParent(function(ix, parent) {
            if (parent.getLabel) {
              parent.getNameMFS({ show: true });
            }
          });
          this.eachParent(function(ix, parent) {
            delete parent.state.updatingLabel;
          });
          delete this.state.updatingLabel;
          this.updateLabel({ show: true });
        }
      },

      updateLabelForKind: function updateLabelForKind(option) {
        (updateLabelForKind.base || arguments.callee.base).call(this);
        if (option && option.init && !this.style.hidden) {
          if (this.state.renderState === 'speculative')
            // show parent labels if we're in toolplay
            option.show = true;
          else option.create = true;
        }
        this.generateMeasureMFS(option);
      },

      /* 
       Initialize a measure object. Called during init. Subclasses may
       override.
       */
      initMeasure: function initMeasure() {
        //This seeds our unitsObject with our initial unitPowers value
        this.setUnits(this.unitPowers);

        if (this.value !== undefined) {
          this.uValue = GSP.units.convertFromBaseToUnitObject(
            this.value,
            this.unitsObject
          );
        }
      },

      /* This is a temporary stopgap until we implement the full genera hierarchy (see WSP-1378).
       * In the meantime we must make sure that an assumed value (a scalar, distance, or angle) is of the same
       * "value type" as the object to which it is being matched. Each possible "value type" can be instantiated
       * as a parameter, a measurement, or a calculation, resulting in the following possible kind/genus pairs:
       * Scalar: Expression/ScalarParameter, Measure/ScalarMeasure, and Expression/ScalarMeasure (i.e., calculation)
       * Distance: Expression/DistanceParameter, Measure/DistanceMeasure, and Expression/DistanceMeasure (i.e., calculation)
       * Angle: Expression/AngleParameter, Measure/AngleMeasure, and Expression/AngleMeasure (i.e., calculation)
       * Paradoxically an assumed tool object might fit any of these nine pairs, so we need to check both kind and genus.
       * This code also handles two special cases:
       * A radian angle measure or expression can be used as a scalar.
       * Any measure or expression can be used to plot a point.
       * This code is essentially duplicated for Expressions; it would be better to have it in one place,
       * or even better to have a genus hierarchy that expresses the "value type" (scalar, distance, or angle).
       * See identical code in expression.js.
       */
      matchesAssumedSpec: function matchesAssumedSpec(assumedSpec) {
        if (
          assumedSpec.kind === 'Expression' ||
          assumedSpec.kind === 'Measure'
        ) {
          if (assumedSpec.genus.includes('Scalar'))
            return (
              this.genus.includes('Scalar') ||
              (this.genus.includes('Angle') && this.unit === 'rad') ||
              (assumedSpec.children.length === 1 &&
                assumedSpec.children[0].genus === 'PlottedPoint')
            );
          else if (assumedSpec.genus.includes('Distance'))
            return this.genus.includes('Distance');
          else if (assumedSpec.genus.includes('Angle'))
            return (
              this.genus.includes('Angle') ||
              (this.genus.includes('Scalar') && assumedSpec.unit === 'rad')
            );
          else if (assumedSpec.genus === 'Function')
            return this.genus === 'Function';
        }
        return false;
      },

      /*
       * Initialize mfs for measure. This is a concatenation of the
       * nameAndEqualsMFS, a value placeholder and the units, if present.
       */
      generateMeasureMFS: function generateMeasureMFS(option) {
        var buf = [],
          nameMFS,
          unitsMFS;

        // JSP sketches use fixed strings to label function expressions
        if (this.style.nameOrigin === 'namedFromFixedString') {
          this.parsedMFS = GSP.mfs.makeTextMFS(this.label);
          return;
        }

        if (this.style.hidden && !this.isGobjExistInWSPSays()) {
          // don't generate new ancestor labels unless needed to show a measurement
          return;
        }

        nameMFS = this.getNameMFS(option);

        if (this.style.nameOrigin !== 'noVisibleName') {
          if (!nameMFS && option.init) {
            return; // delay setting parsedMFS during init if the name can't yet be generated
          }
          buf.push(nameMFS);
          buf.push(GSP.mfs.makeTextMFS(' = '));
        }

        // polymorphic call
        buf.push(this.getValueMFS());

        unitsMFS = this.getUnitsMFS();
        if (unitsMFS !== null) {
          buf.push(unitsMFS);
        }

        if (this.style.suffix) {
          buf.push(GSP.mfs.makeTextMFS(this.style.suffix));
        }

        // variadic call
        this.parsedMFS = GSP.mfs.makeHorizontalMFS.apply(this, buf);
      },

      getValueMFS: function getValueMFS() {
        return { type: 'parameter', value: 'value' };
      },

      /*
       * Computes an expression name based on the infix expression.
       * @param option: if option.force, a measure with no visible name returns a value instead of ""
       */
      generateNameMFS: function(option) {
        var s,
          nameOrigin = this.style.nameOrigin,
          nameMFS,
          self = this;

        // Replace the pattern's switch parameters with their current labels
        function replaceValues(pattern, subs) {
          var ix, item, sub;
          if (!pattern.value) return;
          for (ix = 0; ix < pattern.value.length; ix++) {
            item = pattern.value[ix];
            if (item.type === 'switch' && item.value) {
              sub = item.value[0];
              if (sub.type === 'parameter') {
                pattern.value[ix] = subs[sub.value];
              }
            }
          }
        }

        function getCompositeMFS(children) {
          // If self is hidden and there's a visible CompositeText child, generate the name from the child
          var theChild, ix, ret;
          if (self.style.hidden) {
            // What if it's visible? Shouldn't we still use the composite child?
            // How do we know what was tapped? Should this be the convention:
            // If the value parent (a measure) is immediately followed in the parent list by
            // a composite text that's a child of the value parent, get the parsed MFS and
            // references from that composite child.
            for (ix = 0; ix < children.length; ix++) {
              if (
                children[ix].constraint === 'CompositeText' &&
                !children[ix].style.hidden
              ) {
                theChild = children[ix];
                break;
              }
            }
            if (theChild && theChild.parsedMFS) {
              // During init MFSValues may not be ready
              //theChild.updateLabelForConstraint (); // does this do the needed substitutions?
              // If so, we can skip the for loop below.

              ret = JSON.parse(JSON.stringify(theChild.parsedMFS));

              for (ix = 0; ix < ret.value.length; ix++) {
                if (
                  ret.value[ix].type === 'text' &&
                  ret.value[ix].value.match(/=/)
                ) {
                  ret.value.splice(ix, ret.value.length);
                  replaceValues(
                    ret,
                    theChild.MFSValues || theChild.parentMFSValues
                  );
                }
              }
            }
            return ret;
          }
        }

        if (nameOrigin === 'noVisibleName' && option && option.force) {
          nameOrigin = 'namedFromLabel';
        }
        switch (nameOrigin) {
          case 'namedFromLabel':
            s = this.label ? this.label.replace(/ += +$/, '') : '';
            nameMFS = GSP.labels.parseLabelExpression(
              s,
              this.getMathItalicization()
            );
            break;
          case 'noVisibleName':
            nameMFS = GSP.mfs.makeTextMFS('');
            break;
          case 'namedFromTemplate':
            nameMFS = this.getParentalNameMFS(option);
            break;
          case 'namedFromCustom':
            nameMFS = getCompositeMFS(this.children);
            if (nameMFS) break;
          /* falls through */
          default:
            nameMFS = null;
            GSP.signalErrorWithMessage(
              "Measure.getNameMFS() doesn't know how to do nameOrigin" +
                nameOrigin
            );
            break;
        }

        return nameMFS;
      },

      /**
       * Updates the unitPowers property and generates a new unitsObject based on
       * the new value
       * @param {Object} unitPowers - an object specifying the powers of each unit family (length and/or angle)
       */
      setUnits: function(unitPowers) {
        this.unitPowers = unitPowers;
        this.unitsObject = GSP.units.makeUnitObjectFromUnitsAndPowers(
          this.sQuery().prefs().units,
          unitPowers
        );
      },
      /**
       * Measure Constraints should override this method.
       */
      getUnitsMFS: function() {
        // This reason for unsetting the units is that in Java Sketches that are loaded
        // into WSP with the java2wsp shim, there should be no unit measurements displayed.
        // Therefore, the only time that this condition can be true is when it's loaded with
        // the shim, and the preferences for unit.display is set to false.
        if (this.style.showUnits === false) {
          return GSP.mfs.makeTextMFS('');
        }
        return GSP.units.getMFSForUnitObject(this.unitsObject);
      },

      /**
       * Returns the raw value of this measure in base units
       */
      getRawValue: function() {
        return this.value;
      },
      getColorableComponent: function() {
        return 'TextGObject_BackgroundContrast';
      },
      getTextType: function() {
        return 'Measurement';
      },
      getMFSAppearanceForVariant: function getMFSAppearanceForVariant(variant) {
        var measure = this,
          origValue,
          buf = [],
          addendReturnValue;

        function formattedValue() {
          var units = measure.radiansOrScalar();
          return measure.formatNumberAsMFS(
            measure.uValue,
            measure.style.precision,
            units,
            true
          );
        }

        switch (variant) {
          case 'valueAsAddend':
            if (!this.state.exists) {
              return null;
            }

            //See UniValueEmbeddedText_GetCurrentAppearance() for reference
            if (measure.uValue < 0) {
              buf.push(GSP.mfs.makeTextMFS(' '));
              buf.push({ type: 'symbol', value: '103' });
              buf.push(GSP.mfs.makeTextMFS(' '));
            } else {
              buf.push(GSP.mfs.makeTextMFS(' + '));
            }

            origValue = measure.uValue;
            measure.uValue = Math.abs(measure.uValue);

            buf.push(formattedValue());
            // variadic call
            addendReturnValue = GSP.mfs.makeHorizontalMFS.apply(this, buf);
            measure.uValue = origValue;
            return addendReturnValue;

          case 'byLabel':
            return this.getLabelMFS();
          case 'byName':
            return this.getParentalNameMFS();
          //case "default":
          //case "byValue":
          default:
            if (!this.state.exists) return null;
            // JSP Pegged text expects a prefix string to be inserted before the value.
            var hasPrefix =
              variant === 'default' && this.style.prefixWithLabel && this.label;
            if (hasPrefix || this.style.suffix) {
              var horizontals = [formattedValue()];
              if (hasPrefix) {
                horizontals.unshift(GSP.mfs.makeTextMFS(this.label));
              }
              if (this.style.suffix) {
                horizontals.push(GSP.mfs.makeTextMFS(this.style.suffix));
              }
              return GSP.mfs.makeHorizontalMFS.apply(this, horizontals);
            } else {
              return formattedValue();
            }
        }
      },
      /**
       * Verifies the initial state of this object by comparing its
       * initial values against values calculated by the sketchpad exporter.
       */
      verificationString: function verificationString(expected, args) {
        var msg = (verificationString.base || arguments.callee.base).call(
          this,
          expected,
          args
        );
        var lengthPower, anglePower;
        if (expected.exists && this.state.exists) {
          if (this.genus !== 'Function') {
            //None of the following tests are appropriate for functions
            if (!GSP.math.expect(this.uValue, expected.value)) {
              msg +=
                'value: <span class="error">' +
                this.uValue +
                '</span>(<span class="expected">' +
                expected.value +
                '</span>)';
            }

            //Convert undefined to 0 for consistency with desktop
            lengthPower = this.unitPowers.length ? this.unitPowers.length : 0;
            if (!GSP.math.expect(lengthPower, expected.lengthPower)) {
              msg +=
                'length power: <span class="error">' +
                lengthPower +
                '</span>(<span class="expected">' +
                expected.lengthPower +
                '</span>)';
            }

            //Convert undefined to 0 for consistency with desktop
            anglePower = this.unitPowers.angle ? this.unitPowers.angle : 0;
            if (!GSP.math.expect(anglePower, expected.anglePower)) {
              msg +=
                'length power: <span class="error">' +
                anglePower +
                '</span>(<span class="expected">' +
                expected.anglePower +
                '</span>)';
            }
          }
        }
        return msg;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   *  A numeric expression.
   *  @class Expression
   *  @augments GSP.gObjects.Measure
   */

  GSP.gObjects.Expression = GSP.makeClass(
    /** @lends GSP.gObjects.Expression */ GSP.gObjects.Measure,
    (function() {
      return {
        doc: {
          description: 'A numeric expression.',
          inherits: 'Measure',
          properties: {
            expression: {
              description: 'An infix expression',
              type: 'String',
            },
            expressionType: {
              description:
                'The type of expression. Used mainly for interpreting functions.',
              type: 'UnivExpressionType',
            },
            functionExpr: {
              description: 'A set of properties used for function expressions.',
              required: false,
              properties: {
                notation: {
                  description:
                    "Display notation type of the function: 'function' (e.g. 'f(x)') or 'dependentVariable' (e.g. 'y =')",
                  type: 'String',
                  required: false,
                },
                name: {
                  description:
                    "The name of the function, e.g. 'f' in 'y = f(x)'.",
                  type: 'String',
                  required: false,
                },
                dependentVar: {
                  description:
                    "The name of the dependent variable, e.g. 'y' in 'y = f(x)'.",
                  type: 'String',
                  required: false,
                },
                independentVar: {
                  description:
                    "The name of the independent variable, e.g. 'x' in 'y = f(x)'.",
                  type: 'String',
                  required: false,
                },
              },
            },
            style: {
              description:
                'Properties that influence the appearance of a GObject.',
              properties: {
                contenteditable: {
                  description:
                    'Whether the element is inline-editable. Applicable only to Parameters.',
                  type: 'Boolean',
                },
              },
            },
          },
        },
        kind: 'Expression',
        expression: '',
        isExpressionDirty: false,
        unitPowers: { scalar: 1 },
        notation: 'function',
        parsedInfix: undefined,
        style: {
          contenteditable: false,
        },
        value: undefined,
        /*
         * An expression can be a resolvable expression or a function. Either
         * type may have parental references to other gobjects. These may be
         * resolved for a resolvable expression and at any point the expression
         * exists or may be computed as a single scalar value. A function has a
         * variable, and may not be resolved to a single value. The value of
         * a function is the function of a single variable created by resolving
         * all references.
         */
        isFunction: function() {
          return this.expressionType !== 'UniMeasure_ExprType';
        },
        /*
         * An expression may be a parameter. Are simple values and are not dependent
         * on other gobjects. This, in GSP, is determined by genus.
         * We replicate the logic, here.
         */
        isParameter: function() {
          return (
            this.genus === 'ScalarParameter' ||
            this.genus === 'AngleParameter' ||
            this.genus === 'DistanceParameter'
          );
        },

        /*
         * This reminds the HTML engine to register our element with the
         * NumpadMgr as soon as it creates it.
         *
         * Parameters and non-parameter expressions use different methods
         * for registration. Whereas the former are registered when an mfs
         * input element is found, the latter are registered when their
         * root element is first rendered. This has consequences for touch
         * handling too.
         */
        renderPrepare: function renderPrepare(drawContext, renderArgs) {
          if (!this.isParameter()) {
            renderArgs.isEditableByCalculator = true;
          }
          return (renderPrepare.base || arguments.callee.base).apply(
            this,
            arguments
          );
        },

        initMeasure: function initMeasure() {
          var unitMap = this.sQuery().prefs().units;

          // set measureType based on genus
          this.unit = '';
          if (this.genus === 'AngleParameter') {
            this.setUnits({ angle: 1 });
            this.unit = unitMap.angle;
          } else if (this.genus === 'DistanceParameter') {
            this.setUnits({ length: 1 });
            this.unit = unitMap.length;
          }

          this.parseInfixExpression();
        },
        initPrecision: function initPrecision() {
          if (!this.isFunction()) {
            return (initPrecision.base || arguments.callee.base).call(this);
          }

          //otherwise functions don't have precision
          return undefined;
        },

        getValueMFS: function getValueMFS() {
          if (this.isFunction()) {
            return GSP.mfs.makeMFSFromParsedInfix(
              this.parsedInfix,
              this.parentsList,
              true,
              this.getMathItalicization()
            );
          } else if (this.isEditableSimpleExpression()) {
            return { type: 'input', value: 'value' };
          } else {
            return { type: 'parameter', value: 'value' };
          }
        },

        isHittable: function isHittable() {
          // We can be hit if we're visible, and either selectable or editable
          return (
            this.isRenderable() &&
            (this.style.contenteditable || this.style.selectable)
          );
        },

        /* This is a temporary stopgap until we implement the full genera hierarchy (see WSP-1378).
         * In the meantime we must make sure that an assumed value (a scalar, distance, or angle) is of the same
         * "value type" as the object to which it is being matched. Each possible "value type" can be instantiated
         * as a parameter, a measurement, or a calculation, resulting in the following possible kind/genus pairs:
         * Scalar: Expression/ScalarParameter, Measure/ScalarMeasure, and Expression/ScalarMeasure (i.e., calculation)
         * Distance: Expression/DistanceParameter, Measure/DistanceMeasure, and Expression/DistanceMeasure (i.e., calculation)
         * Angle: Expression/AngleParameter, Measure/AngleMeasure, and Expression/AngleMeasure (i.e., calculation)
         * Paradoxically an assumed tool object might fit any of these nine pairs, so we need to check both kind and genus.
         * This code also handles two special cases:
         * A radian angle measure or expression can be used as a scalar.
         * Any measure or expression can be used to plot a point.
         * This code is essentially duplicated for Measures; it would be better to have it in one place,
         * or even better to have a genus hierarchy that expresses the "value type" (scalar, distance, or angle).
         * See identical code in measure.js.
         */
        matchesAssumedSpec: function matchesAssumedSpec(assumedSpec) {
          if (
            assumedSpec.kind === 'Expression' ||
            assumedSpec.kind === 'Measure'
          ) {
            if (assumedSpec.genus.includes('Scalar'))
              return (
                this.genus.includes('Scalar') ||
                (this.genus.includes('Angle') && this.unit === 'rad') ||
                (assumedSpec.children.length === 1 &&
                  assumedSpec.children[0].genus === 'PlottedPoint')
              );
            else if (assumedSpec.genus.includes('Distance'))
              return this.genus.includes('Distance');
            else if (assumedSpec.genus.includes('Angle'))
              return (
                this.genus.includes('Angle') ||
                (this.genus.includes('Scalar') && assumedSpec.unit === 'rad')
              );
            else if (assumedSpec.genus === 'Function')
              return this.genus === 'Function';
          }
          return false;
        },

        createDefaultSpec: function(sketch, props) {
          var locX =
            (sketch.metadata.sketchRect.right -
              sketch.metadata.sketchRect.left) /
            2;
          var locY =
            (sketch.metadata.sketchRect.bottom -
              sketch.metadata.sketchRect.top) /
            2;
          var style = (props && props.style) || {};
          var label = (props && props.label) || '';

          if (
            props.constraint !== 'Free' ||
            ['ScalarParameter', 'AngleParameter', 'DistanceParameter'].indexOf(
              props.genus
            ) < 0
          ) {
            return;
          }
          if (props && props.geom && props.geom.loc) {
            // Grab its location, which will be relative to a (0,0) origin.
            locX = sketch.metadata.sketchRect.left + props.geom.loc.x;
            locY = sketch.metadata.sketchRect.top + props.geom.loc.y;
          }

          return {
            '1': {
              kind: 'Expression',
              genus: props.genus,
              constraint: 'Free',
              expressionType: 'UniMeasure_ExprType',
              expression: props.expression,
              style: style,
              label: label,
              geom: {
                loc: {
                  x: locX,
                  y: locY,
                },
              },
            },
          };
        },

        /**
         *  Returns jquery-wrapped edit box element(s)
         */
        getEditBoxElement: function() {
          var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this);
          return $('.mfs-input', $(displayObject.element));
        },

        /**
         *  Returns true if the passed in position is within this parameter's
         *  edit box.
         *
         *  Pos is a position object made by EventToSketch()
         */
        positionInEditBox: function(pos) {
          if (this.state.renderState !== 'invisible') {
            return GSP.positionInElement(pos, this.getEditBoxElement());
          }

          return false;
        },

        hitTest: function(rect, hotSpot, options) {
          var displayObject = this.sQuery.sketch.getDisplayObjForGObj(this),
            dims = {
              left: this.geom.loc.getX(),
              top: this.geom.loc.getY(),
              width: displayObject.width(),
              height: displayObject.height(),
            },
            rect1 = {
              left: dims.left,
              right: dims.left + dims.width,
              top: dims.top,
              bottom: dims.top + dims.height,
            },
            isHit = GSP.Geom.RectsIntersect(dims, rect1),
            gobj = this;

          // But wait - if we hit the edit box, return a custom click tracker that
          // begins editing on a successful click.
          // Note: hitTest clients are free to ignore the tracker when they only care
          // whether the gobj was hit.
          if (isHit && hotSpot && this.positionInEditBox(hotSpot)) {
            return GSP.ClickTracker.createOnElement(
              this.getEditBoxElement(),
              function() {
                gobj.presentUI(options && options.onCompleteUI);
              }
            );
          }

          // Now that we've checked if this was a param edit, we can return true
          // if we are selectable for dragging or if options.assumeArrowSelectable is true
          return (
            isHit &&
            (this.style.selectable ||
              (options && options.assumeArrowSelectable))
          );
        },

        presentUI: function(finishedCallback) {
          var displayObj = this.sQuery.sketch.getDisplayObjForGObj(this);
          var controller;
          var element = displayObj.mfsElement;

          if (this.isParameter()) {
            controller = $('.mfs-input', element).data('wsp-numfield-ctl');
          } else {
            controller = $(element).data('wsp-numfield-ctl');
          }

          if (finishedCallback) {
            controller.setListener(function(result) {
              finishedCallback(result);
              controller.clearListener();
            });
          }
          controller.vFocus(this);
        },

        doubleClicked: function(touch) {
          var element = this.sQuery.sketch.getDisplayObjForGObj(this).element;

          var controller = $(element).data('wsp-numfield-ctl');
          if (controller) {
            // undefined on parameters
            controller.click(touch, this);
          }
        },

        /*
         * creates a function from an infix expression. This function also
         * updates the unitMultiplier property to allow conversion from the uValue
         * to the value property via a simple multiplication.
         */
        makeFnFromInfixExpression: function() {
          var expr = GSP.mfs.getParsedInfixAndFunction(this.expression);

          this.parsedInfix = expr.parsedInfix;

          //Now that we have a parse tree, we can compute the unitMultiplier
          this.setUnits(
            GSP.mfs.determineUnit(this.parsedInfix, this.parentsList)
          );
          this.unitMultiplier = GSP.units.convertToBaseFromUnitObject(
            1,
            this.unitsObject
          );
          // Changing a calculation can modify its genus, so use the unitPowers to check that
          // When editing a calculation might affect a descendant that requires certain units,
          // GSP issues a "Units Warning" to the user, but still allows the change. It appears
          // that the warning is issued only when the edit constrains a descendant that
          // requires specific units -- but it doesn't test whether units reaching the
          // descendant are inappropriate. How important is such a warning in WSP?
          if (GSP.isCalculation(this)) {
            if (this.unitPowers.angle === 1 && !this.unitPowers.length)
              this.genus = 'AngleMeasure';
            else if (!this.unitPowers.angle && this.unitPowers.length === 1)
              this.genus = 'DistanceMeasure';
            else this.genus = 'ScalarMeasure';
          }

          return expr.func;
        },
        /**
         * return unit powers for the function given an independent variable with
         * iIndependentVariableUnitPowers units.  The function must have been
         * constrained prior to calling this method.
         *
         * @param {object} iIndependentVariableUnitPowers - the unit powers of the independent variable
         */
        getUnitPowers: function(iIndependentVariableUnitPowers) {
          //NOTE: If called on a non-function, iUnitPowers will have no effect since
          //it's only used in places the independent variable appears in the expression
          return GSP.mfs.determineUnit(
            this.parsedInfix,
            this.parentsList,
            iIndependentVariableUnitPowers
          );
        },
        curryReferences: function(gobj, pvalues, units) {
          return function(x) {
            var indVar =
              gobj.functionExpr && gobj.functionExpr.independentVar
                ? gobj.functionExpr.independentVar
                : 'x';
            pvalues[indVar] = x;
            return gobj.fnExpression(pvalues, units);
          };
        },

        /**
         */
        parseInfixExpression: function() {
          var unitMap = this.sQuery().prefs().units;

          this.fnExpression = this.makeFnFromInfixExpression();
          this.fnUnits = unitMap;

          // If constraint is 'free' evaluate: the constraint will not.
          if (this.constraint === 'Free') {
            if (!this.isFunction()) {
              this.uValue = this.fnExpression([], unitMap);
              this.value = this.uValue * this.unitMultiplier;
            } else {
              var theFunc = this;
              this.uValue = this.curryReferences(this, [], unitMap);
              this.value = function(x) {
                return theFunc.uValue(x) * theFunc.unitMultiplier;
              };
            }
            this.isExpressionDirty = false;
          }
        },

        // Fix up an expression when internal mfs and / or parents have changed
        expressionAndParentsWereUpdated: function() {
          var sketch = this.sQuery.sketch,
            gobjList = sketch.gobjList;

          GSP.ObjectGraph.setParents(
            gobjList.constraintList,
            this,
            this.parents
          );
          this.parentsList = gobjList.createCanonicalParentReferences(this);
          this.descendantGraphHasChanged();
          //  Send an "edit" sketch event. An "update" event isn't appropriate, because
          //  "update" is already sent for expressions when they are moved around in the sketch
          sketch.document.raiseSketchEvent(sketch.getPageId(), this.id, 'edit');
        },

        graphHasChanged: function graphHasChanged() {
          this.parseInfixExpression();
          return (graphHasChanged.base || arguments.callee.base).call(this);
        },

        isEditableSimpleExpression: function() {
          //  If the parameter is selectable or contenteditable, show an edit box whether or not GSP says so.
          //  If the parameter is neither, it's uneditable.
          if (!this.style.selectable && !this.style.contenteditable) {
            return false;
          }
          if (this.parsedInfix === undefined) {
            this.parsedInfix = GSP.mfs.getParsedInfix(this.expression);
          }
          return GSP.mfs.isSimpleExpression(this.parsedInfix);
        },
        getUnitsMFS: function getUnitsMFS() {
          if (this.isFunction()) {
            return null;
          }

          return (getUnitsMFS.base || arguments.callee.base).call(this);
        },
        /*
         * Computes an expression name based on the infix expression.
         */
        generateNameMFS: function() {
          var ital = this.getMathItalicization();
          // For function expressions, "name" is something like "f(x)" or "y"
          if (this.functionExpr) {
            var fName = this.getLabelMFS() || GSP.mfs.makeTextMFS('f', ital),
              depVarNode = GSP.mfs.makeTextMFS(
                this.functionExpr.dependentVar || 'y',
                ital
              ),
              indepVarNode = GSP.mfs.makeTextMFS(
                this.functionExpr.independentVar || 'x',
                ital
              ),
              fExpr =
                this.functionExpr.notation === 'function'
                  ? [fName, { type: 'paren', value: [indepVarNode] }]
                  : [depVarNode];
            // call variadic function
            return GSP.mfs.makeHorizontalMFS.apply(this, fExpr);
          }

          var s,
            nameOrigin = this.style.nameOrigin,
            nameMFS;

          switch (nameOrigin) {
            case 'namedFromLabel':
            /* they are asking for a name, so give them what we have 
            even if we're not displaying it ourselves */
            case 'noVisibleName':
              s = this.label ? this.label.replace(/ = $/, '') : '';
              nameMFS = GSP.labels.parseLabelExpression(s, ital);
              break;
            case 'namedFromTemplate':
              nameMFS = this.createMFSFromInfixExpression();
              break;
            /*case "namedFromCustom":*/
            default:
              nameMFS = GSP.mfs.makeTextMFS('Expression ' + this.id);
              //Silencing error until reform of label renderPrepare is completed
              //GSP.signalErrorWithMessage("Expression.getNameMFS() doesn't know how to do nameOrigin" + nameOrigin);
              break;
          }

          return nameMFS;
        },
        createMFSFromInfixExpression: function() {
          if (this.parsedInfix === undefined) {
            this.parsedInfix = GSP.mfs.getParsedInfix(this.expression);
          }
          return GSP.mfs.makeMFSFromParsedInfix(
            this.parsedInfix,
            this.parentsList,
            false,
            this.getMathItalicization()
          );
        },
        getMFSAppearanceForVariant: function getMFSAppearanceForVariant(
          variant
        ) {
          //cf. FunctionEmbeddedText_GetCurrentAppearance()
          var expression = this;

          function getFunctionAppearance() {
            var mathItalicization = expression.getMathItalicization();

            switch (variant) {
              case 'expressionOnly':
                if (!expression.parsedInfix) {
                  expression.parseInfixExpression();
                }
                return GSP.mfs.makeMFSFromParsedInfix(
                  expression.parsedInfix,
                  expression.parentsList,
                  true,
                  expression.getMathItalicization()
                );
              case 'independentVariable':
                return GSP.mfs.makeTextMFS(
                  expression.functionExpr.independentVar || 'x',
                  mathItalicization
                );
              case 'dependentVariable':
                return GSP.mfs.makeTextMFS(
                  expression.functionExpr.dependentVar || 'y',
                  mathItalicization
                );
              case 'byLabel':
                return expression.getLabelMFS();
              //case "default":
              default:
                //Default is the full representation of the function
                return expression.parsedMFS;
            }
          }

          if (this.isFunction()) {
            return getFunctionAppearance();
          }
          if (variant === 'byName') {
            // A calculation's "name" variant is simply its infix expression.
            // This is triggered when a calculation is inserted "as
            // calculation" into composite text.
            return this.createMFSFromInfixExpression();
          } else {
            return (
              getMFSAppearanceForVariant.base || arguments.callee.base
            ).call(this, variant);
          }
        },
        /*
         *  Updates the value of the parameter with newValue.  newValue is assumed
         *  to be a number here.
         */

        updateValue: function(newValue) {
          var sketch = this.sQuery().sketch;
          if (
            typeof newValue === 'function' ||
            typeof this.value === 'function'
          ) {
            throw GSP.createError(
              'Expression.updateValue() called on function or with value arg that is a function'
            );
          }

          this.value = newValue;
          this.uValue = this.value / this.unitMultiplier;
          //These shouldn't be needed by clients since we have a valid value, uValue
          //and unitMultiplier.  By setting them to undefined, we ensure the stale
          //ones are not used (and potentially free up memory).
          this.isExpressionDirty = true;
          this.fnExpression = undefined;
          this.parsedInfix = undefined;
          sketch.invalidateGeom(this);
          sketch.document.raiseSketchEvent(
            sketch.getPageId(),
            this.id,
            'update'
          );
        },

        prepareToSerialize: function() {
          if (this.isExpressionDirty) {
            this.setParameterValue(this.uValue, this.unit);
          }
        },

        /**
         *  Sets a parameter's value with the specified text value.
         *  This is presumed to be the result of a user edit which
         *  requires validation. The value of the parameter is only
         *  changed if validation/evaluation indicates it is valid.
         *
         *  @param {string} iText
         */
        setEditedValue: function(iText) {
          var value,
            expr,
            trimmedText = iText.trim(),
            // Set to true to allow units to be entered as part of parameter values
            kAllowUnits = false,
            unitMap = kAllowUnits ? this.sQuery().prefs().units : undefined,
            isBlank = iText === '',
            isValid = false,
            sketch = this.sQuery.sketch;

          // Check validity -- only valid/evaluable expressions are accepted
          try {
            expr = GSP.mfs.getParsedInfixAndFunction(trimmedText);
            value = expr.func && expr.func([], unitMap);

            isValid = GSP.math.isFiniteScalar(value);
          } catch (ex) {
            // any exceptions indicate an invalid expression
          }

          // Set the new value if it's determined to be valid
          if (isValid || isBlank) {
            // Note: there is an inefficiency here in that setParameterValue()
            // will parse the expression again. A refactoring of setParameterValue()
            // that allowed the parsedInfix and the built function to be passed in
            // would allow setParameterValue() to bypass the redundant parse steps.
            // For instance, setParameterValue() could take an options parameter
            // that could potentially include 'units', 'parsedInfix', 'fn' and
            // possibly other optional arguments.
            if (trimmedText !== this.expression) {
              sketch.document.raiseSketchEvent(
                sketch.getPageId(),
                this.id,
                'edit'
              );
            }
            this.setParameterValue(trimmedText);
            this.blank = isBlank;
          }

          this.sQuery().invalidateGeom(this);
        },

        /**
         *  sets a parameter's value with newValue, which can be any expression,
         *  either a string or a numeric value.
         *
         *  @param {number} newValue
         *  @param {string} unit - an optional unit for newValue
         */
        setParameterValue: function(newValue, unit) {
          var oldFnExpression = this.fnExpression,
            oldExpression = this.expression,
            oldParseTree = this.parsedInfix,
            unitExpression = unit || this.unit;

          // NaN is just blank
          if (isNaN(newValue)) newValue = '';

          // newValue could be an expression like "π/12" followed by unitExpression
          // "rad" which would lead to "π/12rad" which binds wrongly without parenthesis
          // around the expression.  That was what made it necessary to add parenthesis
          // around the expression value so that we get the correct expression(π/12)rad
          // SS: Update: this strategy makes angle parameters uneditable after the first edit, so we guard it by doing the right thing when this.expression is numeric.
          // Question: might it be problematic that editing an angle param changes it from "60°" to "60deg"?
          // NOTE: There could be a bug lurking here if the WSP parameter-editing interface ever changes to allow simple expressions including pi, e, and so forth.
          // If that extension happens, make sure it's compatible with the (pi/12)*1rad solution below.
          this.expression = String(newValue);
          if (unitExpression) {
            if ($.isNumeric(this.expression)) this.expression += unitExpression;
            else if (this.expression !== '') {
              this.expression = '(' + this.expression + ')*1' + unitExpression;
            }
          }
          this.parsedInfix = undefined;
          try {
            this.fnExpression = this.makeFnFromInfixExpression();
          } catch (ex) {
            ex.message =
              "In expression: '" + this.expression + "': " + ex.message;
            GSP.signalCaughtError(ex);
            this.fnExpression = oldFnExpression;
            this.expression = oldExpression;
            this.parsedInfix = oldParseTree;
          }
          var unitMap = this.sQuery().prefs().units;
          this.uValue = this.fnExpression([], unitMap);
          this.value = this.uValue * this.unitMultiplier;
          this.isExpressionDirty = false;
          this.sQuery().invalidateGeom(this);
        },

        /**
         * @param {Object} gobj: A potential match to which the parameter can be merged.
         * @returns {Object} The actual match (possibly an ancestor of gobj, or false if no match.
         * gobj can be a measurement, a Pegged text object, or a CompositeText object.
         * The matching ancestor must be a measurement that satisfies param.matchesAssumedSpec().
         * To avoid ambiguity, any intervening CompositeText object must have a single measurement parent.
         * The param can match not only a text object showing a measurement's value,
         * but also one showing a measurement's name.
         */
        getLegalMatchForParam: function(gobj) {
          var self = this,
            hit,
            newHit;

          function textMatchesParam(gobj) {
            var parent;
            // self is a parameter and gobj is text, perhaps Pegged or Composite, which may descend
            // from a single possibly matching measurement. Return the unique such object, or false otherwise.
            if (gobj.isOfKind('Measure')) {
              if (gobj.matchesAssumedSpec(self)) {
                newHit = gobj;
                if (hit && newHit !== hit) return false;
                hit = newHit;
                return hit;
              }
            } else if (
              gobj.constraint === 'Pegged' &&
              gobj.parentsList.length === 2
            ) {
              return textMatchesParam(gobj.parents.text);
            } else if (gobj.constraint === 'CompositeText') {
              // CompositeText that includes a single measurement may qualify
              for (var ix = 0; ix < gobj.parentsList.length; ix++) {
                parent = gobj.parentsList[ix];
                newHit = self.getLegalMatchForParam(parent);
                if (newHit) {
                  if (hit && newHit !== hit) return false;
                  hit = newHit;
                }
              }
              return hit;
            }
            return false;
          }

          if (!this.genus.match(/Parameter/)) {
            // If this isn't a param, it can't be merged.
            return false;
          }
          if (gobj.isOfKind('Measure') && gobj.matchesAssumedSpec(this)) {
            // genus matches: Angle to Angle, Distance to Distance, Scalar to Scalar
            return gobj;
          } else if (gobj.kind === 'Text') {
            // Pegged or CompositeText
            return textMatchesParam(gobj);
          }
        },

        getColorableComponent: function() {
          return 'TextGObject_BackgroundContrast';
        },

        verificationString: function verificationString(expected, args) {
          var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          );

          if (this.blank || /^isDefined\(/.test(this.expression)) {
            return 'NO_VERIFICATION';
          } else if (expected.exists && this.state.exists) {
            if (this.isFunction()) {
              var zeroValue = this.uValue(0),
                oneValue = this.uValue(1);

              if (!GSP.math.expect(zeroValue, expected.zeroValue)) {
                msg +=
                  'Function zero value: <span class="error">' +
                  zeroValue +
                  '</span>(<span class="expected">' +
                  expected.zeroValue +
                  '</span>)';
              }
              if (!GSP.math.expect(oneValue, expected.oneValue)) {
                msg +=
                  'Function one value: <span class="error">' +
                  oneValue +
                  '</span>(<span class="expected">' +
                  expected.oneValue +
                  '</span>)';
              }
            }
          }
          return msg;
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class A message rendered in to a sketch canvas.
   * @augments GSP.gObjects.Unknown
   */

  GSP.gObjects.AngleMarker = GSP.makeClass(
    /** @lends GSP.gObjects.AngleMarker */ GSP.gObjects.Arc,
    (function() {
      var EPSILON = 0.001,
        SQRT2 = 0.7071067811865475,
        ARROW_ADJUST = 4; // inset adjustment to account for arrowhead in geomBound

      return {
        doc: {
          description:
            'Marks the span of an angle. In geometry, angle markers are used to assert congruency relationships.',
          inherits: 'Arc',
          refspec: {
            gspKindRef: 'AngleMarkerKind',
          },
          properties: {
            style: {
              properties: {
                'inner-radius': {
                  description:
                    'The arc radius contained within the angle marker, in pixels',
                  type: 'Number',
                },
                opacity: {
                  description: '0 (transparent) to 1 (fully opaque)',
                  type: 'Number',
                },
                'radial-spacing': {
                  description:
                    'The separation between arc strokes in an angle marker, in pixels',
                  type: 'Number',
                },
                'show-angle-direction': {
                  description: 'Whether to show a direction arrow.',
                  type: 'Boolean',
                },
                strokes: {
                  description: 'The number of strokes to draw for the marker.',
                  type: 'Number',
                },
              },
            },
          },
        },
        kind: 'AngleMarker',
        hasLabel: true,
        geom: {},
        invertArrowhead: false, // computed value whether to show arrowhead on foot
        style: {
          'show-angle-direction': false,
          'inner-radius': 24,
          opacity: 0.25,
          'radial-spacing': 3,
          strokes: 1,
        },

        // An angle marker's labelOrigin is at the center of its visible
        // label rect. To get its labelTopLeft, add labelOffset to
        // labelOrigin (this is true for all labels).
        initLabelOffset: function(size) {
          var labelStyle = this.style.label;
          labelStyle.labelOffsetX = -size.width / 2;
          labelStyle.labelOffsetY = -size.height / 2;
        },

        // Returns the special "label path" used in positioning labels.
        mapPositionToLabelPathParam: function(pos) {
          var path = this.getLabelPath();
          var ret = GSP.GeometricPoint.mapPointToLine(path.oA, path.oB, pos, {
            clampP0: true,
            clampP1: true,
          });
          return ret.param;
        },

        /* labels.c:GetAngleMarkerLabelPath_UTIL: For purposes of label
     placement, an AngleMarker is a segment on the angle bisecor,
     of radius about innerRadius, extending in both directions from
     the vertexPoint. */
        getLabelPath: function() {
          var arc = this.geom.arc,
            a = arc.initialAngle + 0.5 * Math.abs(arc.arcAngle),
            cosA = Math.cos(a),
            sinA = Math.sin(a),
            vertexPoint = this.getParent('p1').geom.loc,
            r,
            oA,
            oB;
          /* No real theoretical justification for this interval,
         we just want a bit more room "in the angle" than opposite
         it. */
          r = arc.radius * 1.3;
          oA = GSP.GeometricPoint(
            vertexPoint.x - r * cosA,
            vertexPoint.y - r * sinA
          );

          r = this.outerRadius() * 1.8;
          oB = GSP.GeometricPoint(
            vertexPoint.x + r * cosA,
            vertexPoint.y + r * sinA
          );
          return { oA: oA, oB: oB };
        },

        constrainLabel: function() {
          var pathParam = 0.9,
            pathSegment,
            pathPoint;

          if (!this.state.exists || !this.geom.arc) return;

          // Check if the label has been dragged.
          if (this.userSetLabelPathParam !== undefined)
            pathParam = this.userSetLabelPathParam;

          pathSegment = this.getLabelPath();
          pathPoint = GSP.GeometricPoint(
            pathSegment.oA.x +
              pathParam * (pathSegment.oB.x - pathSegment.oA.x),
            pathSegment.oA.y + pathParam * (pathSegment.oB.y - pathSegment.oA.y)
          );
          pathPoint.x = Math.round(pathPoint.x);
          pathPoint.y = Math.round(pathPoint.y);
          this.labelSpec.location = pathPoint;
        },

        getAngleMarkerMFS: function(option, shouldShowSymbol) {
          var gobjA = this.getParent('p0'),
            gobjB = this.getParent('p1'),
            gobjC = this.getParent('p2'),
            horizontals;
          if (!gobjA.label) {
            gobjA.getLabel(option);
          }
          if (!gobjB.label) {
            gobjB.getLabel(option);
          }
          if (!gobjC.label) {
            gobjC.getLabel(option);
          }
          horizontals = [
            gobjA.getNameMFS(),
            gobjB.getNameMFS(),
            gobjC.getNameMFS(),
          ];
          return GSP.mfs.makeHorizontalNamesMFS(
            horizontals,
            shouldShowSymbol ? { type: 'symbol', value: 'd0' } : null
          );
        },

        // No angle symbol
        getNameMFSForLabel: function(option) {
          return this.getAngleMarkerMFS(option, false);
        },

        getColorableComponent: function() {
          return 'AngleMarker';
        },
        renderPrepare: function(drawContext, renderArgs) {
          renderArgs = {
            kind: this.kind,
            id: this.id,
            strokes: this.style.strokes,
          };
          return drawContext.prepareAngleMarker(renderArgs);
        },
        renderCleanup: function(drawContext, drawRefCon) {
          return drawContext.cleanupAngleMarker(drawRefCon);
        },
        render: function(drawContext, drawRefCon, renderArgs) {
          var aGobj = this.getParent('p0'),
            bGobj = this.getParent('p1'),
            cGobj = this.getParent('p2'),
            a = aGobj.geom.loc,
            b = bGobj.geom.loc,
            c = cGobj.geom.loc,
            orientation = GSP.Geom.ThreePointCollinear(a, b, c).orientation,
            firstArc = this.geom.arc,
            swap,
            renderAttrs;

          //The angle marker may exist but have an angle of 0 size, which
          //has an undefined arc and needs no rendering
          if (firstArc) {
            swap =
              firstArc.arcAngle <= Math.PI ? orientation < 0 : orientation >= 0;
            renderAttrs = {
              color: this.style.color,
              firstArc: firstArc,
              isRight: Math.abs(firstArc.arcAngle - Math.PI / 2) < EPSILON,
              opacity: this.style.opacity,
              fadeOpacity: this.calculateFadeOpacity(),
              radialSpacing: this.style['radial-spacing'],
              renderable: this.isRenderable(),
              'show-angle-direction': this.style['show-angle-direction'],
              invertArrowhead: this.invertArrowhead,
              strokes: this.style.strokes,
              width: this.style.width,
              swap: swap,
            };

            this.modifyRenderAttrsForCurrentState(renderAttrs);

            drawContext.drawAngleMarker(drawRefCon, renderAttrs);

            this.updateKindHTMLStyle();
          }
        },
        outerRadius: function() {
          var arc = this.geom.arc,
            radialSpacing = this.style['radial-spacing'],
            strokes = this.style.strokes,
            width = this.style.width,
            isRight = Math.abs(arc.arcAngle - Math.PI / 2) < EPSILON,
            radialMultiplier = isRight ? SQRT2 : 1;
          return (
            arc.radius * radialMultiplier +
            (strokes - 1) * (radialSpacing + width)
          );
        },
        getGeomBounds: function getGeomBounds() {
          if (!this.state.exists || !this.geom.arc) {
            return;
          }
          var arc = this.geom.arc,
            ext = this.style.width,
            isRight = Math.abs(arc.arcAngle - Math.PI / 2) < EPSILON,
            radius = this.outerRadius(),
            newP0,
            newP1,
            newArc,
            pts = [],
            bounds;
          if (this.style['show-angle-direction']) {
            ext += ARROW_ADJUST;
          }

          if (isRight) {
            pts.push(arc.center);
            newP0 = arc.initialPoint
              .subtract(arc.center)
              .unit()
              .multiply(radius);
            pts.push(arc.center.add(newP0));
            pts.push(arc.center.add(new GSP.GeometricPoint(-newP0.y, newP0.x)));
            pts.push(pts[2].add(newP0));
            bounds = {};
            $.each(pts, function(k, v) {
              if (bounds.left === undefined || bounds.left > v.x) {
                bounds.left = v.x;
              }
              if (bounds.top === undefined || bounds.top > v.y) {
                bounds.top = v.y;
              }
              if (bounds.right === undefined || bounds.right < v.x) {
                bounds.right = v.x;
              }
              if (bounds.bottom === undefined || bounds.bottom < v.y) {
                bounds.bottom = v.y;
              }
            });
            bounds = GSP.Geom.insetRect(bounds, -ext);
          } else {
            newP0 = arc.initialPoint
              .subtract(arc.center)
              .unit()
              .multiply(radius)
              .add(arc.center);
            newP1 = arc.finalPoint
              .subtract(arc.center)
              .unit()
              .multiply(radius)
              .add(arc.center);
            newArc = GSP.GeometricArc.FromCenterAndEndpoints(
              arc.center,
              newP0,
              newP1
            );
            bounds = this.getArcBounds(newArc, ext);
            bounds = GSP.Geom.unionRectPoint(bounds, this.geom.arc.center);
          }

          return bounds;
        },
        hitTest: function(rect, hotSpot) {
          var that = this,
            radius,
            initialPoint,
            finalPoint,
            isRight,
            radialMultiplier,
            p0Vector,
            p1Vector;

          function angleMarkerArcHitTest() {
            //construct an arcSector that is the size of the biggest arc stroke.
            var arcToTest = GSP.GeometricArc.FromCenterAndEndpoints(
              that.geom.arc.center,
              initialPoint,
              finalPoint,
              1
            );

            return GSP.Geom.RectIntersectsCurve(rect, {
              type: 'arcSector',
              curve: arcToTest,
            });
          }

          function rightAngleMarkerHitTest() {
            return GSP.Geom.ParallelogramSectsRect(
              rect,
              initialPoint,
              that.geom.arc.center,
              finalPoint
            );
          }

          if (!this.geom.arc) {
            return false;
          }

          //logic here parallels that of AngleMarker drawing code in canvasEngine.js
          isRight = Math.abs(this.geom.arc.arcAngle - Math.PI / 2) < EPSILON;
          //right angle scales down the radius for the initial and final points
          radialMultiplier = isRight ? SQRT2 : 1;
          //radius is the radius of the outer-most stroke
          radius =
            this.geom.arc.radius * radialMultiplier +
            (this.style['radial-spacing'] + this.style.width) *
              (this.style.strokes - 1);
          p0Vector = GSP.GeometricPoint(
            Math.cos(this.geom.arc.initialAngle),
            Math.sin(this.geom.arc.initialAngle)
          ).multiply(radius);
          p1Vector = GSP.GeometricPoint(
            Math.cos(this.geom.arc.finalAngle),
            Math.sin(this.geom.arc.finalAngle)
          ).multiply(radius);
          initialPoint = p0Vector.add(this.geom.arc.center);
          finalPoint = p1Vector.add(this.geom.arc.center);

          if (isRight) {
            //test for right angle
            return rightAngleMarkerHitTest();
          } else {
            //test for non-right angle
            return angleMarkerArcHitTest();
          }
        },

        /**
         * Verifies the initial state of this object by comparing its
         * initial values against values calculated by the sketchpad exporter.
         */
        verificationString: function verificationString(expected, args) {
          var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          );

          if (expected.exists && this.state.exists) {
            if (!GSP.math.expect(this.value, expected.value)) {
              msg +=
                'value: <span class="error">' +
                this.value +
                '</span>(<span class="expected">' +
                expected.value +
                '</span>)';
            }
          }
          return msg;
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
  
   */

  /**
   *  @class PathMarker
   *  @augments GSP.gObjects.Kind
   */

  GSP.gObjects.PathMarker = GSP.makeClass(
    /** @lends GSP.gObjects.PathMarker */ [GSP.gObjects.Kind, GSP.Genus],
    {
      doc: {
        description: 'A location in the Euclidean plane.',
        inherits: 'Kind',
        refspec: {
          gspKindRef: 'PathMarkerKind',
        },
        usage: {},
        properties: {
          style: {
            description: '',
            properties: {
              color: {
                description: 'Foreground color of the path marker.',
                type: 'Color',
              },
              'tick-mark-style': {
                description: 'type of tick marks',
                type: 'TickMarkStyle',
              },
              'arrow-direction': {
                description: 'The direction of the arrows of the path marker.',
                type: 'ArrowDirection',
              },
              width: {
                description: 'Width of the strokes in pixels',
                type: 'Number',
              },
              strokes: {
                description: 'The number of strokes to draw for the marker.',
                type: 'Number',
              },
            },
          },
        },
      },
      kind: 'PathMarker',
      style: {
        hidden: false,
        label: {
          showLabel: false,
        },
        selectable: true,
        traced: false,
        width: 3,
        'tick-mark-style': 'Crossbar',
        strokes: 1,
        'arrow-direction': 'Forward',
      },

      state: {},
      renderPrepare: function(drawContext, renderArgs) {
        renderArgs.kind = this.kind;
        renderArgs.id = this.id;

        return drawContext.preparePathMarker(renderArgs);
      },
      renderCleanup: function(drawContext, drawRefCon) {
        return drawContext.cleanupPathMarker(drawRefCon);
      },

      render: function(drawContext, drawRefCon, renderArgs) {
        var renderable,
          color,
          attrs,
          opacity = this.calculateOpacity(),
          style = this.style;

        if (
          this.state.renderState === 'invisible' ||
          this.state.exists === false
        ) {
          return;
        }

        color = style.color;
        renderable = this.isRenderable();

        attrs = {
          renderable: renderable,
          metrics: this.state.renderMetrics,
          color: color,
          width: style.width,
          opacity: opacity,
          strokes: style.strokes,
          'tick-mark-style': style['tick-mark-style'],
        };

        this.modifyRenderAttrsForCurrentState(attrs);

        drawContext.drawPathMarker(drawRefCon, attrs);

        this.updateKindHTMLStyle();
      },

      calculateRenderMetrics: function() {
        var m = {},
          normal = this.geom.normal,
          tickStyle = this.style['tick-mark-style'],
          numTicks = this.style.strokes,
          originDelta,
          boundingRectOrigin,
          p0,
          p1,
          p2,
          p3,
          isArrow = tickStyle !== 'Crossbar',
          tickLen = 6.0 + 1.5 * this.style.width,
          tickSpacing = tickLen,
          ticksForCentering = numTicks - 1,
          pathParent = this.parents.path,
          thisLoc = this.geom.loc,
          direction = this.style['arrow-direction'],
          markerLen;

        function adjustEndMarkers() {
          // Markers should not extend beyond a path endpoint
          var hiPos,
            loPos,
            hiVal,
            loVal,
            locVal,
            delta = originDelta;
          // Handle both directions for arrow markers
          if (isArrow && direction === 'Backward') {
            delta = originDelta.multiply(-1);
          }
          hiPos = pathParent.mapPathValueToPosition(1).add(delta);
          loPos = pathParent.mapPathValueToPosition(0).subtract(delta);
          if (pathParent.isOfKind('Straight')) {
            hiVal = pathParent.mapPositionToExtendedPathValue(hiPos);
            loVal = pathParent.mapPositionToExtendedPathValue(loPos);
            locVal = pathParent.mapPositionToExtendedPathValue(thisLoc);
          } else {
            hiVal = pathParent.mapPositionToPathValue(hiPos);
            loVal = pathParent.mapPositionToPathValue(loPos);
            locVal = pathParent.mapPositionToPathValue(thisLoc);
          }
          if (locVal < loVal) {
            locVal = loVal;
          }
          if (locVal > hiVal && !pathParent.isOfGenus('Ray')) {
            // The through point of a ray isn't an endpoint
            locVal = hiVal;
          }
          if (hiVal < loVal) {
            locVal = (hiVal + loVal) / 2;
          }
          m.origin = pathParent
            .mapPathValueToPosition(locVal)
            .subtract(originDelta);
        }

        switch (tickStyle) {
          case 'Crossbar':
            tickSpacing *= 0.5;
            tickLen *= 0.75;
            break;
          case 'OpenArrow':
            tickSpacing *= 0.75;
            ticksForCentering++;
            break;
          case 'HollowArrow':
          case 'SolidArrow':
            tickSpacing *= 1;
            ticksForCentering++;
            break;
        }

        markerLen = numTicks * tickSpacing;

        m.delta = GSP.GeometricPoint(
          -tickSpacing * normal.y,
          tickSpacing * normal.x
        );

        m.normal = normal.multiply(tickLen);

        m.len = GSP.GeometricPoint(-markerLen * normal.y, markerLen * normal.x);
        m.diagonal = m.normal.add(m.len);

        originDelta = m.delta.multiply(ticksForCentering * 0.5);
        // Check paths with endpoints so markers don't extend beyond the endpoints
        if (
          pathParent.isOfGenus('Segment') ||
          pathParent.isOfGenus('Ray') ||
          pathParent.isOfGenus('SimpleArc')
        ) {
          adjustEndMarkers();
        } else {
          // for all other cases, put the marker at the specified location
          m.origin = thisLoc.subtract(originDelta);
        }

        boundingRectOrigin = m.origin;
        if (!isArrow) {
          boundingRectOrigin = boundingRectOrigin.subtract(
            m.delta.multiply(1.5)
          );
        }
        p0 = boundingRectOrigin.add(m.normal);
        p1 = boundingRectOrigin.subtract(m.normal);

        boundingRectOrigin = m.origin.add(m.len);
        boundingRectOrigin = boundingRectOrigin.add(m.delta.multiply(0.5));
        p2 = boundingRectOrigin.add(m.normal);
        p3 = boundingRectOrigin.subtract(m.normal);

        m.boundingQuad = { A: p0, B: p1, C: p3, D: p2 }; // Aka paralleogram BA, BC
        m.boundingRect = GSP.Geom.boundingRect(p0, p1, p2, p3);

        return m;
      },
      getGeomBounds: function() {
        var bounds,
          exp = this.style.width / 2;

        if (this.state.exists) {
          bounds = GSP.Geom.insetRect(
            this.state.renderMetrics.boundingRect,
            -exp
          );
        }
        return bounds;
      },

      hitTest: function(rect, hotSpot) {
        var bq = this.state.renderMetrics.boundingQuad;

        return GSP.Geom.ParallelogramSectsRect(rect, bq.A, bq.B, bq.C);
      },
      verificationString: function verificationString(expected, args) {
        var msg = (verificationString.base || arguments.callee.base).call(
            this,
            expected,
            args
          ),
          p0;

        if (msg === '' && this.state.exists) {
          p0 = GSP.GeometricPoint(expected.loc.x, expected.loc.y);
          if (!GSP.GeometricPoint.expect(p0, this.geom.loc)) {
            msg +=
              'loc: <span class="error">' +
              this.geom.loc +
              '</span>(<span class="expected">' +
              p0 +
              '</span>)';
          }
        }
        return msg;
      },
    }
  );

  /**
   * @fileOverview The base Geometric Object Constraint Definition.
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class GSP.gConstraints.Constraint
   */
  GSP.gConstraints.Constraint = {
    doc: {
      description: 'The parent class for all constraints.',
      refspec: {},
      usage: {
        abstract: true,
      },
      supported: true,
      properties: {},
    },
    /**
     * Used in determining support for a given spec obj in cases where the constraint is supported in general, but certain
     * spec objects within that constraint may not be supported.  Should be overridden in that case to return an appropriate value
     * given the specObj
     *
     * @param specObj
     * @param specObjects - the rest of the objects in the spec - may be required to inspect parents
     */
    constraintSupportsSpecObj: function(/*specObj, specObjects*/) {
      return true;
    },

    /**
     * Can be overridden by constraints that need to perform some initialization
     */
    initConstraint: function() {},

    /**
     * Can be overridden by constraints that need update any cached values
     * based on their parental ancestry.
     *
     * WARNING: Since this is called by init, implementors cannot depend on the
     * sketch having a renderRefCon. Therefore you cannot invalidate
     * geom or appearance.
     */
    updateConstraintAncestry: function() {},
    /**
     * Does this constraint support autoplacement
     * Default algorithm says if there's an autoplacementType
     * then we do. autoplacementType is a necessary but
     * not sufficient condition (e.g. pegged text is not autoplaceable)
     */
    supportsAutoplacement: function() {
      return undefined !== this.autoplacementType;
    },
    /**
     * Gobject initialization for the appearance - mfs name, precision, etc.
     */
    updateLabelForConstraint: function updateLabelForConstraint() {},
    /**
     * Adjusts the geometry or value of this object to fulfill this object's
     * role and relationships in the sketch.
     */
    constrain: function() {
      this.state.exists = false;
      throw GSP.createError('Unimplemented method');
    },
    getParentalNameMFS: function(option) {
      //Silencing error until reform of label renderPrepare is completed
      //GSP.signalErrorWithMessage("Constraint.getParentalNameMFS() shouldn't be called.");
      return GSP.mfs.makeTextMFS('');
    },
    constraintVerificationString: function constraintVerificationString(
      iExpected
    ) {
      return '';
    },
  };

  /**
   * @fileOverview Placeholder for an unrecognized constraint.
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * @class GSP.gConstraints.Unknown
   * Placeholder for an unrecognized constraint.
   */
  GSP.gConstraints.Unknown = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.Unknown */ {
      doc: {
        description: 'Placeholder for an unrecognized constraint.',
        inherits: 'Constraint',
        refspec: {
          msg: 'An artifact of convenience of the application design.',
        },
        usage: {
          abstract: true,
        },
        properties: {},
      },
      constraint: 'Unknown',
      constrain: function() {
        this.state.exists = false;
        this.state.supported = false;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * For unconstrained gobjects.
   */
  GSP.gConstraints.Free = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'An object with a free constraint can be dragged anywhere in the sketch space and is not bound by any dependencies that affect its geometry.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'Free_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Free_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Point', 'Expression', 'Text'],
      },
      existenceRule: 'Exists iff the coordinates of its location exist.',
      properties: {
        geom: {
          description: 'The basic geometry of the GObject',
          properties: {
            loc: {
              description: 'The position of the GObject',
              properties: {
                x: {
                  description:
                    'The horizontal screen coordinate relative to the canvas upper left, in pixel units.',
                  type: 'Number',
                },
                y: {
                  description:
                    'The vertical screen coordinate relative to the canvas upper left, in pixel units.',
                  type: 'Number',
                },
              },
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Free_export.json',
    },
    constrain: function() {
      this.state.exists = this.geom.loc && this.geom.loc.isDefined();
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * For unconstrained gobjects.
   */
  GSP.gConstraints.PictureFree = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'A free picture can be dragged anywhere in the sketch space and is not bound by any dependencies that affect its geometry.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'Free_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Free_C, when applied to Pictures in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Picture'],
      },
      existenceRule: 'Exists iff its image exists.',
      properties: {
        geom: {
          description: 'The basic geometry of the GObject',
          properties: {
            transform: {
              description:
                'Affine transform of picture from its original (0,0)x(width,height) position.',
              type: 'AffineTransform',
              properties: {
                m00: {
                  description: 'm00',
                  type: 'Number',
                },
                m01: {
                  description: 'm01',
                  type: 'Number',
                },
                m10: {
                  description: 'm10',
                  type: 'Number',
                },
                m11: {
                  description: 'm11',
                  type: 'Number',
                },
                m20: {
                  description: 'm20',
                  type: 'Number',
                },
                m21: {
                  description: 'm21',
                  type: 'Number',
                },
              },
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Picture-Misc_export.json',
    },
    constrain: function() {
      this.state.exists = true;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for non free picture constraints.
   */
  GSP.gConstraints.PictureNonFree = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.PictureNonFree */ {
      doc: {
        description: 'Abstract base class for picture constraints.',
        inherits: 'Constraint',
        refspec: {
          msg:
            "This class is an internal object and doesn't have an independent source of requirements.",
        },
        usage: {
          abstract: true,
          kinds: ['Picture'],
        },
      },
    }
  );

  /*
   * @version 0.0
   * DriveChain is a virtual base class for constrains that have a drive chain
   * as numbered parents 0 ... n.
   * These are loci, and custom transforms.
   *
   * It expects the following parents:
   * -drivenObject
   * -driverObject
   * -(optionally) domainObject
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.DriveChain = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'A virtual base class for constraints that have drive-chains',
      inherits: 'Constraint',
      refspec: {},
      usage: {
        abstract: true,
      },
      properties: {
        parents: {
          description: '',
          type: 'Object',
          properties: {
            driverObject: {
              description: 'The object which originates the drive-chain',
              kind: 'Point|Expression',
            },
            drivenObject: {
              description:
                'The object being driven whose location use used in the constraint',
              kind:
                'Point|Expression|Text|Arc|Circle|Picture|Polygon|Straight|ArcInterior|CircleInterior',
            },
          },
          regex: /^[0-9]+$/,
        },
      },
    },
    clonedDriverGObj: undefined,
    clonedSampleGObj: undefined,
    sampleGObj: function() {
      return this.parents.drivenObject;
    },
    //creates and returns the cloned drive chain for this sampler
    updateConstraintAncestry: function updateConstraintAncestry() {
      var sketch = this.sQuery.sketch,
        toClone = [],
        cloned,
        i = 0,
        driverGObj = this.getParent('driverObject'),
        sampleGObjId = this.getParent('drivenObject').id,
        sampleGObj;

      toClone.push(this.getParent('driverObject'));

      while (this.parents.hasOwnProperty(i)) {
        toClone.push(this.getParent(i));
        i++;
      }

      toClone.sort(function(a, b) {
        return Number(a.topologicalIndex) - Number(b.topologicalIndex);
      });

      cloned = sketch.cloneGObjects(toClone);

      //Find cloned driver:
      for (i = 0; i < cloned.length; i++) {
        if (cloned[i].id === driverGObj.id) {
          this.clonedDriverGObj = cloned[i];
          cloned.splice(i, 1); //remove the cloned driver from the cloned array
          break;
        }
      }

      //find cloned sample gobj
      for (i = 0; i < cloned.length; i++) {
        if (cloned[i].id === sampleGObjId) {
          sampleGObj = cloned[i];
          this.driveChain = cloned;
          this.clonedSampleGObj = sampleGObj;
          break;
        }
      }

      //Start the driver off as existing:
      this.clonedDriverGObj.state.exists = true;
    },
  });

  /*
   * @version 0.0
   * Locus is a virtual base clase that implements the methods for GeomLocus and
   * ParametricLocus classes. It expects the following parents:
   * -drivenObject
   * -driverObject
   * -(optionally) domainObject - the path for geomLocus
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.Locus = GSP.makeClass(GSP.gConstraints.DriveChain, {
    doc: {
      description: 'A virtual base class for locus subclasses',
      inherits: 'DriveChain',
      refspec: {},
      usage: {
        abstract: true,
      },
      existenceRule: 'Exists if any samples exist',
    },
    constraintSupportsSpecObj: function(specObj, specObjects) {
      var supportedDrivenObjs = this.doc.properties.parents.properties
        .drivenObject.kind;
      var drivenKind = specObjects[specObj.parents.drivenObject].kind;
      if (supportedDrivenObjs.match(drivenKind) === null) {
        return false;
      }

      return true;
    },
    //creates and returns the cloned drive chain for this sampler
    updateConstraintAncestry: function updateConstraintAncestry() {
      (updateConstraintAncestry.base || arguments.callee.base).call(this);

      this.vectorContext = this.clonedSampleGObj.createVectorContext(
        this.numSamples,
        this,
        this.clonedSampleGObj.constraintChangesColor
      );
      this.lastSampleCount = this.numSamples;
    },

    /**
     * The following 3 methods should be overridden by locus subclasses, and are
     * relied on by the base class' constraint implementation as well as its
     * samplerPathValueToPosition() implementation.  Clients who wish to subclass
     * both of these methods could refrain from implementing these 3 methods.
     */
    /**
     *  Prepare a refCon to be used in advanceDriver.  This typically would involve
     *  constructing an array of values or positions that can be used for advancing
     *  the driver.  Any tasks that can be front loaded prior to sampling should be
     *  done here.
     *
     *  @return {object} the driverWalkInfo
     */
    prepareDriverWalkInfo: function() {
      GSP.signalErrorWithMessage(
        'Locus subclasses must implement prepareDriverWalkInfo'
      );
    },
    /**
     * Given a driver, a driverWalkInfo which was returned from prepareDriverWalkInfo()
     * and a sample index, advance the driver to the appropriate value or position.
     *
     * @param {object} driver
     * @param {object} driverWalkInfo - client defined driver walk information
     * @param {number} index - the sample index
     */
    advanceDriver: function(driver, driverWalkInfo, index) {
      GSP.signalErrorWithMessage(
        'Locus subclasses must implement advanceDriver'
      );
    },
    /**
     * Given a driver, and a desired value within the domain of the locus, move
     * the driver as appropriate for that value.
     *
     * @param {object} driver
     * @param {number} value - a value in the range of the locus' domain
     */

    moveDriverForValue: function(driver, value) {
      GSP.signalErrorWithMessage(
        'Locus subclasses must implement moveDriverForValue'
      );
    },
    constrain: function(sketch) {
      var driveChain = this.driveChain,
        sampleGObj = this.clonedSampleGObj,
        driver = this.clonedDriverGObj,
        numSamples = this.numSamples,
        didSampleCountChange = this.lastSampleCount !== numSamples,
        i,
        filledSample,
        driverWalkInfo;

      if (didSampleCountChange) {
        this.vectorContext = sampleGObj.createVectorContext(
          numSamples,
          this,
          sampleGObj.constraintChangesColor
        );
        this.lastSampleCount = numSamples;
      }

      //Note: Function plot is able to skip resampling depending on which parent
      //was actually dirty.  Locus cannot easily do that here in constraint.  In
      //Desktop, we can skip geometric locus constraint if the driver, and ONLY the
      //driver, is in motion.  Desktop doesn't do the same for an animating driver
      //parameter in parametricLocus constrain.  It makes this decision while building
      //the affect list rather than during constraint.  At this point, all will
      //be marked as needing constrain, and we can't easily know whether we can
      //skip constraint.  This efficiency should be made as a special case while
      //building the affect list.

      if (this.prepareDriverWalkInfo) {
        driverWalkInfo = this.prepareDriverWalkInfo();
      }

      this.state.exists = false;

      sampleGObj.resetVectorSamples(this.vectorContext);
      filledSample = 0;
      for (i = 0; i < numSamples; i++) {
        this.advanceDriver(driver, driverWalkInfo, i);
        sketch.constrainDriveChain(driveChain);
        if (sampleGObj.state.exists || this.vectorContext.isContinuous) {
          sampleGObj.fillSingleSample(this.vectorContext, filledSample);
          filledSample++;
        }
        this.state.exists = this.state.exists || sampleGObj.state.exists;
      }

      if (sampleGObj.recomputeDiscontinuities) {
        sampleGObj.recomputeDiscontinuities(this.vectorContext);
      }
    },

    constrainSampleGObjToConvertedValue: function(value) {
      var driveChain = this.driveChain,
        sampleGObj = this.clonedSampleGObj,
        driver = this.clonedDriverGObj;

      this.moveDriverForValue(driver, value);
      this.sQuery.sketch.constrainDriveChain(driveChain);

      return sampleGObj.state.exists
        ? sampleGObj.geom.loc
        : GSP.GeometricPoint.UNDEFINED;
    },
    /*----- Sampler Path utilities ----- */
    /* Sampler constraints that can be treated as a path are required to implement
     * the following methods.  Currently this is only point loci.
     * These implementations either assume the sampleGObj is a point, or use
     * vector APIs that only path vectors implement.
     */
    samplerPathValueToPosition: function(iValue, output) {
      var low = this.driverDomain.low,
        high = this.driverDomain.high,
        span = high - low,
        convertedValue = low + span * iValue,
        pos,
        self = this;

      pos = this.constrainSampleGObjToConvertedValue(convertedValue);
      if (output && pos.isDefined()) {
        output.derivative = GSP.math.secantApproximationToDerivative(
          convertedValue,
          pos,
          function(x) {
            return x <= high && x >= low
              ? self.constrainSampleGObjToConvertedValue(x)
              : GSP.GeometricPoint.UNDEFINED;
          }
        );
      }

      return pos;
    },
    samplerPositionToPathValue: function(iPosition) {
      return this.clonedSampleGObj.positionToPathValueForVector(
        this.vectorContext,
        iPosition
      );
    },
    samplerPathLength: function() {
      return this.clonedSampleGObj.pathLengthForVector(this.vectorContext);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.GeomLocus = GSP.makeClass(GSP.gConstraints.Locus, {
    doc: {
      description:
        'A Geometric Locus of an object as a parent driver moves along a path.',
      inherits: 'Locus',
      refspec: {
        gspRef: 'GeomLocus_C',
      },
      usage: {
        abstract: false,
        kinds: ['Sampler'],
      },
      supported: true,
      properties: {
        parents: {
          properties: {
            domainObject: {
              description: 'The drive path the driver travels along',
              genus: 'Path',
            },
          },
        },
      },
    },
    updateConstraintAncestry: function updateConstraintAncestry() {
      var domainObject = this.getParent('domainObject');

      this.closedPath = domainObject.closedPath;
      (updateConstraintAncestry.base || arguments.callee.base).call(this);
    },
    /**
     * Override checkParentsExist: it's ok for the drivenObject or driverObject not to exist
     */
    checkParentsExist: function() {
      this.state.exists = this.namedParentExists('domainObject');
      return this.state.exists;
    },
    prepareDriverWalkInfo: function() {
      var numSamples = this.numSamples,
        pathValues = GSP.createFloatVector(numSamples),
        drivePath = this.getParent('domainObject'),
        positions,
        driverDomain = this.driverDomain,
        i,
        low = driverDomain.low,
        step;

      if (drivePath.closedPath) {
        step = (driverDomain.high - low) / numSamples;
      } else {
        step = (driverDomain.high - low) / (numSamples - 1);
      }

      for (i = 0; i < numSamples; i++) {
        pathValues[i] = low + i * step;
      }
      if (!drivePath.closedPath) {
        // here we know the last sample exactly
        pathValues[numSamples - 1] = driverDomain.high;
      }

      positions = drivePath.mapVectorPathValuesToPositions(pathValues);

      return positions;
    },
    advanceDriver: function(driver, driverWalkInfo, index) {
      driver.geom.loc = driverWalkInfo[index];
      driver.state.exists = true;
    },
    moveDriverForValue: function(driver, value) {
      var drivePath = this.getParent('domainObject');

      if (drivePath.closedPath) {
        value = value % 1;
      }

      driver.geom.loc = drivePath.mapPathValueToPosition(value);
      driver.state.exists = true;
    },
    canEditLabel: function() {
      return false;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.CustomTransformedPoint = GSP.makeClass(
    GSP.gConstraints.DriveChain,
    {
      doc: {
        description: 'The image of a point by a custom trasform.',
        inherits: 'DriveChain',
        refspec: {
          gspRef: 'CustomTransformedPoint_C',
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        properties: {
          parents: {
            properties: {
              domainObject: {
                description: 'The point pre-image',
                genus: 'Point',
              },
            },
          },
        },
      },
      constrain: function(sketch) {
        var driveChain = this.driveChain,
          sampleGObj = this.clonedSampleGObj,
          driver = this.clonedDriverGObj,
          domainObject = this.getParent('domainObject');

        // Move the driver to the parent that's the point to be transformed.
        driver.geom.loc = domainObject.geom.loc.copy();
        // Update the drive chain
        sketch.constrainDriveChain(driveChain);

        // reap the sampleGObj for our location
        this.geom.loc = sampleGObj.geom.loc.copy();
        this.state.exists = sampleGObj.state.exists;
      },
    }
  );

  /*
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.CustomTransformedPath = GSP.makeClass(
    GSP.gConstraints.GeomLocus,
    {
      doc: {
        description:
          'A Geometric Locus of an object as a parent driver of the custom trasform moves along a path.',
        inherits: 'GeomLocus',
        refspec: {
          gspRef: 'CustomTransformedPath_C',
        },
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.ParametricLocus = GSP.makeClass(GSP.gConstraints.Locus, {
    doc: {
      description:
        'A Parametric Locus of an object as a driver parameter moves through a range of values.',
      inherits: 'Locus',
      refspec: {
        gspRef: 'ParametricLocus_C',
      },
      usage: {
        abstract: false,
        kinds: ['Sampler'],
      },
      supported: true,
      properties: {
        parents: {
          properties: {
            drivenObject: {
              description:
                'The object whose position changes as the driver moves along the path',
            },
            driverObject: {
              description: 'The point to drive along the path',
              kind: 'Expression',
            },
          },
        },
      },
    },
    /**
     * Override checkParentsExist: it's ok for the drivenObject not to exist
     */
    checkParentsExist: function() {
      this.state.exists = this.namedParentExists('driverObject'); // Locus cannot exist without a driver.
      return this.state.exists;
    },

    prepareDriverWalkInfo: function() {
      var numSamples = this.numSamples,
        values = GSP.createFloatVector(numSamples),
        driverDomain = this.driverDomain,
        i,
        low = driverDomain.low,
        step = (driverDomain.high - low) / (numSamples - 1);

      for (i = 0; i < numSamples; i++) {
        values[i] = low + i * step;
      }

      return values;
    },
    advanceDriver: function(driver, driverWalkInfo, index) {
      driver.updateValue(driverWalkInfo[index]);
    },
    moveDriverForValue: function(driver, value) {
      driver.updateValue(value);
    },
    samplerPathValueToPosition: function samplerPathValueToPosition(
      iPathValue,
      output
    ) {
      var span = this.driverDomain.high - this.driverDomain.low,
        normalizedVal = span ? (iPathValue - this.driverDomain.low) / span : 0;

      return (samplerPathValueToPosition.base || arguments.callee.base).call(
        this,
        normalizedVal,
        output
      );
    },
    samplerPositionToPathValue: function samplerPositionToPathValue(iPosition) {
      var value = (
          samplerPositionToPathValue.base || arguments.callee.base
        ).call(this, iPosition),
        span = this.driverDomain.high - this.driverDomain.low;

      return this.driverDomain.low + value * span;
    },

    samplerConstrainRange: function(v) {
      var result = v,
        low = this.driverDomain.low,
        high = this.driverDomain.high;

      if (v > high) {
        result = high;
      }

      if (v < low) {
        result = low;
      }

      return result;
    },
    samplerIsValueInBounds: function(v) {
      return v >= this.driverDomain.low && v <= this.driverDomain.high;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  GSP.gConstraints.IterateMap = GSP.makeClass(
    GSP.gConstraints.Constraint,
    (function() {
      //private utilities

      //These constant regex's describe the preimage and postimage parents as
      //exported from the exporter.
      var PREIMAGE_REGEX = /^preimage\d+$/,
        POSTIMAGE_REGEX = /^map\d+image\d+$/,
        DRIVECHAIN_REGEX = /^\d+$/;

      /**
       * Given an array of objects, each with an id property, return the actual
       * object specified by the passed in id.
       *
       * @param {array} array
       * @param {string} id
       * @returns {unresolved}
       */

      function getObjectById(array, id) {
        var ret;

        $.each(array, function(key, obj) {
          if (obj.id === id) {
            ret = obj;
            return false;
          }
        });

        return ret;
      }

      /**
       * Given an array of objects, containingArray, and an array of ids, idArray,
       * return an array of actual object references matching that of idArray.
       *
       * @param {array} containingArray
       * @param {array} idArray
       * @returns {array}
       */

      function getObjectArrayById(containingArray, idArray) {
        var ret = [];
        $.each(idArray, function(key, id) {
          ret.push(getObjectById(containingArray, id));
        });

        return ret;
      }

      /**
       * Given a postImage parent key, return an object describing the object's
       * map number and image number.
       *
       * @param {type} key
       * @returns {object }
       */
      function getPostImageInfo(key) {
        return {
          map: /map(\d+)/.exec(key)[1],
          image: /image(\d+)/.exec(key)[1],
        };
      }

      function pushIfNeeded(array, object) {
        if ($.inArray(object, array) === -1) {
          array.push(object);
        }
      }

      return {
        doc: {
          description: 'Iteration Map.',
          inherits: 'Free',
          refspec: {
            gspRef: 'IterateMap_C',
          },
          usage: {
            abstract: false,
            kinds: ['Map'],
          },
          properties: {
            parents: {
              description: '',
              type: 'Object',
              properties: {
                preimage0: {
                  description:
                    "The first preimage.  There can be an arbitrary number of preimages, with the form 'preimageX'",
                  kind: 'kind',
                },
                map0image0: {
                  description:
                    "The first postimage.  There can be an arbitrary number of post-images, with the form 'mapXimageY",
                  kind: 'kind',
                },
                '0': {
                  description:
                    'The first object in the drive chain.  There may be many objects in the drivechain, numbered from 0 to N',
                  kind: 'kind',
                },
              },
              regex: /^preimage[0-9]+$|^map[0-9]+image[0-9]+$|^[0-9]+$/,
            },
            currentDepth: {
              description: 'The depth of the iteration',
              required: true,
              type: 'Number',
            },
          },
        },
        //Vocabulary: Consider the following 2 map example:
        //Map [A->D, B->E, C->F] & [A->G, B->H, C->I]
        //imageArray would be the set of iterated Image children. each privately links
        //to a member of driveChain, though it's not the map's job to know which
        //preImageClones would be clones of [A, B, C]
        //postImageMapArray would be clones [[D, E, F],[G, H, I]]
        //DriveChain would be clones [A, B, C, D, E, F, G, and any other children, hidden or not.
        //For reference the parental order from desktop is as follows:
        //preimages, postImages * numMaps, driveChain from preimages on down (not including preimages, but including postImages
        imageArray: null, //array of iteratedImage children
        preImageClones: null, //array of preimages
        postImageMapArray: null, //array of numMaps items, each item is an array of preImageClones.length postImages
        driveChain: null, //topologically sorted array of all cloned objects - from preimages down to all iterated images
        randomValueCache: null, //cache of random values for rerandomizePointOnPath maps
        onPathPostImages: null, //array of all point on path post-images, if rerandomizing
        rerandomizeNow: true, //set this to true to cause the next constraint to also rerandomize (if approporiate)

        updateConstraintAncestry: function() {
          var sketch = this.sQuery.sketch,
            toClone = [],
            cloned,
            theMap = this;

          function topologicalSortFunction(a, b) {
            return Number(a.topologicalIndex) - Number(b.topologicalIndex);
          }

          this.imageArray = [];
          this.preImageClones = [];
          this.postImageMapArray = [];
          this.driveChain = [];

          if (this.rerandomizePointsOnPaths) {
            this.randomValueCache = [];
            this.onPathPostImages = [];
          }

          $.each(theMap.parents, function(key, object) {
            var imageIndex, info;

            if (PREIMAGE_REGEX.test(key)) {
              imageIndex = key.match(/\d+/)[0];
              theMap.preImageClones[imageIndex] = object.id;
            } else if (POSTIMAGE_REGEX.test(key)) {
              info = getPostImageInfo(key);

              if (!theMap.postImageMapArray[info.map]) {
                theMap.postImageMapArray[info.map] = [];
              }

              theMap.postImageMapArray[info.map][info.image] = object.id;
              pushIfNeeded(theMap.driveChain, object.id);

              if (theMap.rerandomizePointsOnPaths && object.isFreePointOnPath) {
                pushIfNeeded(theMap.onPathPostImages, object.id);
              }
            } else if (DRIVECHAIN_REGEX.test(key)) {
              pushIfNeeded(theMap.driveChain, object.id);
            } else {
              //We don't know about this parent.  Skip it
              return;
            }

            //Push all non-dups into the toClone array
            pushIfNeeded(toClone, object);
          });

          toClone.sort(topologicalSortFunction);
          cloned = sketch.cloneGObjects(toClone);

          //Now we convert each of the arrays from object id to (cloned) object
          theMap.preImageClones = getObjectArrayById(
            cloned,
            theMap.preImageClones
          );
          $.each(theMap.postImageMapArray, function(mapKey, map) {
            theMap.postImageMapArray[mapKey] = getObjectArrayById(
              cloned,
              theMap.postImageMapArray[mapKey]
            );
          });

          if (theMap.rerandomizePointsOnPaths) {
            theMap.onPathPostImages = getObjectArrayById(
              cloned,
              theMap.onPathPostImages
            );
          }

          theMap.driveChain = getObjectArrayById(cloned, theMap.driveChain);
          theMap.driveChain.sort(topologicalSortFunction);

          theMap.numMaps = theMap.postImageMapArray.length;
        },
        //Iterated images are requred to register themselves with their parent
        registerImageAndGetClone: function(iImage) {
          //push iImage to array of images
          //returns a clone that the image will keep track of, and perform vector operations on

          var parent = iImage.getParent('source');

          this.imageArray.push(iImage);
          return getObjectById(this.driveChain, parent.id);
        },
        //Iterated images are requred to deregister themselves with their parent
        deregisterImage: function(iImage) {
          var index = $.inArray(iImage, this.imageArray);

          if (index >= 0) {
            this.imageArray.splice(index, 1);
          }
        },
        /**
         * override checkParentsExist to allow for non-existing drivechain parents
         * @returns {Boolean}
         */
        checkParentsExist: function() {
          var result = true;

          function checkOneParent(parentName, parentGObj) {
            if (parentGObj.state) {
              if (
                !parentGObj.state.exists &&
                !DRIVECHAIN_REGEX.test(parentName)
              ) {
                result = false;
                return false;
              }
            }
          }

          //Use jquery's each rather than eachParent() so we iterate on
          //parent name rather than parent index
          $.each(this.parents, checkOneParent);

          this.state.exists = result;
          return result;
        },
        constrain: function(sketch) {
          var finalIterationOnly = this.finalIterationOnly,
            theMap = this,
            numMaps = this.numMaps,
            rerandomizeCounter = 0;

          if (this.rerandomizeNow) {
            this.randomValueCache = [];
          }

          function collectASample(index, image) {
            image.collectSample();
          }

          function clearSamples(index, image) {
            image.clearSamples();
          }

          function stampTerminalSample(index, image) {
            if (theMap.currentDepth === 0 || image.clonedGObj.state.exists) {
              image.stampTerminalSample();
            }
          }

          //NOTE: geom below actually means geom OR value!
          //Given an object or an array of gobjs, return a cached geom or an array of cached geoms
          function cacheGeom(postImages) {
            var ret = [],
              i,
              numPostImages;

            function cacheOneGObj(gobj) {
              if (gobj.kind === 'Point') {
                return {
                  loc: gobj.geom.loc.copy(),
                  exists: gobj.state.exists,
                };
              } else {
                //parameter
                return {
                  value: gobj.value,
                  exists: gobj.state.exists,
                };
              }
            }
            if ($.isArray(postImages)) {
              numPostImages = postImages.length;
              for (i = 0; i < numPostImages; i++) {
                ret.push(cacheOneGObj(postImages[i]));
              }
              return ret;
            } else {
              return cacheOneGObj(postImages);
            }
          }

          //given an array of gobjs and an array of cached geoms, fill the gobjs'
          //geoms with the geoms in the array

          function moveImagesToCachedLocations(gobjs, cachedLocations) {
            var i,
              numGObjs = gobjs.length,
              gobj;

            for (i = 0; i < numGObjs; i++) {
              gobj = gobjs[i];
              if (gobj.kind === 'Point') {
                gobj.geom.loc = cachedLocations[i].loc;
                gobj.state.exists = cachedLocations[i].exists;
              } else {
                //parameter
                gobj.updateValue(cachedLocations[i].value);
                gobj.state.exists = cachedLocations[i].exists;
              }
            }
          }

          //Given a map, update all pointOnPath postimage objects found in the map to
          //either new or cached random values.  This function must be called in the same order
          //every constraint so that an individual cache index will always refer to the same
          //iterated image.
          //Relies on the closure: rerandomizeCounter
          function updateRandomPointsOnPath(aMap) {
            var numToRandomize = aMap.onPathPostImages.length,
              i,
              gobj,
              path,
              animationRange;

            for (i = 0; i < numToRandomize; i++) {
              gobj = aMap.onPathPostImages[i];
              if (aMap.randomValueCache[rerandomizeCounter] === undefined) {
                path = gobj.getParent('path');
                animationRange = path.getAnimationRange();
                aMap.randomValueCache[rerandomizeCounter] =
                  animationRange.min +
                  (animationRange.max - animationRange.min) * Math.random();
              }

              gobj.updateValue(theMap.randomValueCache[rerandomizeCounter++]);
            }
          }

          function iterationLoop(numIterations) {
            var mapIndex,
              cachedPostImageGeoms = [];

            //Step 1 is to cache the post image locations.  This is the only information
            //we need to successfully move the preimages and constrain.  On the first
            //iteration, the post image locations are located in the parental preimages.
            //On all other iterations, we want to use the position of the clones, since
            //the iteration one level up will have just put them in the position we want.

            if (numIterations === theMap.currentDepth) {
              //First time, we use the initial positions of the actual uncloned postImages
              $.each(theMap.parents, function(key, parent) {
                var info;

                if (POSTIMAGE_REGEX.test(key)) {
                  info = getPostImageInfo(key);

                  if (!cachedPostImageGeoms[info.map]) {
                    cachedPostImageGeoms[info.map] = [];
                  }
                  cachedPostImageGeoms[info.map][info.image] = cacheGeom(
                    parent
                  );
                }
              });
            } else {
              //Otherwise we cache the clones as they lie now, which would have been
              //set by the previous (higher) iteration level
              for (mapIndex = 0; mapIndex < numMaps; mapIndex++) {
                cachedPostImageGeoms[mapIndex] = cacheGeom(
                  theMap.postImageMapArray[mapIndex]
                );
              }
            }

            //Now, for each map, we move the preimages, reconstrain, and collect the
            //image locations, then recurse.  This results in a depth-first recursion,
            //doing the first map of all iterations before moving to the second map.
            for (mapIndex = 0; mapIndex < numMaps; mapIndex++) {
              moveImagesToCachedLocations(
                theMap.preImageClones,
                cachedPostImageGeoms[mapIndex]
              );

              if (theMap.rerandomizePointsOnPaths) {
                updateRandomPointsOnPath(theMap);
              }

              sketch.constrainDriveChain(theMap.driveChain);

              if (!finalIterationOnly || numIterations === 1) {
                //collect a sample for image children
                $.each(theMap.imageArray, collectASample);
              }

              if (numIterations - 1) {
                iterationLoop(numIterations - 1);
              }
            }
          }

          $.each(this.imageArray, clearSamples);
          if (this.currentDepth > 0) {
            iterationLoop(this.currentDepth);
          }
          $.each(theMap.imageArray, stampTerminalSample);

          this.rerandomizeNow = false;
        },
      };
    })()
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  GSP.gConstraints.IterateMapByParametricDepth = GSP.makeClass(
    GSP.gConstraints.IterateMap,
    {
      doc: {
        description: 'Itereation Map by parametric depth.',
        inherits: 'IterateMap',
        refspec: {
          gspRef: 'IterateMapByParametricDepth_C',
        },
        usage: {
          abstract: false,
          kinds: ['Map'],
        },
        properties: {
          parents: {
            description: '',
            type: 'Object',
            properties: {
              depth: {
                description: 'the depth to which the construction is iterated',
                kind: 'Measure',
              },
            },
          },
          //Although this is still present internally in the object, it is not a public property, as it is determined
          //by the depth parent
          currentDepth: {
            suppressed: true,
          },
        },
      },

      constrain: function constrain(sketch) {
        var newDepth = GSP.math.trunc(this.getParent('depth').uValue);

        if (newDepth < 0) {
          newDepth = 0;
        }
        if (!isFinite(newDepth)) {
          newDepth = null;
        }

        if (newDepth !== this.currentDepth) {
          this.currentDepth = newDepth;

          //In a change from desktop, we rerandomize the entire map if the sample
          //count changed.  Otherwise our (and desktop's) randomization caching
          //strategy results in bizarre rerandomization of some, but not all, of the
          //points on path.
          this.rerandomizeNow = true;
          $.each(this.imageArray, function(index, image) {
            image.sampleCountChanged();
          });
        }

        if (this.currentDepth !== null) {
          this.state.exists = true;
          (constrain.base || arguments.callee.base).call(this, sketch);
        } else {
          this.state.exists = false;
        }
      },

      constraintVerificationString: function constraintVerificationString(
        iExpected
      ) {
        var msg = (
          constraintVerificationString.base || arguments.callee.base
        ).call(this);

        if (iExpected) {
          msg += this.testConsistency(
            'depth',
            this.currentDepth,
            iExpected.depth
          );
        }

        return msg;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * For unconstrained gobjects.
   */
  GSP.gConstraints.IterateImage = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: '',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'IterateImage_C',
      },
      usage: {
        abstract: false,
        kinds: ['IterateImage'],
      },
      existenceRule: '',
      properties: {
        parents: {
          description: '',
          type: 'Object',
          properties: {
            source: {
              description: 'The preimage that is to be iterated',
              kind:
                'Point|Expression|Text|Arc|Circle|Picture|Polygon|Straight|ArcInterior|CircleInterior',
            },
            map: {
              description: 'The iteration map defining the iteration',
              kind: 'Map',
            },
          },
        },
      },
    },
    updateConstraintAncestry: function updateConstraintAncestry() {
      (updateConstraintAncestry.base || arguments.callee.base).call(this);

      //register with the Map parent, storing the returned object in our clonedGObj property
      var map = this.getParent('map'),
        clonedGObj = map.registerImageAndGetClone(this);

      this.clonedGObj = clonedGObj;
      this.initializeSampleBuffer();
      //Also initialize the vectorContext - will need to query the map to figure out the number
      //of samples to allocate (displayFinalIterationOnly ? numMaps : ())
    },
    constrain: function() {
      this.state.exists = this.curSampleNum > 0;
    },

    //Override to allow for non-existing source
    checkParentsExist: function() {
      if (this.getParent('map').state.exists) {
        return true;
      }
      // The map doesn't exist, presumably because the source doesn't,
      // so neither does the iterated image.
      if (this.state.exists) {
        // When setting existence to false, we also need to wipe our
        // samples, since our map's constrain function won't be called and
        // the map usually manages these tasks.
        this.state.exists = false;
        this.clearSamples();
      }
      return false;
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.PointTerminalIteration = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.Midpoint */ {
      doc: {
        description: 'The terminal point of an iterated image of points',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'TerminalIterationPoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Midpoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists if the parental image exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              image: {
                description: '',
                kind: 'IterateImage',
              },
            },
          },
        },
        example: '',
      },
      state: {},

      checkParentsExist: function() {
        //We exist if our image's map exists.  (The image itself can be non-existing,
        //eg. with 0 samples, and the source can also be non-existing)
        // Provisionally set state.exists to the returned result.
        var image = this.getParent('image');
        this.state.exists = image && image.namedParentExists('map');
        return this.state.exists;
      },

      constrain: function() {
        var image = this.getParent('image'),
          terminalGeom = image.getTerminalGeom();

        if (terminalGeom === null) {
          this.state.exists = false;
          this.geom.loc = GSP.GeometricPoint.UNDEFINED;
        } else {
          this.geom = terminalGeom;
          this.state.exists = true;
        }
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Virtual base class for Transformation constraints
   * @class Transformation
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.CompositeText = (function() {
    var kDelimiter = '-';
    var kMFSValueKeyRegex = new RegExp('\\d+' + kDelimiter + '.*');

    /**
     * Convert a number (an enumeration in a switch node refcon for appearance type)
     * into a string for use by WSP.
     *
     * cf embeddedtext.h for equivalent enum
     *
     * @param {Number} index
     * @returns {String}
     */
    function indexToAppearanceType(index) {
      switch (index) {
        case 10:
          return 'byLabel';
        case 11:
          return 'byName';
        case 12:
          return 'byValue';
        case 13:
          return 'valueAsAddend';
        case 14:
          return 'expressionOnly';
        case 15:
          return 'independentVariable';
        case 16:
          return 'dependentVariable';
        case 17:
          return 'pictureIcon';
        //case 0:
        default:
          return 'default';
      }
    }

    /**
     * Given a switch node refCon as output by desktop Sketchpad, parses it into
     * a key that is [PARENT_ID][DELIMITER][APPEARANCE_TYPE] which is the key
     * for the parameter node with in the switch node once within WSP.
     *
     * @param {Object} theGObj
     * @param {String} refCon
     * @returns {String}
     */
    function refConToMergeTextKey(theGObj, refCon) {
      /*jslint bitwise: true */
      var intValue = parseInt(refCon, 16),
        parentIndex = (intValue & 0xffff) - 1,
        appearance = indexToAppearanceType((intValue & 0xffff0000) >> 16);

      return parentIndex + kDelimiter + appearance;
    }

    return GSP.makeClass(GSP.gConstraints.Constraint, {
      doc: {
        description:
          'Defines a caption that has references to dynamically generated text from other objects.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'CompositeText_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, CompositeText_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Text'],
        },
        existenceRule: 'Exists iff parents exist.',
        properties: {
          parents: {
            description: 'Objects referenced in the caption',
            properties: {
              '0': {
                description: 'Objects labeled "0", ..., "n"',
                kind: 'kind',
              },
            },
            regex: /^[0-9]+$/,
          },
        },
      },
      updateLabelForConstraint: function updateConstraintAncestry(option) {
        (updateConstraintAncestry.base || arguments.callee.base).call(this);

        var theGObj = this;

        this.parentMFSValues = {};

        //initialize the parentMFSValues - basically rewriting the switch node
        //content into parameter nodes

        function fillSwitchNode(switchNode) {
          var key = refConToMergeTextKey(theGObj, switchNode.refCon);

          //Override Desktop functionality, which sets visibleNode to 0 for
          //switch nodes in hidden hot text captions.  For our uses, they can
          //always be 1.
          switchNode.visibleNode = 1;

          switchNode.value[0] = { type: 'parameter', value: key };
          theGObj.parentMFSValues[key] = { type: 'text', value: 'unfilled' };
        }

        GSP.mfs.walkNode(this.parsedMFS, 'switch', fillSwitchNode);

        theGObj.state.exists = true; //we exist until proven otherwise

        //update the parentMFSValues
        $.each(theGObj.parentMFSValues, function(key) {
          //Ensure that the key in parentMFSValues matches our expected key for
          //a parent.  parentMFSValues caches state about its last rendered values
          //which we don't want to iterate over.
          if (!key.match(kMFSValueKeyRegex)) {
            return;
          }

          var keyComponents = key.split(kDelimiter),
            objIndex = keyComponents[0],
            appearance = keyComponents[1],
            parent = theGObj.parentsList[objIndex],
            doShow = !theGObj.style.hidden,
            // composite text, if visible, should show the label of any object it references
            option = { constrain: true, show: doShow },
            newMFSValue = parent.getStrippedMFSAppearanceForVariant(
              appearance,
              option
            );

          if (newMFSValue === null) {
            //A non-existing parent with an undefined appearance.  We don't
            //exist either
            theGObj.state.exists = false;
            return false;
          }

          // Cache the id of the parent, for later embedding in DOM data attribute.
          newMFSValue.referenceId = parent.id;

          theGObj.parentMFSValues[key] = newMFSValue;
        });
      },

      constrain: function() {
        this.updateLabelForConstraint(); // Update parsedMFS after setting parentMFSValues
      },

      checkParentsExist: function() {
        return true;
      },
    });
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind picture's upper left to a point.
   */
  GSP.gConstraints.PictureAcrossThreePoints = GSP.makeClass(
    GSP.gConstraints.PictureNonFree,
    /** @lends GSP.gConstraints.PictureAcrossThreePoints */ {
      doc: {
        description:
          'Defines a picture with upper left defined by a <span class="kind">Param</span>.',
        inherits: 'PictureNonFree',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent point exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description:
                  'The location of the original bottom left of the picture',
                kind: 'Point',
              },
              p1: {
                description:
                  'The location of the original bottom right of the picture',
                kind: 'Point',
              },
              p2: {
                description:
                  'The location of the original top left of the picture',
                kind: 'Point',
              },
            },
          },
        },
      },
      constrain: function() {
        var p0 = this.getParent('p0').geom.loc,
          p1 = this.getParent('p1').geom.loc,
          p2 = this.getParent('p2').geom.loc,
          image = this.getImage(),
          transform = GSP.AffineTransform.fromPointMapping(
            [
              GSP.GeometricPoint(0, image.height),
              GSP.GeometricPoint(image.width, image.height),
              GSP.GeometricPoint(0, 0),
            ],
            [p0, p1, p2]
          );

        if (transform) {
          this.geom.transform = transform;
        } else {
          this.state.exists = false;
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind picture's upper left to a point.
   */
  GSP.gConstraints.PictureBetweenTwoPoints = GSP.makeClass(
    GSP.gConstraints.PictureNonFree,
    /** @lends GSP.gConstraints.PictureBetweenTwoPoints */ {
      doc: {
        description:
          'Defines a picture with upper left defined by a <span class="kind">Param</span>.',
        inherits: 'PictureNonFree',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent points exist, and their rounded-to-integer coordinates differ in both x and y values.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description:
                  'One corner of the rectangle in which the picture is presented',
                kind: 'Point',
              },
              p1: {
                description:
                  'The other corner of the rectangle in which the picture is presented',
                kind: 'Point',
              },
            },
          },
        },
      },
      constrain: function() {
        var p0 = this.getParent('p0').geom.loc.round(),
          p1 = this.getParent('p1').geom.loc.round(),
          delta = p1.subtract(p0),
          image = this.getImage();

        this.state.exists = delta.getX() !== 0 && delta.getY() !== 0;

        if (this.state.exists) {
          this.geom.transform = GSP.AffineTransform({
            m20: delta.getX() < 0 ? p1.getX() : p0.getX(),
            m21: delta.getY() < 0 ? p1.getY() : p0.getY(),
            m00: Math.abs(delta.getX()) / image.width,
            m11: Math.abs(delta.getY()) / image.height,
          });
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind picture's upper left to a point.
   */
  GSP.gConstraints.PictureCenteredOnOnePoint = GSP.makeClass(
    GSP.gConstraints.PictureNonFree,
    /** @lends GSP.gConstraints.PictureCenteredOnOnePoint */ {
      doc: {
        description:
          'Defines a picture centered on a <span class="kind">Point</span>.',
        inherits: 'PictureNonFree',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent point exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: '',
                kind: 'Point',
              },
            },
          },
          scaleX: {
            description: 'Horizontal scaling factor about center.',
            type: 'Number',
          },
          scaleY: {
            description: 'Vertical scaling factor about center.',
            type: 'Number',
          },
          angle: {
            description: 'Angle of rotation about center.',
            type: 'Number',
          },
        },
      },
      constrain: function() {
        var p0 = this.getParent('p0').geom.loc,
          scaleX = this.scaleX,
          scaleY = this.scaleY,
          angle = this.angle,
          image = this.getImage();

        this.geom.transform = GSP.AffineTransform.Identity.translate(
          -image.width / 2,
          -image.height / 2
        )
          .scale(scaleX, scaleY)
          .rotate(angle)
          .translate(p0);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind picture's upper left to a point.
   */
  GSP.gConstraints.PictureCroppedByInterior = GSP.makeClass(
    GSP.gConstraints.PictureNonFree,
    /** @lends GSP.gConstraints.PictureCroppedByInterior */ {
      doc: {
        description:
          'Defines a picture cropped by an <span class="genus">Interior</span>.',
        inherits: 'PictureNonFree',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent point exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              source: {
                description: 'Picture to be cropped',
                kind: 'Picture',
              },
              cropInterior: {
                description: 'Polygon to which picture will be cropped',
                kind: 'Polygon',
              },
            },
          },
        },
      },
      updateConstraintAncestry: function() {
        var crop = this.getParent('cropInterior');

        this.geom.clipVertices = crop.getVertices();
      },
      constrain: function() {
        var source = this.getParent('source'),
          crop = this.getParent('cropInterior'),
          that = this;

        function shouldExist() {
          var transformedVertices = [],
            pictureRect = {
              top: 0,
              left: 0,
              bottom: source.getImage().height,
              right: source.getImage().width,
            },
            inverseTransform = that.geom.transform.inverse(),
            i;

          if (!inverseTransform) {
            return false;
          }

          for (i = 0; i < crop.geom.points.length; i++) {
            transformedVertices.push(crop.geom.points[i].copy());
          }

          inverseTransform.transform(transformedVertices);

          return GSP.Geom.RectSectsPolygon(pictureRect, transformedVertices);
        }

        this.geom.transform = source.geom.transform;
        this.geom.clipVertices = crop.getVertices();
        this.state.exists = shouldExist();
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind picture's upper left to a point.
   */
  GSP.gConstraints.PictureHungOnOnePoint = GSP.makeClass(
    GSP.gConstraints.PictureNonFree,
    /** @lends GSP.gConstraints.PictureHungOnOnePoint */ {
      doc: {
        description:
          'Defines a picture with upper left at a <span class="kind">Point</span>.',
        inherits: 'PictureNonFree',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent point exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: '',
                kind: 'Point',
              },
            },
          },
        },
      },
      constrain: function() {
        var p0 = this.getParent('p0').geom.loc;
        this.geom.transform = GSP.AffineTransform({
          m20: p0.getX(),
          m21: p0.getY(),
          m00: 1,
          m11: 1,
        });
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrain a point to a path.
   */
  GSP.gConstraints.PointOnPathBase = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      // value is the normalized distance along the path
      // it is used by constrain()
      value: 0.5,

      //True if the point is a free point draggable on a path (and subject to
      //onPath behavior such as animation and rerandomization
      isFreePointOnPath: true,

      constrain: function constrain() {
        var pathObject = this.getParent('path'),
          exists = false,
          newPoint = GSP.GeometricPoint.UNDEFINED;

        if (pathObject.isValueInBounds(this.value)) {
          newPoint = pathObject.mapPathValueToPosition(this.value);
          if (newPoint && newPoint.isDefined()) {
            exists = true;
          } else {
            // normalize return value
            newPoint = GSP.GeometricPoint.UNDEFINED;
          }
        }
        this.state.exists = exists;
        this.geom.loc = newPoint;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a line to its two definition points.
   */
  GSP.gConstraints.Straight = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.Straight */ {
      doc: {
        description: 'The base class for all straight constraints.',
        inherits: 'Constraint',
      },
      /**
       * Return the first control point. Default implementation
       * assumes a 'p0' parent.
       */
      getStraightP0: function() {
        var p0 = this.getParent('p0');
        return p0.geom.loc;
      },
      /**
       * Return the second control point. Default implementation
       * assumes a 'p1' parent.
       */
      getStraightP1: function() {
        var p1 = this.getParent('p1');
        return p1.geom.loc;
      },
      // See mfs.js overbarSpecs
      getOverBarType: function() {
        return this.overbarType; // a property set by subclasses
      },

      getParentalNameMFS: function(option) {
        var p0Name = this.getParent('p0').getNameMFS(option),
          p1Name = this.getParent('p1').getNameMFS(option);
        return {
          type: 'overbar',
          variant: this.getOverBarType(),
          value: GSP.mfs.makeHorizontalNamesMFS([p0Name, p1Name]),
        };
      },

      /*
       * Determine whether two gobjs are defined by the same parents in such a way that
       * they can be merged, typically used when one is created by a tool and the other already
       * exists in the sketch.
       * N.B. If the two straights have opposite directionality, the direction of gobj will be flipped
       * so point-on-path and plotted children must have their values adjusted.
       */
      canMergeTo: function(gobj) {
        // Parents p0 and p1 can be interchanged, unless this is a ray.
        var a0 = this.getParent('p0'),
          b0 = gobj.getParent('p0'),
          a1 = this.getParent('p1'),
          b1 = gobj.getParent('p1'),
          retVal = false;
        if (!(a0 && b0 && a1 && b1)) {
          // all parents must exist
          GSP.signalErrorWithMessage('Straight canMergeTo() missing parents!');
        } else {
          retVal =
            (a0 === b0 && a1 === b1) ||
            (this.constraint !== 'Ray' && a0 === b1 && a1 === b0);
        }
        if (retVal && a0 !== b0) {
          // gobj is opposite-direction from this, so flip values of points on path
          gobj.children.forEach(function(child, ix) {
            if (
              child.constraint === 'PointOnPath' ||
              child.constraint === 'PointOnPathPlotFixedValue'
            ) {
              child.value = 1 - child.value;
            }
          });
        }
        return retVal;
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Virtual base class for Transform constraints
   * @class Transform
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.Transform = GSP.makeClass(
    [GSP.gConstraints.Constraint, GSP.mixins.transformable],
    {
      doc: {
        description: 'The parent class for all transformations.',
        inherits: 'Constraint',
        refspec: {
          msg:
            "This class is an internal object and doesn't have an independent source of requirements.",
        },
        usage: {
          abstract: true,
          kinds: [
            'Arc',
            'ArcInterior',
            'Circle',
            'CircleInterior',
            'Picture',
            'Point',
            'Polygon',
            'Straight',
          ],
        },
        properties: {
          parents: {
            description: '',
            properties: {
              source: {
                description: 'The source of the transformation',
                kind: 'kind',
                type: 'GObject',
              },
            },
          },
        },
      },

      /* Does this object descend from transformation?*/

      isTransformationConstraint: true,
      /*
       * Determine whether the object exists.
       * Subclasses must override.
       */
      determineExists: function() {
        return undefined;
      },
      /**
      Fetch the geom that is the source of our transformation.
      Subclasses can override.
      
      @param {GSP.Sketch} sketch  The current Sketch
      @return {Object} GObject.geom
    */
      getSourceGeom: function() {
        return this.getParent('source').geom;
      },

      constrain: function() {
        var transformer = this.getTransformer();
        transformer.transformGeom(this.getSourceGeom(), this.geom);
        this.state.exists = this.determineExists();
      },

      getParentalNameMFS: function(option) {
        var source = this.getParent('source');
        return GSP.mfs.makeHorizontalMFS(
          source.getNameMFS(option),
          GSP.mfs.makeTextMFS("'")
        );
      },

      // The following angle utilities serve both rotations and translations
      // child is the child of the 3 points. It can't be "this" because the actual child may be an angle marker, parent to the transformation
      // Params a, b, c are "A", "B", "C" for marked angles and "p0", "p1", "p2" if this.parent.marker exists
      get3PtAngleText: function(a, b, c, option) {
        // Prefer using all 3 labels, or (if other labels aren't shown) the vertex label only, generating it if needed
        var child = this, // "this" works for 3-point angle constraints, but not for angle-marker constraints
          aLabel,
          bLabel,
          cLabel;
        switch (this.constraint) {
          case 'RotateAngleMarker':
            child = this.getParent('angle');
            break;
          case 'TranslateFixDistAngleMarker':
          case 'TranslateMeasureDistAngleMarker':
            child = this.getParent('marker');
        }
        aLabel = child.getVisibleParentLabel(a);
        bLabel = child.getVisibleParentLabel(b, option);
        cLabel = child.getVisibleParentLabel(c);
        if (aLabel && bLabel && cLabel) {
          return '\u2220' + aLabel + bLabel + cLabel;
        } else if (bLabel) {
          return '\u2220' + bLabel;
        } else return '';
      },

      // Return the text for an angle marker. Use the angle marker's parents if it's not labeled; if those don't exist use the existing marker label, a newly-created marker (if option is 'create' or 'show'), or a default value.
      getAngleMarkerText: function(id, option) {
        // Note that id is "marker" for translations and "angle" for rotation
        var marker = this.getParent(id),
          retVal = marker.label; // Prefer the marker's label, if it exists. This allows the user control of the notation.
        // Ideally we don't show an existing angle marker if it's hidden, so the user can use the label while intentionally leaving the marker hidden.
        if (!retVal) {
          // marker doesn't have a label yet
          if (option && !marker.style.hidden) {
            // if the marker is showing, generate and use its label.
            retVal = this.getParentLabel(id, option);
          } else {
            // marker not visible, so try to use its parental points
            retVal = this.get3PtAngleText('p0', 'p1', 'p2', option);
          }
          if (!retVal && option) {
            // show the marker and create its label
            retVal = this.getParentLabel(id, { show: true });
          }
        }
        if (!retVal) {
          retVal = '1'; // default value for angle marker
        }
        if (retVal.indexOf('\u2220') === -1) {
          retVal = '\u2220' + retVal;
        }
        return retVal;
      },

      /*    Return the text for a fixed angle
        We'd prefer to format the value as MFS, to get values like π/2, but here we're limited to a text label
        The following function would give us the MFS
      getAngleLabelMFS: function () {  // return the MFS of the angle.
        var prefs = this.sQuery.sketch.preferences.units.angle;
        return this.formatNumberAsMFS (this.angle, prefs.precision.angle, prefs.units.angle);
      },
  */
      getFixedAngleText: function(angle) {
        // Return the given using units and precision from prefs
        var prefs = this.sQuery.sketch.preferences,
          unitData = GSP.units.findUnit(prefs.units.angle),
          roundFactor = Math.pow(10, prefs.precision.angle),
          val =
            Math.round(-angle * unitData.conversionFromBase * roundFactor) /
            roundFactor; // use -angle to account for flipped coord sys
        return (val < 0 ? '\u2013' : '') + Math.abs(val) + unitData.symbol;
      },

      makeParentalLabel: function(nameOrigin, option) {
        /*  Accepts a notation style (namedByPrime,namedByFullFn, namedByShortFn,
         *  namedFromLabel) and returns a label. The value of option can be:
         *  init: avoid any renderRefCon use. It's ok to generate a label, but not to show it.
         *  create: called to generate if needed (but not display) both this label and any needed parental labels.
         *  show: called to show the label, generating it if needed along with any required parental labels.
         */

        var preLabel,
          prefix = '',
          postfix = "'",
          retVal;
        if (
          option.init &&
          this.style.label.showLabel &&
          this.style.nameOrigin === nameOrigin
        ) {
          // create parent labels only if the gobj needs to show them.
          option.create = true; // Need to create but not constrain parent labels
        }
        nameOrigin = nameOrigin || 'namedByPrime';
        switch (nameOrigin) {
          case 'namedByFullFn':
          case 'namedByShortFn':
            preLabel = this.getParentLabel('source', option); // create but don't constrain or show preimage label
            if (!this.makeFnLabelPrefix) {
              GSP.signalErrorWithMessage(
                'makeFnLabelPrefix undefined for ' + this.constraint
              );
            } else {
              prefix = this.makeFnLabelPrefix(nameOrigin, option) + '(';
              postfix = ')';
            }
            break;
          case 'namedFromLabel':
            return this.label; // this might be undefined; that's ok.
          case 'namedByPrime':
            preLabel = this.getParentLabel('source', option);
            // The option wasn't init, so we should have a preimage label
            break;
          default:
            GSP.signalErrorWithMessage(
              "makeParentalLabel doesn't recognize nameOrigin = " + nameOrigin
            );
            this.style.nameOrigin = 'namedFromLabel';
            return this.label;
        }
        if (preLabel) {
          retVal = prefix + preLabel + postfix;
        }
        return retVal;
      },

      updateLabelForConstraint: function(option) {
        var sourceLabel = this.getParent('source').label, // possibly undefined
          newLabel,
          origin = this.style.nameOrigin,
          i,
          origins;
        if (
          !this.label &&
          !(this.style.label && this.style.label.showLabel) &&
          (!option || option.init)
        )
          return; // don't update a non-existent label unless option says otherwise
        if (!option && !origin) {
          option.init = true;
        }
        if (this.baseGenera.includes('Path') && !option.init)
          this.constrainLabelForPath();
        option = option || { constrain: true }; // Prefer the caller's option, but only if it exists.
        if (origin) {
          newLabel = this.makeParentalLabel(origin, option);
        } else if (sourceLabel) {
          // try to figure it out from the current label
          origins = [
            'namedByPrime',
            'namedByShortFn',
            'namedByFullFn',
            'namedFromLabel',
          ];
          for (i = 0; i < 3; i++) {
            newLabel = this.makeParentalLabel(origins[i], option);
            if (newLabel === this.label) {
              origin = origins[i];
              break; // found a match; now we know the origin.
            }
          }
          if (i === 3) {
            // no match
            if (this.shouldAutogenerateLabel) {
              origin = 'namedByPrime';
              newLabel = this.makeParentalLabel(origin, option);
            } else {
              origin = 'namedFromLabel';
              newLabel = this.label;
            }
          }
        } else {
          // no nameOrigin and no sourceLabel, so default to current label
          origin = 'namedFromLabel';
          newLabel = this.label;
        }
        if (newLabel !== this.label) {
          if (option.init) {
            // just assign it
            this.label = newLabel;
          } else {
            // redraw it properly
            this.setLabel(newLabel, option);
          }
        }
        if (origin !== 'namedFromLabel') {
          this.shouldAutogenerateLabel = true;
        }
        this.style.nameOrigin = origin;
      },
    }
  );
  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a ray to its two definition points.
   */
  GSP.gConstraints.Ray = GSP.makeClass(GSP.gConstraints.Straight, {
    doc: {
      description:
        'Defines a ray from two points. The first point, p0, is the base of the ray.',
      inherits: 'Straight',
      refspec: {
        gspRef: 'Ray_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Ray_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Straight'],
      },
      existenceRule:
        'Exists iff the parent points exist and are not coincident.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'The foot of the ray.',
              kind: 'Point',
            },
            p1: {
              description: 'A point on the ray not incident with the foot.',
              kind: 'Point',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Ray_export.json',
    },
    overbarType: 3,
    getPointOnPath: function(path, distance) {
      return this.getPointOnRay(path, distance);
    },
    /**
     * A value bound to within the range of values on the path.
     * Points on paths are implicitly scaled. For example, the values of
     * points on segments ranges from zero to one, inclusive, where zero
     * is coincident with p0, and one with p1. This method makes sure values are
     * within the implied range, if such a range exists.
     * @param {Number} v
     * @return {Number}
     */
    constrain: function() {
      var p0, p1, p1m0, len, multiplier, end;
      p0 = this.getStraightP0();
      this.geom.p0 = p0;
      p1 = this.getStraightP1();
      this.geom.p1 = p1;
      p1m0 = p1.subtract(p0);
      if (p1m0.isZeroLength()) {
        this.geom.xp0 = GSP.GeometricPoint(0, 0);
        this.geom.xp1 = GSP.GeometricPoint(0, 0);
      } else {
        len = p1m0.vLength();
        multiplier = 10000 / len;
        end = p0.add(p1m0.multiply(multiplier));
        this.geom.xp0 = p0;
        this.geom.xp1 = end;
      }
      this.state.exists = !p1m0.isZeroLength();
      //GSP.log("p0: " + p0 + ", p1: " + end);
    },

    /*
     * Determine whether two gobjs are defined by the same parents in such a way that
     * they can be merged, typically used when one is created by a tool and the other already
     * exists in the sketch.
     */
    canMergeTo: function(gobj) {
      return (
        gobj.constraint === 'Ray' &&
        this.getParent('p0') === gobj.getParent('p0') &&
        this.getParent('p1') === gobj.getParent('p1')
      );
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a ray to the three points, A, B, and C that
   * form an angle the ray bisects. The foot of the ray is the midpoint, B.
   * Bisectors do not exist if either vertex-endpoint (A/C) is coincident to B;
   * otherwise, they exist and are well-defined numerically
   * (even if A=C, or, weaker, if BA and BC are collinear)
   */
  GSP.gConstraints.AngleBisector = GSP.makeClass(
    GSP.gConstraints.Ray,
    /** @lends GSP.gConstraints.AngleBisector */ {
      doc: {
        description:
          "Constrains a ray to bisect an angle. The ray's foot is the angle vertex.",
        usage: {
          abstract: false,
          kinds: ['Straight'],
          genus: ['Ray'],
        },
        inherits: 'Ray',
        refspec: {
          gspRef: 'Bisector_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Bisector_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        properties: {
          parents: {
            properties: {
              A: {
                description: 'A point',
                kind: 'Point',
              },
              B: {
                description: 'A point',
                kind: 'Point',
              },
              C: {
                description: 'A point',
                kind: 'Point',
              },
              p0: { suppressed: true },
              p1: { suppressed: true },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-AngleBisector_export.json',
      },
      constrain: function() {
        var a = this.getParent('A').geom.loc,
          b = this.getParent('B').geom.loc,
          c = this.getParent('C').geom.loc,
          delta,
          t,
          p5,
          p6,
          bisector;
        // reset everything
        this.geom.p0 = this.geom.p1 = this.geom.xp0 = this.geom.xp1 = undefined;
        // if (GeometricPoints_Equal_UTIL(A, B)
        //     || GeometricPoints_Equal_UTIL(B, C)
        //     self->g.geomExists = false;
        // else
        if (a.equals(b) || b.equals(c)) {
          this.state.exists = false;
        } else {
          // dX = A->x-B->x;
          // dY = A->y-B->y;
          delta = a.subtract(b);
          // t=sqrt(9000.0/(dX*dX+dY*dY));
          t = Math.sqrt(9000 / delta.dot(delta));
          // p5.x=B->x+t*dX;
          // p5.y=B->y+t*dY;
          p5 = b.add(delta.multiply(t));

          // dX = C->x-B->x;
          // dY = C->y-B->y;
          delta = c.subtract(b);
          // t=sqrt(9000.0/(dX*dX+dY*dY));
          t = Math.sqrt(9000 / delta.dot(delta));
          // p6.x=B->x+t*dX;
          // p6.y=B->y+t*dY;
          p6 = b.add(delta.multiply(t));

          // self->geom.B.x=(p5.x + p6.x)/2.0;
          // self->geom.B.y=(p5.y + p6.y)/2.0;
          bisector = p5.add(p6).multiply(0.5);
          delta = bisector.subtract(b);

          /*
           If the points form a straight angle, p4 and B will be identical, within ROUND_TO_INT_COORDing errors.
           These ROUND_TO_INT_COORDing errors get worse as B approaches closely to A or C; the following tolerance 
           of 0.01 pixel seems necessary to prevent spurious bisectors appearing as a vertex point-on-segment
           approaches the end points of the segment. Since the circle on which p5 and p6 lie has a radius 
           of almost 100 pixels, this tolerance corresponds to a deviation of approximately 10^-4 radians 
           or 0.006 degrees) from a straight angle. It's better to fail to show the bisector of an angle }
           from 179.994 to 180.006 degrees, than to have a bisector that should not exist wildly flipping about.
        */

          if (Math.abs(delta.x) > 0.01 || Math.abs(delta.y) > 0.01) {
            this.geom.p1 = bisector;
            this.geom.xp0 = this.geom.p0 = b;
            this.geom.xp1 = b.add(delta.multiply(10000));
          } else {
            this.state.exists = false;
          }
        }
      },
      getParentalNameMFS: function() {
        //Silencing error until reform of label renderPrepare is completed
        //GSP.signalErrorWithMessage("Parallel.getParentalNameMFS() shouldn't be called.");
        return GSP.mfs.makeTextMFS('AngleBisector ' + this.id);
      },

      /*
       * Determine whether two gobjs are defined by the same parents in such a way that
       * they can be merged, typically used when one is created by a tool and the other already
       * exists in the sketch.
       */
      canMergeTo: function(gobj) {
        // Parents A and C can be interchanged; parent B must be the same
        var a1 = this.getParent('A'),
          a2 = gobj.getParent('A'),
          b1 = this.getParent('B'),
          b2 = gobj.getParent('B'),
          c1 = this.getParent('C'),
          c2 = gobj.getParent('C');
        return (
          gobj.constraint === 'AngleBisector' &&
          b1 === b2 &&
          ((a1 === a2 && c1 === c2) || (a1 === c2 && c2 === a1))
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a circle to two defining points.
   */
  GSP.gConstraints.ArcAroundPoint = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'Defines an arc centered about a point, counter-clockwise from the first selected bounding point to the second.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'ArcAroundPoint_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, ArcAroundPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Arc'],
      },
      existenceRule:
        'Exists iff parents exist, and parental points are not coincident.',
      properties: {
        parents: {
          description: '',
          properties: {
            center: {
              description: 'Center of circle on which the arc is situated',
              kind: 'Point',
            },
            p0: {
              description: 'First bounding point',
              kind: 'Point',
            },
            p1: {
              description: 'Second bounding point',
              kind: 'Point',
            },
          },
        },
      },
    },
    constrain: function() {
      var c = this.getParent('center').geom.loc;
      var p0 = this.getParent('p0').geom.loc;
      var p1 = this.getParent('p1').geom.loc;
      this.geom.arc = GSP.GeometricArc.FromCenterAndEndpoints(c, p0, p1, -1);
      this.state.exists = this.geom.arc.exists;
    },
    getParentalNameMFS: function(option) {
      var p0 = this.getParent('p0'),
        p1 = this.getParent('p1');
      if (!p0.label) {
        this.getParentLabel('p0', option);
      }
      if (!p1.label) {
        this.getParentLabel('p1', option);
      }
      return GSP.mfs.parentsHorizontalOverbar(this, ['p0', 'p1']);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind an arc to three defining points.
   */
  GSP.gConstraints.Arc3Points = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'Defines an arc from three points.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'Arc3Points_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Arc3Points_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Arc'],
      },
      existenceRule:
        'Exists iff parent points exist and are not pairwise coincident.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'Initial point',
              kind: 'Point',
            },
            p1: {
              description: 'Middle point',
              kind: 'Point',
            },
            p2: {
              description: 'Final point',
              kind: 'Point',
            },
          },
        },
      },
    },
    constrain: function() {
      var p0 = this.getParent('p0').geom.loc;
      var p1 = this.getParent('p1').geom.loc;
      var p2 = this.getParent('p2').geom.loc;
      this.geom.arc = GSP.GeometricArc.FromThreePoints(p0, p1, p2);
      this.state.exists = this.geom.arc.exists;
    },

    getParentalNameMFS: function(option) {
      var p0 = this.getParent('p0'),
        p1 = this.getParent('p1'),
        p2 = this.getParent('p2');
      if (!p0.label) {
        p0.getLabel(option);
      }
      if (!p1.label) {
        p1.getLabel(option);
      }
      if (!p2.label) {
        p2.getLabel(option);
      }
      return GSP.mfs.parentsHorizontalOverbar(this, ['p0', 'p1', 'p2']);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind an arc interior to its parent arc.
   */
  GSP.gConstraints.ArcInterior = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'Base class for arc interiors: ArcSegment, ArcSector.',
      inherits: 'Constraint',
      usage: {
        abstract: true,
        kinds: ['ArcInterior'],
      },
      existenceRule: 'Exists iff parents exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            arc: {
              description: 'Defining arc',
              kind: 'Arc',
            },
          },
        },
      },
    },
    constrain: function() {
      var arc = this.getParent('arc');
      this.geom.arc = arc.getGeometricArc();
      this.state.exists = arc.state.exists && isFinite(this.geom.arc.radius);
    },
    getParentalNameMFS: function(option) {
      return this.getParent('arc').getNameMFS(option);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind an arc to its parent circle and two defining points.
   */
  GSP.gConstraints.ArcOnCircle = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'Defines an arc on circle, counter-clockwise from the first selected bounding point to the second.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'ArcOnCircle_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, ArcOnCircle_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Arc'],
      },
      existenceRule: 'Exists iff parent points exist and are not coincident.',
      properties: {
        parents: {
          description: '',
          properties: {
            circle: {
              description: 'Circle on which the arc is situated',
              kind: 'Circle',
            },
            p0: {
              description: 'First bounding point',
              kind: 'Point',
            },
            p1: {
              description: 'Second bounding point',
              kind: 'Point',
            },
          },
        },
      },
    },
    constrain: function() {
      var c = this.getParent('circle').geom.c;
      var p0 = this.getParent('p0').geom.loc;
      var p1 = this.getParent('p1').geom.loc;
      this.geom.arc = GSP.GeometricArc.FromCenterAndEndpoints(c, p0, p1, -1);
      this.state.exists = this.geom.arc.exists;
    },
    getParentalNameMFS: function(option) {
      var p0 = this.getParent('p0'),
        p1 = this.getParent('p1');
      if (!p0.label) {
        this.getParentLabel('p0', option);
      }
      if (!p1.label) {
        this.getParentLabel('p1', option);
      }
      return GSP.mfs.parentsHorizontalOverbar(this, ['p0', 'p1']);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * Base class of button constraints.
   */
  GSP.gConstraints.ActionButton = GSP.makeClass(GSP.gConstraints.Free, {
    doc: {
      description: 'The parent class of all action button constraints.',
      refspec: {},
      inherits: 'Free',
      usage: {
        abstract: true,
        kinds: ['Button'],
      },
      existenceRule: 'Exists regardless of existence of parents.',
      properties: {
        messages: {
          description: 'First message is default button label',
          type: 'Array',
          required: false,
        },
      },
    },
    constrain: function() {
      if (this.messages && this.messages.length && this.shouldAutogenerateLabel)
        this.label = this.messages[0];
    },
    /*
     * Press the button
     *
     * @param {object} sketch
     * @param {string} pressSource - (optional) Who pressed the button.
     *      Possible values: ["user" | "simultaneousButton" | "sequenceButton"].
     *      If omitted, "user" is assumed
     *
     */

    press: function(sketch, pressSource) {
      GSP.log(
        'press() not implemented for this button; Constraint: ' +
          this.constraint
      );
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the result of a calculation. Assumed to constrain an expression.
   * A corollary of this assumption is that we can assume there is a member
   * function, fn, that is usable to calculate the value. Further,
   * we assume that each parent of the calculation reports a numerical value
   * in its value property.
   */
  GSP.gConstraints.Calculation = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'A calculated expression',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'CalculationM_C',
      },
      usage: {
        abstract: false,
        kinds: ['Expression'],
      },
      existenceRule: 'Exists iff the parent points exist.',
      properties: {
        parents: {
          description:
            'An associative array of objects used in the expression.',
          type: 'Array',
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Expression-Calculation_export.json',
    },
    baseUnits: {
      angle: GSP.units.unitFamilies.angle.baseUnit,
      length: GSP.units.unitFamilies.length.baseUnit,
    },
    constrain: function() {
      // No need to regenerate the fnExpression because neither our
      // expression nor our parents list has changed. Although the
      // existing fnExpression's result may be different, its code
      // is unchanged.
      // However, on redo the name of a calculation won't have been generated during init,
      // so get the mfs name if it's missing

      if (!this.parsedMFS) {
        this.getNameMFS({ create: true });
      }

      this.uValue = this.fnExpression(this.parentsList, this.fnUnits);

      this.blank =
        this.expression === '' ||
        (GSP.math.isDefined(this.uValue)
          ? false
          : this.determineParentalBlank());
      this.value = this.uValue * this.unitMultiplier;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a circle to its defining center point and radius.
   */
  GSP.gConstraints.CircleByRadius = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'Defines a circle from a center point and the length of a <span class="genus">Path</span>.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'CircleRadius_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, CircleRadius_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Circle'],
      },
      existenceRule:
        'Exists iff parent center point and path or measure exist and the length or the value is finite and positive.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'The center point.',
              kind: 'Point',
            },
            radius: {
              description:
                'A parent whose length or value provides the radius.',
              kind: 'Measure',
              genus: 'Path',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Circle-CircleByRadius_export.json',
    },
    constrain: function() {
      var centerGobj, p0Vector, radius, r;
      centerGobj = this.getParent('center');
      // backwards compatibility
      if (!centerGobj) {
        centerGobj = this.getParent('p0');
      }
      p0Vector = centerGobj.geom.loc;
      radius = this.getParent('radius');

      if (radius.pathLength) {
        r = radius.pathLength();
      } else {
        r = radius.value;
      }
      this.geom.c = p0Vector;
      this.geom.r = r;

      // Circles with a negative or non-finite radius should not exist to match Desktop behavior.
      this.state.exists =
        this.geom.r > 0 && GSP.math.isFiniteScalar(this.geom.r);
    },

    /*
     * Determine whether two circles are defined by the same parents in such a way that
     * they can be merged, typically used when one is created by a tool and the other already
     * exists in the sketch.
     */
    canMergeTo: function(gobj) {
      // Parents p0 and p1 can be interchanged.
      var a0 = this.getParent('p0'),
        b0 = gobj.getParent('p0'),
        a1 = this.getParent('radius'),
        b1 = gobj.getParent('radius'),
        retVal = false;
      if (!(a0 && b0 && a1 && b1)) {
        GSP.signalErrorWithMessage(
          'Circle by center & radius canMergeTo() missing parents!'
        );
      } else {
        retVal = a0 === b0 && a1 === b1;
      }
      return retVal;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a circle to two defining points.
   */
  GSP.gConstraints.CircleFromTwoPoints = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'Defines a circle from a center point and a point on the circumference.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'Circle_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Circle_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Circle'],
        },
        existenceRule: 'Exists iff parent points exist and are not coincident.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: 'The center of the circle',
                kind: 'Point',
              },
              p1: {
                description: 'A point on the circle',
                kind: 'Point',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Circle-CircleFromTwoPoints_export.json',
      },
      constrain: function() {
        var p0 = this.getParent('p0').geom.loc;
        var p1 = this.getParent('p1').geom.loc;
        this.geom.c = p0;
        this.geom.r = p1.subtract(p0).vLength();
        this.state.exists = Boolean(this.geom.r);
      },
      getParentalNameMFS: function(option) {
        var p0, p1, p0Name, p1Name;
        p0 = this.getParent('p0');
        p1 = this.getParent('p1');
        if (!p0.label) {
          p0.getLabel(option);
        }
        if (!p1.label) {
          p1.getLabel(option);
        }
        p0Name = p0.getNameMFS();
        p1Name = p1.getNameMFS();
        return GSP.mfs.makeHorizontalNamesMFS([p0Name, p1Name]);
      },

      /*
       * Determine whether two circles are defined by the same parents in such a way that
       * they can be merged, typically used when one is created by a tool and the other already
       * exists in the sketch.
       */
      canMergeTo: function(gobj) {
        // Parents p0 and p1 cannot be interchanged.
        var a0 = this.getParent('p0'),
          b0 = gobj.getParent('p0'),
          a1 = this.getParent('p1'),
          b1 = gobj.getParent('p1'),
          retVal = false;
        if (!(a0 && b0 && a1 && b1)) {
          GSP.signalErrorWithMessage(
            'Circle by two points canMergeTo() missing parents!'
          );
        } else {
          retVal = a0 === b0 && a1 === b1;
        }
        return retVal;
      },

      collapseDoubledParent: function(parent) {
        // If there are two point parents collapsed into one, delete the circle
        // after merging any point-on-path child to the merged parent.
        var sketch = this.sQuery.sketch;
        this.children.forEach(function(child) {
          if (child.constraint === 'PointOnPath') {
            sketch.mergeGobjToCandidate(child, parent);
          }
        });
        sketch.gobjList.removeGObjAndDescendants(this);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a circle interior to its parent circle.
   */
  GSP.gConstraints.CircleInterior = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'Defines a circle interior from a circle.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'CircleInterior_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, CircleInterior_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['CircleInterior'],
      },
      existenceRule: 'Exists iff parents exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            circle: {
              description: 'The defining circle',
              kind: 'Circle',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/CircleInterior-CircleInterior_export.json',
    },
    constrain: function() {
      var circle = this.getParent('circle');
      this.geom.c = circle.geom.c;
      this.geom.r = circle.geom.r;
    },
    getParentalNameMFS: function(option) {
      return this.getParent('circle').getNameMFS(option);
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Virtual base class for Colorize constraints
   * @class Colorize
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.Colorize = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.Colorize */ {
      doc: {
        description:
          'Defines a new GObject that is coincident to another GObject, but colored differently.',
        inherits: 'Transform',
        refspec: {
          gspRef: 'Colorization_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: true,
          subKinds: ['Picture'],
        },
        existenceRule: 'Exists iff the parent measures exist and are finite.',

        properties: {
          colorRange: {
            description:
              "Color Range: 'LimitToRange', 'WrapToRange', 'ReflectToRange'",
            type: 'String',
          },
          colorModel: {
            description:
              "Color model of parameters: 'UnivariateHue', 'UnivariateIntensity', 'TrivariateRGB', 'TrivariateHSV'",
            type: 'String',
          },
          parameterDomainFrom: {
            description: 'Lower bound of parameter domain.',
            type: 'Number',
          },
          parameterDomainTo: {
            description: 'Upper bound of parameter domain.',
            type: 'Number',
          },
          style: {
            type: 'Object',
            properties: {
              color: {
                suppressed: true,
              },
            },
          },
        },
      },
      constraintChangesColor: true,

      getTransform: function() {
        return function(point) {
          return point.copy();
        };
      },

      normalizeColorParameter: function(value) {
        var multiple, param;

        param =
          (value - this.parameterDomainFrom) /
          (this.parameterDomainTo - this.parameterDomainFrom);
        multiple = Math.floor(param);
        param = param - multiple;

        if ('LimitToRange' === this.colorRange) {
          if (multiple < 0) {
            param = 0.0;
          } else if (multiple > 0) {
            param = 1.0;
          }
          multiple = 0;
        }

        multiple = Math.abs(multiple);

        if (1 === multiple % 2 && 0 === param) {
          /* Convert wraps to zero (exactly) to 1.0 (exactly) at high end of spectrum */
          multiple--;
          param = 1.0;
        }

        if ('ReflectToRange' === this.colorRange && 1 === multiple % 2) {
          param = 1.0 - param;
        }

        if (param < 0.0) {
          param = 0.0;
        } else if (param > 1.0) {
          param = 1.0;
        }

        return param;
      },

      constrain: function constrain() {
        var color, colorString;

        (constrain.base || arguments.callee.base).call(this);

        color = this.convertToColor();

        if (color) {
          colorString = 'rgb(';
          colorString += Math.floor(255 * color.red);
          colorString += ',';
          colorString += Math.floor(255 * color.green);
          colorString += ',';
          colorString += Math.floor(255 * color.blue);
          colorString += ')';

          this.style.color = colorString;
        }
      },

      constraintVerificationString: function constraintVerificationString(
        iExpected
      ) {
        var msg = (
          constraintVerificationString.base || arguments.callee.base
        ).call(this);

        if (iExpected && iExpected.color) {
          msg += this.testConsistency(
            'color',
            this.style.color,
            iExpected.color
          );
        }

        return msg;
      },
      makeFnLabelPrefix: function(nameOrigin, option) {
        return 'C';
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Curries a function expression to resolve parental relationships.
   * The curried function is placed as the value of the object and is a function
   * of a single numerical variable.
   */
  GSP.gConstraints.Function = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'A calculated expression',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'FunctionM_C',
      },
      usage: {
        abstract: false,
        kinds: ['Expression'],
      },
      existenceRule: 'Exists iff the parent objects exist.',
      properties: {
        parents: {
          description:
            'An associative array of objects used in the expression.',
          type: 'Array',
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Expression-Function_export.json',
    },
    baseUnits: {
      angle: GSP.units.unitFamilies.angle.baseUnit,
      length: GSP.units.unitFamilies.length.baseUnit,
    },
    constrain: function() {
      var theFunction = this;

      //  No need to regenerate the fnExpression because neither our
      // expression nor our parents list has changed. Although the
      // existing fnExpression's result may be different, its code
      // is unchanged.

      this.uValue = this.curryReferences(this, this.parentsList, this.fnUnits);
      this.blank = this.expression === '' || this.determineParentalBlank();

      this.value = function(x) {
        return theFunction.uValue(x) * theFunction.unitMultiplier;
      };
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /*
   * A simple function plot.
   */
  GSP.gConstraints.FunctionPlot = (function() {
    return GSP.makeClass(
      [GSP.gConstraints.Constraint, GSP.mixins.pointVector],
      {
        doc: {
          description: 'A simple function plot',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'FunctionPlot_C',
          },
          usage: {
            abstract: false,
            kinds: ['Sampler'],
          },
          existenceRule:
            'Exists iff the parent function and coordinate system exist and at least one sample of the plot exists',
          properties: {
            parents: {
              properties: {
                function: {
                  description: 'The function evaluated for x',
                  kind: 'Expression',
                },
                coordSys: {
                  description:
                    'The coordinate system in which the function is evaluated.',
                  kind: 'CoordSys',
                },
              },
            },
          },
        },
        getFunctionType: function() {
          var func = this.getParent('function');
          return func && func.expressionType;
        },

        setPlottingInfo: function() {
          var funcType = this.getFunctionType(),
            anglePref = this.sQuery.sketch.preferences.units.angle;

          var plottingInfo = {};

          /*
           * plottingInfo is state of the function plot that describes what kind of
           * plot it is. It may change when calculators edit functions.
           *  - conversionFactor: is the multiplier to apply to the result of the
           *     function to take into account units.  Only applies to polar plots,
           *     and is 1 in non-polar plots
           *  - polar: is this plot a polar plot?
           *  - invertXAndY: true for f(y) and f(r) plots.  False otherwise.
           */
          if (funcType === 'RofT_FunctionExprType') {
            plottingInfo.conversionFactor = GSP.units.convert(
              1,
              'rad',
              anglePref,
              1
            );
            plottingInfo.polar = true;
            plottingInfo.invertXAndY = false;
          } else if (funcType === 'TofR_FunctionExprType') {
            plottingInfo.conversionFactor = GSP.units.convert(
              1,
              anglePref,
              'rad',
              1
            );
            plottingInfo.polar = true;
            plottingInfo.invertXAndY = true;
          } else if (funcType === 'XofY_FunctionExprType') {
            plottingInfo.conversionFactor = 1;
            plottingInfo.polar = false;
            plottingInfo.invertXAndY = true;
          } else if (funcType === 'YofX_FunctionExprType') {
            plottingInfo.conversionFactor = 1;
            plottingInfo.polar = false;
            plottingInfo.invertXAndY = false;
          }

          this.plottingInfo = plottingInfo;
        },

        updateConstraintAncestry: function updateConstraintAncestry() {
          this.setPlottingInfo();

          /* Since function plot does not actually have a real sample gobj, we create
           * a pseudoSampleGObj object to implement the vector api.
           */
          this.pseudoSampleGObj = GSP.makeClass(GSP.mixins.pointVector, {
            fillSingleSample: function(/*vectorContext, index*/) {
              //override of pointVector method just to assert it isn't called.
              //(It is assumed that only the constraint would call this...)
              throw GSP.createError(
                "fillSingleSample() should not be called on functionPlot's sample vector"
              );
            },
            //Instead of filling single samples, the function plot version fills
            //all samples at once.  Most of the work here is in recomputing geomBounds
            setAllSamples: function(vectorContext, samples, numSamples) {
              if (samples) {
                vectorContext.samples = samples;
                vectorContext.filledSampleCount = numSamples;

                //compute geombounds
                var minX = null,
                  maxX = null,
                  minY = null,
                  maxY = null,
                  sampleX,
                  sampleY;

                for (var i = 0; i < samples.length; i += 2) {
                  sampleX = samples[i];
                  sampleY = samples[i + 1];

                  if (isFinite(sampleX) && isFinite(sampleY)) {
                    minX = minX === null || sampleX < minX ? sampleX : minX;
                    minY = minY === null || sampleY < minY ? sampleY : minY;
                    maxX = maxX === null || sampleX > maxX ? sampleX : maxX;
                    maxY = maxY === null || sampleY > maxY ? sampleY : maxY;
                  }
                }
                vectorContext.geomBounds = {
                  left: minX,
                  top: minY,
                  right: maxX,
                  bottom: maxY,
                };
              } else {
                vectorContext.samples = null;
                vectorContext.filledSampleCount = 0;
                vectorContext.geomBounds = null;
              }
            },
          });
          this.vectorContext = this.pseudoSampleGObj.createVectorContext(
            this.numSamples,
            this,
            false
          );
          this.vectorContext.isDiscrete = this.isDiscrete;
        },
        /**
        Returns true if sampling the function is required, false otherwise.
        @param    {Object}  sketch -- the current sketch object
        @returns  {Boolean} True if sampling is required, false otherwise.
       */
        isSamplingRequired: function(sketch) {
          var func = this.getParent('function');
          // We obviously need to be constrained, otherwise we wouldn't be
          // here.  If the function also needs to be constrained in this
          // constraint cycle or if we haven't sampled the function yet,
          // or if its domain has changed as a result of endpoint
          // dragging, then we must sample.
          return (
            !this.rawSamples ||
            this.state.constraintFrame <= func.state.constraintFrame
          );
        },

        /* Given a domainal value, returns the value of the x (or theta)
         * coordinate of the point to plot. Here this is just identity,
         * but it is overridden by parametric curves. */
        xFunc: function(xD) {
          return xD;
        },

        /*
         * A simple evenly spaced sample set with no adjustment for boundary
         * conditions. Returns a JavaScript array of x,y double values. Even indexed
         * values are x, odd indexed values are y.
         * This method performs the job of normalizing x and y (so that x is always
         * the x axis) as well as normalizing polar functions to (x,y) coordinates.
         * The returned array is 'ready to use' except for the scaling for the
         * coordinate system.
         *
         * If all samples are NaN, we return false, rather than an array of samples.
         *
         */
        computeSamples: function() {
          var func = this.getParent('function').uValue,
            lowerX = this.driverDomain.low,
            upperX = this.driverDomain.high,
            num = this.numSamples,
            samples = GSP.createFloatVector(num * 2),
            xD,
            x,
            y,
            dx = (upperX - lowerX) / (num - 1),
            ix,
            someExist = false,
            conversionFactor = this.plottingInfo.conversionFactor,
            polar = this.plottingInfo.polar,
            invertXAndY = this.plottingInfo.invertXAndY,
            temp,
            r,
            theta;

          for (ix = 0; ix < num; ++ix) {
            xD = dx * ix + lowerX;
            x = this.xFunc(xD);
            y = func(xD) * conversionFactor;
            if (!someExist && isFinite(y)) {
              someExist = true;
            }

            if (invertXAndY) {
              temp = x;
              x = y;
              y = temp;
            }

            if (polar) {
              theta = x;
              r = y;

              x = r * Math.cos(theta);
              y = r * Math.sin(theta);
            }

            samples[2 * ix] = x;
            samples[2 * ix + 1] = y;
          }
          return someExist && samples;
        },

        updateDomain: function(sketchRect) {
          var coordSys = this.getParent('coordSys'),
            domain = this.driverDomain,
            left,
            right,
            origin,
            unit0,
            unit1,
            xUnitSize,
            yUnitSize;

          this.funcType = this.getFunctionType();

          if (this.funcType === 'RofT_FunctionExprType') {
            domain.low = 0;
            domain.high = 2 * Math.PI;
          } else {
            if (coordSys.state.exists) {
              origin = coordSys.geom.origin;
              if (this.funcType === 'XofY_FunctionExprType') {
                unit1 = coordSys.geom.unit1;
                yUnitSize = origin.y - unit1.y;
                domain.high = -(sketchRect.top - origin.y) / yUnitSize;
                domain.low = -(sketchRect.bottom - origin.y) / yUnitSize;
              } else {
                left = sketchRect.left;
                right = sketchRect.right;
                unit0 = coordSys.geom.unit0;
                xUnitSize = unit0.x - origin.x;
                domain.high = (right - origin.x) / xUnitSize;
                if (this.funcType === 'TofR_FunctionExprType') {
                  // Functions of r have positive domains initially. If
                  // the origin is to the right of the screen right, then we choose a
                  // default high parameter equal to half the width of the screen.
                  domain.low = 0;
                  if (domain.high < 0)
                    domain.high = (right - left) / 2 / xUnitSize;
                } else {
                  domain.low = (left - origin.x) / xUnitSize;
                }
              }
            } else {
              domain.low = 10.0;
              domain.high = -10.0;
            }
          }
        },

        initConstraint: function() {
          this.funcType = this.getFunctionType();
        },

        parentsExist: function() {
          var func = this.getParent('function'),
            coordSys = this.getParent('coordSys');

          return func && coordSys && func.state.exists && coordSys.state.exists;
        },

        domainNeedsUpdate: function() {
          // Only update the domain if the funcType has been changed.
          return this.funcType !== this.getFunctionType();
        },

        constrain: function(sketch) {
          var coordSys = this.getParent('coordSys'),
            parentsExist = this.parentsExist(),
            samplingRequired = this.isSamplingRequired(sketch);

          if (parentsExist) {
            // We only need to resample the function if the function has changed.
            // For uniform sampling, sampling isn't required if the axis changes.
            if (samplingRequired) {
              if (this.domainNeedsUpdate()) {
                this.updateDomain(sketch.sketchRect());
              }
              this.rawSamples = this.computeSamples();
            }

            if (this.rawSamples) {
              // Convert the function samples to screen coordinates
              var convertedSamples = coordSys.vectorLocatePlot(this.rawSamples);
              this.pseudoSampleGObj.setAllSamples(
                this.vectorContext,
                convertedSamples,
                this.numSamples
              );
              if (samplingRequired) {
                this.pseudoSampleGObj.recomputeDiscontinuities(
                  this.vectorContext
                );
              }
            } else {
              this.pseudoSampleGObj.setAllSamples(this.vectorContext, null);
            }
          }

          this.state.exists = this.rawSamples && parentsExist;
        },
        samplerPathLength: function() {
          return this.pseudoSampleGObj.pathLengthForVector(this.vectorContext);
        },
        getParentalNameMFS: function(option) {
          var func = this.getParent('function'),
            coordSys = this.getParent('coordSys'),
            xAxis = coordSys.getParent('axisX'),
            yAxis = coordSys.getParent('axisY'),
            funcType = func.expressionType,
            indMfs,
            depMfs;

          if (
            funcType === 'RofT_FunctionExprType' ||
            funcType === 'YofX_FunctionExprType'
          ) {
            indMfs = xAxis.getNameMFS(option);
            depMfs = yAxis.getNameMFS(option);
          } else {
            //XofY_FunctionExprType
            //TofR_FunctionExprType
            depMfs = xAxis.getNameMFS(option);
            indMfs = yAxis.getNameMFS(option);
          }

          return GSP.mfs.makeHorizontalMFS(
            depMfs,
            GSP.mfs.makeTextMFS(' = '),
            func.getLabelMFS(),
            GSP.mfs.makeTextMFS('('),
            indMfs,
            GSP.mfs.makeTextMFS(')')
          );
        },
        //tricks sampler into using us to do the rendering
        //alternately we could have a small object private to this module that
        //really implemented vector methods and return it.
        sampleGObj: function() {
          return this.pseudoSampleGObj;
        },
        samplerPathValueToPosition: function(iPathValue, output) {
          var func = this.getParent('function'),
            coordSys = this.getParent('coordSys'),
            plottingInfo = this.plottingInfo,
            plot = this,
            pos;

          function locatePlotFromPathValue(iPathValue) {
            var xD = iPathValue,
              x = plot.xFunc(xD),
              y = func.uValue(xD) * plottingInfo.conversionFactor,
              temp,
              r,
              theta;

            if (plottingInfo.invertXAndY) {
              temp = x;
              x = y;
              y = temp;
            }

            if (plottingInfo.polar) {
              theta = x;
              r = y;

              x = r * Math.cos(theta);
              y = r * Math.sin(theta);
            }
            return coordSys.locatePlot(x, y);
          }

          pos = locatePlotFromPathValue(iPathValue);

          if (output && pos.isDefined()) {
            output.derivative = GSP.math
              .secantApproximationToDerivative(
                iPathValue,
                pos,
                locatePlotFromPathValue
              )
              .multiply(this.driverDomain.high - this.driverDomain.low);
          }

          return pos;
        },
        samplerPositionToPathValue: function(iPosition) {
          var value = this.pseudoSampleGObj.positionToPathValueForVector(
              this.vectorContext,
              iPosition
            ),
            span = this.driverDomain.high - this.driverDomain.low;

          return this.driverDomain.low + value * span;
        },
        samplerConstrainRange: function(v) {
          var result = v,
            low = this.driverDomain.low,
            high = this.driverDomain.high;

          if (v > high) {
            result = high;
          }

          if (v < low) {
            result = low;
          }

          return result;
        },
        samplerIsValueInBounds: function(v) {
          return v >= this.driverDomain.low && v <= this.driverDomain.high;
        },
      }
    );
  })();

  GSP.gConstraints.ParametricCurvePlot = (function() {
    return GSP.makeClass(GSP.gConstraints.FunctionPlot, {
      doc: {
        description:
          'A parametric plot graphs two functions on a coordinate system. Each plotted point (x, y) or (r, theta) corresponds to a particular value of an independent variable. This independent variable is used to evaluate each of the two functions.',
        inherits: 'FunctionPlot',
        usage: {
          abstract: true,
          kinds: ['Sampler'],
        },
        existenceRule:
          'Exists iff both parent functions and the coordinate system exist and at least one sample of the plot exists',
        properties: {
          parents: {
            properties: {
              xFunction: {
                description: 'The function evaluated for x',
                kind: 'Expression',
              },
            },
          },
        },
      },

      xFunc: function(xD) {
        return this.getParent('xFunction').uValue(xD);
      },

      parentsExist: function parentsExist() {
        var xFunc = this.getParent('xFunction'),
          exists = (parentsExist.base || arguments.callee.base).call(this);

        return exists && xFunc && xFunc.state.exists;
      },

      domainNeedsUpdate: function() {
        // never update the domain
        return false;
      },

      isSamplingRequired: function isSamplingRequired(sketch) {
        var xFunc = this.getParent('xFunction');

        if (
          (isSamplingRequired.base || arguments.callee.base).call(this, sketch)
        )
          return true;

        return this.state.constraintFrame <= xFunc.state.constraintFrame;
      },

      setPlottingInfo: function() {
        this.plottingInfo = {
          conversionFactor: 1,
          polar: this.isPolarCurve,
          invertXAndY: false,
        };
      },
    });
  })();

  GSP.gConstraints.ParametricCartesianCurvePlot = (function() {
    return GSP.makeClass(GSP.gConstraints.ParametricCurvePlot, {
      doc: {
        description: 'A parametric curve plotted using Cartesian coordinates',
        inherits: 'ParametricCurvePlot',
        refspec: {
          gspRef: 'ParametricCartesianCurvePlot_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ParametricCartesianCurvePlot_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      isPolarCurve: false,
    });
  })();

  GSP.gConstraints.ParametricPolarCurvePlot = (function() {
    return GSP.makeClass(GSP.gConstraints.ParametricCurvePlot, {
      doc: {
        description: 'A parametric curve plotted using Polar coordinates',
        inherits: 'ParametricCurvePlot',
        refspec: {
          gspRef: 'ParametricCartesianCurvePlot_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ParametricPolarCurvePlot_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      isPolarCurve: true,
    });
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * The intersection of two straight objects
   */
  GSP.gConstraints.Intersection = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'A point defined by the intersection of two <span class="kind">Straight</span> objects.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'InterLL_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, InterLL_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Point'],
      },
      existenceRule:
        'Exists iff parents exist and are not parallel and the intersection point is within the extent of both parents. E.g., the lines containing two segments might intersect outside the extent of the segments. In this case the intersection point for the segments would not exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            line0: {
              description: '',
              kind: 'Straight',
            },
            line1: {
              description: '',
              kind: 'Straight',
            },
          },
        },
        style: {
          description: 'Appearance of GObject',
          properties: {
            color: {
              description: '"(black)',
              type: 'Color',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection_export.json',
    },
    constrain: function() {
      var ln0 = this.getParent('line0');
      var ln1 = this.getParent('line1');
      this.geom.loc = GSP.Geom.LineLineIntersection(ln0, ln1);
      this.state.exists = this.geom.loc.isDefined();
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a line to its two definition points.
   */
  GSP.gConstraints.Line = GSP.makeClass(GSP.gConstraints.Straight, {
    doc: {
      description: 'A straight line that extends to infinity.',
      inherits: 'Straight',
      refspec: {
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Straight'],
      },
      existenceRule:
        'Exists iff the parent points exist and are not coincident.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'First reference point defining the line',
              kind: 'Point',
            },
            p1: {
              description: 'Second reference point defining the line',
              kind: 'Point',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Line_export.json',
    },
    overbarType: 4,
    /**
     * Returns the nearest point on the path.
     */
    getPointOnPath: function(path, distance) {
      return this.getPointOnLine(path, distance);
    },
    constrain: function() {
      var p0, p1, p1m0, len, multiplier, begin, end;
      p0 = this.getStraightP0();
      this.geom.p0 = p0;
      p1 = this.getStraightP1();
      this.geom.p1 = p1;
      p1m0 = p1.subtract(p0);
      if (p1m0.isZeroLength()) {
        this.geom.xp0 = GSP.GeometricPoint(0, 0);
        this.geom.xp1 = GSP.GeometricPoint(0, 0);
      } else {
        len = p1m0.vLength();
        multiplier = 10000 / len;
        begin = p0.add(p1m0.multiply(-multiplier));
        end = p0.add(p1m0.multiply(multiplier));
        this.geom.xp0 = begin;
        this.geom.xp1 = end;
      }
      this.state.exists = !p1m0.isZeroLength();
      //GSP.log("p0: " + p0 + ", p1: " + end);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of an angle between two lines
   */
  GSP.gConstraints.MeasurementAngle = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description: 'The measurement of an angle defined by three points.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'Angle3PointsMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Angle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parent points exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: '',
                kind: 'Point',
              },
              p1: {
                description: '',
                kind: 'Point',
              },
              p2: {
                description: '',
                kind: 'Point',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementAngle_export.json',
      },
      unitPowers: { angle: 1 },
      constrain: function() {
        var a = this.getParent('p0').geom.loc,
          b = this.getParent('p1').geom.loc,
          c = this.getParent('p2').geom.loc,
          angle,
          units = this.sQuery().prefs().units.angle;

        angle = GSP.GeometricPoint.threePointFlippedAngle(a, b, c);

        // degree unit in sketchpad implies positive measured interior angle.
        if (units === 'deg') {
          if (angle < 0) {
            angle += 2 * Math.PI;
          }
          // Convert angles that are obviously exterior angles to interior.
          if (angle > Math.PI) {
            angle = 2 * Math.PI - angle;
          }
        }

        this.value = angle;
        // Convert to document units.
        this.uValue = GSP.units.convert(angle, 'radians', units);
      },
      getParentalNameMFS: function(option) {
        var parents,
          ix,
          par,
          name,
          names = [],
          nameMFS,
          italic = this.getMathItalicization();

        parents = this.parentsList;
        for (ix = 0; ix < parents.length; ix += 1) {
          par = parents[ix];
          name = par.getNameMFS(option);
          names.push(name);
        }
        nameMFS = GSP.mfs.makeHorizontalNamesMFS(names);

        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('m', italic),
          { type: 'symbol', value: 'd0' },
          nameMFS
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the value of an angle marker
   */
  GSP.gConstraints.MeasurementAngleMarker = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description: 'The value of an angle marker',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'AngleMarkerMeasure_C',
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parent marker exists.',
        properties: {
          parents: {
            properties: {
              marker: {
                description: 'The AngleMarker to be measured',
                kind: 'AngleMarker',
              },
            },
          },
        },
      },
      unitPowers: { angle: 1 },
      genus: 'AngleMeasure',
      constrain: function() {
        var marker = this.getParent('marker'),
          units = this.sQuery().prefs().units.angle,
          angle;
        // convert "true" coordinate angle to primal angle,
        //since primal coordinate system is upside down
        angle = -marker.value;
        this.value = angle;

        if (units === 'deg') {
          if (angle < 0) {
            angle = -angle;
          }
        }

        // Convert to document units.
        this.uValue = GSP.units.convert(angle, 'radians', units);
      },
      getParentalNameMFS: function(option) {
        var marker = this.getParent('marker'),
          name;
        name = marker.getNameMFS(option);
        if (GSP.mfs.isEmptyTextMFS(name)) {
          name = GSP.mfs.makeTextMFS(marker.id);
        }
        var italicName = GSP.mfs.makeItalicMFS(name);
        var horizontals = [
          GSP.mfs.makeTextMFS('m', true),
          { type: 'symbol', value: 'd0' },
          italicName,
        ];
        // call variadic function
        return GSP.mfs.makeHorizontalMFS.apply(this, horizontals);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the area of a polygon, circle, or circle interior.
   */
  GSP.gConstraints.MeasurementArea = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the area of a <span class="kind">Polygon</span>, <span class="kind">Circle</span>, or <span class="kind">CircleInterior</span>.',
        inherits: 'Constraint',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TBD, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule:
          'Exists iff the parent points exist and are not all coincident.',
        properties: {
          parents: {
            description: '',
            properties: {
              shape: {
                description: '',
                kind: 'Arc|Circle|Polygon',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementArea_export.json',
      },
      unitPowers: { length: 2 },
      constrain: function() {
        var area, shapeGobj;

        shapeGobj = this.getParent('shape');
        area = shapeGobj.area();

        this.value = area;
        this.uValue = GSP.units.convertFromBaseToUnitObject(
          area,
          this.unitsObject
        );
      },
      getParentalNameMFS: function(option) {
        var shape = this.getParent('shape'),
          buf = [GSP.mfs.makeTextMFS('Area ')];
        if (shape.kind === 'Circle' || shape.kind === 'CircleInterior') {
          buf.push({ type: 'symbol', value: '100' });
        }
        buf.push(
          GSP.mfs.makeItalicMFS(
            GSP.mfs.makeHorizontalMFS(shape.getNameMFS(option))
          )
        );
        // variadic call
        return GSP.mfs.makeHorizontalMFS.apply(this, buf);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the circumference of a circle.
   */
  GSP.gConstraints.MeasurementCircumference = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the circumference of a <span class="kind">Circle</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'CircumferenceM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, CircumferenceM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parent circle exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              shape: {
                description: 'The circle whose circumference is to be measured',
                kind: 'Circle',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementCircumference_export.json',
      },
      unitPowers: { length: 1 },
      constrain: function() {
        var circumference,
          shape,
          units = this.sQuery().prefs().units.length;
        shape = this.getParent('shape');
        circumference = shape.circumference();

        this.value = circumference;
        this.uValue = GSP.units.convert(circumference, 'pixels', units);
      },
      getParentalNameMFS: function(option) {
        var shape = this.getParent('shape'),
          name = shape.getNameMFS(option);
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('Circumference '),
          { type: 'symbol', value: '100' },
          GSP.mfs.makeItalicMFS(name)
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementCoordinateBased = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The parent class for all coordinate-system based constraints.',
        inherits: 'Constraint',
        usage: {
          abstract: true,
          kinds: ['Measure'],
        },
        properties: {
          parents: {
            description: '',
            properties: {
              coordSys: {
                description: 'The coordinate system used for the measurements',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      unitPowers: { scalar: 1 },
      /* Given a Point GObj, return its coordinates as a GeometricPoint */
      getCoordinates: function(pointGObj) {
        var coordSys = this.getParent('coordSys');
        return coordSys.locatePoint(pointGObj.geom.loc);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the distance between a point and either another
   * point or a Straight.
   */
  GSP.gConstraints.MeasurementDistance = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the distance between two <span class="kind">Point</span>s.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'DistanceM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, DistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parent points exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: 'The point from which distance is to be measured',
                kind: 'Point',
              },
              obj0: {
                description:
                  'The point or line to which distance is to be measured',
                kind: 'Point|Straight',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementDistance_export.json',
      },
      unitPowers: { length: 1 },
      constrain: function() {
        var dist,
          p0gobj,
          obj0gobj,
          p0,
          p1,
          units = this.sQuery().prefs().units.length;
        p0gobj = this.getParent('p0');
        p0 = p0gobj.geom.loc;
        // obj0 is either a point kind or a straight kind
        obj0gobj = this.getParent('obj0');
        if (obj0gobj.kind === 'Point') {
          p1 = obj0gobj.geom.loc;
          dist = p1.subtract(p0).vLength();
        } else if (obj0gobj.isOfKind('Straight')) {
          p1 = obj0gobj.getClosestPointOnLine(
            { p0: obj0gobj.getZeroPoint(), p1: obj0gobj.getUnitPoint() },
            p0
          );
          dist = p1.subtract(p0).vLength();
        } else {
          GSP.log(
            this.id +
              ': Cannot compute distance from point to object: ' +
              obj0gobj.id +
              '(' +
              obj0gobj.kind +
              ')'
          );
        }

        this.value = dist;
        this.uValue = GSP.units.convert(dist, 'pixels', units);
      },
      getParentalNameMFS: function(option) {
        var p0, obj0, p0Name, obj0Name;
        p0 = this.getParent('p0');
        obj0 = this.getParent('obj0');
        if (!p0.label) {
          p0.getLabel(option);
        }
        if (!obj0.label) {
          obj0.getLabel(option);
        }
        p0Name = p0.getNameMFS();
        obj0Name = obj0.getNameMFS();
        if (obj0.kind === 'Straight') {
          return GSP.mfs.makeHorizontalMFS(
            GSP.mfs.makeTextMFS('Distance '),
            GSP.mfs.makeItalicMFS(GSP.mfs.makeHorizontalMFS(p0Name)),
            GSP.mfs.makeTextMFS(' to '),
            GSP.mfs.makeItalicMFS(GSP.mfs.makeHorizontalMFS(obj0Name))
          );
        } else {
          return GSP.mfs.makeItalicMFS(
            GSP.mfs.makeHorizontalNamesMFS([p0Name, obj0Name])
          );
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the length of a Segment.
   */
  GSP.gConstraints.MeasurementLength = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the length of a <span class="constraint">Segment</span>s.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'LengthM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, LengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule:
          'Exists if the parent segment exists. Also exists if the parent segment is an original segment and end-points are coincident. Then, the length is zero.',
        properties: {
          parents: {
            description: '',
            properties: {
              path: {
                description: '',
                genus: 'Path',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementLength_export.json',
      },
      unitPowers: { length: 1 },
      /*
       * Override default for length measurement. If parent does not exist
       * the measure has a zero length.
       */
      checkParentsExist: function() {
        return true;
      },
      checkExists: function() {
        var segment = this.getParent('path');
        if (segment.state.exists) {
          return true;
        }
        if (
          segment.constraint === 'Segment' &&
          segment.getParent('p0').state.exists &&
          segment.getParent('p1').state.exists
        ) {
          return true;
        }
        return false;
      },
      constrain: function() {
        var len,
          segment = this.getParent('path'),
          units = this.sQuery().prefs().units.length;

        this.state.exists = this.checkExists();
        if (this.state.exists) {
          len = segment.state.exists ? segment.pathLength() : 0;
          this.value = len;
          this.uValue = GSP.units.convert(len, 'pixels', units);
        }
      },
      getParentalNameMFS: function(option) {
        var name,
          path = this.getParent('path'),
          ital = this.getMathItalicization(),
          //labeled or transformed objects omit the leading 'm'
          buf =
            path.label || path.isTransformationConstraint
              ? []
              : [GSP.mfs.makeTextMFS('m ', ital)];

        name = path.getNameMFS(option);
        if (GSP.mfs.isEmptyTextMFS(name)) {
          name = GSP.mfs.makeTextMFS(path.id, ital);
        }

        buf.push(name);
        // variadic call
        return GSP.mfs.makeHorizontalMFS.apply(this, buf);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the perimeter of a polygon.
   */
  GSP.gConstraints.MeasurementPerimeter = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the perimeter of a <span class="kind">Polygon</span>s.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'PerimeterM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PerimeterM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule:
          'Exists iff the parent points all exist and are not coincident.',
        properties: {
          parents: {
            description: '',
            properties: {
              shape: {
                description: '',
                kind: 'Arc|Polygon',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementPerimeter_export.json',
      },
      unitPowers: { length: 1 },
      constrain: function() {
        var perimeter, shape, units;
        shape = this.getParent('shape');
        perimeter = shape.perimeter();
        units = this.sQuery().prefs().units.length;

        this.value = perimeter;
        this.uValue = GSP.units.convert(perimeter, 'pixels', units);
      },
      getParentalNameMFS: function(option) {
        var shape = this.getParent('shape');
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('Perimeter '),
          GSP.mfs.makeItalicMFS(shape.getNameMFS(option))
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the radius of a circle.
   */
  GSP.gConstraints.MeasurementRadius = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the radius of a <span class="kind">Circle</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'RadiusM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, RadiusM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parent circle exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              shape: {
                description: '',
                kind: 'Arc|Circle',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementRadius_export.json',
      },
      unitPowers: { length: 1 },
      constrain: function() {
        var radius,
          circleGobj,
          units = this.sQuery().prefs().units.length;
        circleGobj = this.getParent('shape');
        radius = circleGobj.radius();
        if (!isFinite(radius)) {
          radius = Number.POSITIVE_INFINITY;
        }

        this.value = radius;
        this.uValue = GSP.units.convert(radius, 'pixels', units);
      },
      getParentalNameMFS: function(option) {
        var buf = [GSP.mfs.makeTextMFS('Radius ')],
          shape = this.getParent('shape').kind;
        if (shape === 'Circle' || shape === 'CircleInterior') {
          buf.push({ type: 'symbol', value: '100' });
        }
        buf.push(
          GSP.mfs.makeItalicMFS(this.getParent('shape').getNameMFS(option))
        );
        // variadic call
        return GSP.mfs.makeHorizontalMFS.apply(this, buf);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the ratio of the lengths of two segments or
   * distances from a point to two colinear points.
   */
  GSP.gConstraints.MeasurementRatio = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the ratio of two segments or three points.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'RatioM_C',
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule:
          'Exists iff the parent points all exist and are not coincident.',
        properties: {
          parents: {
            description: '',
            properties: {
              // TODO: Consider splitting into two constraints:
              // MeasurementRatioOfTwoSegments and MeasurementRatioOfThreePoints
              obj0: {
                description: 'First segment or point',
                kind: 'Straight|Point',
              },
              obj1: {
                description: 'Second segment or point',
                kind: 'Straight|Point',
              },
              obj2: {
                description: 'Third point',
                kind: 'Point',
                required: false,
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Measure-MeasurementRatio_export.json',
      },
      unitPowers: { scalar: 1 },
      ratioFromTwoSegments: function() {
        var seg0 = this.getParent('obj0'),
          seg1 = this.getParent('obj1'),
          ratio;
        this.state.exists = seg0.state.exists && seg1.state.exists;
        if (this.state.exists) {
          ratio = seg0.pathLength() / seg1.pathLength();
          return ratio;
        }
      },
      ratioFromThreePoints: function() {
        var p0 = this.getParent('obj0'),
          p1 = this.getParent('obj1'),
          p2 = this.getParent('obj2'),
          ratio;
        this.state.exists =
          p0.state.exists && p1.state.exists && p2.state.exists;
        if (this.state.exists) {
          ratio = GSP.GeometricPoint.mapPointToLine(
            p0.geom.loc,
            p1.geom.loc,
            p2.geom.loc
          ).param;
          /* Per desktop, we interpret a 3-point ratio is defined as +infinite, rather than undefined,
                  if its denominator is zero but its numerator non-zero. */
          if (isNaN(ratio)) {
            if (
              p0.geom.loc.equals(p1.geom.loc) &&
              !p1.geom.loc.equals(p2.geom.loc)
            ) {
              ratio = Number.POSITIVE_INFINITY;
            }
          }
          return ratio;
        }
      },
      constrain: function() {
        var ratio,
          obj0 = this.getParent('obj0');

        if (obj0.kind === 'Straight') {
          ratio = this.ratioFromTwoSegments();
        } else {
          ratio = this.ratioFromThreePoints();
        }
        this.value = ratio;
        this.uValue = ratio;
      },
      nameFromTwoSegments: function(option) {
        var seg0 = this.getParent('obj0'),
          seg1 = this.getParent('obj1');
        if (!seg0.label) {
          seg0.getLabel(option);
        }
        if (!seg1.label) {
          seg1.getLabel(option);
        }
        return {
          type: 'fraction',
          value: [
            GSP.mfs.makeHorizontalMFS(
              GSP.mfs.makeTextMFS('m ', true),
              seg0.getNameMFS()
            ),
            GSP.mfs.makeHorizontalMFS(
              GSP.mfs.makeTextMFS('m ', true),
              seg1.getNameMFS()
            ),
          ],
        };
      },
      nameFromThreePoints: function(option) {
        var p0 = this.getParent('obj0'),
          p1 = this.getParent('obj1'),
          p2 = this.getParent('obj2');
        if (!p0.label) {
          p0.getLabel(option);
        }
        if (!p1.label) {
          p1.getLabel(option);
        }
        if (!p2.label) {
          p2.getLabel(option);
        }

        return {
          type: 'fraction',
          value: [
            GSP.mfs.makeHorizontalNamesMFS([p0.getNameMFS(), p2.getNameMFS()]),
            GSP.mfs.makeHorizontalNamesMFS([p0.getNameMFS(), p1.getNameMFS()]),
          ],
        };
      },
      getParentalNameMFS: function(option) {
        var buf,
          obj0 = this.getParent('obj0');
        if (obj0.kind === 'Straight') {
          buf = this.nameFromTwoSegments(option);
        } else {
          buf = this.nameFromThreePoints(option);
        }
        return buf;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the radius of a circle.
   */
  GSP.gConstraints.MeasurementValueOfPointOnPath = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description: 'The measurement of the value of a point on path',
        inherits: 'Constraint',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TBD, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule:
          'Exists iff the parent points exist and are not all coincident.',
        properties: {
          parents: {
            properties: {
              point: {
                description: 'The point',
                kind: 'Point',
              },
              path: {
                description: 'The path that the point lives on.',
                genus: 'Path',
              },
            },
          },
        },
      },
      unitPowers: { scalar: 1 },
      constrain: function(sketch) {
        var point, path;
        point = this.getParent('point');
        path = this.getParent('path');

        this.value = path.mapPositionToPathValue(point.geom.loc);
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        var point = this.getParent('point'),
          path = this.getParent('path');
        if (!point.label) {
          point.getLabel(option);
        }
        if (!point.label) {
          point.getLabel(option);
        }
        return GSP.mfs.makeHorizontalMFS(
          point.getNameMFS(),
          GSP.mfs.makeTextMFS(' on '),
          path.getNameMFS()
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.MultimeasureBase = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description: 'Abstract class for multimeasure constraints .',
        inherits: 'Constraint',
        usage: {
          abstract: true,
          kinds: ['Text'],
        },
        existenceRule: 'Exists iff the parents exist.',
      },
      isMultimeasure: true,
      //An array of key-value pairs for the value portions of the multimeasure
      //eg. rect cooridante might have the kexy: xValue, yValue

      /*
       * A Multimeasure has a collection of numeric values indexed by key.  It is a
       * requirement of a multimeasure that the same sets of keys are in the values,
       * precisions, and units properties.  The precisions and units properties
       * inform the multimeasure how to format and display a given value in the
       * values array.
       */
      values: {},

      // valuesMFS is used by embedding clients, eg. hotText. It contains
      // the value of the measurement, without a name in the front.
      valuesMFS: null,

      precisions: {},
      units: {},
      initTextMFS: function() {
        GSP.signalErrorWithMessage('Multimeasures must implement initTextMFS');
      },
      initUnits: function() {
        GSP.signalErrorWithMessage('Multimeasures must implement initUnits');
      },
      initPrecision: function() {
        GSP.signalErrorWithMessage(
          'Multimeasures must implement initPrecision'
        );
      },
      initConstraint: function() {
        this.initUnits();
        this.initPrecision();
      },

      updateLabelForConstraint: function updateLabelForConstraint() {
        (
          updateLabelForConstraint.base || updateLabelForConstraint.callee.base
        ).call(this);
        this.initTextMFS();
      },
      /**
       * Returns a object whose keys are the same keys found in the values/precesions/
       * units objects, and whose objects are full MFS representations of the value.
       *
       * Currently we do no caching, but could easily cache the mfs representations
       * and reuse them unless the values change.
       */
      getValuesAsMFS: function() {
        var theMultimeasure = this,
          ret = {};

        if (!theMultimeasure.formatNumberAsMFS) {
          GSP.signalErrorWithMessage(
            'multimeasures are required to be Text kind'
          );
        }

        $.each(theMultimeasure.values, function(key, value) {
          ret[key] = theMultimeasure.formatNumberAsMFS(
            value,
            theMultimeasure.precisions[key],
            theMultimeasure.units[key],
            false
          );
        });
        return ret;
      },

      getMultiMeasureParentLabelMFS: function() {
        var point = this.getParent('point');
        if (!point.label) {
          point.getLabel({ create: true });
        }
        return point.getNameMFS();
      },

      getColorableComponent: function() {
        return 'TextGObject_BackgroundContrast';
      },
      verificationString: function verificationString(expected, args) {
        //No Test
        return '';
      },
      getMFSAppearanceForVariant: function() {
        var returnedMFS = $.extend(true, {}, this.valuesMFS);
        GSP.mfs.realizeParamNodes(returnedMFS, this.getValuesAsMFS());

        return returnedMFS;
      },
      getMFSListSeparator: function() {
        return GSP.mfs.makeTextMFS(', ');
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.MeasurementRectCoordinates = GSP.makeClass(
    GSP.gConstraints.MultimeasureBase,
    {
      doc: {
        description:
          'The (x, y) coordinates of a point relative to a coordinate system.',
        inherits: 'MultiMeasureBase',
        refspec: {
          gspRef: 'RectCoordinateM_C',
          msg:
            'This constraint is intended to behave in the same way as the corresponding constraint, ' +
            "RectCoordinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Text'],
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      initTextMFS: function() {
        var xValMFS = { type: 'parameter', value: 'xValue' },
          yValMFS = { type: 'parameter', value: 'yValue' },
          horizontalNode = GSP.mfs.makeHorizontalMFS(
            xValMFS,
            this.getMFSListSeparator(),
            yValMFS
          );

        this.valuesMFS = {
          type: 'paren',
          value: [horizontalNode],
        };

        this.parsedMFS = GSP.mfs.makeHorizontalMFS(
          this.getMultiMeasureParentLabelMFS(),
          GSP.mfs.makeTextMFS(': '),
          this.valuesMFS
        );
      },
      initUnits: function() {
        this.units = {
          xValue: 'scalar',
          yValue: 'scalar',
        };
      },
      initPrecision: function() {
        var preferences = this.sQuery().prefs(),
          scalarPrecision = preferences.precision.scalar;

        this.precisions = {
          xValue: scalarPrecision,
          yValue: scalarPrecision,
        };
      },
      constrain: function() {
        var coordSys = this.getParent('coordSys'),
          point = this.getParent('point'),
          pos = coordSys.locatePoint(point.geom.loc);

        this.values = {
          xValue: pos.x,
          yValue: pos.y,
        };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.MeasurementPolarCoordinates = GSP.makeClass(
    GSP.gConstraints.MultimeasureBase,
    {
      doc: {
        description:
          'The (r, theta) coordinates of a point relative to a coordinate system.',
        inherits: 'MultiMeasureBase',
        refspec: {
          gspRef: 'PolarCoordinateM_C',
          msg:
            'This constraint is intended to behave in the same way as the corresponding constraint, ' +
            "PolarCoordinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Text'],
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      initTextMFS: function() {
        var rValMFS = { type: 'parameter', value: 'rValue' },
          thetaValMFS = { type: 'parameter', value: 'thetaValue' },
          unitObject = GSP.units.makeUnitObjectFromUnitsAndPowers(
            { angle: this.units.thetaValue },
            { angle: 1 }
          ),
          angleUnitsMFS = GSP.units.getMFSForUnitObject(unitObject),
          horizontalNode = GSP.mfs.makeHorizontalMFS(
            rValMFS,
            this.getMFSListSeparator(),
            thetaValMFS,
            angleUnitsMFS
          );

        this.valuesMFS = {
          type: 'paren',
          value: [horizontalNode],
        };

        this.parsedMFS = GSP.mfs.makeHorizontalMFS(
          this.getMultiMeasureParentLabelMFS(),
          GSP.mfs.makeTextMFS(': '),
          this.valuesMFS
        );
      },
      initUnits: function() {
        var units = this.sQuery().prefs().units;

        this.units = {
          rValue: 'scalar',
          thetaValue: units.angle,
        };
      },
      initPrecision: function() {
        var preferences = this.sQuery().prefs();

        this.precisions = {
          rValue: preferences.precision.scalar,
          thetaValue: preferences.precision.angle,
        };
      },
      constrain: function() {
        var coordSys = this.getParent('coordSys'),
          point = this.getParent('point'),
          pos = coordSys.locatePoint(point.geom.loc),
          dist = pos.vLength(),
          angle = Math.atan2(pos.y, pos.x);

        this.values = {
          rValue: dist,
          thetaValue: GSP.units.convert(
            angle,
            'radians',
            this.units.thetaValue
          ),
        };
      },
    }
  );

  GSP.gConstraints.LinearEquation = GSP.makeClass(
    GSP.gConstraints.MultimeasureBase,
    {
      doc: {
        description: 'Constraint for linear equation measurements',
        inherits: 'MultimeasureBase',
        usage: {
          abstract: false,
          kinds: ['Text'],
        },
        properties: {
          parents: {
            description: '',
            properties: {
              coordSys: {
                description: 'The coordinate system used for the measurements',
                kind: 'CoordSys',
              },
              straight: {
                description: 'The straight we are measuring.',
                kind: 'Straight',
              },
            },
          },
        },
      },

      // Unlike point multimeasures, line and circle multimeasures may
      // change their text mfs template during reconstraint.
      initTextMFS: function() {},

      initUnits: function() {
        this.units = {
          xValue: 'scalar',
          yValue: 'scalar',
          slope: 'scalar',
          yIntercept: 'scalar',
        };
      },

      initPrecision: function() {
        var preferences = this.sQuery().prefs(),
          scalarPrecision = preferences.precision.scalar;

        this.precisions = {
          xValue: scalarPrecision,
          yValue: scalarPrecision,
          slope: scalarPrecision,
          yIntercept: scalarPrecision,
        };
      },

      getMultiMeasureParentLabelMFS: function() {
        return this.getParent('straight').getNameMFS();
      },

      // see analytic.c: multimeasureConstraint()
      constrain: function() {
        var coordSys = this.getParent('coordSys'),
          straight = this.getParent('straight'),
          p0 = coordSys.locatePoint(straight.getStraightP0()),
          p1 = coordSys.locatePoint(straight.getStraightP1()),
          run = p1.x - p0.x,
          rise = p1.y - p0.y,
          equation = this;

        equation.values = {};

        function renderNum(name, value) {
          equation.values[name] = value;
          return { type: 'parameter', value: name };
        }

        //
        // There are three possible MFS forms
        //

        function setSlopeInterceptForm() {
          var slope = rise / run,
            yIntercept = p1.y - slope * p1.x,
            horizontal;

          var op = ' + ';
          if (yIntercept < 0) {
            op = ' \u2212 '; // N.B. U+2212 − MINUS SIGN; not U+002D HYPHEN-MINUS
            yIntercept = -yIntercept;
          }

          horizontal = [
            GSP.mfs.makeTextMFS('y', true),
            GSP.mfs.makeTextMFS(' = '),
            renderNum('slope', slope),
            GSP.mfs.makeTextMFS('x', true),
          ];

          if (yIntercept !== 0) {
            horizontal.push(GSP.mfs.makeTextMFS(op));
            horizontal.push(renderNum('yIntercept', yIntercept));
          }
          equation.valuesMFS = GSP.mfs.makeHorizontalMFS.apply(
            this,
            horizontal
          );
        }

        function setVerticalLineForm() {
          equation.valuesMFS = GSP.mfs.makeHorizontalMFS(
            GSP.mfs.makeTextMFS('x', true),
            GSP.mfs.makeTextMFS(' = '),
            renderNum('xValue', p1.x)
          );
        }

        function setHorizontalLineForm() {
          equation.valuesMFS = GSP.mfs.makeHorizontalMFS(
            GSP.mfs.makeTextMFS('y', true),
            GSP.mfs.makeTextMFS(' = '),
            renderNum('yValue', p1.y)
          );
        }

        if (run === 0) {
          setVerticalLineForm();
        } else if (rise === 0) {
          setHorizontalLineForm();
        } else {
          setSlopeInterceptForm();
        }

        equation.parsedMFS = GSP.mfs.makeHorizontalMFS(
          straight.getNameMFS(),
          GSP.mfs.makeTextMFS(': '),
          equation.valuesMFS
        );
      },
    }
  );

  GSP.gConstraints.QuadraticEquation = GSP.makeClass(
    GSP.gConstraints.MultimeasureBase,
    {
      doc: {
        description: 'Constraint for quadratic equation multimeasures.',
        inherits: 'MultimeasureBase',
        usage: {
          abstract: false,
          kinds: ['Text'],
        },
        properties: {
          parents: {
            description: '',
            properties: {
              coordSys: {
                description: 'The coordinate system used for the measurements',
                kind: 'CoordSys',
              },
              circle: {
                description: 'The circle we are measuring',
                kind: 'Circle',
              },
            },
          },
        },
      },

      // Unlike point multimeasures, line and circle multimeasures may
      // change their text mfs template during reconstraint.
      initTextMFS: function() {},

      initUnits: function() {
        this.units = {
          cX: 'scalar',
          cY: 'scalar',
          rX: 'scalar',
          rY: 'scalar',
        };
      },

      initPrecision: function() {
        var preferences = this.sQuery().prefs(),
          scalarPrecision = preferences.precision.scalar;

        this.precisions = {
          cX: scalarPrecision,
          cY: scalarPrecision,
          rX: scalarPrecision,
          rY: scalarPrecision,
        };
      },

      getMultiMeasureParentLabelMFS: function() {
        return GSP.mfs.makeHorizontalMFS(
          { type: 'symbol', value: '100' },
          GSP.mfs.makeItalicMFS(this.getParent('circle').getNameMFS())
        );
      },

      // see analytic.c: multimeasureConstraint()
      constrain: function() {
        var coordSys = this.getParent('coordSys'),
          circle = this.getParent('circle'),
          c = coordSys.locatePoint(circle.geom.c),
          unit0Len = coordSys.geom.unit0.x - coordSys.geom.origin.x,
          unit1Len = -(coordSys.geom.unit1.y - coordSys.geom.origin.y),
          rX = circle.geom.r / unit0Len,
          rY = circle.geom.r / unit1Len,
          kTolerance = 1e-13,
          equation = this;

        // For equation display: Flip the signs of c.x and c.y.
        c.x = -c.x;
        c.y = -c.y;

        equation.values = {};

        function renderNum(name, value) {
          equation.values[name] = value;
          return { type: 'parameter', value: name };
        }

        /*
         * Returns a squared MFS expression.
         *
         * If second is 0, just square first. Otherwise, square first +
         * second, but make it look right if second is negative.
         *
         * secondName is used for rendering second as an MFS parameter (using this.values).
         */
        function squaredDistance(first, second, secondName) {
          var op;

          function squared(expr) {
            return { type: 'super', value: [expr, GSP.mfs.makeTextMFS('2')] };
          }

          if (second === 0) {
            return squared(first);
          }

          op = ' + ';

          if (second < 0) {
            // express "negativeness" with the operator
            op = ' \u2212 '; // N.B. U+2212 − MINUS SIGN not U+002D HYPHEN-MINUS
            second = -second;
          }

          return squared(
            GSP.mfs.makeParenthesisMFS(
              GSP.mfs.makeHorizontalMFS(
                first,
                GSP.mfs.makeTextMFS(op),
                renderNum(secondName, second)
              )
            )
          );
        }

        //
        // There are two possible MFS forms
        //

        function setCircleForm() {
          equation.valuesMFS = GSP.mfs.makeHorizontalMFS(
            squaredDistance(GSP.mfs.makeTextMFS('x', true), c.x, 'cX'),
            GSP.mfs.makeTextMFS(' + '),
            squaredDistance(GSP.mfs.makeTextMFS('y', true), c.y, 'cY'),
            GSP.mfs.makeTextMFS(' = '),
            squaredDistance(renderNum('rX', rX), 0)
          );
        }

        function setEllipseForm() {
          equation.valuesMFS = GSP.mfs.makeHorizontalMFS(
            GSP.mfs.makeFractionMFS(
              squaredDistance(GSP.mfs.makeTextMFS('x', true), c.x, 'cX'),
              squaredDistance(renderNum('rX', rX), 0)
            ),
            GSP.mfs.makeTextMFS(' + '),
            GSP.mfs.makeFractionMFS(
              squaredDistance(GSP.mfs.makeTextMFS('y', true), c.y, 'cY'),
              squaredDistance(renderNum('rY', rY), 0)
            ),
            GSP.mfs.makeTextMFS(' = '),
            GSP.mfs.makeTextMFS('1')
          );
        }

        if (Math.abs(unit0Len - unit1Len) >= kTolerance) {
          setEllipseForm();
        } else {
          setCircleForm();
        }

        equation.parsedMFS = GSP.mfs.makeHorizontalMFS(
          { type: 'symbol', value: '100' },
          GSP.mfs.makeItalicMFS(circle.getNameMFS()),
          GSP.mfs.makeTextMFS(': '),
          equation.valuesMFS
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a midpoint to its Straight.
   * @class Midpoint
   *
   * This constraint expects to be configured as a Point kind with a Straight kind
   * parent named path. For example:
   * <pre>
   *   { "kind": "Point", "constraint":"Midpoint", "parents": { "path": "ln0" }}
   * </pre>
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.Midpoint = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.Midpoint */ {
      doc: {
        description:
          'The midpoint of a <span class="constraint">Segment</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'Midpoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Midpoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists iff the parent segment exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              path: {
                description: '',
                kind: 'Straight',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Midpoint_export.json',
      },
      state: {},
      /**
       * @override
       */
      constrain: function() {
        var lineObject, newPoint;
        lineObject = this.getParent('path');
        newPoint = lineObject.mapPathValueToPosition(0.5);
        this.state.exists = lineObject.state.exists;
        this.geom.loc = newPoint;
      },

      /*
       * Determine whether two gobjs are defined by the same parents in such a way that
       * they can be merged, typically used when one is created by a tool and the other already
       * exists in the sketch.
       */
      canMergeTo: function(gobj) {
        // Parents p0 and p1 can be interchanged.
        var a0 = this.getParent('path'),
          b0 = gobj.getParent('path'),
          retVal = false;
        if (!(a0 && b0)) {
          // all parents must exist
          GSP.signalErrorWithMessage('Midpoint canMergeTo() missing parents!');
        } else {
          retVal = a0 === b0;
        }
        return retVal;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a text object to its parent text object and a point.
   */
  GSP.gConstraints.Pegged = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'A translation of a <span class="kind">Text</span> message to a <span class="kind">Point</span>.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'PeggedText_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, PeggedText_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Text'],
      },
      existenceRule: 'Exists iff the parent text and point exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'The point to which the pegged text is bound.',
              kind: 'Point',
            },
            text: {
              description: 'The original text replicated by this object.',
              kind: 'Text',
            },
          },
        },
        geom: {
          suppressed: true,
        },
      },
      example:
        '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Text/Pegged_export.json',
    },
    style: {
      'text-align': 'center',
      'vertical-align': 'middle',
    },
    supportsAutoplacement: function() {
      return false; // constraint always places our text
    },
    constrain: function() {
      var p0Gobj = this.getParent('p0'),
        textGobj = this.getParent('text');

      this.parsedMFS = textGobj.getStrippedMFSAppearanceForVariant('default');
      this.text = null;
      this.state.exists = this.parsedMFS !== null && p0Gobj.state.exists;

      if (this.state.exists) {
        this.geom.loc = p0Gobj.geom.loc;
      } else {
        this.geom.loc = GSP.GeometricPoint.INFINITY;
      }
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrain a point to a path.
   */
  GSP.gConstraints.PointOnPath = GSP.makeClass(
    GSP.gConstraints.PointOnPathBase,
    {
      doc: {
        description: 'A point on a <span class="genus">Path</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'OnPath_C',
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists iff the parent path exists.',
        properties: {
          value: {
            description: '',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              path: {
                description: '',
                genus: 'Path',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-PointOnPath_export.json',
      },

      /**
        Update value to newValue, normalizing to a valid value.
      */
      updateValue: function(newValue) {
        this.value = newValue;
      },
      transform: function(sketch, trans) {
        var pathGobj, pointVector;
        pointVector = trans.geom.loc.copy();
        trans.affine.transform(pointVector);
        pathGobj = this.getParent('path');
        this.updateValue(pathGobj.mapPositionToPathValue(pointVector));
      },
      constraintVerificationString: function constraintVerificationString(
        iExpected
      ) {
        return this.testConsistency('value', this.value, iExpected.value);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrains a point to a path according to a fixed value.
   */
  GSP.gConstraints.PlotFixedValueOnPath = GSP.makeClass(
    GSP.gConstraints.PointOnPathBase,
    {
      doc: {
        description:
          'Defines a point on a <span class="genus">Path</span> that has a fixed value.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'PlotFixedValueOnPath_C',
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists iff the parent path exists.',
        properties: {
          value: {
            description: '',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              path: {
                description:
                  'Identifies the path on which the point is plotted',
                genus: 'Path',
              },
            },
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Point-PlotFixedValueOnPath_export.json',
      },
      isFreePointOnPath: false,
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrains a point to a path according to a parameter value.
   */
  GSP.gConstraints.PlotValueOnPath = GSP.makeClass(
    GSP.gConstraints.PointOnPathBase,
    {
      doc: {
        description:
          'Defines a point on a <span class="genus">Path</span> that has a value defined by a <span class="kind">Param</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'PlotMarkedValueOnPath_C',
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists iff the parent param and path exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              param: {
                description:
                  'Identifies a measure whose value determines the position on the path as a normalized path coordinate',
                kind: 'Measure',
              },
              path: {
                description:
                  'Identifies the path on which the point is plotted',
                genus: 'Path',
              },
            },
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Point/PlottedPoint_export.json',
      },
      isFreePointOnPath: false,

      constrain: function constrain() {
        var param = this.getParent('param');
        //In line with desktop, we use the 'unit-ed' value of the param, so 3 radians
        //gets plotted on a path the same place 3 cm would.
        this.value = param.uValue;
        (constrain.base || arguments.callee.base).call(this);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates an object to be a reflection of a parent object.
   * @class Reflect
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.Reflect = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.Reflection */ {
      doc: {
        description:
          'Defines a <span class="kind">GObject</span> that is the reflection of another GObject with respect to a <span class="kind">Straight</span> object.',
        inherits: 'Transform',
        refspec: {
          gspRef: 'Reflect_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Reflect_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent object and mirror exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Reflection_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              mirror: {
                description: '',
                kind: 'Straight',
              },
            },
          },
        },
      },

      /*
       * A reflection does not exist if the line of reflection does not exist
       */
      determineExists: function() {
        return true;
      },
      /** @overlay */
      getTransform: function() {
        var mirrorGObj = this.getParent('mirror');

        return function(preImage) {
          var tMirrorA = mirrorGObj.geom.xp0,
            tMirrorB = mirrorGObj.geom.xp1,
            rMirrorAX = tMirrorA.x,
            rMirrorAY = tMirrorA.y,
            rDeltaX = tMirrorB.x - rMirrorAX,
            rDeltaY = tMirrorB.y - rMirrorAY,
            rMasterTemp = rDeltaX * rDeltaX + rDeltaY * rDeltaY,
            rTemp =
              ((preImage.x - rMirrorAX) * rDeltaX +
                (preImage.y - rMirrorAY) * rDeltaY) /
              rMasterTemp;

          return GSP.GeometricPoint(
            2.0 * (rTemp * rDeltaX + rMirrorAX) - preImage.x,
            2.0 * (rTemp * rDeltaY + rMirrorAY) - preImage.y
          );
        };
      },

      /*  Prefixes in preference order:
          1. The label of the mirror object, if both the mirror and its label exist and are visible
          2. The labels of the two point parents of the mirror, if the parents and their labels exist and are visible
          3. The label of the mirror object, creating it if necessary. If the mirror is hidden, it is shown.
       */
      makeFnLabelPrefix: function(nameOrigin, option) {
        // Handles namedByFullFn and namedByShortFn only
        // option.create creates a required label if it doesn't exist, option.show both creates and shows it
        // option.init does neither.
        var retVal = '',
          mirror = this.getParent('mirror'),
          labelP1,
          labelP2;
        option = option || {};
        switch (nameOrigin) {
          case 'namedByFullFn':
            // If mirror isn't labeled, use the mirror's parent points if they are labeled.
            // Generate new labels ONLY if option.show or option.create is set, NOT for option.init
            retVal = mirror.label; // If the mirror has its own label, use it
            if (!retVal) {
              // mirror is not yet labeled, so check for parent labels, optionally generating them
              labelP1 = mirror.getParentLabel('p0', option);
              labelP2 = mirror.getParentLabel('p1', option);
              if (labelP1 && labelP2) retVal = labelP1 + labelP2;
            }
            if (!retVal) {
              // Still no label, so optionally generate the mirror's own label.
              retVal = mirror.getLabel(option);
            }
            retVal = 'r[' + (retVal ? retVal : '') + ']';
            break;
          case 'namedByShortFn':
            retVal = 'r';
        }
        return retVal;
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates an object to be a glide reflection of a parent object.
   * @class GlideReflect
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.GlideReflect = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.GlideReflect */ {
      doc: {
        description:
          'Defines a <span class="kind">GObject</span> that is the glide reflection of another GObject with respect to a <span class="kind">Straight</span> object that defines the vector/mirror.',
        inherits: 'Transform',
        refspec: {
          gspRef: 'GlideReflect_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, GlideReflect_C, in a future published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the preimage and segment (vector/mirror) exist.',
        example: '',
        properties: {
          parents: {
            description: '',
            properties: {
              vector: {
                description: '',
                kind: 'Straight',
              },
            },
          },
        },
      },

      /*
       * A glide reflection does not exist if the vector does not exist
       */
      determineExists: function() {
        var parent = this.getParent('vector'),
          p0 = parent.geom.p0,
          p1 = parent.geom.p1,
          p1m0 = p1.subtract(p0);
        return !p1m0.isZeroLength();
      },
      /** @overlay */
      getTransform: function() {
        var vectorGObj = this.getParent('vector');

        return function(preImage) {
          var tVectorA = vectorGObj.geom.p0,
            tVectorB = vectorGObj.geom.p1,
            rVectorAX = tVectorA.x,
            rVectorAY = tVectorA.y,
            rDeltaX = tVectorB.x - rVectorAX,
            rDeltaY = tVectorB.y - rVectorAY,
            rMasterTemp = rDeltaX * rDeltaX + rDeltaY * rDeltaY,
            rTemp =
              ((preImage.x - rVectorAX) * rDeltaX +
                (preImage.y - rVectorAY) * rDeltaY) /
              rMasterTemp;

          return GSP.GeometricPoint(
            2.0 * (rTemp * rDeltaX + rVectorAX) - preImage.x + rDeltaX,
            2.0 * (rTemp * rDeltaY + rVectorAY) - preImage.y + rDeltaY
          );
        };
      },

      /*  Prefixes in preference order:
          1. The labels of the two point parents of the mirror/vector, if the parents and their labels exist and are visible
          2. The label of the mirror/vector object, if the label exists and is visible.
          3. Create labels for the two point parents of the mirror/vector, if the points exist.
          4. Create a label for the vector.
       */
      makeFnLabelPrefix: function(nameOrigin, option) {
        // Handles namedByFullFn and namedByShortFn only
        var vector = this.getParent('vector'),
          vectorLabel = 'v',
          p0 = vector.getParent('p0'),
          p1 = vector.getParent('p1'),
          retVal = 'G'; // default
        option = option || {};
        if (nameOrigin === 'namedByFullFn') {
          // If the vector endpoints are labeled, prefer them.
          if (p0 && p0.label && p1 && p1.label) {
            vectorLabel =
              vector.getParentLabel('p0') + vector.getParentLabel('p1');
          } else if (vector.label) {
            // Second choice is if the vector itself is labeled
            vectorLabel = this.getParentLabel('vector');
          } else if (p0 && p1) {
            vectorLabel =
              vector.getParentLabel('p0', option) +
              vector.getParentLabel('p1', option);
          } else vectorLabel = this.getParentLabel('vector', option);
          retVal = 'G[' + vectorLabel + ']';
        }
        return retVal;
      },
    }
  );
  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that positions an object as a rotation of another object
   * about point by fixed angle.
   * @class Rotate
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.Rotate = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.Rotate */ {
      doc: {
        description:
          'Defines a new GObject as a rotation of a GObject by a fixed angle about a pivot point p0.',
        inherits: 'Transform',
        refspec: {
          gspRef: 'RotatefA_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, RotatefA_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent object exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Rotation_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              center: {
                description: 'The center of the rotation',
                kind: 'Point',
              },
            },
          },
          angle: {
            description: '',
            type: 'Number',
            required: true,
          },
        },
      },

      angle: 0,

      /*
       * A rotation does not exist if the angle is undefined.
       */
      determineExists: function() {
        var angle = this.getAngle();
        return typeof angle !== 'undefined' && isFinite(angle);
      },
      /**
        Fetch the pivot point of our transformation.
        Subclasses can override.
        
        @param {GSP.Sketch} sketch  The current Sketch
        @return {GeometricPoint} pivot point
      */
      getPivot: function() {
        var centerGobj = this.getParent('center');
        return centerGobj.geom.loc;
      },

      /**
        Fetch the angle our transformation.
        Subclasses can override.
        
        @param {GSP.Sketch} sketch  The current Sketch
        @return {Number} angle of rotation in radians
      */
      getAngle: function() {
        return this.angle;
      },

      getTransform: function() {
        var that = this;

        return function(point) {
          return point.rotate(that.getPivot(), that.getAngle());
        };
      },

      // The default getAngleText () is for fixed rotations. Descendants will override this function.
      getAngleText: function() {
        // Return the gobj's angle using units and precision from prefs
        return this.getFixedAngleText(this.angle);
      },

      // This works for all rotate constraints; no need for overrides
      makeFnLabelPrefix: function(nameOrigin, option) {
        // Handles namedByFullFn and namedByShortFn only
        var center = this.getParentLabel('center', option),
          retVal = 'R';
        if (nameOrigin === 'namedByFullFn')
          retVal += '[' + center + ',' + this.getAngleText(option) + ']';
        return retVal;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a segment to its two endpoints.
   */
  GSP.gConstraints.Segment = GSP.makeClass(GSP.gConstraints.Straight, {
    doc: {
      description: 'Defines a line segment from two points.',
      inherits: 'Straight',
      refspec: {
        gspRef: 'Segment_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Segment_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Straight'],
      },
      existenceRule: 'Exists iff the parent points exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: 'First reference point defining the segment',
              kind: 'Point',
            },
            p1: {
              description: 'Second reference point defining the segment',
              kind: 'Point',
            },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Segment_export.json',
    },
    overbarType: 2,
    /**
     * A value bound to within the range of values on the path.
     * Points on paths are implicitly scaled. For example, the values of
     * points on segments ranges from zero to one, inclusive, where zero
     * is coincident with p0, and one with p1. This method makes sure values are
     * within the implied range, if such a range exists.
     * @param {Number} v
     * @return {Number}
     */
    getPointOnPath: function(path, distance) {
      return this.getPointOnSegment(path, distance);
    },
    /**
     * Computes endpoints of this segment from the position of the parent points.
     * If the parent points are coincident, the segment stills exists.
     * This is GSP behavior replicated here.
     */
    constrain: function() {
      var p1m0;
      this.geom.xp0 = this.geom.p0 = this.getStraightP0();
      this.geom.xp1 = this.geom.p1 = this.getStraightP1();
      p1m0 = this.geom.p1.subtract(this.geom.p0);
      this.state.exists = !p1m0.isZeroLength();
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class ColorizeTrivariate
   *
   * @augments GSP.gConstraints.Colorize
   */
  GSP.gConstraints.ColorizeTrivariate = GSP.makeClass(
    GSP.gConstraints.Colorize,
    /** @lends GSP.gConstraints.ColorizeTrivariate */ {
      doc: {
        description:
          'Defines a new GObject that is coincident to another GObject, but colored differently.',
        inherits: 'Colorize',
        refspec: {
          gspRef: 'Colorization_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent measures exist and are finite.',

        properties: {
          parents: {
            description: '',
            properties: {
              red: {
                description:
                  'For a trivariate parameterization, the red value.',
                kind: 'Measure',
              },
              green: {
                description:
                  'For a trivariate parameterization, the green value.',
                kind: 'Measure',
              },
              blue: {
                description:
                  'For a trivariate parameterization, the blue value.',
                kind: 'Measure',
              },
            },
          },
        },
      },
      determineExists: function() {
        var red = this.getParent('red'),
          green = this.getParent('green'),
          blue = this.getParent('blue');
        return !!(
          red &&
          GSP.math.isFiniteScalar(red.uValue) &&
          green &&
          GSP.math.isFiniteScalar(green.uValue) &&
          blue &&
          GSP.math.isFiniteScalar(blue.uValue)
        );
      },

      /*
        Wavelength to RGB color conversion based on C++ code from Tim Erickson 
        which in turn derived from Java code from  
        http://www.physics.sfasu.edu/astro/color/spectra.html.
       */
      convertToColor: function() {
        var red = this.getParent('red'),
          green = this.getParent('green'),
          blue = this.getParent('blue'),
          r = red && red.uValue,
          g = green && green.uValue,
          b = blue && blue.uValue;

        if (
          !GSP.math.isFiniteScalar(r) ||
          !GSP.math.isFiniteScalar(g) ||
          !GSP.math.isFiniteScalar(b)
        ) {
          return null;
        }

        r = this.normalizeColorParameter(r);
        g = this.normalizeColorParameter(g);
        b = this.normalizeColorParameter(b);
        if ('TrivariateHSV' === this.colorModel) {
          /* HSV to RGB Color Conversion algorithm from http://www.cs.rit.edu/~ncs/color/t_convert.html */
          var i,
            f,
            p,
            q,
            t,
            hue = r,
            saturation = g,
            value = b;

          if (saturation === 0.0) {
            /* achromatic (grey) */
            r = g = b = value;
          } else {
            hue = hue / (60.0 / 360.0); /* sector 0 to 5 */
            i = Math.floor(hue);
            f = hue - i; /* factorial part of h */
            p = value * (1.0 - saturation);
            q = value * (1.0 - saturation * f);
            t = value * (1.0 - saturation * (1.0 - f));
            switch (i) {
              case 0:
                r = value;
                g = t;
                b = p;
                break;
              case 1:
                r = q;
                g = value;
                b = p;
                break;
              case 2:
                r = p;
                g = value;
                b = t;
                break;
              case 3:
                r = p;
                g = q;
                b = value;
                break;
              case 4:
                r = t;
                g = p;
                b = value;
                break;
              default:
                /* case 5 */
                r = value;
                g = p;
                b = q;
                break;
            }
          }
        }

        return { red: r, green: g, blue: b };
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for UnitPoint constraints
   * These assume an 'origin' point parent,
   * with a displacement therefrom.
   * Override unitPointDeltaX and unitPointDeltaY to return
   * your displacement.
   * @class UnitPoint
   *
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.UnitPoint = GSP.makeClass(
    GSP.gConstraints.Constraint,
    /** @lends GSP.gConstraints.UnitPoint */ {
      doc: {
        description: 'Base class for all unit point constraints',
        inherits: 'Constraint',
        usage: {
          abstract: true,
          kinds: ['Point'],
        },
      },
      state: {},

      /**
       * The minimum unit point distance, which limits drags.
       * See kMIN_UNIT_POINT_DISTANCE_FROM_ORIGIN in gpoints.c.
       */
      kMinUnitPointDistanceFromOrigin: 0.1,

      /**
       * Returns the X displacement from the origin.
       */
      unitPointDeltaX: function() {
        return 0.0;
      },
      /**
       * @override
       * Returns the Y displacement from the origin.
       */
      unitPointDeltaY: function() {
        return 0.0;
      },
      /**
       * Get the origin point. Default assumption assumes an
       * 'origin' parent.
       */
      unitPointOrigin: function() {
        return this.parents.origin;
      },
      /**
       * @override
       */
      constrain: function() {
        var origin = this.unitPointOrigin();

        this.geom.loc = GSP.GeometricPoint(
          origin.geom.loc.getX() + this.unitPointDeltaX(),
          origin.geom.loc.getY() + this.unitPointDeltaY()
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * @class Transformation
   *
   * @augments GSP.gConstraints.ColorizeUnivariate
   */
  GSP.gConstraints.ColorizeUnivariate = GSP.makeClass(
    GSP.gConstraints.Colorize,
    /** @lends GSP.gConstraints.ColorizeUnivariate */ {
      doc: {
        description:
          'Defines a new GObject that is coincident to another GObject, but colored differently.',
        inherits: 'Colorize',
        refspec: {
          gspRef: 'Colorization_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Colorization_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent measures exist and are finite.',

        properties: {
          parents: {
            description: '',
            properties: {
              color: {
                description:
                  'For a univariate parameterization, the color value.',
                kind: 'Measure',
              },
            },
          },
        },
      },
      determineExists: function() {
        var color = this.getParent('color');
        return !!(color && GSP.math.isFiniteScalar(color.uValue));
      },

      /*
    Converts a singleton measurement value (in GeomFloatingType range) to a color.
    iRangeMin & Max determines the spread of the varying colorization range, which
    is either spectral (if iColorizeByHue) at full intensity or intensity-based
    (if !iColorizeByHue).
    
    Wavelength to RGB color conversion based on C++ code from Tim Erickson 
    which in turn derived from Java code from  
    http://www.physics.sfasu.edu/astro/color/spectra.html.
  
  */
      convertToColor: function() {
        var colorParent = this.getParent('color'),
          value = colorParent && colorParent.uValue;
        if (!GSP.math.isFiniteScalar(value)) {
          return null;
        }

        var kUVLimit = 3800.0,
          kPureGreen = 5100.0,
          kPureRed = 6450.0,
          kPureBlue = 4400.0,
          kIRLimit = 7800.0,
          kLowVisibleSpectrum = 3850.0,
          kHighVisibleSpectrum = 6750.0;

        var r = 0.0,
          g = 0.0,
          b = 0.0,
          sss,
          waveLength,
          parameter,
          lambdaFrac;
        parameter = this.normalizeColorParameter(value);

        if ('UnivariateHue' === this.colorModel) {
          waveLength =
            kLowVisibleSpectrum +
            parameter * (kHighVisibleSpectrum - kLowVisibleSpectrum);
          if (waveLength < kPureBlue && waveLength > kUVLimit) {
            b = 1.0;
            r = (kPureBlue - waveLength) / (kPureBlue - kUVLimit);
          } else if (waveLength < kPureGreen) {
            /* Blue and green cross parabolically. Green at 5100 */
            lambdaFrac = (kPureGreen - waveLength) / (kPureGreen - kPureBlue);
            g = 1.0 - lambdaFrac * lambdaFrac;
            lambdaFrac = (waveLength - kPureBlue) / (kPureGreen - kPureBlue);
            b = 1.0 - lambdaFrac * lambdaFrac;
          } else if (waveLength < kPureRed) {
            /* Red and green cross parabolically. */
            lambdaFrac = (waveLength - kPureGreen) / (kPureRed - kPureGreen);
            g = 1.0 - lambdaFrac * lambdaFrac;
            lambdaFrac = (kPureRed - waveLength) / (kPureRed - kPureGreen);
            r = 1.0 - lambdaFrac * lambdaFrac;
          } else if (waveLength < kIRLimit) {
            r = 1.0;
          } else {
            r = 1.0;
            g = 1.0;
            b = 1.0;
          }

          /* Compute falloff near ends of visible spectrum */
          if (waveLength > 7000.0) {
            sss = 0.3 + (0.7 * (kIRLimit - waveLength)) / (7800.0 - 7000.0);
          } else {
            sss = 1.0;
          }
        } else {
          r = 1.0;
          g = 1.0;
          b = 1.0;
          sss = parameter;
        }

        return { red: r * sss, green: g * sss, blue: b * sss };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for constraint for an axis.
   * Derived classes should override 'constrain', and as a side effect
   * set, as GeometricPoint, 'this.geom.p0' to the axis origin, and
   * 'this.geom.p1' to the axis unit point.
   */
  GSP.gConstraints.AxisDist = GSP.makeClass(GSP.gConstraints.Line, {
    doc: {
      description: 'An axis determined by origin and unitPoint.',
      inherits: 'Line',
      refspec: {
        gspRef: 'DistAxis_C',
      },
      usage: {
        abstract: true,
        kinds: ['Axis'],
      },
      existenceRule: 'Exists iff the parent origin point and unitPoint exists.',
      properties: {
        parents: {
          description: '',
          properties: {
            origin: {
              description: 'The origin of the axis',
              kind: 'Point',
            },
            unitPoint: {
              description: 'The unit point defines one unit along the axis',
              kind: 'Point',
            },
            p0: { suppressed: true },
            p1: { suppressed: true },
          },
        },
      },
    },
    /**
     * Return the first control point. Default implementation
     * assumes a 'p0' parent.
     */
    getStraightP0: function() {
      return this.geom.p0;
    },
    /**
     * Return the second control point. Default implementation
     * assumes a 'p1' parent.
     */
    getStraightP1: function() {
      return this.geom.p1;
    },

    constrain: function constrain() {
      var SEMI_AXIS_PIXEL_BALANCE = 100.0,
        delta = this.geom.unit.subtract(this.geom.origin),
        normed = delta.multiply(SEMI_AXIS_PIXEL_BALANCE / delta.vLength());

      normed.y = -normed.getY();

      this.geom.p0 = this.geom.origin.subtract(normed);
      this.geom.p1 = this.geom.origin.add(normed);

      (constrain.base || arguments.callee.base).call(this);
    },
    getParentalNameMFS: function(option) {
      var origin = this.getParent('origin');
      return GSP.mfs.makeHorizontalMFS(
        GSP.mfs.makeTextMFS('axis '),
        origin.getNameMFS(option)
      );
    },

    /*
     * Determine whether two axes are defined identically and define the same coordinate system.
     * This is needed to detect situations in which a constructibleGiven has been matched to an axis;
     * when the tool finishes the constructibleGiven and its candidate may need to be merged.
     */
    canMergeTo: function(gobj) {
      // Parents p0 and p1 can be interchanged.
      var a0 = this.getParent('origin'),
        b0 = gobj.getParent('unitPoint'),
        a1 = this.getParent('origin'),
        b1 = gobj.getParent('unitPoint'),
        aCoordSys,
        bCoordSys;

      function coordSysFilter(someGobj) {
        return someGobj.kind === 'CoordSys';
      }

      if (
        gobj.constraint !== this.constraint ||
        a0 !== b0 ||
        a1 !== b1 ||
        this.orientation !== gobj.orientation
      )
        return false;
      aCoordSys = this.children.filter(coordSysFilter);
      bCoordSys = gobj.children.filter(coordSysFilter);

      return (
        aCoordSys.length === 1 &&
        bCoordSys.length === 1 &&
        aCoordSys[0] === bCoordSys[0]
      );
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind an arc sector to its parent arc.
   */
  GSP.gConstraints.ArcSector = GSP.makeClass(GSP.gConstraints.ArcInterior, {
    doc: {
      description:
        'Defines an arc sector, bounded by the arc and by the radii to the two endpoints of the arc',
      inherits: 'ArcInterior',
      usage: {
        abstract: false,
      },
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind an arc segment to its parent arc.
   */
  GSP.gConstraints.ArcSegment = GSP.makeClass(GSP.gConstraints.ArcInterior, {
    doc: {
      description:
        'Defines a arc segment, bounded by the arc and by the chord connecting the two endpoints of the arc.',
      inherits: 'ArcInterior',
      usage: {
        abstract: false,
      },
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that positions an object as a scaled replicate of another
   * by a fixed factor with respect to a pivot point.
   * @class DilateFixFactor
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.DilateFixFactor = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.DilateFixFactor */ {
      doc: {
        description:
          'Defines a new GObject as a dilation about a point of a GObject by a fixed factor.',
        inherits: 'Transform',
        refspec: {
          gspRef: 'DilatefR_C',
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the center point exists. For dilations of non-points, existence also requires that the dilation factor be non-zero.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-DilateFixFactor_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              center: {
                description: 'The center of the dilation',
                kind: 'Point',
              },
            },
          },
          scaleFactor: {
            description: 'A scale factor.',
            type: 'Number',
            required: false,
          },
        },
      },
      scaleFactor: 0,
      determineExists: function() {
        var scaleFactor = this.getScaleFactor();
        return (
          GSP.math.isFiniteScalar(scaleFactor) &&
          (this.kind === 'Point' || scaleFactor !== 0)
        );
      },
      getScaleFactor: function() {
        return this.scaleFactor;
      },
      getPivot: function() {
        return this.getParent('center').geom.loc;
      },

      /** @overlay */
      getTransform: function() {
        var that = this;
        return function(point) {
          return point.scale(that.getPivot(), that.getScaleFactor());
        };
      },
      getScalarTransform: function() {
        var that = this;
        return function(scalar) {
          return Math.abs(scalar * that.getScaleFactor());
        };
      },

      // The default getScaleText () is for fixed dilations. Descendants will override this function.
      getScaleText: function() {
        // Return the passed scale using units and precision from prefs
        var prefs = this.sQuery.sketch.preferences,
          unitData = GSP.units.findUnit(prefs.units.scalar),
          roundFactor = Math.pow(10, prefs.precision.scalar),
          val =
            Math.round(
              this.scaleFactor * unitData.conversionFromBase * roundFactor
            ) / roundFactor;
        return (val < 0 ? '\u2013' : '') + Math.abs(val) + unitData.symbol;
      },

      // This works for all dilate constraints; no need for overrides
      makeFnLabelPrefix: function(nameOrigin, option) {
        // Handles namedByFullFn and namedByShortFn only
        var center = this.getParentLabel('center', option),
          retVal = 'D';
        if (nameOrigin === 'namedByFullFn')
          retVal += '[' + center + ',' + this.getScaleText(option) + ']';
        return retVal;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a line to its two definition points.
   */
  GSP.gConstraints.AxisExternalDist = GSP.makeClass(GSP.gConstraints.AxisDist, {
    doc: {
      description: 'An axis determined by origin and parental unit distance.',
      inherits: 'AxisDist',
      refspec: {
        gspRef: 'ExternalDistAxis_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, ExternalDistAxis_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Axis'],
      },
      existenceRule:
        'Exists iff the parent origin point exists and distance parent exists and is positive.',
      properties: {
        parents: {
          description: '',
          properties: {
            unitDistance: {
              description: 'A measure or segment',
              kind: 'Measure|Straight',
            },
            unitPoint: { suppressed: true },
          },
        },
      },
    },
    constrain: function constrain() {
      var distance = this.getParent('unitDistance'),
        p0 = this.getParent('origin').geom.loc,
        d = distance.pathLength ? distance.pathLength() : distance.value,
        dx = 0,
        dy = 0;

      if (isNaN(d) || d <= 0) {
        this.state.exists = false;
        return;
      }

      if (this.orientation === 'horizontal') {
        dx = d;
      }
      if (this.orientation === 'vertical') {
        dy = -d;
      }

      this.geom.origin = GSP.GeometricPoint(p0.getX(), p0.getY());
      this.geom.unit = GSP.GeometricPoint(p0.getX() + dx, p0.getY() + dy);

      (constrain.base || arguments.callee.base).call(this);
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @class SquareUnitPoint
   *
   *
   * @augments GSP.gConstraints.UnitPoint
   */
  GSP.gConstraints.UnitPointExternalRectangle = GSP.makeClass(
    GSP.gConstraints.UnitPoint,
    /** @lends GSP.gConstraints.UnitPointExternalRectangle */ {
      doc: {
        description:
          'A unit point displaced perpendicularly from the origin of an axis by a given distance.',
        inherits: 'UnitPoint',
        refspec: {
          gspRef: 'ExternalRectangleUnitPoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ExternalRectangleUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent axis exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              axis: {
                description: 'The Axis for which this point is the unit point',
                kind: 'Axis',
              },
            },
          },
          unitDistance: {
            description: 'unit distance from grand-parental origin in pixels',
            type: 'Number',
          },
        },
      },
      constrain: function() {
        var axis = this.getParent('axis'),
          x0 = axis.geom.origin.getX(),
          y0 = axis.geom.origin.getY(),
          dx = axis.geom.unit.getX() - x0,
          dy = axis.geom.unit.getY() - y0,
          d = this.unitDistance;

        dx = dx > 0 ? 1 : dx === 0 ? 0 : -1; // dx = sgn(dx)
        dy = dy > 0 ? 1 : dy === 0 ? 0 : -1; // dy = sgn(dy)

        dx *= d;
        dy *= d;

        this.geom.loc = GSP.GeometricPoint(x0 + dy, y0 - dx);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @class SquareUnitPoint
   *
   *
   * @augments GSP.gConstraints.UnitPoint
   */
  GSP.gConstraints.UnitPointExternalSquare = GSP.makeClass(
    GSP.gConstraints.UnitPoint,
    /** @lends GSP.gConstraints.UnitPointExternalSquare */ {
      doc: {
        description:
          'A unit point displaced perpendicularly from the origin of an axis by the unit distance of that axis.',
        inherits: 'UnitPoint',
        refspec: {
          gspRef: 'ExternalSquareUnitPoint_C',
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent origin point exists and distance parent exists and is positive.',
        properties: {
          parents: {
            description: '',
            properties: {
              axis: {
                description: 'The Axis for which this point is the unit point',
                kind: 'Axis',
              },
            },
          },
        },
      },

      constrain: function() {
        var axis = this.getParent('axis'),
          x0 = axis.geom.origin.getX(),
          y0 = axis.geom.origin.getY(),
          dx = axis.geom.unit.getX() - x0,
          dy = axis.geom.unit.getY() - y0;

        this.geom.loc = GSP.GeometricPoint(x0 + dy, y0 - dx);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @class HorizontalUnitPoint
   *
   *
   * @augments GSP.gConstraints.UnitPoint
   */
  GSP.gConstraints.HorizontalUnitPoint = GSP.makeClass(
    GSP.gConstraints.UnitPoint,
    /** @lends GSP.gConstraints.HorizontalUnitPoint */ {
      doc: {
        description:
          'A unit point of a horizontal <span class="kind">Axis</span>.',
        inherits: 'UnitPoint',
        refspec: {
          gspRef: 'HorizontalUnitPoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, HorizontalUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent origin point exists.',
        properties: {
          value: {
            description:
              'horizontal displacement from parental origin in pixels.',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              origin: {
                description: 'origin point of related axis.',
                kind: 'Point',
              },
            },
          },
        },
      },
      value: 20,
      /**
       * @override
       */
      unitPointDeltaX: function() {
        return this.value;
      },
      transform: function(sketch, trans) {
        var origin = this.unitPointOrigin(),
          newUnit = trans.geom.loc.copy();
        trans.affine.transform(newUnit);
        this.value = Math.max(
          this.kMinUnitPointDistanceFromOrigin,
          newUnit.getX() - origin.geom.loc.getX()
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a line to its two definition points.
   */
  GSP.gConstraints.AxisInternalDist = GSP.makeClass(GSP.gConstraints.AxisDist, {
    doc: {
      description: 'An axis determined by origin and unitPoint.',
      inherits: 'AxisDist',
      refspec: {
        gspRef: 'InternalDistAxis_C',
      },
      usage: {
        abstract: false,
        kinds: ['Axis'],
      },
      existenceRule: 'Exists iff the parent origin point and unitPoint exists.',
      properties: {
        parents: {
          description: '',
          properties: {
            origin: {
              description: '',
              genus: 'Point',
            },
            unitPoint: {
              description: '',
              genus: 'Point',
            },
          },
        },
      },
    },
    constrain: function constrain() {
      var p0 = this.getParent('origin').geom.loc,
        p1 = this.getParent('unitPoint').geom.loc;

      this.geom.origin = GSP.GeometricPoint(p0.getX(), p0.getY());
      this.geom.unit = GSP.GeometricPoint(p1.getX(), p1.getY());

      (constrain.base || arguments.callee.base).call(this);
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @class UnitPointInternalRectangle
   *
   *
   * @augments GSP.gConstraints.UnitPoint
   */
  GSP.gConstraints.UnitPointInternalRectangle = GSP.makeClass(
    GSP.gConstraints.UnitPoint,
    /** @lends GSP.gConstraints.UnitPointInternalRectangle */ {
      doc: {
        description:
          'A unit point displaced perpendicularly from the origin of a parental axis of a unit point by a given distance.',
        inherits: 'UnitPoint',
        refspec: {
          gspRef: 'InternalRectangleUnitPoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, InternalRectangleUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent unitPoint exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              unitPoint: {
                description: '',
                kind: 'Point',
              },
            },
          },
          unitDistance: {
            description: 'unit distance from grand-parental origin in pixels',
            type: 'Number',
          },
        },
      },
      transform: function(sketch, trans) {
        var parentUnitPoint = this.getParent('unitPoint'),
          origin = parentUnitPoint.getParent('origin'),
          newUnit = trans.geom.loc.copy();

        trans.affine.transform(newUnit);
        this.unitDistance = Math.max(
          this.kMinUnitPointDistanceFromOrigin,
          origin.geom.loc.getY() - newUnit.getY()
        );
      },
      constrain: function() {
        var parentUnitPoint = this.getParent('unitPoint'),
          origin = parentUnitPoint.getParent('origin'),
          x0 = origin.geom.loc.getX(),
          y0 = origin.geom.loc.getY(),
          d = this.unitDistance,
          dx = parentUnitPoint.geom.loc.getX() - x0,
          dy = parentUnitPoint.geom.loc.getY() - y0;

        dx = dx > 0 ? 1 : dx === 0 ? 0 : -1; // dx = sgn(dx)
        dy = dy > 0 ? 1 : dy === 0 ? 0 : -1; // dy = sgn(dy)

        dx *= d;
        dy *= d;

        this.geom.loc = GSP.GeometricPoint(x0 + dy, y0 - dx);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   *
   * @class UnitPointInternalSquare
   *
   *
   * @augments GSP.gConstraints.UnitPoint
   */
  GSP.gConstraints.UnitPointInternalSquare = GSP.makeClass(
    [GSP.gConstraints.UnitPoint, GSP.mixins.transformable],
    /** @lends GSP.gConstraints.InternalSquareUnitPoint */ {
      doc: {
        description:
          'A unit point displaced perpendicularly from the origin of a parental axis of a unit point by the unit distance of that axis.',
        inherits: 'UnitPoint',
        refspec: {
          gspRef: 'InternalSquareUnitPoint_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, InternalSquareUnitPoint_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent unitPoint exists.',
        properties: {
          parents: {
            description: '',
            properties: {
              unitPoint: {
                description: '',
                kind: 'Point',
              },
            },
          },
        },
      },
      constrain: function() {
        var parentUnitPoint = this.getParent('unitPoint'),
          origin = parentUnitPoint.getParent('origin'),
          x0 = origin.geom.loc.getX(),
          y0 = origin.geom.loc.getY(),
          dx = parentUnitPoint.geom.loc.getX() - x0,
          dy = parentUnitPoint.geom.loc.getY() - y0;

        this.geom.loc = GSP.GeometricPoint(x0 + dy, y0 - dx);
      },
      getParentalNameMFS: function() {
        //Silencing error until reform of label renderPrepare is completed
        //GSP.signalErrorWithMessage("InternalSquareUnitPoint.getParentalNameMFS() shouldn't be called.");
        return GSP.mfs.makeTextMFS('Unit point ' + this.id);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementAbscissa = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description:
          'The abscissa (x coordinate) of a point relative to a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'AbscissaM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AbscissaM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      constrain: function() {
        var pos = this.getCoordinates(this.getParent('point'));

        this.value = pos.x;
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        var point = this.getParent('point');
        if (!point.label) {
          point.getLabel(option);
        }
        return {
          type: 'sub',
          value: [GSP.mfs.makeTextMFS('x', true), point.getNameMFS()],
        };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementAnalyticSlope = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description: 'The slope of a straight relative to a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'AnalyticSlopeM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AnalyticSlopeM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              seg: {
                description: '',
                kind: 'Straight',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      constrain: function() {
        var seg = this.getParent('seg'),
          coordSys = this.getParent('coordSys'),
          p0 = coordSys.locatePoint(seg.geom.p0),
          p1 = coordSys.locatePoint(seg.geom.p1),
          delta = p1.subtract(p0);

        this.value = delta.getX() === 0.0 ? NaN : delta.getY() / delta.getX();
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('Slope '),
          this.getParent('seg').getNameMFS(option)
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  GSP.gConstraints.GeometricSlope = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'The slope of a straight.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'GeometricSlopeM_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, GeometricSlopeM_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Measure'],
      },
      existenceRule: 'Exists iff the parents exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            straight: {
              description: '',
              kind: 'Straight',
            },
          },
        },
      },
    },
    constrain: function() {
      var straight = this.getParent('straight'),
        p0 = straight.getP0(),
        p1 = straight.getP1(),
        delta = p1.subtract(p0);

      this.value = delta.getX() === 0.0 ? NaN : -(delta.getY() / delta.getX());
      this.uValue = this.value;
    },
    getParentalNameMFS: function(option) {
      return GSP.mfs.makeHorizontalMFS(
        GSP.mfs.makeTextMFS('Slope '),
        this.getParent('straight').getNameMFS(option)
      );
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for an arc measure
   */
  GSP.gConstraints.MeasurementArcBase = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'The measurement of the angle of an arc. The arc is either an arc object, or a circle and points on the circle which define an arc.',
        inherits: 'Constraint',
        usage: {
          abstract: true,
          kinds: ['Measure'],
        },
        existenceRule: 'Exists iff the parents and are non-coincident exist.',
      },

      /*
       * Fetch a GeometricArc representing our parental geometry.
       * The parents could be an arc, but also a Circle with arc endpoints
       * on it (with an optional point to determine arc direction).
       */
      getParentalArc: function() {
        // derived classes must override
        throw GSP.createError(
          'MeasurementArcBase.getParentalArc: Derived class must override!'
        );
      },

      getArcNameMFS: function(option) {
        // derived classes must override
        throw GSP.createError(
          'MeasurementArcBase.getParentalArc: Derived class must override!'
        );
      },

      measureArcAngle: function() {
        var arc = this.getParentalArc(),
          angle = arc.arcAngle,
          units = this.sQuery().prefs().units.angle;

        this.value = angle;
        // Convert to document units.
        this.uValue = GSP.units.convert(angle, 'radians', units);
      },

      measureArcLength: function() {
        var arc = this.getParentalArc(),
          len = arc.getCache(arc.genus).arcLength || arc.arcLength,
          units = this.sQuery().prefs().units.length;

        this.value = len;
        this.uValue = GSP.units.convert(len, 'pixels', units);
      },

      getAngleNameMFS: function(option) {
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS('m ', true),
          this.getArcNameMFS(option)
        );
      },

      getLengthNameMFS: function(option) {
        return GSP.mfs.makeHorizontalMFS(
          GSP.mfs.makeTextMFS(GSP.Strings.loc('GSP.Measure.arcLength') + ' '),
          this.getArcNameMFS(option)
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for an arc measure
   */
  GSP.gConstraints.MeasurementArc = GSP.makeClass(
    GSP.gConstraints.MeasurementArcBase,
    {
      doc: {
        description: 'The measurement of the angle of an arc.',
        inherits: 'MeasurementArcBase',
        existenceRule: 'Exists iff the parents and are non-coincident exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              arc: {
                description: 'The arc to be measured',
                kind: 'Arc',
              },
            },
          },
        },
      },

      /*
       * Fetch a GeometricArc representing our parental geometry.
       */
      getParentalArc: function() {
        var arc = this.getParent('arc');
        return arc && arc.geom.arc;
      },

      getArcNameMFS: function(option) {
        var arcParent = this.getParent('arc');
        return arcParent && arcParent.getParentalNameMFS(option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of an angle between two lines
   */
  GSP.gConstraints.MeasurementArcAngle = GSP.makeClass(
    GSP.gConstraints.MeasurementArc,
    {
      doc: {
        description: 'The measurement of an angle defined by three points.',
        inherits: 'MeasurementArc',
        refspec: {
          gspRef: 'ArcAngle3PointsMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ArcAngle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      unitPowers: { angle: 1 },

      constrain: function() {
        this.measureArcAngle();
      },

      getParentalNameMFS: function(option) {
        return this.getAngleNameMFS(option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the length of a Segment.
   */
  GSP.gConstraints.MeasurementArcLength = GSP.makeClass(
    GSP.gConstraints.MeasurementArc,
    {
      doc: {
        description:
          'The measurement of the length of a <span class="kind">Arc</span>s.',
        inherits: 'MeasurementArc',
        refspec: {
          gspRef: 'ArcLengthM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ArcLengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      unitPowers: { length: 1 },

      constrain: function() {
        this.measureArcLength();
      },

      getParentalNameMFS: function(option) {
        return this.getLengthNameMFS(option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for an arc measure
   */
  GSP.gConstraints.MeasurementArcOnCircle = GSP.makeClass(
    GSP.gConstraints.MeasurementArcBase,
    {
      doc: {
        description:
          'The measurement of the angle of an arc. The arc is defined by a circle and points on the circle which define an arc.',
        inherits: 'MeasurementArcBase',
        existenceRule: 'Exists iff the parents and are non-coincident exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              circle: {
                description: 'Circle containing arc',
                kind: 'Circle',
              },
              p0: {
                description: 'Initial point',
                kind: 'Point',
              },
              p1: {
                description: 'Final point (or if p2 is set, middle point)',
                kind: 'Point',
              },
              p2: {
                description: 'Final point',
                kind: 'Point',
                required: false,
              },
            },
          },
        },
      },

      /*
       * Fetch a GeometricArc representing our parental geometry.
       * The parents could be an arc, but also a Circle with arc endpoints
       * on it (with an optional point to determine arc direction).
       */
      getParentalArc: function() {
        var arc, a, b, c, linearity, circle;

        circle = this.getParent('circle');
        a = this.getParent('p0').geom.loc;
        b = this.getParent('p1').geom.loc;
        c = this.getParent('p2');
        if (c) {
          linearity = GSP.Geom.ThreePointCollinear(a, c.geom.loc, b);
          arc = GSP.GeometricArc.FromCenterAndEndpoints(
            circle.geom.c,
            a,
            c.geom.loc,
            linearity.orientation
          );
        } else {
          linearity = GSP.Geom.ThreePointCollinear(a, circle.geom.c, b);

          // Arcs on circles are always measured as the minor arc, so we need to factor in orientation.
          arc = GSP.GeometricArc.FromCenterAndEndpoints(
            circle.geom.c,
            a,
            b,
            linearity.orientation
          );
        }

        return arc;
      },
      // arcs on circles are always the minor arc, but
      // the geometricArc's  arcAngle is always a positive
      // value. For signed angle units, we need to keep the
      // sign to match desktop (+ is CCW). So we override
      // base class measureArcAngle
      measureArcAngle: function() {
        var arc = this.getParentalArc(),
          angle = arc.arcAngle,
          units = this.sQuery().prefs().units.angle;

        if (units !== 'deg') {
          // geometric arc orientation:+1 is CW (documented!)
          angle *= -arc.orientation;
        }

        this.value = angle;

        // Convert to document units.
        this.uValue = GSP.units.convert(angle, 'radians', units);
      },

      getArcNameMFS: function(option) {
        var circleParent = this.getParent('circle'),
          self = this,
          arc = { type: 'style', value: [{ code: 'fontStyle', value: '2' }] },
          names = [],
          pointParent;
        // The names array cannot hold empty text elements,
        // because we don't want separators to appear between them
        // upon calling makeHorizontalNamesMFS.
        ['p0', 'p1', 'p2'].forEach(function(iName) {
          pointParent = self.getParent(iName);
          if (pointParent) {
            names.push(pointParent.getNameMFS(option));
          }
        });
        arc.value.push(GSP.mfs.makeHorizontalNamesMFS(names));

        arc = { type: 'overbar', variant: 5, value: arc };

        var circle = GSP.mfs.makeHorizontalMFS(
          { type: 'symbol', value: '100' },
          circleParent.getParentalNameMFS(option)
        );
        return GSP.mfs.makeHorizontalMFS(
          arc,
          GSP.mfs.makeTextMFS(' on '),
          circle
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the length of a Segment.
   */
  GSP.gConstraints.MeasurementArcOnCircleAngle = GSP.makeClass(
    GSP.gConstraints.MeasurementArcOnCircle,
    {
      doc: {
        description:
          'The measurement of the length of a <span class="kind">Arc</span>s.',
        inherits: 'MeasurementArcOnCircle',
        refspec: {
          gspRef: 'ArcAngle3PointsMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ArcAngle3PointsMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      unitPowers: { angle: 1 },

      constrain: function() {
        this.measureArcAngle();
      },

      getParentalNameMFS: function(option) {
        return this.getAngleNameMFS(option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of the length of a Segment.
   */
  GSP.gConstraints.MeasurementArcOnCircleLength = GSP.makeClass(
    GSP.gConstraints.MeasurementArcOnCircle,
    {
      doc: {
        description:
          'The measurement of the length of a <span class="kind">Arc</span>s.',
        inherits: 'MeasurementArcOnCircle',
        refspec: {
          gspRef: 'ArcLengthM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, ArcLengthM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      unitPowers: { length: 1 },

      constrain: function() {
        this.measureArcLength();
      },

      getParentalNameMFS: function(option) {
        return this.getLengthNameMFS(option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementCoordinateDistance = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description:
          'The distance between two points relative to a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'CoordinateDistanceM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, CoordinateDistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: 'The point from which distance is to be measured',
                kind: 'Point',
              },
              p1: {
                description: 'The point to which distance is to be measured',
                kind: 'Point',
              },
            },
          },
        },
      },
      constrain: function() {
        var p0 = this.getCoordinates(this.getParent('p0')),
          p1 = this.getCoordinates(this.getParent('p1'));

        this.value = p1.subtract(p0).vLength();
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        var p0, p1, p0Name, p1Name;
        p0 = this.getParent('p0');
        p1 = this.getParent('p1');
        if (!p0.label) {
          p0.getLabel(option);
        }
        if (!p1.label) {
          p1.getLabel(option);
        }
        p0Name = p0.getNameMFS();
        p1Name = p1.getNameMFS();
        return GSP.mfs.makeHorizontalNamesMFS([p0Name, p1Name]);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementOrdinate = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description:
          'The ordinate (y coordinate) of a point relative to a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'OrdinateM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, OrdinateM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      constrain: function() {
        var pos = this.getCoordinates(this.getParent('point'));

        this.value = pos.y;
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        var point = this.getParent('point');
        if (!point.label) {
          point.getLabel(option);
        }
        return {
          type: 'sub',
          value: [GSP.mfs.makeTextMFS('y', true), point.getNameMFS()],
        };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementPolarDirection = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description:
          'The angle (theta-value of the polar coordinates) of a point relative to the x-axis of a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'PolarDirectionM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PolarDirectionM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      unitPowers: { angle: 1 },
      constrain: function(sketch) {
        var pos = this.getCoordinates(this.getParent('point')),
          units = sketch.preferences.units.angle,
          angle;

        angle = Math.atan2(pos.getY(), pos.getX());

        this.value = angle;
        this.uValue = GSP.units.convert(angle, 'radians', units);
      },
      getParentalNameMFS: function(option) {
        return {
          type: 'sub',
          value: [
            GSP.mfs.makeItalicMFS({ type: 'symbol', value: '71' }),
            this.getParent('point').getNameMFS(option),
          ],
        };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class of measure constraints that have a coordinate system parent.
   */
  GSP.gConstraints.MeasurementPolarDistance = GSP.makeClass(
    GSP.gConstraints.MeasurementCoordinateBased,
    {
      doc: {
        description:
          'The distance from the origin (r-value of the polar coordinates) of a point relative to a coordinate system.',
        inherits: 'MeasurementCoordinateBased',
        refspec: {
          gspRef: 'PolarDistanceM_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PolarDistanceM_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parents exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              point: {
                description: '',
                kind: 'Point',
              },
              coordSys: {
                description: '',
                kind: 'CoordSys',
              },
            },
          },
        },
      },
      constrain: function() {
        var pos = this.getCoordinates(this.getParent('point'));

        this.value = pos.vLength();
        this.uValue = this.value;
      },
      getParentalNameMFS: function(option) {
        return {
          type: 'sub',
          value: [
            GSP.mfs.makeTextMFS('r', true),
            this.getParent('point').getNameMFS(option),
          ],
        };
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrain a point to a polygon according to desktop sketchpad semantics,
   * to wit, a point on a polygon is defined by its parametric position on a given edge.
   * So when the polygon changes, the point stays on the same edge and parametric position
   * thereof. But - you can still drag it to other edges.
   *
   *  This constraints model is:
   *  baseVertex - the 0 based index of the first vertex of the edge;.
   *  baseValue - parameter of the point on the edge.
   */
  GSP.gConstraints.PointOnPolygonEdge = GSP.makeClass(
    GSP.gConstraints.PointOnPathBase,
    {
      doc: {
        description: 'A point on a <span class="kind">Polygon</span>.',
        inherits: 'Constraint',
        refspec: {
          gspRef: 'OnPath_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, OnPath_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule: 'Exists iff the parent param and path exist.',
        properties: {
          baseVertex: {
            description: 'index of initial vertex of edge containing point',
            type: 'Number',
          },
          baseValue: {
            description:
              'parameterized location on edge starting at baseVertex',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              path: {
                description: '',
                kind: 'Polygon',
              },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-PointOnPath_export.json',
      },
      // value is the normalized distance along the path it is
      // computed by transform() and used by constrain()
      value: 0.5,

      /**
        Three equivalent values are maintained by this constraint:
        the path value [0,1), the characteristic { baseVertex, baseValue },
        and the geometry (geom.loc). Most of the time, we want to start
        with the path value and derive the other two from it. The desktop
        code, however, exports the characteristic, so we need to compute
        the path value from the characteristic immediately after export.
        (Note: I believe the desktop code would be improved by treating
        the path value as primary and exporting it instead, but this is
        a non-trivial undertaking.) This property is set to false initially,
        indicating that the characteristic is primary when the sketch is
        loaded, but is set to true once the value is altered by dragging,
        animation, etc.
       */
      isPathValuePrimary: false,

      /**
        Update value to newValue, normalizing to a valid value.
       */
      updateValue: function(newValue) {
        this.value = newValue - Math.floor(newValue);
        this.isPathValuePrimary = true;

        // Synchronize characteristic to the new path value
        var polygon = this.getParent('path'),
          characteristic = polygon.mapPathValueToCharacteristic(this.value);
        this.baseVertex = characteristic.baseVertex;
        this.baseValue = characteristic.baseValue;
      },

      transform: function(sketch, trans) {
        var polygon = this.getParent('path'),
          pointVector = trans.geom.loc.copy();
        trans.affine.transform(pointVector);

        this.updateValue(polygon.mapPositionToPathValue(pointVector));
      },

      constrain: function() {
        var polygon = this.getParent('path');

        // Update the geometry from the characteristic
        var points = polygon.geom.points,
          p0 = points[this.baseVertex],
          p1 = points[(this.baseVertex + 1) % points.length];
        this.geom.loc = p0.add(p1.subtract(p0).multiply(this.baseValue));

        // Update the value from the geometry if appropriate
        if (!this.isPathValuePrimary) {
          this.value = polygon.mapPositionToPathValue(this.geom.loc);
        }
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A constraint that positions an object as a rotation of another object
   * by an angle determined from an Angle Marker.
   *
   * @class RotateAngleMarker
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.RotateAngleMarker = GSP.makeClass(
    GSP.gConstraints.Rotate,
    /** @lends GSP.gConstraints.RotateAngleMarker */ {
      doc: {
        description:
          'Defines a new GObject as a rotation of a GObject by the measure of a marked angle about a pivot point.',
        inherits: 'Rotate',
        refspec: {
          gspRef: 'RotateByMarkedAngleMarker_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, RotateByMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent object and the three angle points exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-RotateAngleMarker_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              angle: {
                description: '',
                kind: 'AngleMarker',
              },
            },
          },
          angle: {
            suppressed: true,
          },
        },
      },
      getAngle: function() {
        var angleGobj;
        angleGobj = this.getParent('angle');

        //Angle marker's value is not user facing, no
        //need for flipping
        return angleGobj.value;
      },

      getAngleText: function(option) {
        return this.getAngleMarkerText('angle', option);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A constraint that positions an object as a rotation of another object
   * by an angle determined from an angle measurement.
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.RotateMeasureAngle = GSP.makeClass(
    GSP.gConstraints.Rotate,
    /** @lends GSP.gConstraints.RotateMeasureAngle */ {
      doc: {
        description:
          'Defines a new GObject as a rotation of a GObject by a measure about a pivot point, p0.',
        inherits: 'Rotate',
        refspec: {
          gspRef: 'RotateByMarkedAngleMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, RotateByMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent object and the three angle points exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-RotateMeasureAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              angle: {
                description: '',
                kind: 'Measure',
              },
            },
          },
          angle: {
            suppressed: true,
          },
        },
      },
      getAngle: function() {
        var angleGobj;
        angleGobj = this.getParent('angle');

        //convert from user-visible (CCW) to primal (flipped y == CW)
        // but don't conditionalize on PI? I think not
        return -angleGobj.value;
      },

      getAngleText: function(option) {
        return this.getParentLabel('angle', option);
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A constraint that positions an object as a rotation of another object
   * by an angle determined from the angle subtended by three points.
   * @class Rotate3
   *
   * @augments GSP.gConstraints.Constraint
   */
  GSP.gConstraints.Rotate3 = GSP.makeClass(
    GSP.gConstraints.Rotate,
    /** @lends GSP.gConstraints.Rotate3 */ {
      doc: {
        description:
          'Defines a new GObject as a rotation of a GObject about a pivot point, p0, by an angle from three points.',
        inherits: 'Rotate',
        refspec: {
          gspRef: 'Rotate3A_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Rotate3A_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent object and the three angle points exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Rotation3_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              A: {
                description: '',
                kind: 'Point',
              },
              B: {
                description: '',
                kind: 'Point',
              },
              C: {
                description: '',
                kind: 'Point',
              },
            },
          },
          angle: {
            suppressed: true,
          },
        },
      },
      getAngle: function() {
        var a, b, c;
        a = this.getParent('A').geom.loc;
        b = this.getParent('B').geom.loc;
        c = this.getParent('C').geom.loc;
        return GSP.GeometricPoint.threePointAngle(a, b, c);
      },

      getAngleText: function(option) {
        return this.get3PtAngleText('A', 'B', 'C', option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a line to its two definition points.
   */
  GSP.gConstraints.AxisUnitCircle = GSP.makeClass(GSP.gConstraints.AxisDist, {
    doc: {
      description: 'An axis determined a unit circle.',
      inherits: 'AxisDist',
      refspec: {
        gspRef: 'UnitCircleAxis_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, UnitCircleAxis_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Axis'],
      },
      existenceRule:
        'Exists iff the parent circle exists and has positive radius.',
      properties: {
        parents: {
          description: '',
          properties: {
            circle: {
              description: '',
              kind: 'Circle',
            },
            origin: { suppressed: true },
            unitPoint: { suppressed: true },
          },
        },
      },
    },
    constrain: function constrain() {
      var circle = this.getParent('circle'),
        r = circle.geom.r,
        dx = 0,
        dy = 0;

      this.geom.origin = circle.geom.c;

      if (isNaN(r) || r <= 0) {
        this.state.exists = false;
        return;
      }

      if (this.orientation === 'horizontal') {
        dx = r;
      }
      if (this.orientation === 'vertical') {
        dy = -r;
      }

      this.geom.unit = GSP.GeometricPoint(
        this.geom.origin.getX() + dx,
        this.geom.origin.getY() + dy
      );

      (constrain.base || arguments.callee.base).call(this);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of an angle between two lines
   */
  GSP.gConstraints.AngleMarker = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'Marks the angle between two lines.',
      inherits: 'Constraint',
      refspec: {},
      usage: {
        abstract: true,
        kinds: ['AngleMarker'],
      },
      existenceRule: 'Exists iff parents exist, and define a non-zero angle.',
      properties: {
        parents: {
          properties: {
            p0: {
              description: 'A point on an angle edge',
              kind: 'Point',
            },
            p1: {
              description: 'The focal point of an angle',
              kind: 'Point',
            },
            p2: {
              description: 'A point on the other angle edge',
              kind: 'Point',
            },
          },
        },
      },
    },
    makeArcs: function(a, b, c, angle, orientation) {
      var v = a.subtract(b),
        arcp0,
        arcp1;

      if (Math.abs(this.value) < 0.0004) {
        this.geom.arc = undefined;
        this.state.exists = true; //The marker exists, but it is not renderable or hittable
        return;
      }

      if (v.isZeroLength()) {
        this.state.exists = false;
      } else {
        arcp0 = v.multiply(this.style['inner-radius'] / v.vLength());
        v = c.subtract(b);
        if (v.isZeroLength()) {
          this.state.exists = false;
        } else {
          arcp1 = v.multiply(this.style['inner-radius'] / v.vLength());
          this.geom.arc = GSP.GeometricArc.FromCenterAndEndpoints(
            b,
            b.add(arcp0),
            b.add(arcp1),
            orientation
          );
          this.state.exists = this.geom.arc.exists;
        }
      }
    },

    getParentalNameMFS: function(option) {
      // show angle symbol
      return this.getAngleMarkerMFS(option, false);
    },

    /*
     * Virtual method for use in constrain() - what's the appropriate angle for this kind of marker.
     * Input angle is in sketch based coordinates, but must be re-jiggered for the particular
     * orientation of the marker constrain (e.g. it might always be CCW).
     * Subclasses will generally want to override.
     *
     * @param {Number} angle
     * @param {Object} orientationInfo
     * @return {Number}
     */
    constrainedAngle: function(angle, orientationInfo) {
      return angle;
    },
    constrain: function() {
      var a = this.getParent('p0').geom.loc,
        b = this.getParent('p1').geom.loc,
        c = this.getParent('p2').geom.loc,
        //Because the Y Axis is inverted in primal coords,
        //angle's sign is opposite from the direction you'd expect (positive = CW)
        angle = GSP.GeometricPoint.threePointAngle(a, b, c),
        orientationInfo = GSP.Geom.ThreePointCollinear(a, b, c),
        orientation;

      if (!orientationInfo.isStraight) {
        if (angle + Math.PI < GSP.math.SIMPLE_PI_THRESHOLD) {
          angle += 2 * Math.PI;
        }
      }

      this.value = this.constrainedAngle(angle, orientationInfo);

      orientation = orientationInfo.orientation;

      this.makeArcs(a, b, c, angle, orientation);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Manages the animation of a set of points.
   */
  GSP.gConstraints.ActionButtonAnimate = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description: 'A button that moves a point on a path.',
        inherits: 'ActionButton',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          parents: {
            description: 'Animating objects',
            type: 'Object',
            properties: {
              '0': {
                description:
                  'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                kind: 'kind',
              },
            },
            regex: /^[0-9]+$/,
          },
          animationStates: {
            description:
              'Array of objects containing state information (rate, repeat, motionType, etc.) for each animation controlled by this button.  State information depends on the kind of animation',
            type: 'Array',
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-Animation_export.json',
      },
      animationStates: [],
      smoothInSpace: true,
      /**
       * Press the button.
       */
      press: function(sketch, pressSource) {
        var button = this,
          i,
          motion,
          motionGObj;

        /*
         * motionmanager applyMotion proc
         * 'this' is the motion object
         */
        function animateApplyMotion() {
          if (!this.animateFunction(sketch)) {
            sketch.MotionManager.EndMotion(this.motionID);
            sketch.event('EndAnimate', {
              button: button,
              id: button.id,
            });

            if (!pressSource) button.state.pressedUp = true;
          }
        }

        /*
         * motionmanager completeMotion proc
         * 'this' is the motion object
         */

        function animateCompleteMotion() {
          var i;

          this.motionID = undefined;
          //if we've only got one, we're stopping the last one
          button.activate(button.state.motions.length > 1);

          //remove from the array of motions
          for (i = 0; i < button.state.motions.length; i++) {
            if (this === button.state.motions[i]) {
              button.state.motions.splice(i, 1);
              break;
            }
          }

          if (!button.state.isActive) {
            sketch.invalidateGeom(button);
          }
        }

        /**
         * Animate a point randomly on the plane.
         * 'this' is the motion object
         *
         * @param {object} sketch
         * @return {bool} true to keep going
         */

        function animateOnPlane(sketch) {
          var kRANDOM_ANGLE_BIAS = Math.PI / 2,
            distToTravel,
            curSampleTime = Date.now(),
            motionVector,
            point = this.gobj,
            sketchRect = sketch.sketchRect(),
            context;
          if (!this.animContext) {
            this.animContext = {
              currentAngle: Math.random() * 2 * Math.PI,
              lastSampleTime: Date.now() - 16,
            };
          }

          /*
    Utility supporting RandomOnPlane_advance() in biasing a potential movement vector to favor the screen.
  
    Given an curPosition and a range determined by lowerLimit..upperLimit, compute a bias of up to
    maxBiasStep in size that tends toward keeping curPosition within the specified range,
    and returns it. 
          
    If curPosition is within the endpoints of the range by some fraction, there is no bias, in
    that we consider the curPosition "safe" from moving outside the range.
    
    If curPosition is outside of the endpoints of the range by some fraction, there is full bias,
    because the point (over successive biased steps) needs to be driven toward the range.
    
    If curPosition is between the two fractional "windows" on the range, then there is a linear
    degree of bias between 0.0 and maxBiasStep.
          
          @param {number} curPosition 
          @param {number} biasOffset - the amount to move
          @param {number} lowerLimit
          @param {number} upperLimit
          @param {number} maxBiasStep - the max amount to move in one step
          @return {number} the new position
          */
          function brownianBias(
            curPosition,
            biasOffset,
            lowerLimit,
            upperLimit,
            maxBiasStep
          ) {
            var kINNER_WINDOW_FRACTION = 0.2,
              kOUTER_WINDOW_FRACTIONAL_WIDTH = 0.3,
              rangeWidth = upperLimit - lowerLimit,
              fractionalPosition,
              temp,
              ret = biasOffset;

            if (rangeWidth) {
              fractionalPosition = (curPosition - lowerLimit) / rangeWidth;

              if (fractionalPosition < kINNER_WINDOW_FRACTION) {
                temp = kINNER_WINDOW_FRACTION - fractionalPosition;
                if (temp >= kOUTER_WINDOW_FRACTIONAL_WIDTH) {
                  ret += maxBiasStep;
                } else {
                  ret += (maxBiasStep * temp) / kOUTER_WINDOW_FRACTIONAL_WIDTH;
                }
              } else if (fractionalPosition > 1 - kINNER_WINDOW_FRACTION) {
                temp = fractionalPosition - (1 - kINNER_WINDOW_FRACTION);
                if (temp >= kOUTER_WINDOW_FRACTIONAL_WIDTH) {
                  ret -= maxBiasStep;
                } else {
                  ret -= (maxBiasStep * temp) / kOUTER_WINDOW_FRACTIONAL_WIDTH;
                }
              }
            }

            return ret;
          }

          context = this.animContext;
          context.currentAngle +=
            kRANDOM_ANGLE_BIAS * Math.random() - kRANDOM_ANGLE_BIAS * 0.5;

          //distance is fixed in space, not fixed in time, for animations on path
          distToTravel = this.rate * GSP.kWebSpeedMultiplier;
          motionVector = {
            x: Math.cos(context.currentAngle) * distToTravel,
            y: Math.sin(context.currentAngle) * distToTravel,
          };

          motionVector.x = brownianBias(
            point.geom.loc.getX(),
            motionVector.x,
            sketchRect.left,
            sketchRect.right,
            distToTravel
          );

          motionVector.y = brownianBias(
            point.geom.loc.getY(),
            motionVector.y,
            sketchRect.top,
            sketchRect.bottom,
            distToTravel
          );

          point.transform(sketch, {
            geom: point.geom,
            affine: GSP.AffineTransform({
              m00: 1,
              m11: 1,
              m20: motionVector.x,
              m21: motionVector.y,
            }),
          });

          sketch.invalidateGeom(point);
          context.lastSampleTime = curSampleTime;

          return true;
        }

        /*
         * Workhorse for onPath and parameter animation methods, both of which advance a
         * gobj's current value by a step value, potentially changing direction
         * if the step overruns the range of the gobj.  The animating gobj must
         * implement updateValue() for this method to work.
         *
         * @param {object} sketch
         * @param {object} motion
         * @param {object} curFrameState - object containing:
         *    {boolean} firstTime - is it the first animation frame?
         *    {number} curSampleTime - timestamp of this frame
         * @returns {boolean} true to keep going
         */
        function defaultAnimationPerFrame(sketch, motion, curFrameState) {
          var context = motion.animContext,
            pointOrParamGObj = motion.gobj,
            msSinceLastFrame =
              curFrameState.curSampleTime - context.lastSampleTime,
            adjustedStepSize = motion.smoothInSpace
              ? context.stepSize
              : context.stepSize *
                ((msSinceLastFrame * GSP.kIdealFrameRate) / 1000),
            newValue,
            oldValue = pointOrParamGObj.value,
            continueMotion = true,
            wrappedValueObject,
            didWrap = false;

          //Calculate wraparound
          //returns object with new value and direction
          function calculateWrappedPosition(animContext, newValue) {
            var pathLength = animContext.maxValue - animContext.minValue,
              shiftedValue = newValue - animContext.minValue,
              outsideAmt,
              numBounces,
              newPosition;

            if (shiftedValue >= 0 && shiftedValue <= pathLength) {
              //no wrapping needed
              GSP.signalErrorWithMessage(
                'calculateWrappedPosition() should only be called when we need wrapping'
              );
              return;
            }

            //We rely on the 'signed' modulo that JS implements rather than the 'correct' modulo
            newPosition = shiftedValue % pathLength;

            if (animContext.oscillate) {
              outsideAmt =
                shiftedValue > 0 ? shiftedValue - pathLength : shiftedValue;
              numBounces = 1 + Math.floor(Math.abs(outsideAmt / pathLength));

              if (numBounces % 2 === 1) {
                newPosition *= -1;
              }
            }

            if (newPosition > 0) {
              return {
                value: animContext.minValue + newPosition,
                direction: 1,
              };
            } else {
              return {
                value: animContext.maxValue + newPosition,
                direction: -1,
              };
            }
          }

          //Worker function to detect when we have hit a final value
          //This function should only be called when there is a final value
          //Relies on the following closures:
          //context: the animation context
          //oldValue: the value that the animator started with
          //newValue: the value after making a step and being wrapped
          //adjustedStepSize: the size of the step
          //didWrap: boolean indicating whether we have wrapped
          function crossedFinalValue() {
            var pathLength = context.maxValue - context.minValue;

            if (context.finalValue !== null) {
              if (adjustedStepSize >= pathLength) {
                //We've wrapped more than once.  We've definitely hit any final value
                return true;
              } else if (curFrameState.firstTime) {
                //It's our first time through and we haven't wrapped all the way around
                //Never stop
                return false;
              }

              if (didWrap) {
                //If we've wrapped and the new and old values are both on the same side
                //of the final value, that means we've crossed the final value as part
                //of our wrap.
                if (
                  (newValue >= context.finalValue &&
                    oldValue >= context.finalValue) ||
                  (newValue <= context.finalValue &&
                    oldValue <= context.finalValue)
                ) {
                  return true;
                }
              } else {
                //If we haven't wrapped and the new and old values are opposite sides
                //of the final value, that means we have crossed the final value in
                //this step
                if (
                  (newValue >= context.finalValue &&
                    context.finalValue >= oldValue) ||
                  (oldValue >= context.finalValue &&
                    context.finalValue >= newValue)
                ) {
                  return true;
                }
              }
            }

            return false;
          }

          //Unlike desktop, we first clamp the value to the animation range on the
          //first frame of the animation.  On desktop, in SOME cases, it would
          //clamp it, but in other cases, it would let the value animate towards
          //the range without jumping.  This only happened if the movement was
          //increasing or decreasing (not bidirectional), and if the movement was
          //moving toward the valid animation range rather than away from it.  WSP
          //decides it's more consistent to always clamp to the animation range
          //at the beginning of the animation.
          if (oldValue < context.minValue) {
            oldValue = context.minValue;
          }

          if (oldValue > context.maxValue) {
            oldValue = context.maxValue;
          }

          newValue = oldValue + adjustedStepSize * context.direction;

          if (newValue < context.minValue || newValue > context.maxValue) {
            wrappedValueObject = calculateWrappedPosition(context, newValue);
            newValue = wrappedValueObject.value;
            context.direction = wrappedValueObject.direction;
            didWrap = true;
            //Note: didWrap will be true when we bounce back in a bidirectional
            //animation.  Our strategy below would be wrong for a bounce-back
            //style wraparound (we don't want to reverse the polarity of our test,
            //but would need a more complicated test).  Fortunately, bidirectional
            //animations don't support the once-only option.
          }

          if (crossedFinalValue()) {
            newValue = context.finalValue;
            continueMotion = false;
          }

          if (pointOrParamGObj.updateValue) {
            //point on path
            pointOrParamGObj.updateValue(newValue);
          } else {
            GSP.signalErrorWithMessage(
              'animateOneStep encountered unexpected object type'
            );
          }
          sketch.invalidateGeom(pointOrParamGObj);

          return continueMotion;
        }

        /* Workhorse for onPath and parameter random animations.  The animating
         * gobj must implement updateValue() for this method to work.
         *
         * @param {object} sketch
         * @param {object} motion
         * @param {object} curFrameState - object containing:
         *    {boolean} firstTime - is it the first animation frame?
         *    {number} curSampleTime - timestamp of this frame
         * @returns {boolean} true to keep going
         */
        function randomAnimationPerFrame(sketch, motion, curFrameState) {
          var context = motion.animContext,
            keepGoing = true;

          if (curFrameState.curSampleTime >= context.nextRandomEventTime) {
            motion.gobj.updateValue(
              context.minValue +
                Math.random() * (context.maxValue - context.minValue)
            );

            sketch.invalidateGeom(motion.gobj);
            context.nextRandomEventTime =
              curFrameState.curSampleTime + context.randomPeriod;
            keepGoing = context.repeat;
          }
          return keepGoing;
        }

        /**
         * Animate a single point on a path.
         * 'this' is the motion object
         *
         * @param {object} sketch
         * @return {bool} true to keep going
         */
        function animateOnPath(sketch) {
          var context,
            pathGObj = this.path,
            frameState = {
              curSampleTime: Date.now(),
              firstTime: false,
            },
            curPathLength = pathGObj.pathLength(),
            curMinAndMax = pathGObj.getAnimationRange(),
            continueMotion = true; //only onceOnly animations will kill themselves

          //one time initialization
          if (!this.animContext) {
            frameState.firstTime = true;
            this.animContext = {
              lastPathLength: 0,
              lastSampleTime:
                frameState.curSampleTime - 1000 / GSP.kIdealFrameRate,
              stepSize: null,
              minValue: null,
              maxValue: null,
              direction: this.motionType === 'backward' ? -1 : 1,
              oscillate: this.motionType === 'both',
              random: this.motionType === 'random',
              repeat: this.repeat,
              finalValue: null,
              perFrameAdvanceFn: defaultAnimationPerFrame,
            };

            if (!this.repeat) {
              this.animContext.finalValue = this.gobj.value;
            }

            if (this.animContext.random) {
              //randomInterval is period in milliseconds for rerandomization
              //note: timeInterval is only used in parameter motions
              this.animContext.randomPeriod =
                (GSP.kNormalSpeedRate / this.rate) * 1000;
              this.animContext.nextRandomEventTime = frameState.curSampleTime; //rerandomize now!
              this.animContext.perFrameAdvanceFn = randomAnimationPerFrame;
            }
          }

          context = this.animContext;

          //recompute step size and animation min and max
          //some paths may need recomputing if they've changed
          //size (eg closed paths) but others may be the same size with new bounds
          //(eg a dragged horizontal line).  Therefore we must check all of these
          //things and recompute if any have changed.
          if (
            pathGObj.state.exists &&
            !(
              curMinAndMax.min === context.minValue &&
              curMinAndMax.max === context.maxValue &&
              curPathLength === context.lastPathLength
            )
          ) {
            //compute step size - the amount the value should change
            //to achieve the desired pixel step

            var unitDistance = pathGObj.unitLength();

            if (!context.random) {
              context.stepSize = Math.abs(
                (this.rate / unitDistance) * GSP.kWebSpeedMultiplier
              );
            }
            //update min and max values here so that they can be dynamic as the
            //path changes size/bounds/etc.
            context.minValue = curMinAndMax.min;
            context.maxValue = curMinAndMax.max;
            context.lastPathLength = curPathLength;
          }

          continueMotion = context.perFrameAdvanceFn(sketch, this, frameState);
          context.lastSampleTime = frameState.curSampleTime;

          return continueMotion;
        }

        /**
         * Animate a single parameter.
         * 'this' is the motion object
         *
         * @param {object} sketch
         * @return {bool} true to keep going
         */
        function animateParameter(sketch) {
          var frameState = {
              curSampleTime: Date.now(),
              firstTime: false,
            },
            continueMotion = true; //only onceOnly animations will kill themselves

          //per-frame advance function for discrete parameter animations
          function parameterDiscretePerFrame(sketch, motion, curFrameState) {
            var ret = true,
              context = motion.animContext;

            if (curFrameState.curSampleTime >= context.nextDiscreteEventTime) {
              ret = defaultAnimationPerFrame(sketch, motion, curFrameState);
              context.nextDiscreteEventTime =
                curFrameState.curSampleTime + context.discretePeriod;
            }

            return ret;
          }

          //One time initialization
          if (!this.animContext) {
            frameState.firstTime = true;
            this.animContext = {
              lastSampleTime:
                frameState.curSampleTime - 1000 / GSP.kIdealFrameRate,
              stepSize: null,
              minValue: this.paramMinValue,
              maxValue: this.paramMaxValue,
              direction: this.motionType === 'backward' ? -1 : 1,
              oscillate: this.motionType === 'both',
              random: this.motionType === 'random',
              repeat: this.repeat,
              finalValue: null,
              perFrameAdvanceFn: defaultAnimationPerFrame,
            };

            if (!this.repeat) {
              this.animContext.finalValue = this.gobj.value;
            }

            if (this.animContext.random) {
              this.animContext.randomPeriod = 1000 * this.timeInterval;
              this.animContext.nextRandomEventTime = frameState.curSampleTime; //rerandomize now!
              this.animContext.perFrameAdvanceFn = randomAnimationPerFrame;
            } else if (this.discrete) {
              this.animContext.discretePeriod = 1000 * this.timeInterval;
              this.animContext.nextDiscreteEventTime = frameState.curSampleTime; //do it now!
              this.animContext.stepSize = Math.abs(this.rate);
              this.animContext.perFrameAdvanceFn = parameterDiscretePerFrame;
            } else {
              //Protect against divide-by-0
              if (this.timeInterval === 0) {
                GSP.signalErrorWithMessage('invalid time interval');
              }
              this.animContext.stepSize = Math.abs(
                this.rate / (GSP.kIdealFrameRate * this.timeInterval)
              );
            }
          }

          continueMotion = this.animContext.perFrameAdvanceFn(
            sketch,
            this,
            frameState
          );
          this.animContext.lastSampleTime = frameState.curSampleTime;

          return continueMotion;
        }

        if (!this.state.isActive) {
          GSP.log('Started animation ' + this.id);
          this.state.motions = [];
          this.activate(true, pressSource);

          for (i = 0; i < this.numParents(); i++) {
            motionGObj = this.parentsList[i];
            motion = {
              applyMotion: animateApplyMotion,
              completeMotion: animateCompleteMotion,
              animateFunction: undefined, //will be assigned below based on the motion type

              controlList: sketch.Bap.createControlList([motionGObj]),
              gobj: motionGObj,
              rate: this.animationStates[i].rate,
              repeat: this.animationStates[i].repeat,
              motionType: this.animationStates[i].motionType,
              smoothInSpace: this.smoothInSpace,
            };

            if (motionGObj.isFreePointOnPath) {
              motion.path = motionGObj.parents.path;
              motion.animateFunction = animateOnPath;
            } else if (motion.gobj.kind === 'Point') {
              motion.animateFunction = animateOnPlane;
            } else if (motion.gobj.kind === 'Expression') {
              motion.animateFunction = animateParameter;
              motion.isValueChangingMotion = true;

              //Although always exported, timeInterval's value is only
              //meaningful for parameter animations
              motion.timeInterval = this.animationStates[i].timeInterval;
              //These are only exported/defined for parameter animations
              motion.paramMinValue = this.animationStates[i].lowerParamBound;
              motion.paramMaxValue = this.animationStates[i].upperParamBound;
              motion.discrete = this.animationStates[i].discrete;
            }

            sketch.event('StartAnimate', {
              button: button,
              id: button.id,
            });
            motion.motionID = sketch.MotionManager.StartMotion(motion);
            this.state.motions.push(motion);

            if (!pressSource) button.state.pressedDown = true;
          }
          sketch.invalidateGeom(this);
        } else {
          GSP.log('Canceling animation ' + this.id);
          for (i = 0; i < this.state.motions.length; i++) {
            sketch.MotionManager.EndMotion(this.state.motions[i].motionID);
          }
          sketch.event('EndAnimate', {
            button: button,
            id: button.id,
          });

          if (!pressSource) button.state.pressedUp = true;
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that a coordinate system to its axes.
   */
  GSP.gConstraints.CoordSys = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'An coordinate system determined by two axes.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'CoordSys_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, CoordSys_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['CoordSys'],
      },
      existenceRule: 'Exists iff the parent axes exists.',
      properties: {
        parents: {
          description: '',
          properties: {
            axisX: {
              description: 'The horizontal axis',
              kind: 'Axis',
            },
            axisY: {
              description: 'The vertical axis',
              kind: 'Axis',
            },
          },
        },
      },
    },
    /**
     * A coordinate system is considered visible if either it is visible or both of its axes are visible
     */
    isVisible: function() {
      return (
        !this.style.hidden ||
        (!this.getParent('axisX').style.hidden &&
          !this.getParent('axisY').style.hidden)
      );
    },

    constrain: function() {
      var axisX = this.getParent('axisX'),
        axisY = this.getParent('axisY'),
        unitSpacing;

      this.geom.origin = axisX.geom.origin;
      this.geom.unit0 = axisX.geom.unit;
      this.geom.unit1 = axisY.geom.unit;
      unitSpacing = {
        x: this.geom.unit0.x - this.geom.origin.x,
        y: -(this.geom.unit1.y - this.geom.origin.y),
      };
      this.geom.gridSpacing =
        this.shape === 'polar'
          ? axisX.getPolarSpacing(unitSpacing).pixelsBetweenTicks
          : {
              x: axisX.getLineSpacing().pixelsBetweenTicks,
              y: axisY.getLineSpacing().pixelsBetweenTicks,
            };
    },
  });

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that scales by the ratio of two line lengths
   * with respect to a fixed point.
   * @class Dilate2SegRatio
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.Dilate2SegRatio = GSP.makeClass(
    GSP.gConstraints.DilateFixFactor,
    /** @lends GSP.gConstraints.Dilate2SegRatio */ {
      doc: {
        description:
          'Defines a new GObject as a dilation about a point of a GObject by the ratio of the lengths of two segments.',
        inherits: 'DilateFixFactor',
        refspec: {
          gspRef: 'Dilate2R_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Dilate2R_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object, the center, and the two segments all exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Dilate2SegRatio_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              seg0: {
                description:
                  'Segment defining the numerator of the scale ratio',
                kind: 'Straight',
              },
              seg1: {
                description:
                  'Segment defining the denominator of the scale ratio',
                kind: 'Straight',
              },
            },
          },
          scaleFactor: { suppressed: true },
        },
      },
      getScaleFactor: function() {
        var seg0Gobj = this.getParent('seg0');
        var seg1Gobj = this.getParent('seg1');
        var scaleFactor = seg0Gobj.pathLength() / seg1Gobj.pathLength();
        return scaleFactor;
      },

      getScaleText: function(option) {
        var seg0 = this.getParent('seg0'),
          seg1 = this.getParent('seg1');
        if (!seg0.label || !seg1.label) {
          // At least one segment label is missing; try the endpoints
          if (
            seg0.getParentLabel('p0') &&
            seg0.getParentLabel('p1') &&
            seg1.getParentLabel('p0') &&
            seg1.getParentLabel('p1')
          )
            // all endpoints have labels, so use them.
            return (
              seg0.getVisibleParentLabel('p0', option) +
              seg0.getVisibleParentLabel('p1', option) +
              '/' +
              seg1.getVisibleParentLabel('p0', option) +
              seg1.getVisibleParentLabel('p1', option)
            );
        }
        // Some endpoint labels are missing, so label the segments.
        return (
          this.getVisibleParentLabel('seg0', option) +
          '/' +
          this.getVisibleParentLabel('seg1', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that scales by the ratio of the distances of two points from a
   * single point with respect to another fixed point.
   * @class Dilate3PtRatio
   *
   * @augments GSP.gConstraints.DilateFixFactor
   */
  GSP.gConstraints.Dilate3PtRatio = GSP.makeClass(
    GSP.gConstraints.DilateFixFactor,
    /** @lends GSP.gConstraints.Dilate3PtRatio */ {
      doc: {
        description:
          'Defines a new GObject as a dilation about a point of a GObject by a ratio of three points, A, B, C. The ratio is |AB|/|AC|.',
        inherits: 'DilateFixFactor',
        refspec: {
          gspRef: 'Dilate3R_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, Dilate3R_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent object, the three angle points exist and the |AB| evaluates to a non-zero length.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Dilate3PtRatio_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              A: {
                description: 'First control point of the line',
                kind: 'Point',
              },
              B: {
                description: 'Second control point of the line',
                kind: 'Point',
              },
              C: {
                description: 'The point that is mapped to the line',
                kind: 'Point',
              },
            },
          },
          scaleFactor: { suppressed: true },
        },
      },

      getScaleFactor: function() {
        var a = this.getParent('A').geom.loc,
          b = this.getParent('B').geom.loc,
          c = this.getParent('C').geom.loc;
        return GSP.GeometricPoint.mapPointToLine(a, b, c).param;
      },

      getScaleText: function(option) {
        // Return the gobj's scale
        var a = this.getVisibleParentLabel('A', option),
          b = this.getVisibleParentLabel('B', option),
          c = this.getVisibleParentLabel('C', option);
        return a + c + '/' + a + b;
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that scales by a measurement with respect to a fixed point.
   * @class DilateFixFactor
   *
   * @augments GSP.gConstraints.DilateFixFactor
   */
  GSP.gConstraints.DilateMeasureFactor = GSP.makeClass(
    GSP.gConstraints.DilateFixFactor,
    /** @lends GSP.gConstraints.DilateFixFactor */ {
      doc: {
        description:
          'Defines a new GObject as a dilation about a point of a GObject by a measurement.',
        inherits: 'DilateFixFactor',
        refspec: {
          gspRef: 'DilatemR_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, DilatemR_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object, the center point and the measurement exist and the measurement evaluates to a finite, non-zero number.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-DilateMeasureFactor_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              measure: {
                description: 'A measurement or calculation',
                kind: 'Measure',
              },
            },
          },
          scaleFactor: { suppressed: true },
        },
      },

      getScaleFactor: function() {
        return this.getParent('measure').value;
      },

      getScaleText: function(option) {
        // Return the gobj's scale
        return this.getParentLabel('measure', option);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * The first intersection of a circle and a straight or circle
   */
  GSP.gConstraints.Intersection1 = GSP.makeClass(
    GSP.gConstraints.Intersection,
    {
      doc: {
        description:
          'One of two points of intersection of an ' +
          '<span class="kind">Arc</span> or <span class="kind">Circle</span> ' +
          'with another Arc, Circle, or <span class="kind">Straight</span> object.',
        inherits: 'Intersection',
        refspec: {
          gspRef: 'InterLCA',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraints, InterLCA and InterCCA, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule:
          'Exists iff the parent objects exist and have at least one point of intersection.',
        properties: {
          parents: {
            description: '',
            properties: {
              circle: {
                description:
                  'The first of two GObjects for which intersection(s) are to be determined',
                kind: 'Arc|Circle',
              },
              obj: {
                description:
                  'The second of two GObjects for which intersection(s) are to be determined',
                kind: 'Arc|Circle|Straight',
                type: 'GObject',
              },
              line0: { suppressed: true },
              line1: { suppressed: true },
            },
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection12_export.json',
      },

      getIntersectionPoints: function() {
        return GSP.getIntersectionPoints(
          this.getParent('circle').getGeometricArc(),
          this.getParent('obj')
        );
      },
      constrain: function() {
        var points = this.getIntersectionPoints();
        if (points[0]) {
          this.geom.loc = points[0];
          this.state.exists = true;
        } else {
          this.geom.loc = GSP.GeometricPoint(undefined, undefined);
          this.state.exists = false;
        }
      },
    }
  );

  GSP.getIntersectionPoints = function(arc0, obj0) {
    var rtn = [],
      obj1IsStraight = obj0.kind === 'Straight' || obj0.kind === 'Axis',
      obj1 = obj1IsStraight ? obj0 : obj0.getGeometricArc(),
      orientation = 0,
      kind0 = arc0.orientation === 0 ? 'Straight' : 'Arc',
      kind1 =
        obj1.kind === 'Straight' ||
        obj1.kind === 'Axis' ||
        obj1.orientation === 0
          ? 'Straight'
          : 'Arc',
      kinds = kind0 + kind1,
      pt;

    switch (kinds) {
      case 'StraightStraight':
        pt = GSP.Geom.LineLineIntersection(arc0, obj1);
        if (pt.isDefined()) {
          rtn.push(pt, pt);
        }
        break;
      case 'ArcStraight':
        rtn = GSP.Geom.CircleStraightIntersection(arc0, obj1);
        break;
      case 'StraightArc':
        orientation = -obj1.orientation;
        rtn = GSP.Geom.CircleStraightIntersection(obj1, arc0);
        break;
      case 'ArcArc':
        rtn = GSP.Geom.CircleCircleIntersection(arc0, obj1);
        break;
    }

    rtn = $.grep(rtn, function(p) {
      //These tests are only needed for the case where one of the curves is an
      //arc, because the tests above have already tested points being in the
      //bounds of the straights.  Therefore, we skip pointIsInBounds on a straight
      //obj1 because it's already been done.
      return (
        arc0.pointIsInBounds(p) && (obj1IsStraight || obj1.pointIsInBounds(p))
      );
    });

    if (-1 === orientation) {
      rtn.reverse();
    }

    return rtn;
  };

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */

  (function() {
    var MoveMotion = {
      init: function init() {
        this.isAtTarget = false;
        this.controlList = this.sketch.Bap.createControlList([this.moverGObj]);
        this.motionID = null;
        this.lastSample = Date.now();
      },
      // Is this an instant motion?
      isInstant: function() {
        // ask our button, since our this.rate might not yet be initialized.
        return this.button.rate === 0;
      },
      /*
       * Decide if our motion is at the target
       *
       * 'this' is assumed to be the motion object
       */
      reconfigureFromConstraints: function() {
        if (this.canKeepMoving() && this.getStep().isAlreadyThere) {
          if (this.wasAtTarget) {
            this.isAtTarget = true; // mover has been at target for two steps in a row, so the target isn't moving
          } else {
            this.wasAtTarget = true; // If the mover is at the target  on the next step, we'll set isAtTarget to true.
          }
        } else {
          // mover isn't at the target, so set both flags to false.
          this.wasAtTarget = false;
          this.isAtTarget = false;
        }
      },

      // movement is on hold if either object does not exist (unless we have
      // a cached target location.
      canKeepMoving: function canKeepMoving() {
        return this.moverGObj.state.exists && false !== this.getDest();
      },

      /*
       * applyMotion callback required by the motion API.  Gets called when
       * the motion is advanced.
       *
       * 'this' is assumed to be the motion object
       */
      applyMotion: function applyMoveMotion() {
        var now = Date.now(),
          msSinceLastFrame = Math.max(now - this.lastSample, 1),
          isPointOnPath = this.moverGObj.genus === 'PointOnPath',
          startValue,
          rate;

        // Check if our target is moving out from under us, so we can
        // keep following it. If our rate is instant, though, we don't
        // care what it does, because we have to stop.
        if (!this.isInstant()) {
          this.reconfigureFromConstraints();
        }
        // We are done if we hit the target on the last movement and
        // the target did not move on its subsequent opportunity.
        if (this.isAtTarget) {
          this.sketch.MotionManager.EndMotion(this.motionID);
          this.sketch.event('EndMove', {
            button: this.button,
            id: this.button.id,
          });

          if (!this.pressSource) this.button.state.pressedUp = true;
        } else {
          if (this.canKeepMoving()) {
            // get rate for movement and adjust for the actual elapsed time.
            // we are expecting a wakeup every 60th of a second.
            rate =
              this.rate *
              GSP.kWebSpeedMultiplier *
              (msSinceLastFrame / 1000) *
              GSP.kIdealFrameRate;

            // Every motion can compute a Step object which either
            // advances the motion by one step or denotes that the
            // motion has hit its target.
            // If the moverGObj is a point on path and it doesn't move, there's no need (and considerable cost!) to reconstrain.
            // This can be the case with a point on path that's trying to move to a destination not on the path.
            // Might this also be a problem with a point at an intersection?
            if (isPointOnPath) {
              startValue = this.moverGObj.value;
            }
            this.isAtTarget = this.getStep().move(rate);
            if (!isPointOnPath || startValue !== this.moverGObj.value) {
              this.sketch.invalidateGeom(this.moverGObj);
            }
          }
          // if destination is non-existing, the motion just freezes
          // where it is until it comes into existence

          this.lastSample = now;
        }
      },

      /*
       * completeMotion callback required by the motion API.  Gets called when
       * the motion is cancelled
       *
       * 'this' is assumed to be the motion object
       */
      completeMotion: function completeMoveMotion() {
        //'this' is the motion object
        var i;

        this.motionID = undefined;
        //if we've only got one, we're stopping the last one
        this.button.activate(
          this.button.state.motions.length > 1,
          this.pressSource
        );

        //remove from the array of motions
        for (i = 0; i < this.button.state.motions.length; i++) {
          if (this === this.button.state.motions[i]) {
            this.button.state.motions.splice(i, 1);
            break;
          }
        }

        if (!this.button.state.isActive) {
          this.sketch.invalidateGeom(this.button);
        }
      },
    };

    var PointMotion = GSP.makeClass(MoveMotion, {
      /*
       * This method computes the distance (in pixels) a movement will
       * travel. 'This' is assumed to be a motion object with a target
       * and a destination. We set this.distance to the distance of the
       * motion, or 0 if the motion should be skipped.
       * Subclass must define both getDestLoc to return the target's geom.loc
       * and getDest() to return a value that determines the location.
       * @return {undefined}
       */
      initializeDistance: function initializePointDistance() {
        var mover = this.moverGObj,
          targetLoc = this.getDestLoc();

        //set the distance between the target and the mover
        if (targetLoc) {
          this.distance = targetLoc.subtract(mover.geom.loc).vLength();
        } else {
          //If the distance is unmeasurable due to a non-existing destination
          //we use the arbitrary distance of sqrt(100) pixels as this motion's distance.  See
          //Motion_CommenceMovementAction() in motion.c for equivalent logic.  A consequence
          //of this is that if there's another motion that does exist, this one gets an
          //extremely slow rate of speed when it comes into existence.  This behavior is
          //probably not desirable, but at least the two implementations are consistent.
          this.distance = 10;
        }
      },
    });

    var ParameterMotion = GSP.makeClass(MoveMotion, {
      init: function init() {
        (init.base || arguments.callee.base).call(this);
        this.isValueChangingMotion = true;
      },

      getDest: function getDest() {
        // If we're instant, and our target is blank,
        // we can become blank.
        if (this.targetGObj.blank) {
          return this.isInstant() ? 'blank' : false;
        }

        // If our own value is blank, and we are not
        // an instant, we can't move towards our desination -
        // there are no intermediate values to move to.
        if (this.moverGObj.blank && !this.isInstant()) {
          return false;
        }

        return !isNaN(this.targetGObj.value) && this.targetGObj.value;
      },

      /*
       * This method computes the distance (in pixels) a movement will
       * travel. 'This' is assumed to be a motion object with a target
       * and a destination. We set this.distance to -1 for parameter
       * motions, or 0 if the motion should be skipped.
       *
       * @return {undefined}
       */
      initializeDistance: function initializeParameterDistance() {
        var mover = this.moverGObj;

        if (mover.value === this.targetGObj.value) {
          //The mover is already at the target.  Consider it a 0
          //distance motion that will be skipped.
          this.distance = 0;
        } else {
          //parameter motions
          this.distance = -1;
        }
      },

      getStep: function getStepValue() {
        var moverGObj = this.moverGObj,
          targetValue = this.getDest(),
          delta = targetValue - moverGObj.value,
          sign = delta < 0 ? -1 : 1,
          atEnd = delta === 0,
          step = {
            isAlreadyThere: atEnd,
            /*
             * workhorse for moving parameters
             *
             * @param {number} rate - the rate in pixels per frame of the motion
             * @return {bool} true to end the motion, false to keep going
             */
            move: function move(rate) {
              // Move to blank happens right away
              if (targetValue === 'blank') {
                moverGObj.setParameterValue('');
                moverGObj.blank = true;
                return true;
              }

              if (!atEnd) {
                // Handle rate 0 specially. This means instant move to the target
                // point.
                if (rate === 0 || Math.abs(delta) <= Math.abs(rate)) {
                  moverGObj.updateValue(targetValue);
                  // If we were blank, we're not now that we've moved
                  // to a non-blank target
                  if (moverGObj.blank) {
                    moverGObj.blank = false;
                  }
                } else {
                  moverGObj.updateValue(
                    moverGObj.value + sign * Math.abs(rate)
                  );
                }
              }

              return rate === 0 || atEnd;
            },
          };
        return step;
      },
    });

    var PointRootsMotion = GSP.makeClass(PointMotion, {
      getStep: function getStepPointRoots() {
        var kLEN_TOLERANCE = 1e-12, // rounding error might get us close but not exactly at target
          p0 = this.moverGObj.geom.loc,
          v = this.getDest().subtract(p0),
          len = v.vLength(),
          motion = this,
          step = {
            isAlreadyThere: len <= kLEN_TOLERANCE,
            /*
             * moveFunction workhorse for moving point roots
             *
             *
             * @param {number} rate - the rate in pixels per frame of the motion
             * @return {bool} true to end the motion, false to keep going
             */
            move: function(rate) {
              var atEnd = false,
                delta;

              // Handle rate 0 specially. This means instant move to the target
              // point.
              if (rate === 0 || Math.abs(rate) >= len) {
                delta = v;
                atEnd = true;
              } else {
                delta = v.multiply(rate / len);
              }

              motion.sketch.MotionManager.ApplyTransformToControlList(
                motion.sketch,
                new GSP.AffineTransform({
                  m00: 1,
                  m11: 1,
                  m20: delta.x,
                  m21: delta.y,
                }),
                motion.controlList,
                { snapPoints: false, onPathTracksIdealLoc: false }
              );

              return atEnd;
            },
          };
        return step;
      },

      getDestLoc: function getDestLoc() {
        return this.targetGObj.geom.loc.isDefined() && this.targetGObj.geom.loc;
      },

      getDest: function getDest() {
        return this.getDestLoc();
      },
    });

    var PointOnPathMotion = GSP.makeClass(PointMotion, {
      // If the point on path is moving to the target's initial destination, we use
      // the cached initial value of the target mapped to the path as our destination.
      // If the point on path is following a moving target, we recalculate the
      // mapped value of the target at every step.

      getStep: function getStepPointOnPath() {
        var motion = this,
          kVAL_TOLERANCE = 1e-10, // rounding error might get us close but not exactly at target
          moverGObj = this.moverGObj,
          targetGObj = this.targetGObj,
          pathGobj = moverGObj.getParent('path'),
          samePath =
            targetGObj.isFreePointOnPath &&
            targetGObj.getParent('path') === pathGobj,
          moverValue = moverGObj.value,
          targetValue = this.getDest(),
          motionPath = pathGobj.makeMotionPath(moverValue, targetValue),
          newValue,
          step,
          atEnd;

        function checkAtEnd() {
          if (motion.button.towardInitialDestination) {
            // Compare the mover's current value to the cached target value
            return (
              Math.abs(moverGObj.value - motion.getDest()) < kVAL_TOLERANCE
            );
          } else {
            // Compare the current locations of the mover and the target.
            return (
              moverGObj.geom.loc.subtract(targetGObj.geom.loc).vLength() <
              kVAL_TOLERANCE
            );
          }
        }

        atEnd = checkAtEnd();
        step = {
          isAlreadyThere: atEnd,
          /*
           * workhorse for moving points on path
           *
           * @param {number} rate - the rate in pixels per frame of the motion
           * @return {bool} true to end the motion, false to keep going
           */
          move: function move(rate) {
            if (!atEnd) {
              // Handle rate 0 specially. This means instant move to the target
              // point.
              if (rate === 0) {
                // newValue = motionPath.advance(motionPath.getDistance());
                // SS: getDistance returns a computed value based on the path's extent and its screenbounds if a ray or line.
                // This can result in failure to get to the correct ending position.
                // For an instant move, can we not just do this instead?
                newValue = motionPath.end;
              } else {
                newValue = motionPath.advance(rate);
              }
              // Ensure we exactly coincide with target point on path.
              if (checkAtEnd(newValue) && samePath) {
                moverGObj.updateValue(targetGObj.value);
              } else {
                moverGObj.updateValue(newValue);
              }
            }
            return rate === 0 || atEnd;
          },
        };
        return step;
      },

      // The mover is a point on path, so its dest must be a value.
      getDest: function getDest() {
        var target = this.targetGObj,
          path = this.moverGObj.getParent('path');
        if (target.isFreePointOnPath && target.getParent('path') === path) {
          return target.value; // target is on path; return its value
        } else {
          return path.mapPositionToPathValue(target.geom.loc); // not on path; find target's value on path
        }
      },

      getDestLoc: function getDestLoc() {
        var path = this.moverGObj.getParent('path');
        if (this.button.towardInitialDestination) {
          // initial destination lies on moverGObj's path.
          return path.mapPathValueToPosition(this.getDest());
        } else {
          // following a moving destination, we have to keep trying.
          return this.targetGObj.geom.loc;
        }
      },
    });

    /**
     * A button that moves a set of points towards other points.
     */
    GSP.gConstraints.ActionButtonMove = GSP.makeClass(
      GSP.gConstraints.ActionButton,
      {
        doc: {
          description:
            'A button that moves a set of points towards other points.',
          inherits: 'ActionButton',
          refspec: {
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: {
            abstract: false,
            kinds: ['Button'],
          },
          properties: {
            parents: {
              description: 'Set of objects to be moved',
              type: 'Object',
              properties: {
                '0': {
                  description:
                    'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                  kind: 'Point|Expression',
                },
              },
              regex: /^[0-9]+$/,
            },
            rate: {
              description:
                'For point animation, the number of pixels to advance per frame cycle.',
              type: 'Number',
            },
            towardInitialDestination: {
              description:
                'Rather than follow a moving destination, move to the position the destination was when the movement started ',
              default: false,
              type: 'Boolean',
            },
          },
          example:
            '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Move_export.json',
        },
        rate: 1,
        towardInitialDestination: false,
        updateConstraintAncestry: function updateConstraintAncestry() {
          (updateConstraintAncestry.base || arguments.callee.base).call(this);
          this.state.motions = [];
        },

        updateLabelForConstraint: function() {
          var target, mover;

          if (this.numParents() !== 2 || !this.shouldAutogenerateLabel) {
            return;
          }

          target = this.parentsList[0];
          mover = this.parentsList[1];

          if (target.labelExists() && mover.labelExists()) {
            this.messages = [
              GSP.Strings.loc(
                'GSP.Label.MoveButton',
                mover.label,
                target.label
              ),
            ];
            this.label = this.messages[0];
          }
        },

        /**
         * Press the button.
         */
        press: function(sketch, pressSource) {
          var button = this,
            i,
            newMotion,
            maxDistanceToTravel = -1,
            numFramesToComplete;

          //numFramesToComplete is calculated as if animations play at an
          //ideal 30 fps and no movement of destinations.  WSP actually
          //runs animations at 60 fps with a .5 speed multiplier.  Movement
          //speeds are set at px/frame in a 30 fps world.

          //The algorithm for setting the rate of motion of a set of motions is
          //as follows (and mirrors desktop Sketchpad):
          //-- The object with the longest distance to travel should travel at
          //   the desired rate (medium = 3 px/frame @ 30 fps, or 90 px/sec)
          //-- All other motions will scale their speed to complete their motion
          //   in the same amount of time (assuming no destinations are moving)
          //-- If all motions are move buttons, they all complete their motion in the
          //   time it would take a point to travel 400 px (which is 4.44 seconds at
          //   medium speed).

          /*
           * Creates and returns a new motion given a mover and a target.  If the
           * motion cannot begin, either because the mover is already at the target
           * or if it's a 'towardInitialDestination' motion, no motion is returned.
           * If it's a 'towardInitialDestination' motion, we cache the target
           * location (PointRootsMotion) or the target value (PointOnPathMotion & ParameterMotion).
           *
           *
           * @param {object} mover - the gobject to move
           * @param {object} target - the gobject that the mover is moving towards
           *
           * @return {object} the initialized motion
           */
          function createNewMotion(mover, target) {
            var cachedDest, // initial target value or location
              motionClass,
              motion;

            switch (mover.kind) {
              case 'Point':
                motionClass = mover.isFreePointOnPath
                  ? PointOnPathMotion
                  : PointRootsMotion;
                break;
              case 'Expression':
                motionClass = ParameterMotion;
                break;
              default:
                throw GSP.createError(
                  'Move button encountered unexpected object type'
                );
            }

            motion = GSP.makeInstance(motionClass);
            $.extend(motion, {
              moverGObj: mover,
              targetGObj: target,
              sketch: sketch,
              button: button,
              pressSource: pressSource,
            });
            motion.init();

            if (button.towardInitialDestination) {
              if (!motion.targetGObj.state.exists) {
                //Our target doesn't exist and we're supposed to move to its initial
                //destination.  We can't do anything.  Just bag out of this motion
                return;
              }
              // Cache the value or location we're moving to.
              cachedDest = motion.getDest();
              motion.getDest = function() {
                return cachedDest;
              };
            }

            if (motion.moverGObj.state.exists) {
              motion.initializeDistance();
              if (0 !== motion.distance) {
                return motion;
              }
            }
            //else return undefined
          }

          if (!this.state.isActive) {
            this.activate(true);
            GSP.log('Starting move ' + button.id);

            for (i = 0; i < this.numParents(); i += 2) {
              newMotion = createNewMotion(
                this.parentsList[i + 1],
                this.parentsList[i]
              );

              if (newMotion) {
                maxDistanceToTravel = Math.max(
                  maxDistanceToTravel,
                  newMotion.distance
                );
                this.state.motions.push(newMotion);
              }
            }

            //nothing to move - bag out now!!!
            if (this.state.motions.length === 0) {
              this.activate(false);
              //invalidate our geometry so downstream presentation buttons have
              //a chance to proceed.
              sketch.invalidateGeom(this);
              return;
            }

            //If we still haven't set maxDistanceToTravel, then all motions are
            //parameter motions, or we have no measurable distance because they all
            //cuurently don't exist.  We choose the arbitrary 'distance' of 400 pixels
            //See Motion_CommenceMovementAction() in motion.c for eqivalent Desktop
            //logic.
            if (this.rate !== 0) {
              maxDistanceToTravel =
                maxDistanceToTravel === -1 ? 400 : maxDistanceToTravel;
              numFramesToComplete = maxDistanceToTravel / this.rate;

              if (numFramesToComplete === 0) {
                numFramesToComplete = 1;
              }
            }

            //now, with a known maxDistance, iterate through each motion, setting
            //a proper speed and starting the motion
            $.each(this.state.motions, function(index, aMotion) {
              var moverValue, targetValue, targetDelta;

              //if the button has 0 rate, then all motions have a rate of 0 (instant)
              if (button.rate === 0) {
                //Instant buttons
                aMotion.rate = 0;
              } else {
                if (aMotion.targetGObj.kind === 'Point') {
                  //points motions
                  aMotion.rate = aMotion.distance / numFramesToComplete;
                } else {
                  //parameter motions
                  moverValue = aMotion.moverGObj.value;
                  targetValue = aMotion.getDest();

                  if (targetValue !== false) {
                    targetDelta = targetValue - moverValue;
                    aMotion.rate = targetDelta / numFramesToComplete;
                  } else {
                    //As per the logic in Motion_CommenceMovementAction(), use
                    //the default of 100 if the delta can not be calculated now.
                    aMotion.rate = 100 / numFramesToComplete;
                  }
                }
              }
              if (isNaN(aMotion.rate)) {
                GSP.signalErrorWithMessage(
                  'This Move Button calculated a Nan rate of speed!'
                );
                //We can't compute a rate of a nan distance.  This shouldn't happen, but
                //in the interest of surviving, we just inherit the overall rate of the button
                aMotion.rate = button.rate;
              }

              sketch.event('StartMove', {
                button: button,
                id: button.id,
              });
              aMotion.motionID = sketch.MotionManager.StartMotion(aMotion);

              if (!pressSource) button.state.pressedDown = true;
            });
          } else {
            GSP.log('Canceling move ' + button.id);

            for (i = 0; i < this.state.motions.length; i++) {
              sketch.MotionManager.EndMotion(this.state.motions[i].motionID);
            }
            sketch.event('EndMove', {
              button: button,
              id: button.id,
            });

            if (!pressSource) button.state.pressedUp = true;
          }
        },
      }
    );
  })();

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint for tables made by users
   */
  /*global JSONcanonical:false */
  GSP.gConstraints.UserTabulation = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: '',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'UserTabulation_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, UserTabulation_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Table'],
      },
      properties: {
        parents: {
          description: 'An associative array of objects used in the table.',
          type: 'Array',
        },
      },
    },

    snapshotParentsAsRowMFS: function() {
      var rowMFS = [];

      this.eachParent(function(i, parent) {
        rowMFS.push(parent.getMFSAppearanceForVariant());
      });

      return rowMFS;
    },

    constrain: function constrain() {
      // If this.finalRowMFS is updated, we have to do a full
      // re-render of the table; we try to avoid that if possible
      // by only updating it if it has changed.
      var finalRowMFS = this.snapshotParentsAsRowMFS(),
        finalRowString = JSONcanonical.stringify(finalRowMFS);

      if (finalRowString !== this.cachedFinalRowString) {
        this.finalRowMFS = finalRowMFS;
        this.cachedFinalRowString = finalRowString;
      }
    },

    doubleClicked: function(/*touch*/) {
      var newRowMFS = this.snapshotParentsAsRowMFS();
      // Create a new array to force a re-render from the html engine.
      this.rowsMFS = this.rowsMFS ? this.rowsMFS.slice() : [];
      this.rowsMFS.push(newRowMFS);
    },

    updateConstraintAncestry: function updateConstraintAncestry() {
      var table = this;

      table.headersMFS = [];

      table.eachParent(function(i, parent) {
        table.headersMFS.push(table.getColumnLabelMFS(parent));
      });
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint for tables made by iteration.
   */
  (function() {
    var MAX_ROWS = 19;

    // class that allows a column to impersonate an iterateImage
    //
    // Our table's first parent, an iterateMap, thinks each column is an
    // iterateImage. So we implement that API here, the most important
    // methods of which are: collectSample, clearSamples, and
    // stampTerminalSample.

    var columnImagePrototype = {
      hasCurrentIterationRow: function() {
        return this.table.currentIterationRow !== null;
      },

      finishRow: function() {
        var table = this.table;

        if (this.hasCurrentIterationRow()) {
          table.rowsMFS.push(table.currentIterationRow);
        } // Do nothing if we've already reached MAX_ROWS rows.

        table.currentIterationRow = null;
        table.rowCount++;
      },

      pushColumnMFSFor: function(gobj) {
        var table = this.table;
        if (this.hasCurrentIterationRow()) {
          table.currentIterationRow.push(gobj.getMFSAppearanceForVariant());
        }
      },

      startRow: function(options) {
        var firstColumnText =
          options && options.hasOwnProperty('firstColumnText')
            ? options.firstColumnText
            : this.table.rowCount;
        this.table.currentIterationRow = [GSP.mfs.makeTextMFS(firstColumnText)];
      },

      // The table's first row is just '0', and the MFS for each parent
      createFirstRow: function() {
        var table = this.table,
          column = this;

        column.startRow();
        table.eachParent(function(i, parent) {
          if (i > 0) {
            column.pushColumnMFSFor(parent);
          }
        });
        column.finishRow();
      },

      collectSample: function() {
        var table = this.table,
          column = this;

        // Create a row if we are the first column in it.
        if (!column.hasCurrentIterationRow()) {
          if (table.rowCount === 0) {
            // The table's first row is just the MFS for each parent
            column.createFirstRow();
          }
          // Any rows after MAX_ROWS are not shown, except the last one.
          if (table.rowCount < MAX_ROWS) {
            column.startRow();
          }
        }

        column.pushColumnMFSFor(column.clonedGObj);

        if (column.isLastColumn) {
          column.finishRow();
        }
      },

      // This is how we tell the map what 'source' object we are tracking.
      //
      // It is called by the map in function registerImageAndGetClone,
      // with one argument, the string 'source.'
      getParent: function() {
        return this.parent;
      },

      clearSamples: function() {
        this.table.rowsMFS = [];
        this.table.rowCount = 0;
        this.table.currentIterationRow = null;
      },

      sampleCountChanged: function() {},

      stampTerminalSample: function() {
        var table = this.table,
          column = this;

        if (table.rowCount > 0 && table.rowCount <= MAX_ROWS) return; // Nothing to do

        function addEllipsesRow() {
          table.currentIterationRow = [];
          table.eachParent(function(i, parent) {
            table.currentIterationRow.push(GSP.mfs.makeTextMFS('...'));
          });
          column.finishRow();
        }

        if (!column.hasCurrentIterationRow()) {
          // This is the first column of the final row.
          // First, show some ellipses if there were any unshown rows.
          if (table.rowCount > MAX_ROWS + 1) {
            addEllipsesRow();
            column.startRow({ firstColumnText: column.table.rowCount - 2 });
          } else if (table.rowCount === 0) {
            column.createFirstRow();
          } else {
            // no ellipses when rowCount === MAX_ROWS + 1
            column.startRow({ firstColumnText: column.table.rowCount - 1 });
          }
        }
        column.pushColumnMFSFor(column.clonedGObj);
        if (column.isLastColumn) {
          column.finishRow();
        }
      },
    };

    function makeColumnImage(table, parent) {
      var columnImage = Object.create(columnImagePrototype);
      columnImage.table = table;
      columnImage.parent = parent;
      return columnImage;
    }

    GSP.gConstraints.IteratedValuesTable = GSP.makeClass(
      GSP.gConstraints.Constraint,
      {
        doc: {
          description: '',
          inherits: 'Constraint',
          refspec: {
            gspRef: 'IteratedValuesTable_C',
            msg:
              "This constraint is intended to behave in the same way as the corresponding constraint, IteratedValuesTable_C, in the currently published version of desktop Geometer's Sketchpad.",
          },
          usage: {
            abstract: false,
            kinds: ['Table'],
          },
          properties: {
            parents: {
              description: 'An associative array of objects used in the table.',
              type: 'Array',
            },
          },
        },

        updateConstraintAncestry: function() {
          var map = this.getParent('0'),
            table = this;
          var columnImage;

          table.headersMFS = [];

          table.eachParent(function(i, parent) {
            if (i === 0) {
              table.headersMFS.push(GSP.mfs.makeTextMFS('n', true));
            } else {
              columnImage = makeColumnImage(table, parent);
              columnImage.clonedGObj = map.registerImageAndGetClone(
                columnImage
              );
              table.headersMFS.push(table.getColumnLabelMFS(parent));
            }
          });

          columnImage.isLastColumn = true;
        },

        constrain: function constrain() {},
      }
    );
  })();
  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A button that scrolls the sketch to the position of a point.
   */
  GSP.gConstraints.ActionButtonScroll = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description:
          'A button that scrolls the sketch to the position of a point.',
        inherits: 'ActionButton',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Button'],
        },
        properties: {
          parents: {
            description: 'First object can be scrolled to particular location',
            type: 'Array',
          },
          scrollDest: {
            description:
              'scrolls the page so that the parental point is at specified destination of the window (possible values: center | topLeft).',
            type: 'String',
          },
        },
        example: '',
      },
      scrollDest: 'topLeft',
      press: function(sketch, pressSource) {
        var parent = this.parentsList[0],
          parentLoc = parent.geom.loc.copy(),
          sketchRect = sketch.sketchRect(),
          sketchRectOrigin,
          sketchRectCenter,
          translation;

        if (this.scrollDest === 'center') {
          sketchRectCenter = GSP.GeometricPoint(
            sketchRect.left + (sketchRect.right - sketchRect.left) / 2,
            sketchRect.top + (sketchRect.bottom - sketchRect.top) / 2
          );
          translation = parentLoc.subtract(sketchRectCenter);
        } else {
          sketchRectOrigin = GSP.GeometricPoint(
            sketchRect.left,
            sketchRect.top
          );
          translation = parentLoc.subtract(sketchRectOrigin);
        }

        if (!pressSource) {
          this.state.pressedDown = true;
          this.updateButtonSpeakableText();
        }

        //animate over 8 frames (equivalent to desktop)
        var counter = 0;
        var kNumFrames = 8,
          theButton = this;

        function animationFrame() {
          sketch.Scroll.translate(
            translation.x / kNumFrames,
            translation.y / kNumFrames
          );
          //sketch.translate(translation.x/kNumFrames, translation.y/kNumFrames);
          counter++;
          if (counter < kNumFrames) {
            sketch.addDeferredCall(theButton, animationFrame);
          } else {
            sketch.setGobjPositionInDocumentBound();
          }
        }
        sketch.addDeferredCall(theButton, animationFrame);

        //non animating version - do it all in one step
        //sketch.Scroll.translate(translation.x, translation.y);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A button that scrolls the sketch to the position of a point.
   */
  GSP.gConstraints.ActionButtonLinkPage = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description: 'A button that switches to another page in the sketch.',
        inherits: 'ActionButton',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Button'],
        },
        properties: {
          pageId: {
            description: 'Id of the page being linked to.',
            type: 'String',
          },
          buttonId: {
            description:
              '(Optional) Id of button to activate on the on the linked page.',
            type: 'String',
            required: false,
          },
        },
        example: '',
      },
      pageId: '1',
      press: function(sketch, pressSource) {
        if (!pressSource) {
          this.state.pressedDown = true;
          this.updateButtonSpeakableText();
        } else {
          sketch.setSpeakabletext('Switching page.');
        }

        var doc = sketch.document;
        // Switch to the new page
        doc.switchPage(this.pageId);

        var newSketch = doc.focusPage;

        // Trigger the target button, if one is specified
        var button = this.buttonId && newSketch.sQuery().get(this.buttonId);
        if (button) button.press(newSketch, 'linkButton');
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A button that scrolls the sketch to the position of a point.
   */
  GSP.gConstraints.ActionButtonLinkURL = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description: 'A button that opens a url.',
        inherits: 'ActionButton',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Button'],
        },
        properties: {
          url: {
            description: 'Url to link to.',
            type: 'String',
          },
        },
        example: '',
      },
      url: '',
      init: function init() {
        (init.base || arguments.callee.base).call(this);
      },
      constrain: function(sketch) {},
      press: function(sketch, pressSource) {
        if (!pressSource) {
          this.state.pressedDown = true;
          this.updateButtonSpeakableText();
        }
        if (window) {
          window.open(this.url);
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a parallel to its parent line and point.
   */
  GSP.gConstraints.Parallel = GSP.makeClass(GSP.gConstraints.Line, {
    doc: {
      description:
        'Defines a line through a <span class="kind">Point</span> parallel with another <span class="kind">Straight</span>.',
      inherits: 'Line',
      refspec: {
        gspRef: 'Parallel_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Parallel_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Straight'],
      },
      existenceRule: 'Exists iff the parent point and line exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: '',
              kind: 'Point',
            },
            line: {
              description: '',
              kind: 'Straight',
            },
            p1: { suppressed: true },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Parallel_export.json',
    },
    constrain: function() {
      var parentLine = this.getParent('line');
      var parentLineP0 = parentLine.geom.p0;
      var parentLineP1 = parentLine.geom.p1;
      var parentPoint = this.getParent('p0').geom.loc;
      var v = parentLineP1.subtract(parentLineP0).multiply(0.5);
      this.geom.p0 = parentPoint.subtract(v);
      this.geom.p1 = parentPoint.add(v);
      var len = v.vLength();
      var multiplier = 10000 / len;
      var begin = parentPoint.add(v.multiply(-multiplier));
      var end = parentPoint.add(v.multiply(multiplier));
      this.geom.xp0 = begin;
      this.geom.xp1 = end;
    },
    //override the straight parental naming - we don't want any parental name
    getParentalNameMFS: function() {
      //Silencing error until reform of label renderPrepare is completed
      //GSP.signalErrorWithMessage("Parallel.getParentalNameMFS() shouldn't be called.");
      return GSP.mfs.makeTextMFS('Parallel line ' + this.id);
    },

    /*
     * Determine whether two gobjs are defined by the same parents in such a way that
     * they can be merged, typically used when one is created by a tool and the other already
     * exists in the sketch.
     */
    canMergeTo: function(gobj) {
      // Parents p0 and p1 can be interchanged.
      var a0 = this.getParent('p0'),
        b0 = gobj.getParent('p0'),
        a1 = this.getParent('line'),
        b1 = gobj.getParent('line'),
        retVal = false;
      if (!(a0 && b0 && a1 && b1)) {
        GSP.signalErrorWithMessage('Parallel canMergeTo() missing parents!');
      } else {
        retVal = a0 === b0 && a1 === b1;
      }
      return retVal;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a perpendicular to its parent line and point.
   */
  GSP.gConstraints.Perpendicular = GSP.makeClass(GSP.gConstraints.Line, {
    doc: {
      description:
        'Defines a line through a <span class="kind">Point</span> perpendicular with another <span class="kind">Straight</span>.',
      inherits: 'Line',
      refspec: {
        gspRef: 'Perpend_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, Perpend_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
        kinds: ['Straight'],
      },
      existenceRule: 'Exists iff the parent point and line exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            p0: {
              description: '',
              kind: 'Point',
            },
            line: {
              description: '',
              kind: 'Straight',
            },
            p1: { suppressed: true },
          },
        },
      },
      example:
        '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Straight-Perpendicular_export.json',
    },
    constrain: function() {
      var parentLineGobj = this.getParent('line');
      var parentVector = parentLineGobj
        .getP1()
        .subtract(parentLineGobj.getP0());
      var perpVector = GSP.GeometricPoint(-parentVector.y, parentVector.x);
      var thruPoint = this.getParent('p0').geom.loc;
      var multiplier = 10000;

      // calculate the reference points for the line
      this.geom.p0 = thruPoint.add(perpVector.multiply(-1 / 2));
      this.geom.p1 = thruPoint.add(perpVector.multiply(1 / 2));
      this.geom.xp0 = thruPoint.add(perpVector.multiply(-multiplier));
      this.geom.xp1 = thruPoint.add(perpVector.multiply(multiplier));
    },
    //override the straight parental naming - we don't want any parental name
    getParentalNameMFS: function() {
      GSP.signalErrorWithMessage(
        "Perpendicular.getParentalNameMFS() shouldn't be called."
      );
      return null;
    },

    /*
     * Determine whether two gobjs are defined by the same parents in such a way that
     * they can be merged, typically used when one is created by a tool and the other already
     * exists in the sketch.
     */
    canMergeTo: function(gobj) {
      // Parents p0 and p1 can be interchanged.
      var a0 = this.getParent('p0'),
        b0 = gobj.getParent('p0'),
        a1 = this.getParent('line'),
        b1 = gobj.getParent('line'),
        retVal = false;
      if (!(a0 && b0 && a1 && b1)) {
        GSP.signalErrorWithMessage(
          'Perpendicular canMergeTo() missing parents!'
        );
      } else {
        retVal = a0 === b0 && a1 === b1;
      }
      return retVal;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A constraint that binds a polygon to a sequence of points.
   */
  GSP.gConstraints.PolygonFromPoints = GSP.makeClass(
    GSP.gConstraints.Constraint,
    {
      doc: {
        description:
          'Defines a polygon from a sequence of <span class="kind">Point</span>s.',
        inherits: 'Free',
        refspec: {
          gspRef: 'Polygon_C',
        },
        usage: {
          kinds: ['Polygon'],
          abstract: false,
        },
        existenceRule:
          'Exists iff the parent points exist and are not all coincident.',
        properties: {
          parents: {
            description:
              'An associative array of points that define the polygon. Key values are ignored in processing.',
            properties: {
              '0': {
                description: 'Vertices labeled "0", ..., "n"',
                kind: 'Point',
              },
            },
            regex: /^[0-9]+$/,
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Polygon-Polygon_export.json',
      },

      standardizeTool: function(objSpecs, poly) {
        console.log(
          'PolygonFromPoints.standardizeTool is a stub; a functional version is in the stek-givens GitHub branch.'
        );
      },

      updateConstraintAncestry: function updateConstraintAncestry() {
        (updateConstraintAncestry.base || arguments.callee.base).call(this);
        this.geom.points = [];
      },
      constrain: function() {
        var key,
          exists = false,
          aPoint;
        this.geom.points = [];
        for (key in this.parents) {
          if (this.parents.hasOwnProperty(key)) {
            aPoint = this.getParent(key).geom.loc;
            this.geom.points.push(aPoint);
          }

          //as soon as there's any distance at all between any points, we exist
          if (!exists && this.geom.points.length) {
            exists = !aPoint.equals(this.geom.points[0]);
          }
        }

        this.state.exists = exists;
      },
      getParentalNameMFS: function(option) {
        var self = this,
          names = [];

        this.eachParent(function(index, parent) {
          if (!parent.label) {
            self.getParentLabel(index, option);
          }
          names.push(parent.getNameMFS());
        });

        return GSP.mfs.makeHorizontalNamesMFS(
          names,
          this.genus === 'Triangle' ? { type: 'symbol', value: '102' } : null
        );
      },

      /*
       * Determine whether two polygons are defined by the same parents in such a way that
       * they can be merged, typically used when one is created by a tool and the other already
       * exists in the sketch.
       * Handedness (CW vs. CCW) is ignored, so a polygon may flip its handedness when merged.
       */
      canMergeTo: function(gobj) {
        // Determine whether two "similar" polygons have the same ancestry and can be merged.
        var i,
          j,
          retVal = true,
          n = this.parentsList.length,
          j0 = gobj.parentsList.indexOf(this.parentsList[0]);
        if (gobj.constraint !== this.constraint) return false;
        if (gobj.parentsList.length !== n || j0 < 0) return false;
        for (i = 0, j = j0; i < this.parentsList.length; i++, j = (j + 1) % n) {
          if (this.parentsList[i] !== gobj.parentsList[j]) {
            retVal = false;
            break;
          }
        }
        if (!retVal) {
          retVal = true;
          for (
            i = 0, j = j0;
            i < this.parentsList.length;
            i++, j = (j + n - 1) % n
          ) {
            if (this.parentsList[i] !== gobj.parentsList[j]) {
              retVal = false;
              break;
            }
          }
        }
        return retVal;
      },

      collapseDoubledParent: function(vertex) {
        // If there are identical adjacent vertices, provided at least 3 vertices will remain,
        // collapse identical vertices and change its genus if appropriate.
        // If fewer than three distinct vertices remain, remove the polygon itself.
        var sketch = this.sQuery.sketch,
          poly = this,
          list = poly.parentsList,
          working = true,
          start = 0,
          ix,
          test;

        function removeDuplicateVertex(index) {
          // list[index] is a duplicate, so remove it
          var childIndex = vertex.children.indexOf(poly);
          list.splice(index, 1); // Remove vertex from poly parent list
          vertex.children.splice(childIndex, 1); // remove first instance of poly as a child of vertex
          if (vertex.children.indexOf(poly) < 0)
            throw GSP.createError(
              "removeDuplicateVertex removed a child that wasn't duplicated"
            );
        }

        while (working) {
          ix = list.indexOf(vertex, start);
          test = ix + 1;
          if (test >= list.length) test = 0;
          if (test !== ix && list[test] === vertex) {
            working = false;
            removeDuplicateVertex(test);
          } else {
            // ix is a singleton, but there may be a later duplication of vertex, so keep checking
            start = Math.max(start + 1, test + 1);
            working = start < list.length;
          }
        }
        poly.parents = {};
        for (ix = 0; ix < list.length; ix++) {
          poly.parents[ix] = list[ix];
        }
        if (list.length < 3) {
          // It's no longer a polygon.
          sketch.gobjList.removeGObjAndDescendants(this);
        } else {
          switch (list.length) {
            case 3:
              poly.genus = 'Triangle';
              break;
            case 4:
              poly.genus = 'Quadrilateral';
              break;
            case 5:
              poly.genus = 'Pentagon';
              break;
            case 6:
              poly.genus = 'Hexagon';
              break;
            default:
              poly.genus = 'Polygon';
              break;
          }
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * An base class for an action button that executes a set of buttons.
   */
  GSP.gConstraints.ActionButtonPresent = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description: 'Defines an action that executes a set of actions.',
        inherits: 'ActionButton',
        refspec: {
          msg: 'Internal class not intended for instantiation.',
        },
        usage: {
          abstract: true,
        },
        properties: {
          parents: {
            description: 'Set of objects to be triggered',
            type: 'Object',
            properties: {
              '0': {
                description:
                  'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                kind: 'Button',
              },
            },
            regex: /^[0-9]+$/,
          },
          stopAnyMotions: {
            description:
              'Stop any previously started animations before commencing the presentation.',
            default: false,
            type: 'Boolean',
          },
          eraseAnyTraces: {
            description:
              'Erase any previously displayed traces before commencing the presentation.',
            default: false,
            type: 'Boolean',
          },
        },
      },
      stopAnyMotions: false,
      eraseAnyTraces: false,
      /*
      Button press API.
      Base class implementation supports behaviors that can
      trigger on the initial press down (i.e. unpressed -> pressed)
    */
      press: function(sketch, pressSource) {
        // If the button is being pressed down ...
        if (!this.state.isActive) {
          // Do tasks specified ...
          if (this.eraseAnyTraces) {
            sketch.clearTraces();
          }
          if (this.stopAnyMotions) {
            sketch.MotionManager.StopAllMotions();
          }

          // if(!pressSource)
          //   this.state.pressedDown = true;
        }
        //  else {
        //   if(!pressSource)
        //     this.state.pressedUp = true;
        // }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints that bind a parallel to its parent line and point.
   */
  GSP.gConstraints.ActionButtonPresentSequentially = GSP.makeClass(
    GSP.gConstraints.ActionButtonPresent,
    {
      doc: {
        description:
          'Defines an action from an ordered sequence of action buttons.',
        inherits: 'ActionButtonPresent',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          waitTime: {
            description: 'Pause between sequential actions in seconds.',
            type: 'Number',
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Sequence_export.json',
      },
      waitTime: 0,
      pressSource: '',
      constrain: function constrain(sketch) {
        (constrain.base || arguments.callee.base).call(this, sketch);

        var gObj, intervalStart;
        if (this.state.isActive) {
          if (!this.state.inInterval) {
            gObj = this.state.buttonList[this.state.current];
            if (!gObj.state.isActive) {
              this.state.current += 1;
              if (this.state.current >= this.state.buttonList.length) {
                this.activate(false);
                sketch.event('EndSequence', {
                  button: this,
                  id: this.id,
                });

                if (!this.pressSource) this.state.pressedUp = true;
              }
              if (this.state.isActive) {
                this.state.inInterval = true;
                intervalStart = 1000 * this.waitTime + Date.now();
                GSP.log(
                  'Begin interval: now=' +
                    Date.now() +
                    ' start=' +
                    intervalStart
                );
                sketch.addDeferredCall(this, function timer(sketch) {
                  var now, gObj;

                  if (this.state.inInterval) {
                    now = Date.now();
                    if (intervalStart <= now) {
                      this.state.inInterval = false;
                      GSP.log('Activating button: ' + this.state.current);
                      gObj = this.state.buttonList[this.state.current];
                      if (!gObj.state.isActive) {
                        gObj.press(sketch, 'sequenceButton');
                      }
                    } else {
                      //GSP.log("In interval: now=" + now
                      //        + " start=" + intervalStart);
                      sketch.addDeferredCall(this, timer);
                    }
                  }
                });
              }
            }
          }
        }
      },
      /**
       * Creates a sequence animation. Each of the parents are assumed to
       * be buttons. Fire each in turn. When all have completed, set
       * active to false. If the button is pressed while the sequence is
       * active, cancel the current animation.
       *
       * This object manages the following state object properties:
       *   {boolean} state.isActive: whether the button is active.
       *   {array} buttonList: array of gobjs for the buttons of the sequence.
       *   {number} current: the index of the currently active button.
       *   {number} start: the time the currently active button will start or
       *            has started. If this value is in the past, the button is
       *            active, if in the future we are waiting for the pause interval
       *            to elapse before starting the new button.
       */
      press: function press(sketch, pressSource) {
        var isActive, key, gObj;

        this.pressSource = pressSource;

        (press.base || arguments.callee.base).call(this, sketch);

        isActive = this.state.isActive;

        if (!isActive) {
          this.activate(true, pressSource);
          sketch.event('StartSequence', {
            button: this,
            id: this.id,
          });
          this.state.buttonList = [];
          for (key in this.parents) {
            if (this.parents.hasOwnProperty(key)) {
              gObj = this.getParent(key);
              this.state.buttonList.push(gObj);
            }
          }
          this.state.current = 0;
          this.state.inInterval = false;
          gObj = this.state.buttonList[this.state.current];
          if (!gObj.state.isActive) {
            gObj.press(sketch, 'sequenceButton');
          }

          if (!pressSource) this.state.pressedDown = true;
        } else {
          this.activate(false);
          gObj = this.state.buttonList[this.state.current];
          if (gObj.state.isActive) {
            gObj.press(sketch, 'sequenceButton');
          }
          if (this.state.inInterval) {
            sketch.cancelDeferredCall(this);
          }
          sketch.event('EndSequence', {
            button: this,
            id: this.id,
          });

          if (!pressSource) this.state.pressedUp = true;
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * An action button that executes a set of buttons simultaneously.
   */
  GSP.gConstraints.ActionButtonPresentSimultaneously = GSP.makeClass(
    GSP.gConstraints.ActionButtonPresent,
    {
      doc: {
        description:
          'Defines an action that executes a collection of actions simultaneously.',
        inherits: 'ActionButtonPresent',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          stopAfter: {
            description:
              'Stop the presentation after the last action stops, first action stops, or an elapsed number of seconds',
            default: 'lastActionStops',
            type: 'StopCondition',
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Simultaneous_export.json',
      },
      activeButtons: [], //should be considered private to the button - the actual buttons we started
      stopAfter: 'lastActionStops',
      pressSource: '',
      /*Activate all parental action buttons.  If a parent is already active,
       * we add it to the list of active buttonss, but don't press it (since it's
       * already active
       */
      activateButtons: function(sketch) {
        var presentationButton = this;

        this.eachParent(function(index, parentButton) {
          if (!parentButton.state.isActive) {
            parentButton.press(sketch, 'simultaneousButton');
          }

          if (parentButton.state.isActive) {
            presentationButton.activeButtons.push(parentButton);
          }
        });
      },
      /* Deactivates all buttons that we are tracking - buttons that still need
       * to be stopped, because they either were started by us, or were active
       * when we started, and remain active.
       *
       * Buttons that started out being tracked by this button but then were stopped
       * and restarted by another agent are not affected by this call.
       */
      deactivateRemainingButtons: function(sketch) {
        var aButton;

        while (this.activeButtons.length) {
          aButton = this.activeButtons.pop();
          if (aButton.state.isActive) {
            aButton.press(sketch);
          }
        }
      },
      /**
       * Constrains the simultaneous button.
       * It is basically the job of this method to evaluate the status
       * of an action and to correctly modify the status of the button.
       */

      constrain: function constrain(sketch) {
        var aParentHasEnded = false,
          aParentIsStillGoing = false,
          i,
          newActiveButtons = [];

        (constrain.base || arguments.callee.base).call(this, sketch);

        if (this.state.isActive) {
          for (i = 0; i < this.activeButtons.length; i++) {
            var parentIsActive = this.activeButtons[i].state.isActive;

            aParentHasEnded = aParentHasEnded || !parentIsActive;
            aParentIsStillGoing = aParentIsStillGoing || parentIsActive;

            if (parentIsActive) {
              newActiveButtons.push(this.activeButtons[i]);
            }
          }

          //prune the no-longer active buttons from the ones we're tracking
          this.activeButtons = newActiveButtons;

          if (this.stopAfter === 'firstActionStops') {
            this.activate(!aParentHasEnded);

            if (!this.state.isActive && aParentIsStillGoing) {
              this.deactivateRemainingButtons(sketch);
            }
          } else {
            this.activate(aParentIsStillGoing);

            if (!this.pressSource) this.state.pressedUp = true;
          }
        }

        if (this.state.timerSet && !this.state.isActive) {
          sketch.cancelDeferredCall(this);
        }
      },
      /**
       * Press the button.
       * Reacts to the completion of a touch drag.
       * If the completion indicates a click, then we want to reverse the
       * state of all parent objects (buttons) whose state corresponds to the
       * state of this button. For example, if this button is inactive, we
       * wish to activate any unactive parent buttons. If this button is
       * active we wish to deactivate any active parents.
       */
      press: function press(sketch, pressSource) {
        var newState = !this.state.isActive,
          stopTime;
        this.pressSource = pressSource;

        GSP.log(
          'SimultaneousButton: state: ' +
            this.state.isActive +
            ' new state: ' +
            newState
        );

        (press.base || arguments.callee.base).call(this, sketch);

        if (newState) {
          this.activateButtons(sketch);
          if (!pressSource) this.state.pressedDown = true;
        } else {
          this.deactivateRemainingButtons(sketch);
          if (!pressSource) this.state.pressedUp = true;
        }

        this.activate(this.activeButtons.length > 0, pressSource);

        if (newState && typeof this.stopAfter === 'number') {
          //Schedule the stopTimer to stop the presentation after the specified
          //number of seconds
          stopTime = 1000 * this.stopAfter + Date.now();
          this.state.timerSet = true;
          sketch.addDeferredCall(this, function stopTimer(sketch) {
            var now;
            if (this.state.timerSet) {
              now = Date.now();
              if (stopTime <= now) {
                this.state.timerSet = false;
                this.deactivateRemainingButtons(sketch);
              } else {
                sketch.addDeferredCall(this, stopTimer);
              }
            }
          });
        }

        if (this.state.timerSet && !newState) {
          sketch.cancelDeferredCall(this);
        }
      },
    }
  );

  /*
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that activates a case action button.
   */

  GSP.gConstraints.ActionButtonPresentCase = GSP.makeClass(
    GSP.gConstraints.ActionButtonPresent,
    {
      doc: {
        description:
          'Defines an action to run one button from an ordered list of action buttons. Operates similarly to a Sequence button, but activates only one of its parents.',
        inherits: 'ActionButtonPresent',
        refspec: {
          msg:
            'This constraint is intended to to allow the activation of just one button from an ordered list of action buttons.',
        },
        usage: {
          abstract: false,
        },
        properties: {
          target: {
            description:
              'The parent button designated by the index (the value of parentsList[0]).',
            type: 'gObject',
          },
          activeParent: {
            description:
              'The currently-activated parent button (may not be the target if the index has changed).',
            type: 'gObject',
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/Sequence_export.json',
      },
      activeParent: null, // the currently activated parent (may not be the current target if the index has changed)
      target: null, // the parent pointed to by the index (the first parent's value is the index)

      checkTarget: function() {
        // set this.target to the currently-targeted parent
        // If the index has changed, it's possible a different parent may already be active.
        var index = this.parentsList[0].value,
          retVal = null;
        //  If index is an integer between 1 and parentsList.length - 1, return the targeted parent
        if (
          index &&
          Number.isInteger(index) &&
          index < this.parentsList.length
        ) {
          retVal = this.parentsList[index];
        }
        this.target = retVal;
        return retVal;
      },

      constrain: function constrain(sketch) {
        var target;

        (constrain.base || arguments.callee.base).call(this, sketch);

        if (this.state.isActive) {
          // Check the current case. If it doesn't exist or has completed, the case is finished.
          if (!this.activeParent || !this.activeParent.state.isActive) {
            // current case has completed
            this.activate(false);
            sketch.event('EndCase', {
              button: this,
              id: this.id,
              activeParent: this.activeParent,
            });
            this.activeParent = null;
          }
        }
        // Label this button based on its target's label
        target = this.checkTarget();
        if (this.label === 'auto') {
          // "auto" is a flag set by wsp_runner to auto-label this button
          this.style.autoLabel = true;
        }
        if (target && this.style.autoLabel && this.label !== target.label) {
          this.label = target.label;
        }
      },

      /**
       * Creates a case button. The first parent must be a value
       * which is used as an index into the rest of the parents,
       * all of which are assumed to be buttons.
       * If there's a button parent corresponding to the value
       * of the first parent, that parent button is pressed,
       * and the case button remains active until the pressed button finishes.
       * If there is no parent corresponding to the value,
       * the case button does nothing and terminates immediately.
       * If the case button is pressed while it's active,
       * cancel the current parent button.
       *
       * This object manages the following state object properties:
       *   {gobj} activeParent: the currently active parent button
       *   {gobj} target:the parent button pointed to by the index.
       *   {array} buttonList: array of gobjs for the buttons corresponding to the cases
       */
      press: function press(sketch, pressSource) {
        var isActive, target;

        (press.base || arguments.callee.base).call(this, sketch);

        isActive = this.state.isActive;
        target = this.checkTarget();
        if (isActive) {
          // This case button was pressed while active, so turn off the activeParent
          if (this.activeParent && this.activeParent.state.isActive) {
            this.activeParent.press(sketch, 'caseButton');
          }
          this.activate(false);
          sketch.event('EndCase', {
            button: this,
            id: this.id,
            activeParent: this.activeParent,
          });
          this.activeParent = null;
        } else {
          // pressed while inactive, so start it up, even if there's no target
          this.activeParent = target;
          sketch.event('StartCase', {
            button: this,
            id: this.id,
            activeParent: this.activeParent,
          });
          if (target && !target.state.isActive) {
            target.press(sketch, 'caseButton');
          } else {
            // We didn't start a button, so force a call to constrain() so we can deactivate politely.
            this.invalidateGeom();
          }
          this.activate(true, pressSource);
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Defines a button that hides visible objects or shows hidden objects,
   * depending on their state.
   */
  GSP.gConstraints.ActionButtonToggleHideShow = GSP.makeClass(
    GSP.gConstraints.ActionButton,
    {
      doc: {
        description:
          'Defines a button that hides visible objects or shows hidden objects, depending on their state.',
        inherits: 'ActionButton',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          messages: {
            description: 'Hide message, Show message',
            type: 'Array',
          },
          parents: {
            description: 'Set of objects to be hidden/shown',
            type: 'Object',
            properties: {
              '0': {
                description:
                  'The first target to be acted upon.  There can be an arbitrary number of objects numbered from 0 to N',
                kind: 'kind',
              },
            },
            regex: /^[0-9]+$/,
          },
          fade: {
            description: 'when true, the objects fade in or out',
            type: 'Boolean',
            default: false,
          },
        },
        example:
          '../../wsp-test/test-bed.html?sketch=documents/GSPSketches/Button/ToggleDisplayButton_export.json',
      },
      fade: false,
      value: false /* value is true when all parents are hidden */,

      updateLabelForConstraint: function() {
        var parent;
        if (this.numParents() !== 1 || !this.shouldAutogenerateLabel) {
          return;
        }
        parent = this.parentsList[0];
        if (parent.labelExists())
          if (parent.style.hidden)
            this.label = GSP.Strings.loc(
              'GSP.Label.HideButton',
              parent.genus,
              parent.label
            );
          else
            this.label = GSP.Strings.loc(
              'GSP.Label.ShowButton',
              parent.genus,
              parent.label
            );
      },

      setMessagesFromParent: function(genus, label) {
        // This approach is English-centric and inflexible. Better to recognize key strings ("Show" and "Hide" in English) and swap them based on current state of parents
        var SHOW = 1,
          HIDE = 0;
        this.messages[SHOW] = GSP.Strings.loc(
          'GSP.Label.ShowButton',
          genus,
          label
        );
        this.messages[HIDE] = GSP.Strings.loc(
          'GSP.Label.HideButton',
          genus,
          label
        );
      },

      /* Set the label to the correct message */
      updateLabelFromMessage: function() {
        var showSwap = GSP.Locale.current['GSP.Label.ShowButtonSwap'],
          hideSwap = GSP.Locale.current['GSP.Label.HideButtonSwap'],
          newLabel;
        // GSP5 allows alternates (such as "show" and "hide" in addition to "Show" and "Hide") as the pairs to be swapped.
        if (this.value) {
          newLabel = this.label.replace(hideSwap, showSwap);
        } else {
          newLabel = this.label.replace(showSwap, hideSwap);
        }
        this.label = newLabel;
      },

      constrain: function(sketch) {
        this.value = this.areHidden();
        this.updateLabelFromMessage();
      },
      /*
       * Returns true if all of the parents are already hidden
       */
      areHidden: function() {
        var ret = true;

        this.eachParent(function(index, parent) {
          if (!parent.style.hidden) {
            ret = false;
          }
        }, false);

        return ret;
      },
      beginAction: function(action, pressSource, sketch) {
        var theButton = this;

        //The hide and show callbacks are all ready to handle fading.  They get
        //called in a tight cycle using addDeferredCall, and have a startTime and
        //a timeToComplete property in their hideShowState.  Based on this,
        //we could set the opacity of the gobj on each frame of the callback,
        //or we could begin some sort of fade animation that knew how to fade the
        //object over the desired time at the start.

        /*
         * hideCallback is called repeatedly until the hide is complete
         *
         * 'this' is the button
         */
        function hideCallback(sketch) {
          var state = this.hideShowState,
            now = Date.now(),
            fade =
              (now - state.startTime) /
              (state.timeToComplete - state.startTime);

          if (now >= state.timeToComplete) {
            this.eachParent(function(index, parent) {
              this.state.fade = undefined;
              parent.hide();
              if (parent.updateKindHTMLStyle) {
                parent.updateKindHTMLStyle();
              }
            }, false);

            this.activate(false);
            this.hideShowState = undefined;
            sketch.invalidateGeom(this);

            if (!pressSource) this.state.pressedDown = true;
          } else {
            this.eachParent(function(index, parent) {
              this.state.fade = fade;
              sketch.invalidateAppearance(this);
            }, false);

            sketch.addDeferredCall(this, hideCallback);
          }
        }

        /*
         * showCallback is called repeatedly until the hide is complete
         *
         * 'this' is the button
         */

        function showCallback(sketch) {
          var state = this.hideShowState,
            now = Date.now(),
            fade =
              (now - state.startTime) /
              (state.timeToComplete - state.startTime);

          if (!state.oneTimeShow) {
            this.eachParent(function(index, parent) {
              if (parent.style.hidden) {
                parent.state.fade = 1;
                parent.show();
              }
            });
            state.oneTimeShow = true;
          }

          if (now >= state.timeToComplete) {
            this.eachParent(function(index, parent) {
              this.state.fade = undefined;
              sketch.invalidateGeom(this);
            }, false);

            this.activate(false);
            this.hideShowState = undefined;
            sketch.invalidateGeom(this);

            if (!pressSource) this.state.pressedUp = true;
            // sketch.sortAllGobj();
          } else {
            this.eachParent(function(index, parent) {
              if (undefined !== parent.state.fade) {
                parent.state.fade = 1 - fade;
                sketch.invalidateAppearance(parent);
              }
            }, false);
            sketch.addDeferredCall(this, showCallback);
          }
        }

        function createState(action, pressSource) {
          var K_NORMAL_FADE_TIME = 500,
            now = Date.now(),
            hideShowActionState = {
              startTime: now, //when did I start
              timeToComplete: now, //when should I be complete
            };

          //set time to fade
          if (theButton.fade && pressSource !== 'simultaneousButton') {
            if (pressSource === 'sequenceButton') {
              hideShowActionState.timeToComplete += K_NORMAL_FADE_TIME / 2;
            } else {
              hideShowActionState.timeToComplete += K_NORMAL_FADE_TIME;
            }
          }

          return hideShowActionState;
        }

        this.hideShowState = createState(action, pressSource);

        switch (action) {
          case 'hide':
            sketch.addDeferredCall(this, hideCallback);
            break;
          case 'show':
            sketch.addDeferredCall(this, showCallback);
            break;
        }

        if (
          pressSource === 'simultaneousButton' ||
          (pressSource === 'sequenceButton' && !this.fade)
        ) {
          //If we're being pressed by an action button, and have no fade,
          //override our state.isActive field to false so the action button
          //won't consider this an action that started and completed after a single
          //frame.  We want it considered as an action immediately completed.
          this.activate(false);
        }
      },
      press: function(sketch, pressSource) {
        if (this.state.isActive) {
          //for now, just return if we're currently active until we figure out desired behavior
          return;
        }

        this.activate(true, pressSource);
        sketch.invalidateGeom(this);

        if (this.areHidden()) {
          this.beginAction('show', pressSource, sketch);
        } else {
          this.beginAction('hide', pressSource, sketch);
        }
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed vector
   * @class Translate
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.TranslateBase = GSP.makeClass(
    GSP.gConstraints.Transform,
    /** @lends GSP.gConstraints.TranslateBase */ {
      doc: {
        description:
          'Abstract class that defines a new GObject that is identical to another GObject, but translated by some amount.',
        inherits: 'Transform',
        usage: {
          abstract: true,
        },
        existenceRule: 'Exists iff the parent point exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-Translation_export.json',
      },
      determineExists: function() {
        var offset = this.getOffset();
        return typeof offset !== 'undefined' && offset.isFinite();
      },

      /**
       * Returns the .value of the named parent interpreted as a distance
       * in document units
       *
       * @param {String} parentName name of parent from which to extract value.
       * @return {Number} distance value in pixels
       */
      getParentPixelValue: function(parentName) {
        var distGobj = this.getParent(parentName),
          units;
        if (this.unit) {
          return distGobj.value; /* Already in pixels */
        }

        units = this.sQuery().prefs().units;
        return GSP.units.convert(distGobj.uValue, units.length, 'pixels');
      },

      getOffset: function() {
        throw GSP.createError(
          'Translation subclasses required to implement getOffset()'
        );
      },

      /** @overlay */
      getTransform: function() {
        var that = this;
        return function(point) {
          return point.add(that.getOffset());
        };
      },

      // Return the text for a fixed distance
      getFixedDistanceText: function(dist) {
        // Return the passed pixel distance using units and precision from prefs
        var prefs = this.sQuery.sketch.preferences,
          unitData = GSP.units.findUnit(prefs.units.length),
          roundFactor = Math.pow(10, prefs.precision.length),
          val =
            Math.round(dist * unitData.conversionFromBase * roundFactor) /
            roundFactor;
        return (val < 0 ? '\u2013' : '') + Math.abs(val) + unitData.digraph;
      },

      /*    Return the text for a fixed angle
        We'd prefer to format the value as MFS, to get values like π/2, but here we're limited to a text label
        The following function would give us the MFS
      getAngleLabelMFS: function () {  // return the MFS of the angle.
        var prefs = this.sQuery.sketch.preferences.units.angle;
        return this.formatNumberAsMFS (this.angle, prefs.precision.angle, prefs.units.angle);
      },
  */
      getFixedAngleText: function(angle) {
        // Return the passed pixel distance using units and precision from prefs
        var prefs = this.sQuery.sketch.preferences,
          unitData = GSP.units.findUnit(prefs.units.angle),
          roundFactor = Math.pow(10, prefs.precision.angle),
          val =
            Math.round(angle * unitData.conversionFromBase * roundFactor) /
            roundFactor;
        return (val < 0 ? '\u2013' : '') + Math.abs(val) + unitData.symbol;
      },

      // The default getTranslateText () must be overridden in the descendant class
      getTranslateText: function(option) {
        // Return the gobj's angle using units and precision from prefs
        return '?';
      },

      // This works for all Translate constraints that instantiate getTranslateText(); no need for overrides
      makeFnLabelPrefix: function(nameOrigin, option) {
        // Handles namedByFullFn and namedByShortFn only
        var retVal;
        switch (nameOrigin) {
          case 'namedByFullFn':
            retVal = 'T[' + this.getTranslateText(option) + ']';
            break;
          case 'namedByShortFn':
            retVal = 'T';
        }
        return retVal;
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed vector
   * @class Translate
   *
   * @augments GSP.gConstraints.Transform
   */
  GSP.gConstraints.TranslateFixXFixY = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.Translation */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed x,y coordinate.',
        inherits: 'TranslateBase',
        refspec: {
          gspRef: 'TranslatefXfY_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefXfY_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          offset: {
            description: 'Offset in pixel coordinates from the source object',
            type: 'GeometricPoint',
            required: false,
            properties: {
              x: {
                description: 'Horizontal coordinate in pixels',
                type: 'Number',
              },
              y: {
                description: 'Vertical coordinate in pixels',
                type: 'Number',
              },
            },
          },
        },
      },

      offset: { x: 0, y: 0 },

      /**
       * Returns the translation offset.
       * @return {GSP.GeometricPoint} offset
       */
      getOffset: function() {
        if (!this.offset.transformClass) {
          this.offset = GSP.GeometricPoint(this.offset.x, this.offset.y);
        }
        return this.offset;
      },

      // The default getTranslateText (option) must be overridden
      getTranslateText: function() {
        // Return the gobj's offset using units and precision from prefs
        return (
          this.getFixedDistanceText(this.offset.x) +
          ',' +
          this.getFixedDistanceText(-this.offset.y)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed distance and angle defined by
   * three points.
   * @class TranslateFixDist3PtAngle
   *
   */
  GSP.gConstraints.TranslateFixDist3PtAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateFixDist3PtAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction of an angle delineated by three points.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatefD3A_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefD3A_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the three points exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDist3PtAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              A: {
                description: '',
                kind: 'Point',
              },
              B: {
                description: '',
                kind: 'Point',
              },
              C: {
                description: '',
                kind: 'Point',
              },
            },
          },
          distance: {
            description: 'A distance in pixels.',
            default: '0',
            type: 'Number',
          },
        },
      },
      distance: 0,
      /**
       * Returns the translation offset.
       * @return {GSP.GeometricPoint} offset
       * @overlay
       */
      getOffset: function() {
        var aGobj = this.getParent('A');
        var bGobj = this.getParent('B');
        var cGobj = this.getParent('C');
        var a = aGobj.geom.loc;
        var b = bGobj.geom.loc;
        var c = cGobj.geom.loc;

        var angle = GSP.GeometricPoint.threePointAngle(a, b, c);
        var offset = GSP.GeometricPoint(this.distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getFixedDistanceText(this.distance) +
          ',' +
          this.get3PtAngleText('A', 'B', 'C', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed distance and the value of an angle
   * marker.
   * @class TranslateFixDistAngleMarker
   *
   */
  GSP.gConstraints.TranslateFixDistAngleMarker = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateFixDistAngleMarker */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction specified by an angle marker.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslateFixedDataMarkedAngleMarker_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslateFixedDataMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the angle marker exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistAngleMarker_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              marker: {
                description: '',
                kind: 'AngleMarker',
              },
            },
          },
          distance: {
            description: 'A distance.',
            type: 'Number',
          },
        },
      },
      distance: 0,
      /**
       * Returns the translation offset.
       * @return {GSP.GeometricPoint} offset
       * @overlay
       */
      getOffset: function() {
        var angleGobj = this.getParent('marker');
        var angle = angleGobj.value;

        var offset = GSP.GeometricPoint(this.distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getFixedDistanceText(this.distance) +
          ',' +
          this.getAngleMarkerText('marker', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed distance and angle.
   * @class TranslateFixDistFixAngle
   *
   */
  GSP.gConstraints.TranslateFixDistFixAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateFixDistFixAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction of a fixed angle.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatefDfA_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefDfA_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the source object exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistFixAngle_export.json',
        properties: {
          distance: {
            description: 'A distance.',
            type: 'Number',
          },
          angle: {
            description: 'An angle, in radians.',
            type: 'Number',
          },
        },
      },
      distance: 0,
      angle: 0,
      /**
       * Returns the translation offset.
       * @return {GSP.GeometricPoint} offset
       */
      getOffset: function() {
        var offset = GSP.GeometricPoint(this.distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          this.angle
        );
        return offset;
      },

      // The default getTranslateText () must be overridden
      getTranslateText: function() {
        // Return the gobj's offset using units and precision from prefs
        return (
          this.getFixedDistanceText(this.distance) +
          ',' +
          this.getFixedAngleText(this.angle)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by fixed distance and measured angle.
   * @class TranslateFixDistMeasureAngle
   *
   */
  GSP.gConstraints.TranslateFixDistMeasureAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateFixDistMeasureAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed distance in the direction defined by an angle measurement.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslateFixedDistanceMarkedAngleMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslateFixedDistanceMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent object exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixDistMeasureAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              measure: {
                description: '',
                kind: 'Measure',
              },
            },
          },
          distance: {
            description: 'A distance in pixels.',
            type: 'Number',
          },
        },
      },
      distance: 0,
      /**
       * Returns the translation offset.
       * @return {GSP.GeometricPoint} offset
       * @overlay
       */
      getOffset: function() {
        var angleGobj = this.getParent('measure');
        //convert from user-visible (CCW) to primal (flipped y == CW)
        var angle = -angleGobj.value;
        var offset = GSP.GeometricPoint(this.distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getFixedDistanceText(this.distance) +
          ',' +
          this.getParentLabel('measure', option)
        );
      },
    }
  );

  /*
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints translates by a fixed X and a measured Y distance.
   * @class TranslateFixXMeasureY
   *
   * @augments GSP.gConstraints.Translate
   */
  GSP.gConstraints.TranslateFixXMeasureY = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateFixXMeasureY */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed x coordinate and a y coordinate defined by a measure.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatefXmY_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatefXmY_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the measurement exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateFixXMeasureY_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              measure: {
                description: '',
                kind: 'Measure',
              },
            },
          },
          offsetX: {
            description: '',
            default: '0',
            type: 'Number',
          },
        },
      },
      offsetX: 0,

      /**
       * @overlay
       */
      getOffset: function() {
        var offsetX = this.offsetX;
        var offsetY = -this.getParentPixelValue('measure');
        var offset = GSP.GeometricPoint(offsetX, offsetY);
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getFixedDistanceText(this.offsetX) +
          ',' +
          this.getParentLabel('measure', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by measured distance and angle defined by three
   * points.
   * @class TranslateMeasureDist3PtAngle
   *
   */
  GSP.gConstraints.TranslateMeasureDist3PtAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeasureDist3PtAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a distance from a measurement and an angle from three points.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatemD3A_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemD3A_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object, the measurement and the three points all exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDist3PtAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              distance: {
                description: '',
                kind: 'Measure',
              },
              A: {
                description: '',
                kind: 'Point',
              },
              B: {
                description: '',
                kind: 'Point',
              },
              C: {
                description: '',
                kind: 'Point',
              },
            },
          },
        },
      },
      /** @overlay */
      getOffset: function() {
        var distance = this.getParentPixelValue('distance');
        var aGobj = this.getParent('A');
        var bGobj = this.getParent('B');
        var cGobj = this.getParent('C');
        var a = aGobj.geom.loc;
        var b = bGobj.geom.loc;
        var c = cGobj.geom.loc;
        var angle = GSP.GeometricPoint.threePointAngle(a, b, c);
        var offset = GSP.GeometricPoint(distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParentLabel('distance', option) +
          ',' +
          this.get3PtAngleText('A', 'B', 'C', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by measured distance and angle from the value of
   * an angle marker.
   * @class TranslateMeasureDistAngleMarker
   *
   */
  GSP.gConstraints.TranslateMeasureDistAngleMarker = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeasureDistAngleMarker */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a distance measurement in the direction defined by a specified angle marker.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslateMarkedDistanceMarkedAngleMarker_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslateMarkedDistanceMarkedAngleMarker_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object, distance measure, and angle marker exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistAngleMarker_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              distance: {
                description: '',
                kind: 'Measure',
              },
              marker: {
                description: '',
                kind: 'AngleMarker',
              },
            },
          },
        },
      },
      /** @overlay */
      getOffset: function() {
        var distance = this.getParentPixelValue('distance');
        var angleGobj = this.getParent('marker');
        var angle = angleGobj.value;
        var offset = GSP.GeometricPoint(distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParent('distance').label +
          ',' +
          this.getAngleMarkerText('marker', option)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by measured distance and fixed angle
   * @class TranslateMeasureDistFixAngle
   *
   */
  GSP.gConstraints.TranslateMeasureDistFixAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeasureDistFixAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a distance derived from a measurement in the direction defined by a fixed angle in radians.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatemDfA_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemDfA_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and angle measurement exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistFixAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              distance: {
                description: '',
                kind: 'Measure',
              },
            },
          },
          angle: {
            description: 'A angle(radians).',
            type: 'Number',
          },
        },
      },
      angle: 0,
      /** @overlay */
      getOffset: function() {
        var distance = this.getParentPixelValue('distance');
        var angle = this.angle;
        var offset = GSP.GeometricPoint(distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParentLabel('distance', option) +
          ',' +
          this.getFixedAngleText(this.angle)
        );
      },
    }
  );

  /**
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraint that translates by measured distance and measured angle.
   * @class TranslateMeasureDistMeasureAngle
   *
   */
  GSP.gConstraints.TranslateMeasureDistMeasureAngle = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeasureDistMeasureAngle */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a distance measurement in the direction defined by an angle measurement.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslateMarkedDistanceMarkedAngleMeasure_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslateMarkedDistanceMarkedAngleMeasure_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the distance and angle measurements exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureDistMeasureAngle_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              distance: {
                description: '',
                kind: 'Measure',
              },
              angle: {
                description: '',
                kind: 'Measure',
              },
            },
          },
        },
      },
      /** @overlay */
      getOffset: function() {
        var distance = this.getParentPixelValue('distance');
        var angleGobj = this.getParent('angle');
        //convert from user-visible (CCW) to primal (flipped y == CW)
        // but don't conditionalize on PI? I think not
        var angle = -angleGobj.value;
        var offset = GSP.GeometricPoint(distance, 0).rotate(
          GSP.GeometricPoint.ORIGIN,
          angle
        );
        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParentLabel('distance', option) +
          ',' +
          this.getParentLabel('angle', option)
        );
      },
    }
  );

  /*
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints translates by a measured X and fixed Y value.
   * @class TranslateMeasureXFixY
   *
   * @augments GSP.gConstraints.Translate
   */
  GSP.gConstraints.TranslateMeasureXFixY = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeaureXFixY */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by a fixed y coordinate and an x coordinate defined by a measure.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatemXfY_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemXfY_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the measurement exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureXFixY_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              measure: {
                description: '',
                kind: 'Measure',
              },
            },
          },
          offsetY: {
            description: '',
            type: 'Number',
          },
        },
      },
      offsetY: 0,
      /**
       * @overlay
       */
      getOffset: function() {
        var offsetX = this.getParentPixelValue('measure');
        var offsetY = -this.offsetY;
        var offset = GSP.GeometricPoint(offsetX, offsetY);

        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParentLabel('measure', option) +
          ',' +
          this.getFixedDistanceText(this.offsetY)
        );
      },
    }
  );

  /*
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints translates by x and y measurements.
   * @class TranslateMeasureXMeasureY
   *
   * @augments GSP.gConstraints.Translate
   */
  GSP.gConstraints.TranslateMeasureXMeasureY = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateMeasureXMeasureY */ {
      doc: {
        description:
          'Defines a new GObject that is identical to another GObject, but offset by x and y coordinates defined by measures.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslatemXmY_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslatemXmY_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the source object and the two measurements exists.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-TranslateMeasureXMeasureY_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              measureX: {
                description: '',
                kind: 'Measure',
              },
              measureY: {
                description: '',
                kind: 'Measure',
              },
            },
          },
        },
      },
      /**
       * @overlay
       */
      getOffset: function() {
        var offsetX = this.getParentPixelValue('measureX');
        var offsetY = -this.getParentPixelValue('measureY');
        var offset = GSP.GeometricPoint(offsetX, offsetY);

        return offset;
      },

      getTranslateText: function(option) {
        return (
          this.getParentLabel('measureX', option) +
          ',' +
          this.getParentLabel('measureY', option)
        );
      },
    }
  );

  /*
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constraints translates by a vector from point p0 -> p1
   * @class TranslateVector
   *
   * @augments GSP.gConstraints.Translate
   */
  GSP.gConstraints.TranslateVector = GSP.makeClass(
    GSP.gConstraints.TranslateBase,
    /** @lends GSP.gConstraints.TranslateVector */ {
      doc: {
        description:
          'Defines a translation of a GObject by an offset that matches the vector defined by two points.',
        inherits: 'Translate',
        refspec: {
          gspRef: 'TranslateVector_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, TranslateVector_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule:
          'Exists iff the transformed object and both length defining points exist.',
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Gobj-VectorTranslation_export.json',
        properties: {
          parents: {
            description: '',
            properties: {
              p0: {
                description: '',
                kind: 'Point',
              },
              p1: {
                description: '',
                kind: 'Point',
              },
            },
          },
        },
      },

      getOffset: function() {
        var p0Obj = this.getParent('p0'),
          p1Obj = this.getParent('p1'),
          p0 = p0Obj.geom.loc,
          p1 = p1Obj.geom.loc;

        return p1.subtract(p0);
      },
      /**
       * @overlay
       */
      getTransform: function() {
        var that = this;

        return function(point) {
          return point.add(that.getOffset());
        };
      },

      getTranslateText: function(option) {
        // Return parental labels, forcing them to be created (but not necessarily shown)
        return (
          this.getParentLabel('p0', option) +
          '→' +
          this.getParentLabel('p1', option)
        );
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Marks an angle in a constant direction.
   */
  GSP.gConstraints.AngleMarker_CCW = GSP.makeClass(
    GSP.gConstraints.AngleMarker,
    {
      doc: {
        description: 'A counter-clockwise angle marker',
        inherits: 'AngleMarker',
        refspec: {
          gspRef: 'AngleMarker_CCW_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_CCW_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      constrainedAngle: function(angle, orientationInfo) {
        if (orientationInfo.isStraight) {
          angle = orientationInfo.isStraight === 'fullCircle' ? 0 : -Math.PI;
        } else {
          angle -= GSP.math.TWO_PI;
        }

        orientationInfo.orientation = -1;

        return angle;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Marks an angle in a constant direction.
   */
  GSP.gConstraints.AngleMarker_CW = GSP.makeClass(
    GSP.gConstraints.AngleMarker,
    {
      doc: {
        description: 'A clockwise angle marker',
        inherits: 'AngleMarker',
        refspec: {
          gspRef: 'AngleMarker_CW_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_CW_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      constrainedAngle: function(angle, orientationInfo) {
        if (orientationInfo.isStraight) {
          angle = orientationInfo.isStraight === 'fullCircle' ? 0 : Math.PI;
        }

        orientationInfo.orientation = 1;

        return angle;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of an angle between two lines
   */
  GSP.gConstraints.AngleMarker_Reflex = GSP.makeClass(
    GSP.gConstraints.AngleMarker,
    {
      doc: {
        description: 'A reflex angle marker',
        inherits: 'AngleMarker',
        refspec: {
          gspRef: 'AngleMarker_Reflex_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_Reflex_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      constrainedAngle: function(angle, orientationInfo) {
        if (orientationInfo.isStraight) {
          angle =
            orientationInfo.isStraight === 'fullCircle'
              ? GSP.math.TWO_PI
              : Math.PI;
        } else {
          if (angle <= GSP.math.SIMPLE_PI_THRESHOLD) {
            angle = -(2 * Math.PI - angle);
          }
        }

        orientationInfo.orientation = angle <= 0 ? -1 : 1;

        return angle;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Reports the measurement of an angle between two lines
   */
  GSP.gConstraints.AngleMarker_Simple = GSP.makeClass(
    GSP.gConstraints.AngleMarker,
    {
      doc: {
        description: 'A simple angle marker',
        inherits: 'AngleMarker',
        refspec: {
          gspRef: 'AngleMarker_Simple_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, AngleMarker_Simple_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
      },
      constrainedAngle: function(angle, orientationInfo) {
        if (orientationInfo.isStraight) {
          angle = orientationInfo.isStraight === 'fullCircle' ? 0 : -Math.PI;

          orientationInfo.orientation = -1;
        } else {
          if (angle > GSP.math.SIMPLE_PI_THRESHOLD) {
            angle = -(2 * Math.PI - angle);
          }
          orientationInfo.orientation = angle <= 0 ? -1 : 1;
        }

        return angle;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Constrain a point to a path.
   */
  GSP.gConstraints.PathMarker = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description: 'A path marker on a <span class="genus">Path</span>.',
      inherits: 'Constraint',
      refspec: {
        gspRef: 'PathMarker_C',
      },
      usage: {
        abstract: false,
        kinds: ['PathMarker'],
      },
      existenceRule: 'Exists iff the parent path exists.',
      properties: {
        value: {
          description: '',
          type: 'Number',
        },
        parents: {
          description: '',
          properties: {
            path: {
              description: '',
              genus: 'Path',
            },
          },
        },
      },
    },
    value: 0.5,
    constrain: function constrain() {
      var pathObject = this.getParent('path'),
        exists = false,
        output = {},
        len,
        normalLen,
        newPoint = GSP.GeometricPoint.UNDEFINED;

      if (pathObject.isValueInBounds(this.value)) {
        newPoint = pathObject.mapPathValueToPosition(this.value, output);
        if (newPoint && newPoint.isDefined() && output.derivative.isDefined()) {
          len = output.derivative.vLength();
          normalLen = 1;
          if (
            this.style['tick-mark-style'] !== 'Crossbar' &&
            this.style['arrow-direction'] !== 'Forward'
          ) {
            normalLen *= -1;
          }
          this.geom.normal = GSP.GeometricPoint(
            (-normalLen * output.derivative.y) / len,
            (normalLen * output.derivative.x) / len
          );
          exists = true;
        } else {
          // normalize return value
          newPoint = GSP.GeometricPoint.UNDEFINED;
        }
      }
      this.state.exists = exists;
      this.geom.loc = newPoint;
      if (exists) {
        this.state.renderMetrics = this.calculateRenderMetrics();
      }
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for points on a CoordSys by (rho, theta)
   */
  GSP.gConstraints.PlotRhoTheta = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by two polar coordinates.',
      inherits: 'Constraint',
      usage: {
        abstract: true,
        kinds: ['Point'],
      },
      existenceRule:
        'Exists iff the parent CoordSys exists and the coordinates are numbers.',
      properties: {
        parents: {
          description: '',
          properties: {
            coordSys: {
              description: 'The coordinate system for the coordinates.',
              kind: 'CoordSys',
            },
          },
        },
      },
    },
    /*
     * Fetch the rho coordinate. Default implementation assumes 'coordRho' parent.
     */
    getCoordRho: function() {
      return this.getParent('coordRho').uValue;
    },
    /*
     * Fetch the theta coordinate. Default implementation assumes 'coordTheta' parent.
     */
    getCoordTheta: function() {
      return this.getParent('coordTheta').value;
    },
    constrain: function() {
      var coordSys = this.getParent('coordSys'),
        rho = this.getCoordRho(),
        theta = this.getCoordTheta(),
        x = rho * Math.cos(theta),
        y = rho * Math.sin(theta);

      this.geom.loc = coordSys.locatePlot(x, y);
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Base class for points on a CoordSys by (x, y)
   */
  GSP.gConstraints.PlotXY = GSP.makeClass(GSP.gConstraints.Constraint, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by two coordinates.',
      inherits: 'Constraint',
      usage: {
        abstract: true,
        kinds: ['Point'],
      },
      existenceRule:
        'Exists iff the parent CoordSys exists and the coordinates are numbers.',
      properties: {
        parents: {
          description: '',
          properties: {
            coordSys: {
              description: 'The coordinate system for the coordinates.',
              kind: 'CoordSys',
            },
          },
        },
      },
    },
    /*
     * Fetch the x coordinate. Default implementation assumes 'coordX' parent.
     */
    getCoordX: function() {
      return this.getParent('coordX').uValue;
    },
    /*
     * Fetch the y coordinate. Default implementation assumes 'coordY' parent.
     */
    getCoordY: function() {
      return this.getParent('coordY').uValue;
    },
    constrain: function() {
      var coordSys = this.getParent('coordSys'),
        x = this.getCoordX(),
        y = this.getCoordY();

      if (!isFinite(x) || !isFinite(y)) {
        this.state.exists = false;
      } else {
        this.state.exists = true;
        this.geom.loc = coordSys.locatePlot(x, y);
      }
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A button that hides an object.
   */
  GSP.gConstraints.ActionButtonHide = GSP.makeClass(
    GSP.gConstraints.ActionButtonToggleHideShow,
    {
      doc: {
        description: 'A button that hides its parents.',
        inherits: 'ActionButtonToggleHideShow',
        refspec: {
          msg:
            "This constraint does not have a functional match in the current version of Geometer's Sketchpad. It was implemented to meet requirements from the Dynamic Number project.",
        },
        usage: {
          abstract: false,
        },
        properties: {
          parents: {
            description: 'Set of objects to be hidden',
            type: 'Array',
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-HideShow_export.json',
      },
      updateLabelFromMessage: function() {
        this.label = this.messages[0];
      },

      setMessagesFromParent: function(genus, label) {
        this.messages[0] = GSP.Strings.loc(
          'GSP.Label.HideButton',
          genus,
          label
        );
      },

      /**
       * Press the button.
       */
      press: function(sketch, pressSource) {
        if (this.state.isActive) {
          //for now, just return if we're currently active until we figure out desired behavior
          return;
        }

        this.activate(true, pressSource);
        sketch.invalidateGeom(this);

        this.beginAction('hide', pressSource, sketch);
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * The second intersection of a circle and another path object
   */
  GSP.gConstraints.Intersection2 = GSP.makeClass(
    GSP.gConstraints.Intersection1,
    {
      doc: {
        description:
          'One of two points of intersection of a <span class="kind">Circle</span> with another Circle or a Circle with a <span class="kind">Straight</span> object.',
        inherits: 'Intersection1',
        refspec: {
          gspRef: 'InterLCB',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraints, InterLCB and InterCCB, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
          kinds: ['Point'],
        },
        existenceRule:
          'Exists iff the parent objects exist and have at least one point of intersection.',
        properties: {},
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Point-Intersection12_export.json',
      },
      constrain: function() {
        var points = this.getIntersectionPoints(),
          p = points[1] || points[0];
        if (p) {
          this.geom.loc = p;
          this.state.exists = true;
        } else {
          this.geom.loc = GSP.GeometricPoint(undefined, undefined);
          this.state.exists = false;
        }
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: fixed rho, fixed theta
   */
  GSP.gConstraints.PlotFixedRhoFixedTheta = GSP.makeClass(
    GSP.gConstraints.PlotRhoTheta,
    {
      doc: {
        description:
          'Defines a point on a <span class="kind">CoordSys</span> determined by two fixed polar coordinates.',
        inherits: 'PlotRhoTheta',
        refspec: {
          gspRef: 'PlotFixedRhoFixedTheta',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedRhoFixedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent Param and CoordSys exist.',
        properties: {
          coordRho: {
            description: '',
            type: 'Number',
          },
          coordTheta: {
            description: '',
            kind: 'Number',
          },
        },
      },
      getCoordRho: function() {
        return this.coordRho;
      },
      getCoordTheta: function() {
        return this.coordTheta;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: fixed rho, marked theta
   */
  GSP.gConstraints.PlotFixedRhoMarkedTheta = GSP.makeClass(
    GSP.gConstraints.PlotRhoTheta,
    {
      doc: {
        description:
          'Defines a point on a <span class="kind">CoordSys</span> determined by a fixed and a <span class="kind">Param</span> polar coordinate.',
        inherits: 'PlotRhoTheta',
        refspec: {
          gspRef: 'PlotFixedRhoMarkedTheta_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedRhoMarkedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent Param and CoordSys exist.',
        properties: {
          coordRho: {
            description: '',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              coordTheta: {
                description: '',
                kind: 'Measure',
              },
            },
          },
        },
      },
      getCoordRho: function() {
        return this.coordRho;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: fixed X, fixed Y
   */
  GSP.gConstraints.PlotFixedXFixedY = GSP.makeClass(GSP.gConstraints.PlotXY, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by two fixed coordinates.',
      inherits: 'PlotXY',
      refspec: {
        gspRef: 'PlotFixedXFixedY_C',
      },
      usage: {
        abstract: false,
      },
      existenceRule:
        'Exists iff the parent CoordSys exists and the coordinates are numbers.',
      properties: {
        coordX: {
          description: '',
          type: 'Number',
        },
        coordY: {
          description: '',
          type: 'Number',
        },
      },
    },
    getCoordX: function() {
      return this.coordX;
    },
    getCoordY: function() {
      return this.coordY;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: fixed X, marked Y
   */
  GSP.gConstraints.PlotFixedXMarkedY = GSP.makeClass(GSP.gConstraints.PlotXY, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by a fixed coordinate and a <span class="kind">Param</span> coordinate.',
      inherits: 'PlotXY',
      refspec: {
        gspRef: 'PlotFixedXMarkedY_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, PlotFixedXMarkedY_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
      },
      existenceRule: 'Exists iff the parent Param and CoordSys exist.',
      properties: {
        coordX: {
          description: '',
          type: 'Number',
        },
        parents: {
          description: '',
          properties: {
            coordY: {
              description: '',
              kind: 'Measure',
            },
          },
        },
      },
    },
    getCoordX: function() {
      return this.coordX;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: marked rho, fixed theta
   */
  GSP.gConstraints.PlotMarkedRhoFixedTheta = GSP.makeClass(
    GSP.gConstraints.PlotRhoTheta,
    {
      doc: {
        description:
          'Defines a point on a <span class="kind">CoordSys</span> determined by a <span class="kind">Param</span> and a fixed polar coordinate.',
        inherits: 'PlotRhoTheta',
        refspec: {
          gspRef: 'PlotMarkedRhoFixedTheta_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedRhoFixedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent Param and CoordSys exist.',
        properties: {
          coordTheta: {
            description: '',
            type: 'Number',
          },
          parents: {
            description: '',
            properties: {
              coordRho: {
                description: '',
                kind: 'Measure',
              },
            },
          },
        },
      },
      getCoordTheta: function() {
        return this.coordTheta;
      },
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: marked rho, marked theta
   */
  GSP.gConstraints.PlotMarkedRhoMarkedTheta = GSP.makeClass(
    GSP.gConstraints.PlotRhoTheta,
    {
      doc: {
        description:
          'Defines a point on a <span class="kind">CoordSys</span> determined by two <span class="kind">Param</span> polar coordinates.',
        inherits: 'PlotRhoTheta',
        refspec: {
          gspRef: 'PlotMarkedRhoMarkedTheta_C',
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedRhoMarkedTheta_C, in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent Param and CoordSys exist.',
        properties: {
          parents: {
            description: '',
            properties: {
              coordRho: {
                description: '',
                kind: 'Measure',
              },
              coordTheta: {
                description: '',
                kind: 'Measure',
              },
            },
          },
        },
      },
      /* Base class implementation does it all */
    }
  );

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: marked X, fixed Y
   */
  GSP.gConstraints.PlotMarkedXFixedY = GSP.makeClass(GSP.gConstraints.PlotXY, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by a <span class="kind">Param</span> coordinate and a fixed coordinate.',
      inherits: 'PlotXY',
      refspec: {
        gspRef: 'PlotMarkedXFixedY_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedXFixedY_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
      },
      existenceRule: 'Exists iff the parent Param and CoordSys exist.',
      properties: {
        coordY: {
          description: '',
          type: 'Number',
        },
        parents: {
          description: '',
          properties: {
            coordX: {
              description: '',
              kind: 'Measure',
            },
          },
        },
      },
    },
    getCoordY: function() {
      return this.coordY;
    },
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * Point plotted on coordinate system: marked X, marked Y
   */
  GSP.gConstraints.PlotMarkedXMarkedY = GSP.makeClass(GSP.gConstraints.PlotXY, {
    doc: {
      description:
        'Defines a point on a <span class="kind">CoordSys</span> determined by two <span class="kind">Param</span> coordinates.',
      inherits: 'PlotXY',
      refspec: {
        gspRef: 'PlotMarkedXMarkedY_C',
        msg:
          "This constraint is intended to behave in the same way as the corresponding constraint, PlotMarkedXMarkedY_C, in the currently published version of desktop Geometer's Sketchpad.",
      },
      usage: {
        abstract: false,
      },
      existenceRule: 'Exists iff the parent Params and CoordSys exist.',
      properties: {
        parents: {
          description: '',
          properties: {
            coordX: {
              description: '',
              kind: 'Measure',
            },
            coordY: {
              description: '',
              kind: 'Measure',
            },
          },
        },
      },
    },
    /* Base class implementation does it all */
  });

  /*
   * @version 0.0
   *
   * @preserve Copyright © 2011-2012 KCP Technologies, Inc. All rights reserved.
   */
  /**
   * A button that reveals a hidden object.
   */
  GSP.gConstraints.ActionButtonShow = GSP.makeClass(
    GSP.gConstraints.ActionButtonToggleHideShow,
    {
      doc: {
        description: 'Defines an action that reveals a hidden GObject.',
        inherits: 'ActionButtonToggleHideShow',
        refspec: {
          msg:
            "This constraint is intended to behave in the same way as the corresponding constraint (TBD) in the currently published version of desktop Geometer's Sketchpad.",
        },
        usage: {
          abstract: false,
        },
        existenceRule: 'Exists iff the parent objects exist.',
        properties: {
          parents: {
            description: 'Set of objects to be shown',
            type: 'Array',
          },
        },
        example:
          '../../wsp-test/gsp-test-bed.html?sketch=documents/GSPSketches/Button-HideShow_export.json',
      },
      updateLabelFromMessage: function() {
        this.label = this.messages[0];
      },
      setMessagesFromParent: function(genus, label) {
        this.messages[0] = GSP.Strings.loc(
          'GSP.Label.ShowButton',
          genus,
          label
        );
      },

      /**
       * Press the button.
       */
      press: function(sketch, pressSource) {
        if (this.state.isActive) {
          //for now, just return if we're currently active until we figure out desired behavior
          return;
        }

        this.activate(true, pressSource);
        sketch.invalidateGeom(this);

        this.beginAction('show', pressSource, sketch);
      },
    }
  );

  GSP.css =
    '/* For now, these are not in less. Just import them raw. */\n' +
    '/*!\n' +
    '  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved.\n' +
    '  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20230217111107\n' +
    '*/\n' +
    '\n' +
    '/*\n' +
    ' * Styles governing drawing contexts. Within the node we are given we\n' +
    ' * construct a relatively positioned base node. It contains an absolutely\n' +
    ' * positioned node that is used for clipping. All drawing context nodes\n' +
    ' * (canvas layers, html layers) are created within the\n' +
    ' * clipping node and are absolutely positioned. They must correspond exactly\n' +
    ' * to the height and width of the clipping node.\n' +
    ' */\n' +
    '.wsp-version-4-8-0.wsp-base-node {\n' +
    '    position: relative;\n' +
    '    display: inline-block;\n' +
    '    cursor: default;\n' +
    '    vertical-align: top;\n' +
    '    font-size: 0px; /* inline-block adds grot heights for whitespace without this */\n' +
    '    overflow: visible; /* prevents inheritance of overflow: scroll, which can\n' +
    '                          cause layout issues */\n' +
    '\n' +
    '    /* Reset to default in case our containing elt has modified. */\n' +
    '    white-space: normal;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-transform-node {\n' +
    '  transform-origin: top left;\n' +
    '  -webkit-transform-origin: top left;\n' +
    '  -ms-transform-origin: top left;\n' +
    '  position:absolute;\n' +
    '  display: inline;\n' +
    '  border-collapse: collapse;\n' +
    '  border-spacing: 0px;\n' +
    '  top: 0px; left: 0px;\n' +
    '  padding: 0px; margin: 0px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-main-row {\n' +
    '  display: flex;  /* Need this so tool-container and sketch-container are full height */\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container {\n' +
    '  display: table-cell;\n' +
    '  position: relative;\n' +
    '  vertical-align: top;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-text-layer .wsp-responsive-borderwidth {\n' +
    '  border-width: 1px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-transform-large {\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.wsp-version-4-8-0  .wsp-transform-medium {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-transform-small {\n' +
    '  display: none;\n' +
    '}\n' +
    '\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-clip-node {\n' +
    '    position: relative;\n' +
    '    width: 100%;\n' +
    '    height: 100%;\n' +
    '    overflow: hidden;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-clip-node canvas, .wsp-version-4-8-0 .wsp-text-layer, .wsp-version-4-8-0 .wsp-effects {\n' +
    '    position: absolute;\n' +
    '    left: 0; top: 0;\n' +
    '    z-index: 0;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .sketch_canvas {\n' +
    '    -webkit-user-select: none;\n' +
    '    -moz-user-select: -moz-none;\n' +
    '}\n' +
    '\n' +
    '/*\n' +
    ' * Styles governing html-layer sketch objects.\n' +
    ' */\n' +
    '.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Point,\n' +
    '.wsp-version-4-8-0 .wsp-Text, .wsp-version-4-8-0 .wsp-Param,\n' +
    '.wsp-version-4-8-0 .wsp-Button, .wsp-version-4-8-0 .wsp-Expression,\n' +
    '.wsp-version-4-8-0 .wsp-Label, .wsp-version-4-8-0 .wsp-Table {\n' +
    '    /*-webkit-touch-callout: none*/\n' +
    '    /*-moz-touch-callout: none;*/\n' +
    '    position:absolute;\n' +
    '}\n' +
    '\n' +
    '\n' +
    '/*\n' +
    '  Buttons - see comment in wsp-skin.css for details\n' +
    '*/\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Button {\n' +
    '    display: table;\n' +
    '    border-collapse: separate;\n' +
    '    border-spacing: 0px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Button-row {\n' +
    '  display: table-row;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Button-drag-handle {\n' +
    '  display: table-cell;\n' +
    '  content: "";\n' +
    '  height:100%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Button-label-frame {\n' +
    '  display: table-cell;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Text, .wsp-version-4-8-0 .wsp-Param, .wsp-version-4-8-0 .wsp-Expression, .wsp-version-4-8-0 .wsp-Label {\n' +
    '    font-size: 12px;\n' +
    '    border: none;\n' +
    '    margin: 0;\n' +
    '    padding: 0;\n' +
    '    background-color:transparent;\n' +
    '    overflow-x: visible;\n' +
    '    white-space: pre;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Measure, .wsp-version-4-8-0 .wsp-Text {\n' +
    '    cursor: default;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Measure {\n' +
    '    line-height: 1;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Point {\n' +
    '    cursor: pointer;\n' +
    '    font-size: 8px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Expression .mfs-input {\n' +
    '    cursor: text;\n' +
    '}\n' +
    '\n' +
    '/* styles for MFS to HTML conversion */\n' +
    '.wsp-version-4-8-0 .mfs {\n' +
    '    /*\n' +
    '      border: solid thin red;\n' +
    '    */\n' +
    '    display: run-in;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-bracket:before {\n' +
    "    content: '[';\n" +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-bracket:after {\n' +
    "    content: ']';\n" +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-curly:before {\n' +
    "    content: '{';\n" +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-curly:after {\n' +
    "    content: '}';\n" +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-tightness-normal {\n' +
    '    letter-spacing: normal;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-tightness-condensed {\n' +
    '    letter-spacing: -0.1em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-tightness-expanded {\n' +
    '    letter-spacing: .2em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-frac {\n' +
    '    display: inline-block;\n' +
    '    font-size: 90%;\n' +
    '    vertical-align: middle;\n' +
    '    text-align: center;\n' +
    '}\n' +
    '\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-paren + .mfs-exponent,\n' +
    '.wsp-version-4-8-0 .mfs-abs + .mfs-exponent,\n' +
    '.wsp-version-4-8-0 .mfs-root + .mfs-exponent {\n' +
    '    vertical-align: .9em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-exponent{\n' +
    '    vertical-align: super;\n' +
    '    font-size: 70%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-frac .mfs-numr, .wsp-version-4-8-0 .mfs-frac .mfs-denm{\n' +
    '    display: block;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-super-group, .wsp-version-4-8-0 .mfs-sub-group, .wsp-version-4-8-0 .mfs-horizontal, .wsp-version-4-8-0 .mfs-root, .wsp-version-4-8-0 .mfs-paren,\n' +
    '.wsp-version-4-8-0 .mfs-bracket, .wsp-version-4-8-0 .mfs-curly, .wsp-version-4-8-0 .mfs-abs {\n' +
    '    display: inline-block;\n' +
    '    text-decoration: inherit;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-horizontal {\n' +
    '  white-space: pre;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-param {\n' +
    '    /*\n' +
    '     * background-color: lightgray;\n' +
    '     */\n' +
    '    display: inline-block;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 tbody { vertical-align: baseline; }\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-paren, .wsp-version-4-8-0 .mfs-root,\n' +
    '.wsp-version-4-8-0 .mfs-abs {\n' +
    '    display: inline-table;\n' +
    '    border-collapse: collapse;\n' +
    '    border-spacing: 0px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-paren td, .wsp-version-4-8-0 .mfs-root td,\n' +
    '.wsp-version-4-8-0 .mfs-abs td {\n' +
    '    padding: 0px;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-paren td.mfs-left-paren,\n' +
    '.wsp-version-4-8-0 .mfs-paren td.mfs-right-paren,\n' +
    '.wsp-version-4-8-0 .mfs-abs td.mfs-abs-bar\n' +
    ' {\n' +
    '    background-size: 100% 100%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-root td.mfs-left-root {\n' +
    '    background-size: 105% 100%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-root td.mfs-right-root {\n' +
    '    background-size: 100% 100%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 td.mfs-right-root {\n' +
    '    padding-top: .15em;\n' +
    '}\n' +
    '\n' +
    "/* Paren TD's have a dummy span under them, which fixes a rendering\n" +
    'issue with chrome. If you set the width of the TD itself, chrome adds\n' +
    'an extra two pixels to the adjoing td containing the parenthesized\n' +
    'expression! */\n' +
    '.wsp-version-4-8-0 .mfs-paren td.mfs-left-paren >span,\n' +
    '.wsp-version-4-8-0 .mfs-paren td.mfs-right-paren >span\n' +
    '{\n' +
    '    display: inline-block;\n' +
    '    width: .35em;\n' +
    '}\n' +
    '\n' +
    "/* See above comment on paren TD's */\n" +
    '.wsp-version-4-8-0 .mfs-root td.mfs-left-root >span\n' +
    '{\n' +
    '    display: inline-block;\n' +
    '    width: .7em;\n' +
    '}\n' +
    '\n' +
    "/* See above comment on paren TD's */\n" +
    '.wsp-version-4-8-0 .mfs-abs td.mfs-abs-bar >span\n' +
    '{\n' +
    '    display: inline-block;\n' +
    '    width: .2em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-subscript {\n' +
    '    font-size: smaller;\n' +
    '    vertical-align: sub;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-style {\n' +
    '    display: inline;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-arc, .wsp-version-4-8-0 .mfs-overbar-ray, .wsp-version-4-8-0 .mfs-overbar-line,\n' +
    '.wsp-version-4-8-0 .mfs-overbar-seg {\n' +
    '    display: inline-block;\n' +
    '    line-height: 1.4;\n' +
    '    background-repeat: no-repeat;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-ray, .wsp-version-4-8-0 .mfs-overbar-line {\n' +
    '    background-size: 100% .3em;\n' +
    '    padding-top: .02em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-arc {\n' +
    '    background-size: 100% .7em;\n' +
    '    padding-top: .55em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-seg {\n' +
    '    background-size: 100% 100%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-line > .mfs-horizontal .mfs-text:last-child:after,\n' +
    '.wsp-version-4-8-0 .mfs-overbar-ray > .mfs-horizontal .mfs-text:last-child:after {\n' +
    '    content: "\\200A\\200A"; /* two hair spaces */\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-overbar-seg > .mfs-horizontal .mfs-text:last-child:after {\n' +
    '    content: "\\200A"; /* one hair space */\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-underbar-seg {\n' +
    '    border-bottom-width: thin;\n' +
    '    border-bottom-color: black;\n' +
    '    border-bottom-style: solid;\n' +
    '    line-height: 0.9;\n' +
    '    display: inline-block;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-text {\n' +
    '    display: inline;\n' +
    '}\n' +
    '\n' +
    '/* Add some padding to the left of italic text, to workaround\n' +
    '  WSP-1751 "In Safari, screen garbage left behind when you drag a parameter"\n' +
    '*/\n' +
    '.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child,\n' +
    '.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child,\n' +
    '.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-sub-group:first-child > .mfs-text.mfs-text-italic:first-child,\n' +
    '.wsp-version-4-8-0 .wsp-Expression > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-sub-group:first-child > .mfs-text.mfs-text-italic:first-child,\n' +
    '.wsp-version-4-8-0 .wsp-Measure > .mfs-horizontal:first-child > .mfs-horizontal:first-child > .mfs-text.mfs-text-italic:first-child\n' +
    ' {\n' +
    '    padding-left: 0.2em;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-vertical-group {\n' +
    '    display: inline-block;\n' +
    '}\n' +
    '\n' +
    '/* This allows us to use a negative margin to shrink the size,\n' +
    "accomodating borders. If we're a child of an mfs-vertical-group, this property\n" +
    'is overridden by that child selector. */\n' +
    '.wsp-version-4-8-0  .wsp-mfs-reference {\n' +
    '    display: inline-block;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-vertical-group > * {\n' +
    '    display: block;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-text-layer * {\n' +
    '    -ms-user-select: none;\n' +
    '    -webkit-user-select: none;\n' +
    '    -moz-user-select: none;\n' +
    '    -o-user-select: none;\n' +
    '    user-select: none;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-text-layer {\n' +
    '    line-height: normal;\n' +
    '    pointer-events: none;\n' +
    '    border: none;\n' +
    '}\n' +
    '\n' +
    "/* Add border:none to make sure mfs nodes based on html tables (such as mfs-paren) don't inherit disfiguring borders */\n" +
    '.wsp-version-4-8-0 .wsp-text-layer table,\n' +
    '.wsp-version-4-8-0 .wsp-text-layer td,\n' +
    '.wsp-version-4-8-0 .wsp-text-layer tr {\n' +
    '    border: none;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .mfs-input {\n' +
    '    font-size: inherit;\n' +
    '    display: inline-block;\n' +
    '    white-space: nowrap;\n' +
    '    overflow: visible;\n' +
    '    color: inherit;\n' +
    '    font-family: inherit;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-numeric {\n' +
    '     position: absolute;\n' +
    '   }\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-numfield-text {\n' +
    '    white-space: nowrap;\n' +
    '}\n' +
    '\n' +
    '@-webkit-keyframes blinker { from {opacity:1.0;} to {opacity:0.0;} }\n' +
    '          @keyframes blinker { from {opacity:1.0;} to {opacity:0.0;} }\n' +
    '.wsp-version-4-8-0 .wsp-blink {\n' +
    '    font-size: larger;\n' +
    '    color: black;\n' +
    '    font-stretch: ultra-condensed;\n' +
    '    /*text-decoration:blink;*/\n' +
    '\n' +
    '    -webkit-animation-name:blinker;\n' +
    '            animation-name:blinker;\n' +
    '    -webkit-animation-iteration-count:infinite;\n' +
    '            animation-iteration-count:infinite;\n' +
    '    -webkit-animation-timing-function:cubic-bezier(1.0,0,0,1.0);\n' +
    '            animation-timing-function:cubic-bezier(1.0,0,0,1.0);\n' +
    '    -webkit-animation-duration:1s;\n' +
    '            animation-duration:1s;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-selected {\n' +
    '    background-color: yellow;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad {\n' +
    '    position: absolute;\n' +
    '    pointer-events: auto;\n' +
    '    -webkit-user-drag: element;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad:focus {\n' +
    '    outline: 0;\n' +
    '    border: 1px solid black;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad, .wsp-version-4-8-0 .wsp-Numberpad *,\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad *:before, .wsp-version-4-8-0 .wsp-Numberpad *:after {\n' +
    '    /** needs to be set to default in case it has been changed by any plugins/frameworks **/\n' +
    '    /* Bootstrap changes the setting of box-sizing, which is a setting\n' +
    '       that tells browser whether to take margin, padding into account when imposing the\n' +
    '       height/width property. */\n' +
    '    -webkit-box-sizing: content-box;\n' +
    '    -moz-box-sizing: content-box;\n' +
    '    box-sizing: content-box;\n' +
    '}\n' +
    '\n' +
    '/* The body of the Numberpad */\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-body {\n' +
    '    display: -webkit-flex;\n' +
    '    display: flex;\n' +
    '    -webkit-flex-direction: column;\n' +
    '    flex-direction: column;\n' +
    '    -webkit-justify-content: space-around;\n' +
    '    justify-content: space-around;\n' +
    '}\n' +
    '\n' +
    '/* A row of Buttons */\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-row {\n' +
    '    display: -webkit-flex;\n' +
    '    display: flex;\n' +
    '    -webkit-flex-direction: row;\n' +
    '    flex-direction: row;\n' +
    '    -webkit-justify-content: space-around;\n' +
    '    justify-content: space-around;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-error-message {\n' +
    '  text-align: center;\n' +
    '  margin-top: 25px;\n' +
    '  margin-bottom: 25px;\n' +
    '  color: red;\n' +
    '  font-size: 125%;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-tool-container {\n' +
    '  display: table-cell;\n' +
    '  position: relative;\n' +
    '  vertical-align: top;\n' +
    '}\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-draggable-toolButton {\n' +
    '  position: absolute;\n' +
    '  /* Set the z-index. The stacking context is the wsp-transform-node. We\n' +
    '  need our z-index to place us above the wsp-sketch-container, over\n' +
    '  which we will be dragged. Otherwise, a sketch with a non-transparent\n' +
    '  background will occlude us. */\n' +
    '  z-index: 1;\n' +
    '}\n' +
    '\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-tool > img {\n' +
    '  display: block;\n' +
    '}\n' +
    '\n' +
    '\n' +
    '.wsp-version-4-8-0 .wsp-text-target-highlight {\n' +
    '  background-color: rgba(255,0,0,0.5) !important;\n' +
    '}\n' +
    '\n' +
    '/* We could, if desired, move the wsp-Transform section into\n' +
    ' * wsp-skin.css and make the transform skinnable.\n' +
    ' * For that to be worthwhile, we would need to make the scale factors\n' +
    " * used customizable. The css transform isn't a problem - customizers\n" +
    " * just change it. But wsp.js needs to know that at init time, and it's\n" +
    ' * a bit tricky to encode something in css readable by js (e.g. hiding some info\n' +
    " * in a hidden node is stymied by browsers that don't set properties until the node\n" +
    " * is displayed. You could stash something in content::after but querying that isn't\n" +
    ' * supported on IE). Best I can think of here is to have a wsp-responsize-size-small-factor\n' +
    ' * class (and medium, etc.), with some property like opacity set to [0,1]. Code would then sniff that\n' +
    ' * by inserting a node into the DOM. This would have to match the value used in transform: scale();\n' +
    ' */\n' +
    '/* Section Start: wsp-Transform */\n' +
    '\n' +
    '/* The transform node is the target for css transforms that\n' +
    '  scale down the content to fit in smaller form factor devices.\n' +
    '\n' +
    '  CSS transforms are used for the scaling - but since those\n' +
    '  do not change the content size of their targets, we need\n' +
    '  to fix our content size too. The technique used is to take\n' +
    '  the actual content containing wsp-transform-node out of the flow,\n' +
    '  and create sibling DOM elements (wsp-transform-large, wsp-transform-medium,\n' +
    '  wsp-transform-small) of appropriate size, and make sure the right one is displayed\n' +
    '  while the rest are not.\n' +
    '*/\n' +
    '\n' +
    '/* .wsp-transform-node will be position: absolute, with transform-origin: top left\n' +
    '  wsp-transform-large by default is display: inline-block,\n' +
    '  wsp-transform-medium, wsp-transform-small are display: none\n' +
    "  Turn on large, medium, small using media queries - you'll need to override the\n" +
    '  default ones.\n' +
    '*/\n' +
    '\n' +
    '/*\n' +
    ' *  For our default sizing, some assumptions and numbers.\n' +
    " *  For a normal desktop sketch, we'll take a usual width as 800px (Mac window is 780x540 by default)\n" +
    ' *\n' +
    " *  For a mobile friendly document, we'll take as a baseline iPad landscape width (1024), where our ideal sketch width is 600px.\n" +
    ' *  On iPad portrate width (768px = 75% of 1024px), our ideal sketch width is 400px (75% of 600px)\n' +
    ' *  On Smartphone portrate (480px = 46.875% of 1024px), our ideal sketch width is 300px (50% of 600px)\n' +
    ' *\n' +
    ' *  The media queries are conditionalized by several classes on the root node.\n' +
    ' *  wsp-responsiveSizing: must be present for responsive sizing to be in effect\n' +
    ' *  wsp-responsiveSizing-small-size: support the 50% size;\n' +
    ' *  wsp-responsiveSizing-medium-size: support the 75% size;\n' +
    ' *  wsp-responsiveSizing-medium-break: if present, a break at the medium device width\n' +
    ' *    chooses medium size if available, otherwise small size\n' +
    ' *  wsp-responsiveSizing-small-break: if present, a break at the small device width\n' +
    ' *    chooses small size if available, otherwise medium size\n' +
    ' *\n' +
    ' */\n' +
    '\n' +
    '/*\n' +
    ' * First break half way between iPad landscape and iPad Portrate\n' +
    ' * ideal sketch width: 400px;\n' +
    ' * max-width: 892px\n' +
    ' * scale factor: 0.75;\n' +
    '*/\n' +
    '@media only screen and (max-width: 892px) {\n' +
    '\n' +
    '\n' +
    '  /* Small size default if .wsp-responsiveSizing-medium-size*/\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-large {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .mfs-responsive-borderwidth {\n' +
    '    border-width: 2px;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-medium {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-small {\n' +
    '    display: inline-block;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-small-size .wsp-transform-node {\n' +
    '    transform: scale(0.5);\n' +
    '    -webkit-transform: scale(0.5);\n' +
    '    -ms-transform: scale(0.5);\n' +
    '  }\n' +
    '\n' +
    '  /* Override with medium size if wsp-responsiveSizing-medium-size */\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-large {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .mfs-responsive-borderwidth {\n' +
    '    border-width: 2px;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-medium {\n' +
    '    display: inline-block;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-small {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-medium-break.wsp-responsiveSizing-medium-size .wsp-transform-node {\n' +
    '    transform: scale(0.75);\n' +
    '    -webkit-transform: scale(0.75);\n' +
    '    -ms-transform: scale(0.75);\n' +
    '  }\n' +
    '}\n' +
    '\n' +
    '/*\n' +
    ' * Second break half way between iPad portrate and Smartphone portrate\n' +
    ' * ideal sketch width: 300px;\n' +
    ' * max-width: 624px\n' +
    ' * scale factor: 0.5;\n' +
    '*/\n' +
    '@media only screen and (max-width: 624px) {\n' +
    '\n' +
    '  /* Default to medium size if .wsp-responsiveSizing-medium-size */\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-large {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .mfs-responsive-borderwidth {\n' +
    '    border-width: 2px;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-medium {\n' +
    '    display: inline-block;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-small {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-medium-size .wsp-transform-node {\n' +
    '    transform: scale(0.75);\n' +
    '    -webkit-transform: scale(0.75);\n' +
    '    -ms-transform: scale(0.75);\n' +
    '  }\n' +
    '\n' +
    '  /* Override to small size if .wsp-responsiveSizing-small-size */\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-large {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .mfs-responsive-borderwidth {\n' +
    '    border-width: 2px;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-medium {\n' +
    '    display: none;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-small {\n' +
    '    display: inline-block;\n' +
    '  }\n' +
    '  .wsp-version-4-8-0.wsp-responsiveSizing.wsp-responsiveSizing-small-break.wsp-responsiveSizing-small-size .wsp-transform-node {\n' +
    '    transform: scale(0.5);\n' +
    '    -webkit-transform: scale(0.5);\n' +
    '    -ms-transform: scale(0.5);\n' +
    '  }\n' +
    '}\n' +
    '/* Section End: wsp-Transform */\n' +
    '\n' +
    '/* Section Start: wsp-Calculator */\n' +
    "/* On mobile safari, there's an annoying dark background tap effect\n" +
    '   in our mathquill edit area. Turn if off */\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-display {\n' +
    '  -webkit-tap-highlight-color: rgba(0,0,0,0);\n' +
    '}\n' +
    '/* Section End: wsp-Calculator */\n' +
    '\n' +
    '/* CSS Utilities */\n' +
    '\n' +
    '/* A version of the clearfix a la https://css-tricks.com/snippets/css/clear-fix/ */\n' +
    '.wsp-version-4-8-0 .wsp-clearfix-group:after {\n' +
    '  content: "";\n' +
    '  display: table;\n' +
    '  clear: both;\n' +
    '}\n' +
    '\n' +
    '.wsp-sr-only {\n' +
    '  border: 0;\n' +
    '  height: 100%;\n' +
    '  overflow: hidden;\n' +
    '  top: 0;\n' +
    '  position: absolute;\n' +
    '  width: 100%;\n' +
    '  color: transparent;\n' +
    '  background-color: transparent;\n' +
    '  pointer-events: none;\n' +
    '}\n' +
    '.wsp-sr-only:focus {\n' +
    '  outline: none !important;\n' +
    '}\n' +
    '.wsp-live-node {\n' +
    '  width: 0;\n' +
    '  height: 0;\n' +
    '  margin: -1px;\n' +
    '  overflow: hidden;\n' +
    '  clip: rect(0, 0, 0, 0);\n' +
    '  border: 0;\n' +
    '}\n' +
    '.wsp-version-4-8-0 {\n' +
    '  /*\n' +
    '  Web Sketchpad. Copyright &copy; 2019 KCP Technologies, a McGraw-Hill Education Company. All rights reserved.\n' +
    '  Version: Release: 2020Q3, semantic Version: 4.8.0, Build Number: 1077, Build Stamp: stek-MBP-2.fios-router.home/20230217111107\n' +
    '*/\n' +
    '  /* Section Start: wsp-Button */\n' +
    '  /*\n' +
    '\n' +
    '  The outer element of a button will have class .wsp-Button\n' +
    '  Additional modifiers will be added as classes\n' +
    '  .wsp-appearance-drag: The button is being dragged / moved;\n' +
    '  .wsp-appearance-unselect: The button is not arrow selectable\n' +
    '    and thus not draggable;\n' +
    '  .wsp-appearance-short: The button is < 28 pixels high;\n' +
    '  .wsp-appearance-pressed: The button is depressed by user action;\n' +
    '  .wsp-appearance-active: The button is performing its action, which may\n' +
    "    continue after it's been clicked;\n" +
    '\n' +
    '\n' +
    '  Within the button we have some substructure to allow\n' +
    '  for a drag handle, a row of mfs text, and allow for the text\n' +
    "  top to move down one pixel during a click as part of it's depressed\n" +
    '  appearance.\n' +
    '\n' +
    '  wsp-Button contains a wsp-Button-row\n' +
    '  wsp-Button-row contains a wsp-Button-drag-handle and a wsp-Button-label-frame\n' +
    '  wsp-Button-label-frame contains a wsp-Button-label\n' +
    '\n' +
    '+-------------------wsp-Button--------------------------+\n' +
    'o--wsp-Button-row-x------wsp-Button-label-frame--------o|\n' +
    '||                |                                    ||\n' +
    '||                +------------------------------------||\n' +
    '|| wsp-Button-    |                                    ||\n' +
    '|| drag-handle    |                                    ||\n' +
    '||                |    wsp-Button-label                ||\n' +
    '||                |                                    ||\n' +
    '||                |                                    ||\n' +
    'o-----------------x------------------------------------o|\n' +
    '+-------------------------------------------------------+\n' +
    '\n' +
    '*/\n' +
    '  /* base style for the whole button */\n' +
    "  /* When it's dragging about, lighten it up */\n" +
    '  /* Styles for the handle - the dragable bit on the left of the button */\n' +
    '  /* When the button is short (< 28 px high) */\n' +
    "  /* Non-arrow selectable buttons don't have a full sided drag handle.\n" +
    ' It just becomes a narrow vertical strip */\n' +
    '  /* frame the button label (where the text is).\n' +
    " The frame is the part that's stable when the button is pressed down,\n" +
    " so it's just responsible for the top border */\n" +
    '  /* Some padding and border for the interior portion of the label */\n' +
    '  /* When pressed the frame lets the the label handle the\n' +
    ' border so it can move down a pixel */\n' +
    '  /* Add the border on the top now that the frame has punted it to us */\n' +
    '  /* When the button is working, a background */\n' +
    '  /* When the button is working, it looks pressed */\n' +
    '  /*\n' +
    'If you want to remove the drag handle completely, here is one approach:\n' +
    '\n' +
    '.wsp-Button-drag-handle {\n' +
    '  display: none !important;\n' +
    '}\n' +
    '\n' +
    '.wsp-Button-label-frame {\n' +
    '  border-left: 2px solid #c2b892 !important;\n' +
    '  border-bottom-left-radius: 5px !important;\n' +
    '  border-top-left-radius: 5px !important;\n' +
    '}\n' +
    '\n' +
    '.wsp-Button-label {\n' +
    '  padding: 0px 3px 0px 3px !important;\n' +
    '}\n' +
    '*/\n' +
    '  /* Section End: wsp-Button */\n' +
    '  /* Section Start: wsp-HotText */\n' +
    '  /*\n' +
    '  Tweak the "hot" part of the appearance of a hot-text caption.\n' +
    '*/\n' +
    '  /* Section End: wsp-HotText */\n' +
    '  /* Section Start: wsp-Tool */\n' +
    '  /*\n' +
    '\n' +
    '.wsp-tool-container contains a .wsp-tool-column\n' +
    ".wsp-tool-column contains a number of individual .wsp-tool's\n" +
    '\n' +
    'A .wsp-tool is an instance of a tool.\n' +
    '\n' +
    'Note that Numpad and Tools share a png of a "X"\n' +
    '\n' +
    '\n' +
    'To move the tool palette to the right, you will need change the float\n' +
    'of the .wsp-sketch-container and .wsp-tool-container, and change some padding and\n' +
    'margins.\n' +
    '\n' +
    '.wsp-sketch-container {\n' +
    '  float: left!important;\n' +
    '}\n' +
    '.wsp-tool-container {\n' +
    '  float: right!important;\n' +
    '  padding-right: 0px!important;\n' +
    '  margin-right: 0px!important;\n' +
    '  padding-left: 10px!important;\n' +
    '  margin-left: 5px!important;\n' +
    '}\n' +
    '\n' +
    '*/\n' +
    '  /* colors */\n' +
    '  /* default background */\n' +
    '  /* active tool text color */\n' +
    '  /* new look tools: border color */\n' +
    '  /* undo/redo background color */\n' +
    '  /* Toolplay classic Look: Background to blend in with box-shadow -\n' +
    '  you see this outside the rounded border */\n' +
    '  /* Toolplay New Look: Tool text color */\n' +
    '  /* a common background color */\n' +
    '  /* Toolplay new look: Background color for undo/redo hover */\n' +
    '  /* These tool styles are shared between new and classic looks. */\n' +
    '  /* Section End: wsp-Tool */\n' +
    '  /* Section Start: wsp-Parameter */\n' +
    '  /*\n' +
    '  Styles for the box around editable values in the sketch\n' +
    '*/\n' +
    '  /* Section End: wsp-Parameter */\n' +
    '  /* Section Start: wsp-Numberpad */\n' +
    '  /*\n' +
    '  A numeric entry keypad or "Numberpad" has a header and a body. The\n' +
    '  body contains rows of entries, which are either keys or blank\n' +
    '  spaces.\n' +
    '\n' +
    ' *\n' +
    ' *  +-wsp-Numberpad------------------------------------------------------------------+\n' +
    ' *  | +-wsp-Numberpad-header-------------------------------------------------------+ |\n' +
    ' *  | |                                                                            | |\n' +
    ' *  | |                                                       wsp-Numberpad-cancel | |\n' +
    ' *  | |                                                           +--------------+ | |\n' +
    ' *  | |                                                           |              | | |\n' +
    ' *  | |                                                           |       X      | | |\n' +
    ' *  | |                                                           +--------------+ | |\n' +
    ' *  | +----------------------------------------------------------------------------+ |\n' +
    ' *  | +-wsp-Numberpad-Body---------------------------------------------------------+ |\n' +
    ' *  | | +wsp-Numberpad-Row-------------------------------------------------------+ | |\n' +
    ' *  | | | +wsp-Numberpad-key/element/key-1-----+           +-----------+         | | |\n' +
    ' *  | | | |          |             |           |           |           |         | | |\n' +
    ' *  | | | |    1     |             |      2    |           |     3     |         | | |\n' +
    ' *  | | | +----------+             +-----------+           +-----------+         | | |\n' +
    ' *  | | +------------------------------------------------------------------------+ | |\n' +
    ' *  | | +------------------------------------------------------------------------+ | |\n' +
    ' *  | | |  +----------+             +----------+           +-----------+         | | |\n' +
    ' *  | | |  |          |             |          |           |           |         | | |\n' +
    ' *  | | |  |    4     |             |     5    |           |     6     |         | | |\n' +
    ' *  | | |  +----------+             +----------+           +-----------+         | | |\n' +
    ' *  | | +------------------------------------------------------------------------+ | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | | +  +----------+             +----------+           +-----------+        |  | |\n' +
    ' *  | | |  |          |             |          |           |           |        |  | |\n' +
    ' *  | | |  |    7     |             |     8    |           |     9     |        |  | |\n' +
    ' *  | | |  +----------+             +----------+           +-----------+        |  | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | | |  +----------+             +-----------+          +-----------+        |  | |\n' +
    ' *  | | |  |          |             |           |          |           |        |  | |\n' +
    ' *  | | |  |    .     |             |     0     |          |    +/-    |        |  | |\n' +
    ' *  | | |  +----------+             +-----------+          +-----------+        |  | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | |                                                                            | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | | |  +---------+                                     +-----------+        |  | |\n' +
    ' *  | | |  |         |                                     |           |        |  | |\n' +
    ' *  | | |  | clear   |                                     |delete-left|        |  | |\n' +
    ' *  | | |  +---------+                                     +-----------+        |  | |\n' +
    ' *  | | +-----------------------------------------------------------------------+  | |\n' +
    ' *  | |                                                                            | |\n' +
    ' *  | |                                                                            | |\n' +
    ' *  | +----------------------------------------------------------------------------+ |\n' +
    ' *  +--------------------------------------------------------------------------------+\n' +
    ' *\n' +
    ' *\n' +
    ' *\n' +
    ' */\n' +
    '  /* The Numberpad as a whole */\n' +
    '  /* The Numberpad header bar. Contains the cancel button. */\n' +
    '  /* The "cancel" button in the header, contains an "x" */\n' +
    '  /* The "erase to left" button */\n' +
    '  /* The clear button */\n' +
    '  /* A pressable key, like a number or a control key */\n' +
    '  /* A pressable key or empty space between keys */\n' +
    '  /* Each key contains its button text as an attribute. Remove or\n' +
    '   override this to change how keys look. */\n' +
    '  /* You can override the key text for any key. */\n' +
    '  /* These keys are not present by default, but can be enabled with\n' +
    'javascript (see section on Javascript customization). */\n' +
    '  /* Style for a pressed key */\n' +
    '  /* One of the special control keys: delete left, clear, or "+-". These\n' +
    '   control key elements also have the wsp-Numberpad-key class, but the\n' +
    '   style rule below will override styles applied only to that class. */\n' +
    '  /* Section End: wsp-Numberpad */\n' +
    '  /* Section Start: misc */\n' +
    '  /*\n' +
    '  Various misc. styles\n' +
    '*/\n' +
    '  /* In sketch text for error messages e.g. when the document has an unsupported version. */\n' +
    '  /* Section End: misc */\n' +
    '  /* Tables */\n' +
    '  /* Calculators */\n' +
    '  /* override  bootstrap within a calculator */\n' +
    '  /* Render styles */\n' +
    '  /* Insert new styles ABOVE this line to keep version scoping */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Button {\n' +
    '  cursor: pointer;\n' +
    '  padding: 0;\n' +
    '  background-color: transparent;\n' +
    '  border: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Button.wsp-appearance-drag {\n' +
    '  opacity: .8;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Button-drag-handle {\n' +
    '  width: 10px;\n' +
    '  min-width: 10px;\n' +
    '  padding: 0px;\n' +
    '  margin: 0px;\n' +
    '  border: 1px solid;\n' +
    '  border-bottom: 3px solid;\n' +
    '  border-color: rgba(0, 0, 0, 0.2);\n' +
    '  border-bottom-left-radius: 5px;\n' +
    '  border-top-left-radius: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-appearance-unselectable .wsp-Button-drag-handle {\n' +
    '  background-image: none;\n' +
    '  width: 5px;\n' +
    '  min-width: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Button-label-frame {\n' +
    '  border-top: 1px solid #c2b892;\n' +
    '  border-bottom-right-radius: 5px;\n' +
    '  border-top-right-radius: 5px;\n' +
    '  background-color: #f5f5ed;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Button-label {\n' +
    '  padding-left: 2px;\n' +
    '  padding-right: 2px;\n' +
    '  border-style: solid;\n' +
    '  border-color: #c2b892;\n' +
    '  border-left-width: 0px;\n' +
    '  border-right-width: 1px;\n' +
    '  border-top-width: 0px;\n' +
    '  border-bottom-width: 3px;\n' +
    '  border-bottom-right-radius: 5px;\n' +
    '  border-top-right-radius: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-appearance-pressed .wsp-Button-label-frame {\n' +
    '  border-top-color: transparent;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-appearance-pressed .wsp-Button-label {\n' +
    '  padding-top: 1px;\n' +
    '  border-top-width: 1px;\n' +
    '  border-bottom-width: 1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-appearance-active .wsp-Button-label-frame {\n' +
    '  border-top-color: transparent;\n' +
    '  opacity: 1;\n' +
    "  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAoCAIAAACw1AcgAAAKmWlDQ1BpY2MAAHjalZZ3UJPpFsbP933phZaAgJTQO1KkCyT0AArSwUZIAgRCjCFBBGzI4gqsBRURrOiiiIKrUmQtiAXbItiwb5BFRV1FXWyo3D+4xHvv3Dt39sy8M78588zzvue8/zwAtL08qVSMagDkSOSymNAAVlJyCov4AChAAxKogQ2PnyvlREdHwv+s97cBAQC44cCTSsXw90pTIMzlAyDRAJAmyOXnACDHAJAyvlQmB8DYAGC+WC6VA2ACAGDKkpJTALB8AGBmTHAFADDTJngXADBlcTGBANgxABKNx5NlAFA7AYCVx8+QA1CVAOAkEYgkADQNAPDjZ/IEALRoALDPyVkoAKAVAYB12r/4ZPybZ5rKk8fLUPHELAAAQAoS5UrFvCV/cx3/v3LEisk7jACAlpsdGwEAWgBIPp8XHDvJmUJu5CRL5QExkyySc+NUGkVY/CQrsuM5k5y9MEKll6TNilL55wamTHJBZlziJAuEQcGTLFsYo9Ln5sUGf9cHzprkLF549CTzZACTLBSHxnx/c7TqnRLxLNUs6bIQlUaY+31eeWZcmIplcSpNuiiEq5pXFvbdXxyt8pQpYlR7EEriVZ4CXpBqtxAIIpCAEHKABywIgyAAuTBfDgAQuFC6RCbKyJSzOFKpWGjP4kr4jvYsFydnF0hKTmFNfNe7O4AAAKJD+t4rPAnAKQRAI773EmwBGnoBmAu+98xfAzBbAE4U8xWyvIkeDgAADxRQBybogRGYgTU4gAu4gw+wIRjCIQriIBnmAx8yIQdksBiKYCWUQjmsh81QAzthD+yHQ3AE2uAEnIELcAV64RbcByUMwQsYgfcwhiAIEaEjDEQPMUYsEDvEBfFE/JBgJBKJQZKRVCQDkSAKpAhZhZQjlUgNshtpQH5BjiNnkEtIH3IXGUCGkbfIZxRDaSgTNUQt0WmoJ8pBI9A4dB6agS5CC9ASdC1ajdahB9FW9Ax6Bb2FKtEX6CgGGBXTwUwwB8wTC8SisBQsHZNhy7AyrAqrw5qwDqwbu4EpsZfYJxwBx8CxcA44H1wYLh7Hxy3CLcNV4Gpw+3GtuHO4G7gB3AjuG56ON8Db4b3xXHwSPgO/GF+Kr8LX41vw5/G38EP49wQCQYdgRfAghBGSCVmEQkIFYTuhmdBJ6CMMEkaJRKIe0Y7oS4wi8ohyYilxK/Eg8TTxOnGI+JFEJRmTXEghpBSShFRMqiIdIJ0iXSc9JY2RNcgWZG9yFFlAXkJeR95L7iBfIw+RxyiaFCuKLyWOkkVZSammNFHOUx5Q3lGpVFOqF3U2VURdQa2mHqZepA5QP9G0aLa0QNpcmoK2lraP1km7S3tHp9Mt6Wx6Cl1OX0tvoJ+lP6J/VGOoOapx1QRqy9Vq1VrVrqu9UierW6hz1OerF6hXqR9Vv6b+UoOsYakRqMHTWKZRq3Fco19jVJOh6awZpZmjWaF5QPOS5jMtopalVrCWQKtEa4/WWa1BBsYwYwQy+IxVjL2M84whJoFpxeQys5jlzEPMHuaItpb2dO0E7XztWu2T2kodTMdSh6sj1lmnc0Tnts7nKYZTOFOEU9ZMaZpyfcoH3am6bF2hbplus+4t3c96LL1gvWy9DXpteg/1cfq2+rP1F+vv0D+v/3Iqc6rPVP7UsqlHpt4zQA1sDWIMCg32GFw1GDU0Mgw1lBpuNTxr+NJIx4htlGW0yeiU0bAxw9jPWGS8yfi08XOWNovDErOqWedYIyYGJmEmCpPdJj0mY6ZWpvGmxabNpg/NKGaeZulmm8y6zEbMjc1nmheZN5rfsyBbeFpkWmyx6Lb4YGllmWi52rLN8pmVrhXXqsCq0eqBNd3a33qRdZ31TRuCjadNts12m15b1NbNNtO21vaaHWrnbiey227XZ4+397KX2NfZ9zvQHDgOeQ6NDgOOOo6RjsWObY6vpplPS5m2YVr3tG9Obk5ip71O9521nMOdi507nN+62LrwXWpdbrrSXUNcl7u2u76ZbjddOH3H9DtuDLeZbqvduty+unu4y9yb3Ic9zD1SPbZ59HsyPaM9KzwveuG9AryWe53w+uTt7i33PuL92sfBJ9vngM+zGVYzhDP2zhj0NfXl+e72Vfqx/FL9dvkp/U38ef51/o/ZZmwBu579lGPDyeIc5LwKcAqQBbQEfAj0Dlwa2BmEBYUGlQX1BGsFxwfXBD8KMQ3JCGkMGQl1Cy0M7QzDh0WEbQjr5xpy+dwG7ki4R/jS8HMRtIjYiJqIx5G2kbLIjpnozPCZG2c+mGUxSzKrLQqiuFEbox5GW0Uviv51NmF29Oza2U9inGOKYrpjGbELYg/Evo8LiFsXdz/eOl4R35WgnjA3oSHhQ2JQYmWiMmla0tKkK8n6yaLk9hRiSkJKfcronOA5m+cMzXWbWzr39jyrefnzLs3Xny+ef3KB+gLegqOp+NTE1AOpX3hRvDreaBo3bVvaCD+Qv4X/QsAWbBIMC32FlcKn6b7plenPMnwzNmYMZ/pnVmW+FAWKakRvssKydmZ9yI7K3pc9Lk4UN+eQclJzjku0JNmScwuNFuYv7JPaSUulykXeizYvGpFFyOpzkdx5ue1yplwqv6qwVvygGMjzy6vN+7g4YfHRfM18Sf7VJbZL1ix5WhBS8HMhrpBf2FVkUrSyaGApZ+nuZciytGVdy82WlywfWhG6Yv9Kysrslb8VOxVXFv+1KnFVR4lhyYqSwR9Cf2gsVSuVlfav9lm980fcj6Ife9a4rtm65luZoOxyuVN5VfmXCn7F5Z+cf6r+aXxt+tqede7rdqwnrJesv73Bf8P+Ss3KgsrBjTM3tm5ibSrb9NfmBZsvVU2v2rmFskWxRVkdWd2+1Xzr+q1fajJrbtUG1DZvM9i2ZtuH7YLt13ewdzTtNNxZvvPzLtGuO7tDd7fWWdZV7SHsydvzZG/C3u6fPX9uqNevL6//uk+yT7k/Zv+5Bo+GhgMGB9Y1oo2KxuGDcw/2Hgo61N7k0LS7Wae5/DAcVhx+/kvqL7ePRBzpOup5tOmYxbFtLYyWslakdUnrSFtmm7I9ub3vePjxrg6fjpZfHX/dd8LkRO1J7ZPrTlFOlZwaP11werRT2vnyTMaZwa4FXffPJp29eW72uZ7zEecvXgi5cLab0336ou/FE5e8Lx2/7Hm57Yr7ldarbldbfnP7raXHvaf1mse19l6v3o6+GX2nrvtfP3Mj6MaFm9ybV27NutV3O/72nf65/co7gjvP7orvvrmXd2/s/ooH+AdlDzUeVj0yeFT3u83vzUp35cmBoIGrj2Mf3x/kD774I/ePL0MlT+hPqp4aP2145vLsxHDIcO/zOc+HXkhfjL0s/VPzz22vrF8de81+fXUkaWTojezN+NuKd3rv9v01/a+u0ejRR+9z3o99KPuo93H/J89P3Z8TPz8dW/yF+KX6q83Xjm8R3x6M54yPS3kyHgAAYACApqcDvN0HQE8GYPQCUNQm8i4AACATGR1gIoP8d57IxAAA4A6wpxMgsRMgvBNgBxvAgg3AAIBoNkAcG1BXV9X5Z+Wmu7pMeFHbAPBV4+PvEgGINgBf+8fHx9rGx7/WA2D3ADrfT+RsAACCBkClGbrCpep06/oV/5l3/wHNmfXlY/st0gAAAAlwSFlzAAAASAAAAEgARslrPgAAAAl2cEFnAAAAAQAAACgAg9PABgAAADBJREFUCNdjWPjgPxMjAwMTEyMDEzOUZmJkYGJGphmIE4OJMzMhyRNhJgwzMmCYBQDI9ANK1RWWcgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMi0xMi0xOFQxNjoxNDowOS0wODowMMK1MMQAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTItMTItMThUMTY6MTQ6MDktMDg6MDCz6Ih4AAAAAElFTkSuQmCC');\n" +
    '  background-repeat: no;\n' +
    '  background-size: 100% 100%;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-appearance-active .wsp-Button-label {\n' +
    '  padding-top: 1px;\n' +
    '  border-top-width: 1px;\n' +
    '  border-bottom-width: 1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference-tracking {\n' +
    '  outline: 1px solid rgba(255, 0, 0, 0.1);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference {\n' +
    '  background-color: rgba(255, 0, 0, 0.01);\n' +
    '  border: 1px solid rgba(255, 0, 0, 0.1);\n' +
    '  border-radius: 5px;\n' +
    '  -moz-border-radius: 5px;\n' +
    '  -webkit-border-radius: 5px;\n' +
    '  /* Cancel the bottom border-radii for numerators */\n' +
    '  /* No top border or radius for denominators */\n' +
    '  margin: -1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference.mfs-numr {\n' +
    '  border-bottom-right-radius: 0px;\n' +
    '  border-bottom-left-radius: 0px;\n' +
    '  -moz-border-bottom-right-radius: 0px;\n' +
    '  -moz-border-bottom-left-radius: 0px;\n' +
    '  -webkit-border-bottom-right-radius: 0px;\n' +
    '  -webkit-border-bottom-left-radius: 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference.mfs-denm {\n' +
    '  border-top-style: none;\n' +
    '  border-top-right-radius: 0px;\n' +
    '  border-top-left-radius: 0px;\n' +
    '  -moz-border-top-right-radius: 0px;\n' +
    '  -moz-border-top-left-radius: 0px;\n' +
    '  -webkit-border-top-right-radius: 0px;\n' +
    '  -webkit-border-top-left-radius: 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference:hover {\n' +
    '  background-color: rgba(255, 0, 0, 0.1);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-mfs-reference.wsp-mfs-reference-hot {\n' +
    '  background-color: rgba(255, 0, 0, 0.5);\n' +
    '  border-color: #ff0000;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container {\n' +
    "  /* It's ok to float this left; it will still be right of the wsp-tool-container. */\n" +
    '  /* With "float: right;", at least in FireFox, there\'s an unavoidable gap between tools and sketch */\n' +
    '  float: left;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container {\n' +
    '  float: left;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-redo {\n' +
    '  background-color: #FFFFFF;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool-overflow-y.wsp-user-tools {\n' +
    '  overflow-y: auto;\n' +
    '  overflow-x: hidden;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool-logo {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-button:hover,\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-button:hover {\n' +
    '  background-color: #FFFFFF;\n' +
    '  cursor: pointer;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-button:focus,\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-button:focus {\n' +
    '  outline: 0;\n' +
    '  /* gets rid of blue box around focusables in chrome */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-disabled .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-disabled .wsp-redo-button {\n' +
    '  opacity: .3;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-undo-disabled .wsp-undo-button:hover,\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-redo-disabled .wsp-redo-button:hover {\n' +
    '  cursor: default;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool {\n' +
    '  background-color: white;\n' +
    '  word-wrap: break-word;\n' +
    '  white-space: normal;\n' +
    '  height: fit-content;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-draggable-toolButton {\n' +
    '  box-sizing: content-box;\n' +
    '  /* This simplifies dynamic sizing of the draggable */\n' +
    '  border: 2px solid #0087FF;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-container .wsp-tool-column .wsp-tool.wsp-tool-active {\n' +
    '  background-color: #ffffc8;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook {\n' +
    '  /* The following styles are common to these two looks */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo-bottom,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo-bottom {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-image,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-image {\n' +
    '  margin: auto;\n' +
    '  max-width: 100%;\n' +
    '  /* Use the full width of the container */\n' +
    '  height: 100%;\n' +
    '  object-fit: contain;\n' +
    "  /*  Maintain the image's aspect ratio */\n" +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool {\n' +
    '  width: 100%;\n' +
    '  text-align: center;\n' +
    '  font-weight: 200;\n' +
    '  border: 2px solid black;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button {\n' +
    '  width: 50%;\n' +
    '  height: 44px;\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-size: contain;\n' +
    '  background-position: center;\n' +
    '  background-origin: content-box;\n' +
    '  padding-top: 2px;\n' +
    '  padding-bottom: 2px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo button .wsp-inner-text,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo button .wsp-inner-text {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button {\n' +
    '  background-color: #F5F5F5;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook {\n' +
    '  background-color: #F5F5F5;\n' +
    '  padding-right: 10px;\n' +
    '  margin-right: 5px;\n' +
    '  min-width: 100px;\n' +
    '  /* Box shadow for classicLook. Some oddities here: when we set overflow\n' +
    '    to auto/scroll on an element, that seems to kill the box shadow. So\n' +
    "    when there's overflow, we put the box shadow on the enclosing element\n" +
    '    which in this case will be the same size as the visible portion of\n' +
    '    .wsp-tools-inner */\n' +
    '  /* Leave 1px space to align right edge with right edge of user tools */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-column {\n' +
    '  border-radius: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-column.wsp-no-tool-icons {\n' +
    '  width: 125px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-fixed-tool,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tools-inner,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-overflow-y.wsp-user-tools {\n' +
    '  box-shadow: 2px 2px black;\n' +
    '  /* Reduced the shadow and removed the blur to avoid intruding into elements below the sketch_canvas */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-fixed-tool {\n' +
    '  margin-right: 1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tools-inner {\n' +
    '  background-color: #393838;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool {\n' +
    '  font-size: 24px;\n' +
    '  border-radius: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook {\n' +
    '  /*  The compact look is designed for tools that use icons and no text */\n' +
    '  /*  If a tool is displayed as text, its name needs to be short enough to fit using 20-pt type. */\n' +
    '  background-color: #DDD;\n' +
    '  padding-right: 0px;\n' +
    '  border-right: 2px solid black;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook *,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook *:before,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook *:after {\n' +
    '  box-sizing: border-box;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column {\n' +
    '  width: 105px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column .wsp-undo-redo {\n' +
    '  background-color: inherit;\n' +
    '  /* use the same background color for the entire column */\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-column .wsp-undo-redo button {\n' +
    '  border: 2px solid black;\n' +
    '  border-radius: 9px;\n' +
    '  vertical-align: top;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool {\n' +
    '  font-size: 20px;\n' +
    '  /* If you must have a tool with no icon, its name needs to be short enough for 20-pt type */\n' +
    '  padding: 5px 0;\n' +
    '  border-radius: 9px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook {\n' +
    '  padding-right: 0px;\n' +
    '  margin-right: 0px;\n' +
    '  border-left: 2px solid #cdcdcd;\n' +
    '  border-bottom: 2px solid #cdcdcd;\n' +
    '  border-right: 2px solid #cdcdcd;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook *,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook *:before,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook *:after {\n' +
    '  box-sizing: border-box;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-user-tools {\n' +
    '  background-color: white;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner > :last-child {\n' +
    '  border-bottom: 2px solid #cdcdcd;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool {\n' +
    '  display: table;\n' +
    '  width: 220px;\n' +
    '  border-top: 2px solid #cdcdcd;\n' +
    '  padding-right: 20px;\n' +
    '  min-height: 58px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool .wsp-tool-media {\n' +
    '  width: 40px;\n' +
    '  height: 40px;\n' +
    '  display: table-cell;\n' +
    '  vertical-align: middle;\n' +
    '  padding: 5px 0px 0px 7px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tools-inner .wsp-tool .wsp-tool-text {\n' +
    '  display: table-cell;\n' +
    '  max-width: 109px;\n' +
    '  word-wrap: break-word;\n' +
    '  padding: 7px 10px 7px 10px;\n' +
    '  vertical-align: middle;\n' +
    "  font-family: 'Proxima Nova', arial, sans-serif;\n" +
    '  color: #2d2d2d;\n' +
    '  font-size: 18px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo-top {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button {\n' +
    '  margin-right: 2px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button {\n' +
    '  width: 109px;\n' +
    '  background-color: white;\n' +
    '  position: relative;\n' +
    '  border: none;\n' +
    '  height: 58px;\n' +
    '  padding: 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button:hover,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button:hover {\n' +
    '  background-color: #f0f0f0;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-text,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-text {\n' +
    '  position: absolute;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-icon {\n' +
    '  width: 20px;\n' +
    '  height: 20px;\n' +
    '  left: 40px;\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-size: contain;\n' +
    '  position: absolute;\n' +
    '  top: 12px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-undo-button .wsp-inner-text,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo .wsp-redo-button .wsp-inner-text {\n' +
    '  top: 33px;\n' +
    '  font-size: 14px;\n' +
    '  left: 33px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo.wsp-undo-disabled .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-redo.wsp-redo-disabled .wsp-redo-button {\n' +
    '  background-color: white;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-undo-button {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAQAAADbnPi/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBBYQOhiFrU+GAAAEnklEQVRo3u2Z3WsdRRiHn53dU2zqR61gtBQsKi1t1Ua8EUEQ03/AOylU8aONEiGxYi9V8E4Q0ys1qUIEb0Sai1xFChEvFKRKY0UvilA/oB8cJBITmuzMvl7s7DknJ7vJfirC/JYDh2V35jm/eeedd+aAk5OTk5OTk5OTk5OTU0fqvwYoJg9QRDW36K27I/ZTkx7D7+ugHKZPQJA5XoqAoI6ePL5hjrcI0CVbUCiinjFqcRu3MMA2PIQ1VljiL8LM5wsqYIU3WWSiBLJCYWznOxniMAc5wB52soOW9VIIWWaRP/iZn1jgAotEdkRKYs8jCCeBoMBbPr6FfoBTnKONbLiilHttznGKQzZ0klYK6UuE1ULIvo3F3bzGeYxFMYSEaOt51IGOiDBoQsKeZ89zkt3W6YLQ8wgajfBqDmRlmx9imiWLFKJT3ZRU1zWhfXqJaYasBQWS6zyCIcqFHDd8mBlMBzUfaP+VYBtmeKjHiNzAsiVy3OQgU4Q2APK6mu12HCSaKQbz+5wAJ8jjqchx1D5PuxNAdV0ag9DmOeKILgCcjRwAg8zW5GyW07MMkmPi9wInyGM9L3oEwDBXkJ55XgUv7QcbQoQrDAPB5uvheuB+5HiQxojs/XKI2qa8brKLk2CI6cHXRESMdwIwJ3AvcgsfmCjtrUl5z2xwuJvoYp/fA1QWclrEeCgME8BpfD7hGOFWw7RBgkGhUMAiC1zkF37lKsus4XETO9nDXvYzxD5aAGgUCo+Qce7gGRQZNd5Gh7sujzKJsFZiEsWOXeJdhtm1yQ9T3McxzrJovda2v0+zXU4HjuMsXlbLpKlVPueI9a5bXPrWdWWLUb9TPd/JKBetUYY1hClIT3JZwDFyMdx4XEKm2Q94eDlqYEVgwQKeYgHBoFlDeDs9ZLOBi08xjfAVD5MUNfnj3rPFv88IbYSQEOHZNOS6gDXCMqNAwWKmBzqu3O7irM1LKzzChl1nPcAhwo8cgs4Al5Nn89ErtrC6wAB9e8Q6gEOEWW5my1UqlxQB8ARtDMJp+iZfdeAQ4WNyli451QIO8htCxJPrkasCh50UVO8JRwDcz2WEb22RUAtwiPAZmyylFZEf5BrCaK/HVYA1wtdsp6nzowA4gvA7t3c9Lg8cIVznXqgxdvvVAsYQXqeTkcsDG4SnKXY8UFw+MEebHYnHZYE1cYnSnLuxFHAPmpGkr3LAEUKbvfwbp58B8AY/xA6X7S4C5rhMq9aTz3QZ4B0CHkfwywL7CEd5mbDhCAYQfG4wxVHAq5olXqLpSUeMyS5m2F41Ag3vM4JuHFnw+ZPveLQacLz3+4ARdGdv0RwyfMG+qg4nyCcaj+UIWEBVT0ox8oecaNxlxSpXubu6LwkyTFb44yGfLnFrHWk/QT7eqMsCXKNVzzoVI09yvMFYFmCpvoW1i9xkkltlqb5KIEF+scHAEP5W9ks9yB6GKV5oMDBuJA0XQ87aDikEwxngo5r/EE6kA3u6VdeOzMNHOIPPZCPI2zwOMEBUCFgwmyJH+Ci+rx0Wmt8uFFDOUfZQeDVNuvVqvrB3cnJycnJycnJycnJy+p/pHzDs9DpRnhI/AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTA0LTIyVDE2OjU4OjI0LTA0OjAwOz+VcAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wNC0yMlQxNjo1ODoyNC0wNDowMEpiLcwAAAAASUVORK5CYII=);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-redo-button,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-redo-button {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAQAAADbnPi/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBBYQOCnmRS0+AAAElElEQVRo3u3YT6gd5R3G8c+8M0fQaBuzMFYESy0t/k20i3ZTECN03Z0IUqw1USLcaKnLIrgrFHVl6y2FFLopYhZZKVKlCxfFQtKWFnUTWsEqF0m5NSR3/rxdzNyTc5Nz7p1zZkYQ5hkOHM6Z8853nnne3/s7L6NGjRo1atSoUaNGjRo16kuqkPQ4WNK8Lis2r95wVd2BE0GCSrXgIgFR1Rk9EXy3C3AQdmBOfNUNrnONRLTlgk3/lS88fzllCs/7wWrAQVA2ju132CF3usOt9ttn0sQiyn3uvI/80z+cdcb5xqd0BexM4YQX/XF52FTaQN/lOW/ZEK86qjmfbXjLc+4WdozSFpdnRdHby8MmuMWz3lM2KKVcrlCqVFPY+n2pkMtnzn3PT93SON0Oehv3kuid9rChGf6wkzYbpFwx18041/VC3py96aTDjQWhBe4zokKxjMP1wPc6pZyitgO98tjGLp1yaMaIvXArZVvgesiD1hVNANq6utjtOiS5dQd38XkWN7YFrlP7mA1RubKv870uRBt+rE70PNwTU9yWwBkOOt2Ts4ucPu1gc63FuC2AExmO+Ficmec7L9j9Fkq56GNHkE2X9gxrO3D3BK4f0gmVaiYIVVPEcuVMASuawrYqfqFSWZsGcB7uHsCJgBdnvJ1XGaqrfC8XPIt2Pr+E1GQubgOcLcBNVH7nUblMolLJZMh94Iz3nfOR8y6KrrHPzW5zu3scsl9QN0KpZZb9IJFbc8BjcmteUjZNVQvV7v5etDWdy9F5r3vU7bsW+gOO+KUPp09k2YhsiV51fI67u0YixbpoS9n88G+Ou8l2x5vKZFKhOdLmk+1bmXjIay5ZpQyWzYJezf1uLnCGF0RbCqXorB82BSedgVo8UTOJBN92Ur7Aq92RywW/mAuc4UeiXC7acEyKMFNw2kRqu0m6z5/E5sa7H3OAA77jQjNnX3ezyx3astruEY77XOxlhbwKOMF1zqgblKfVS0eX/ySpDHf5uyjvHzjFy6LShgfYM7Ht4pHheqd7QL4COMWDKtG/3IlJZ9jLIyf4bWfkHcD1gvhn0TnfdGUj0lVhWiq7IO8ATnFc9Il7esetDQn4QyfkGeAEN/q36KFBcGuXuda7HSrGDHCGn4nW9JndK5XiGz4VV+zqpsAJ9tnwRjPocMrwcHPpDsApjinc1jy4IZWq26pVYrHD4b/6uaHSO6uAr9tYKRal6O0gFX1f5hcoBweuTJzzBqvusdVN8iPWXZTqc2t0vjK5pzwidpkt1zrlAJ26hra4PNmtSgR8z1989gX4mykc80q34AV8y5v63Smfp4nCMb9a5r/aIuDgrJUnQUtlcke74xJ8zX9cGrj+ThSO+nV3XIKv+HBQ2G13e8ElmPjEkAmeKDzRF26d4c0BgTO5J7zaFy7BpksDwdaFrFdcgv8N5u5E4Sf94hJcHAg3k3vcurLZWOmuWA9bDIIbFB73mz3cXenZ3jAILkdX7hl26yXeSaQDNZX3q5TCri4ut6cUBRfandpXCnvQcCBDLPbJF9Cxjxo1atSoUaNGjRo1atSowfR/LRgeDFizcN0AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDQtMjJUMTY6NTY6NDEtMDQ6MDCxoYPjAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA0LTIyVDE2OjU2OjQxLTA0OjAwwPw7XwAAAABJRU5ErkJggg==);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-undo-button .wsp-inner-icon {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAQAAACBf8+OAAAAtUlEQVR4AbXTVwHEIBBF0SthJEQCEpCABKTEARIiYSUgAQmRMBLSt6XXM588OtCxCD3BE4hdBTzCjEhCEHKUiorUxauuimmXPlJSEXF8ua6TYvnhqOjLM2XR/5bAO54QpoQSxUAvUf10mGNQ4rvvOxhwCPNyKlzfs8CTsU5QXhxQUHGAp8Kwm6XCPhZ/L+aJrR46yPc17fN+BP/9DfOy3yf2pihuzwPumZ3f423/5/vt4ta+dg3LzGOPpQRi5AAAAABJRU5ErkJggg==);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-redo-button .wsp-inner-icon {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAQAAACBf8+OAAAAu0lEQVR4AbXTBxmFIBQF4BPhRjDCjUAEIhDFBkQwwotABCIYgQi+87n39ncxDrgxI3DwCPXiWZa+3SyjBap6CVxiXUrIIVwiWyYMUh206LEc2Fa2Q0dcPZPBEnvapZ9IGS0hWBLEPu7RCowrVvRhLizXLIs51gl7fT9IQD8kFvZlcCigoIqF05Rxh9MM4+az+MWLuXir5x5kr39N5/UfwQn9J5Zt9uagcx+wReJC538PBZ3/+Xr7v7adR/85A2OP4hj58QAAAABJRU5ErkJggg==);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-cancel {\n' +
    '  cursor: pointer ;\n' +
    '  display: block ;\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAB4ElEQVQ4y61UvWsUQRx9s1mEIyF6FpYKFxvB2ORSBgu54giYIoWg/0Caa201nVUqMWksgohY2KlXuFttkBR3CSQHFprAFRZinHXvbm/d25t5FnGP2w8ICz4YmHnDvPl9zBsBSyKNzr3LtVsw1oMx6rMzuAoAvoIsmWh+gX532/Y+ZQ7BkpNRpaoEig4vQKDoVKkq02cnkza5wiLQWrbJlYRQlapCrSWLQmsZR2YAgKONXQhRRlEIUXa0sXteWKpa5iZ3KNsejxJcNCLP9KsgJ7AOVQ2K3EmwfT+K8377m12SpBqRn+UTWBLrX/k6LaTIHSMYo54I95JpEmgAwIMW7kDzJVqDZ2KITQC4P4/FdIbBGHVBzT4E5hI7oxGw7zdEhOfT9PZiubtxDdcztSIG+UIA4A8h9kMRLxdulN9/u4nV3KITfcNXyD5tHQFH4dNp6qSLR28kvDwdX8E1SiaaCXYcAc5gM64J785vcRaPAdd7eOhe+djDcVqoZKKZbX9vEMRd2z7717UwJC3ZgCWBDl/kth+WRMZfP/3vH36l3lEYkj/0Vi/Hd1mLFLVJ2iIt2zs9EGKtkE1I90CItZbtnQI4FwKAJdt1lqEXIo29izT+aOwtC1aXbNeZ2O5/fWx/AXUQdBRBFjTDAAAAAElFTkSuQmCC);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tool-cancel > .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-cancel,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-cancel,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wwcFx4ZWcAjlgAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADyUlEQVRo3t1aT0gUURj/xi7TFkoLKxiMePLPShAiUogFgoKIeOjQRSoPnrzEijcPHRW6JEQX9eDFi4c8dJEIF4KNkBTEDrUHdTUwMWHezu46O29+Hd7kmm26M/Mmt/1gYRnevPn93nzv+37f90YhCQZAI6L7RNRBRFEiaiCiWiIKOUMyRPSdiLaI6DMRfSSiuKIoKbosAxAGEAOQgHdLOHOE/yVwDcA0AAvyzHLm1IIGPyEZeDEiE0EAb/PpKl5cq00W+KGAV/28tzHkF3wMl2+x/xm8NxKO25SbFXUnpdiGdRLNFSov40TUoSjKp9MXq4oMfFmG4MnB9PLsxaqzcZ6I7lD52p2/5gknw14YLq2vX2H09oLv7UlxbL63B6OnB1Yy6Sa8asUITJdyt9HdDaaqSLe2+ibBd3eRbm0FU1UYvb1ubp0uJsxKSlZWMgnW0FAgsbvrHXw0Kua5fRv82ze3SS7sOeZbm5tgN2+Kh0ejrknwVKoAvqMD/ODAX27wonOstTWw2loBoqUFPJUqHXxLi3Cbe/fAj44866XTm9eT5RMJsHC4QGJn53zwOztINzef+DxnzG8M0Hxn3fy7d9BragSJ5ua/kuDb2wXwg4Ows1k52bnU6HOemW/eQL9+vUBie/tP8E1NYKqKzMOHsE1TlryYJgBvZcxkLi5CD4UEiaamExJ8a6sAfngYtiVVmb8lAElZs5nz89BVVZBobEQ+Hke6sRFMVZEdHYVt27IFXpIA6DJnPH71Cswh8euXHR8PSqHqFES1lXv+/AR87tmzQKu2qkAkVy5X+G+agbdJ5LrQixdi9TUN+eVlME1D9unTIPz/xIWkbeLjmRkBPhKBtb4u3vH6OlgkguzICGzOA9nEcsLowgL0q1eh19QgH4//nuxWVqBXVyMzNAQ7n5ceRv0nsqUl6NeuQQ+FYC4tFR/z+jX0UAiZBw9g53JSE5k/KbG8DL26GkxVcTw3d76Lzc4KKdHfD9swpEkJ72Lu/XvoN26IcDk1VVqInZwUJLq7wXXf8UPzLqdXV8EiEZGoxsZc3ZuNxQSJzk7wHz/8yWlPBc3GBlhdndA3jx+7DpG2bSPz6JGQHO3t4Pv7vgua0kvKL1/A6uvFCg4MeFaWtmnCGBgQJG7dclvVWX+cKbgt6o2uLt8bkafTMLq6xHw9Pd6LeldtlWQSRl8f+OGhnLbK4SGMvj7/bZVTBxjlbhMX9UYTZdyd+6Aoyt3Kbu46A56U4eo/OQu+cg84KuKIqSIO+SrimLUiDror5lODcvzYQ/nfP7f5Cce8asR3hlrBAAAAAElFTkSuQmCC);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tools-newLook .wsp-tool-ok > .wsp-inner-icon,\n' +
    '.wsp-version-4-8-0 .wsp-tools-classicLook .wsp-tool-ok,\n' +
    '.wsp-version-4-8-0 .wsp-tools-compactLook .wsp-tool-ok,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok {\n' +
    '  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wwcFwczGXtDWAAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADqklEQVRo3t2aXYgbVRTHfzuzIKNZkIFkRmTFUKSgMShIwz4HpeC8VCHgILoQYfXNKQgDAYtQykJx8QNcCj4UBH0QhUVRH7b65toHcbEpYgsbZF9mMrgg2ZKH7vT2JZHpNbXJzNxssxcuzD1zz+F/zj3n3Dv3zBw5NN/3a1EULYdhuBQEwWK3213Y29ub7/f7cwCGYQjTNA9KpVLPtu1dy7K2isXixdXV1cscVmu1Wsdc192oVqs9QKTp1Wq157ruRqvVOjY14L7v1xzH2dZ1XaQFLndd14XjONu+79eUgm80Gpt5Ah+lSKPR2MwduOd5bhZXSeNanue5uYBvNpvrKq3+f6vRbDbXM4F3XXdj2sDlPsAwm+BTKzFYOnE/9bHdyfM89zB8fpyYGCuwp5lt0mSne+b5qQE6gWAdwc8I/kDww3h8d90nfN+vTc11XkBwHcFOovvju1Jyx9aGD+12+0Icx+rPIiZwDtATtOvA2njscRzTbrcv/OdgNjXrfyxZ/hqCpycP6OEBUAPodDprU7H+88CLEm0duDKZmDiO6XQ6a9PNPAUEW5L1v0GgZ8xIg4BQ7zr+CNc5nk2m7/s1LYqiZeWu8yjwukT7DPgzm9goipa1MAyXlCvwDvBAYvw38EF2sWEYLmlBECwqBV8FHIl2HuhlFx0EwaLW7XYXlCrgJXcb4Hfgy3xEd7vdBQqFwi1lgfukFLg7CJ7JT36hULilDa8+lLQ3pfEmsJ2f+H6/Pzc/MdfDwGvAc8CNgT/vjJj3GHBSon2Yv43mDcMQ+/v746/C18DjUpC+BITSvDeApHkuAVfzBW8YhtBM0zyYiOsnafwI8ClgJGgPAqekeR8pOBea5oFWKpUmS2hnge8l2lPA+4nxKeAhSekr+StQKpV6mm3buxNxCeBt4BeJfhJ4ZfD8qvTuEzU5wrbtXc2yrK2JOW8CbwF/yRemQAM4nqBdA35Vo4BlWVtasVi8mIr7n0Gg3pB8f1Wa97m6PfJf7JmO0y+P2KyG/SqCBbUf+BpApVL5MbUZvgK+u8u7b/M584xqQ8waQLlcPq3renpp7wJ7I+hfqAGv6zrlcvn0HUTHcbYzLWsdweXBbcNvCN5T93E0wHrnrUSlUlnJtAqXgBrwBPAscEad9SuVysrhX2yl7PcsgMza1aImE+r1ejZXQp3r1Ov1laN/vX4kChxHosSUdKeZLfIlqzYzW2aV94mZLHTLhZCZ/dVArincDz97zOW1Kof1u81tdvvvyyQ7/+AAAAAASUVORK5CYII=);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-ok-cancel-mode > .wsp-undo-button,\n' +
    '.wsp-version-4-8-0 .wsp-ok-cancel-mode > .wsp-redo-button {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel {\n' +
    '  cursor: pointer;\n' +
    '  display: block;\n' +
    '  top: 0px;\n' +
    '  right: 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-cancel .wsp-inner-text {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok {\n' +
    '  cursor: pointer;\n' +
    '  display: block;\n' +
    '  top: 0px;\n' +
    '  right: 38px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-tool-ok .wsp-inner-text {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-ok-cancel-button {\n' +
    '  position: absolute;\n' +
    '  margin-right: 10px;\n' +
    '  margin-top: 10px;\n' +
    '  height: 28px;\n' +
    '  width: 28px;\n' +
    '  background-size: 28px, 28px;\n' +
    '  background-color: #888888;\n' +
    '  border-radius: 14px;\n' +
    '  border-color: #888888;\n' +
    '  border-style: solid;\n' +
    '  border-width: thin;\n' +
    '  box-shadow: 3px 3px 7px #888888;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-accessible:focus {\n' +
    '  outline: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Measure:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Text:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Button:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Expression:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Table:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-Table > div:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container table:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .mfs-input:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .mfs-param:focus,\n' +
    '.wsp-version-4-8-0 .wsp-sketch-container .wsp-parameter-sr-only:focus {\n' +
    '  outline: none;\n' +
    '  outline-offset: 2px;\n' +
    '  z-index: 100000 !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-tool-background {\n' +
    '  background-color: rgba(0, 0, 0, 0.1);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .input-element {\n' +
    '  position: relative;\n' +
    '  display: inline-block;\n' +
    '  width: auto;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .input-element input {\n' +
    '  width: 100%;\n' +
    '  position: absolute;\n' +
    '  color: transparent;\n' +
    '  background-color: transparent;\n' +
    '  margin: 2px 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .mfs-input,\n' +
    '.wsp-version-4-8-0 .mfs-html-input {\n' +
    '  background-color: white;\n' +
    '  border: thin solid;\n' +
    '  padding: 2px;\n' +
    '  margin: 2px;\n' +
    '  vertical-align: middle;\n' +
    '  min-width: .6em;\n' +
    '  min-height: 1.2em;\n' +
    '  text-align: start;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad {\n' +
    '  width: 172px;\n' +
    '  height: 298px;\n' +
    '  background-color: #00bdec;\n' +
    '  border-radius: 9px;\n' +
    '  border: thin gray solid;\n' +
    '  padding: 0px 8px 8px 8px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad button:focus {\n' +
    '  outline: none;\n' +
    '  outline-offset: 2px;\n' +
    '  z-index: 100000 !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-header {\n' +
    '  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMDAlJyBoZWlnaHQ9JzI1Jz48cmVjdCBmaWxsPSd3aGl0ZScgeD0nNicgeT0nNicgd2lkdGg9JzkwJScgaGVpZ2h0PScyJy8+PHJlY3QgZmlsbD0nd2hpdGUnIHg9JzYnIHk9JzEyJyB3aWR0aD0nOTAlJyBoZWlnaHQ9JzInLz48cmVjdCBmaWxsPSd3aGl0ZScgeD0nNicgeT0nMTknIHdpZHRoPSc5MCUnIGhlaWdodD0nMicvPjwvc3ZnPgo=");\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-color: #00bdec;\n' +
    '  height: 25px;\n' +
    '  margin-bottom: 8px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-cancel {\n' +
    '  margin-left: auto ;\n' +
    '  text-align: center ;\n' +
    '  vertical-align: middle ;\n' +
    '  font-weight: bold ;\n' +
    '  font-size: larger ;\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-position: center;\n' +
    '  background-color: #00bdec;\n' +
    '  border-color: #00bdec;\n' +
    '  height: 28px;\n' +
    '  width: 28px;\n' +
    '  border-style: solid;\n' +
    '  border-width: thick;\n' +
    '  border-radius: 16px;\n' +
    '  padding: 0px;\n' +
    '  outline-offset: 0px !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-erase-to-left {\n' +
    "  /* the following is an svg image of the 'erase to left' unicode character,\n" +
    '       \\u232b, base64 encoded. To see original, cut out the quoted part after\n' +
    '       base64, then un-base64 encode.  */\n' +
    '  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgCnhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgZmlsbC1vcGFjaXR5PSIxIiBjb2xvci1yZW5kZXJpbmc9ImF1dG8iCmNvbG9yLWludGVycG9sYXRpb249ImF1dG8iIHN0cm9rZT0iYmxhY2siIHRleHQtcmVuZGVyaW5nPSJhdXRvIgpzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1vcGFjaXR5PSIxIgpzaGFwZS1yZW5kZXJpbmc9ImF1dG8iIGZpbGw9ImJsYWNrIiBzdHJva2UtZGFzaGFycmF5PSJub25lIiBzdHJva2Utd2lkdGg9IjEiCnN0cm9rZS1saW5lam9pbj0ibWl0ZXIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBpbWFnZS1yZW5kZXJpbmc9ImF1dG8iCndpZHRoPSIxMDBweCIgaGVpZ2h0PSIxMDBweCIgdmlld0JveD0iMCAwIDI3NyAyMDAiID4KPHBhdGggZD0iTTI2MiAxODYKTDEwMSAxODYKTDE1ICAxMDAKTDEwMSAgMTMKTDI2MiAgMTMKTDI2MiAxODYKWk0yNDggMTcyIApMMjQ4ICAyNwpMMTA3ICAyNwpMMzUgIDEwMApMMTA3IDE3MgpMMjQ4IDE3MgpaTTIxNyAxMzMKTDIwNyAxNDMKTDE3NCAxMDkKTDE0MCAxNDMKTDEzMSAxMzMKTDE2NCAxMDAKTDEzMSAgNjYKTDE0MCAgNTYgCkwxNzQgIDkwCkwyMDcgIDU2CkwyMTcgIDY2CkwxODMgMTAwCkwyMTcgMTMzIFoiIHN0cm9rZT0ibm9uZSIvPgo8L3N2Zz4K");\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-position: center;\n' +
    '  background-size: 30px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-clear {\n' +
    "  /* the following is an svg image of the 'circled latin capital letter c'\n" +
    '       unicode character, \\u2428, base64 encoded. To see original, cut out\n' +
    '       the quoted part after base64, then un-base64 encode.  */\n' +
    '  background-image: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+Cgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMC8vRU4nICdodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCc+CjxzdmcgZmlsbC1vcGFjaXR5PSIxIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKY29sb3ItcmVuZGVyaW5nPSJhdXRvIiBjb2xvci1pbnRlcnBvbGF0aW9uPSJhdXRvIiBzdHJva2U9ImJsYWNrIgp0ZXh0LXJlbmRlcmluZz0iYXV0byIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIgpzdHJva2Utb3BhY2l0eT0iMSIgc2hhcGUtcmVuZGVyaW5nPSJhdXRvIiBmaWxsPSJibGFjayIgc3Ryb2tlLWRhc2hhcnJheT0ibm9uZSIKc3Ryb2tlLXdpZHRoPSIxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiCnN0cm9rZS1kYXNob2Zmc2V0PSIwIiBpbWFnZS1yZW5kZXJpbmc9ImF1dG8iIHdpZHRoPSIxMDBweCIgaGVpZ2h0PSIxMDBweCIKdmlld0JveD0iMCAxNTMgMjg3IDI4NyI+CjxwYXRoIGQ9Ik0xNDQgMTc2IApRMTc2IDE3NiAyMDQgMTkyIApRMjMyLjMxMjUgMjA4LjY4NzUgMjQ4IDIzNyAKUTI2NC42NTYyIDI2NC42NTYyIDI2NSAyOTcgClEyNjQuNjU2MiAzMjguOTIxOSAyNDggMzU3IApRMjMyLjE3MTkgMzg0Ljg5MDYgMjA0IDQwMSAKUTE3Ni4wNjI1IDQxNy4yMzQ0IDE0NCA0MTcgClExMTEuOTM3NSA0MTcuMjM0NCA4NCA0MDEgClE1NS44MjgxIDM4NC44OTA2IDQwIDM1NyAKUTIzLjM0MzggMzI4LjkyMTkgMjMgMjk3IApRMjMuMzQzOCAyNjQuNjU2MiA0MCAyMzcgClE1NS42ODc1IDIwOC41NDY5IDg0IDE5MiAKUTExMS43OTY5IDE3NiAxNDQgMTc2IApaTTE0NCAzOTkgClExODUuOTA2MiAzOTkgMjE2IDM2OSAKUTI0Ni41MTU2IDMzOC43NjU2IDI0NyAyOTcgClEyNDYuNTE1NiAyNjkuNTc4MSAyMzMgMjQ2IApRMjE4Ljk1MzEgMjIxLjkwNjIgMTk1IDIwOCAKUTE3MS4yODEyIDE5NC4zNDM4IDE0NCAxOTQgClExMDEuODEyNSAxOTQuMzQzOCA3MiAyMjUgClE0MS40ODQ0IDI1NC44MTI1IDQxIDI5NyAKUTQxLjQ4NDQgMzM4Ljc2NTYgNzEgMzY5IApRMTAyIDM5OSAxNDQgMzk5IApaTTIwMyAzMjAKUTE5Ni41OTM4IDM0Mi44NDM4IDE4MiAzNTQgClExNjcuMzQzOCAzNjUuMjAzMSAxNDcgMzY1IApRMTE0LjA0NjkgMzY1LjIwMzEgOTkgMzQ0IApRODQuMDkzOCAzMjMuNTc4MSA4NCAyOTUgClE4NC4wOTM4IDI2Mi44MjgxIDEwMiAyNDUgClExMTkuMzkwNiAyMjYuNTQ2OSAxNDcgMjI3IApRMTY2Ljc4MTIgMjI2LjU0NjkgMTgxIDIzNyAKUTE5NC42MjUgMjQ2LjUxNTYgMjAwIDI2NiAKTDE4MyAyNzAgClExNzguMzEyNSAyNTUuNzk2OSAxNjkgMjQ5IApRMTYwLjQ1MzEgMjQxLjU5MzggMTQ3IDI0MiAKUTEyNS4xNTYyIDI0MS41OTM4IDExNCAyNTYgClExMDIuNTE1NiAyNzAuMjgxMiAxMDMgMjk1IApRMTAyLjUxNTYgMzIzLjE1NjIgMTE0IDMzNyAKUTEyNi40MjE5IDM0OS44NzUgMTQ1IDM0OS44NzUgClExNjEuMDE1NiAzNDkuODc1IDE3MSAzNDEgClExODAuODQzOCAzMzIuODU5NCAxODUgMzE2IApMMjAzIDMyMCBaCiIgc3Ryb2tlPSJub25lIiAvPgo8L3N2Zz4K");\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-position: center;\n' +
    '  background-size: 30px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-key {\n' +
    '  cursor: pointer;\n' +
    '  background-color: #eee;\n' +
    '  border: thin black solid;\n' +
    '  border-radius: 8px;\n' +
    '  font-family: Lucida Grande, sans-serif;\n' +
    '  font-size: 20px;\n' +
    '  color: black;\n' +
    '  text-align: center;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-element {\n' +
    '  margin: 1px;\n' +
    '  width: 44px;\n' +
    '  height: 44px;\n' +
    '  display: inline-block;\n' +
    '  vertical-align: middle;\n' +
    '  line-height: 48px;\n' +
    '  padding: 0px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-key:after {\n' +
    '  content: attr(data-keyText);\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-key:active,\n' +
    '.wsp-version-4-8-0 .wsp-Numberpad-key-down {\n' +
    '  background-color: #636568;\n' +
    '  border-color: transparent;\n' +
    '  color: white;\n' +
    '}\n' +
    '.wsp-version-4-8-0 button.wsp-Numberpad-control-key {\n' +
    '  background-color: #c5dee5;\n' +
    '  border-radius: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-error-message {\n' +
    '  text-align: center;\n' +
    '  margin-top: 25px;\n' +
    '  margin-bottom: 25px;\n' +
    '  color: red;\n' +
    '  font-size: 125%;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table {\n' +
    '  border-collapse: collapse;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table {\n' +
    '  border-right: 1px solid;\n' +
    '  border-bottom: 1px solid;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table,\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > th,\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td {\n' +
    '  border: 1px solid;\n' +
    '  text-align: center;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td.wsp-final-row-cell {\n' +
    '  opacity: 0.5;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > td {\n' +
    '  padding: .1em .4em .1em .4em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Table > div > table > tbody > tr > th {\n' +
    '  font-weight: normal;\n' +
    '  font-style: italic;\n' +
    '  padding: .2em .3em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator {\n' +
    '  width: 389px;\n' +
    '  height: 356px;\n' +
    '  background-color: #00bdec;\n' +
    '  border-radius: 9px;\n' +
    '  border: thin gray solid;\n' +
    '  padding: 0px 6px 10px 8px;\n' +
    '  cursor: default;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-title {\n' +
    '  background-color: #ecf8ff;\n' +
    '  text-align: center;\n' +
    '  border-radius: 5px;\n' +
    '  margin-top: 4px;\n' +
    '  padding: 2px 0;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-display {\n' +
    '  border-radius: 4px;\n' +
    '  height: 80px;\n' +
    '  background-color: white;\n' +
    '  margin: 7px 0;\n' +
    '  overflow: auto;\n' +
    '  font-size: 18px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-display-wrapper {\n' +
    '  position: relative;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-body-wrapper {\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-body-wrapper > .wsp-Calculator-body {\n' +
    '  display: inline-block;\n' +
    '  margin-left: 7px;\n' +
    '  /* The default vertical-align for display:inline-block is\n' +
    '     baseline. This leaves room at the bottom for letters like "j."\n' +
    '     Setting vertical-align to "top" eliminates the spacing. */\n' +
    '  vertical-align: top;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-left {\n' +
    '  display: inline-block;\n' +
    '  border-radius: 4px;\n' +
    '  vertical-align: top;\n' +
    '  width: 140px;\n' +
    '  height: 186px;\n' +
    '  background-color: #ecf8ff;\n' +
    '  margin-top: 3px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-label-insert {\n' +
    '  width: 50%;\n' +
    '  text-align: center;\n' +
    '  margin: 35px auto 10px auto;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-textual {\n' +
    '  font-family: Lucida Grande, sans-serif;\n' +
    '  font-size: 16px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator button.dropdown-toggle {\n' +
    '  background-color: #f0f0f0;\n' +
    '  border: 2px outset #f0f0f0;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .dropdown-toggle {\n' +
    '  width: 110px;\n' +
    '  white-space: nowrap;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-left .dropdown-toggle {\n' +
    '  height: 24px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .dropdown {\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-select-function ul {\n' +
    '  top: -220px;\n' +
    '  left: 110px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-select-units ul {\n' +
    '  top: -70px;\n' +
    '  left: 110px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-select-equation ul {\n' +
    '  top: -170px;\n' +
    '  left: 135px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-topmost-select-for-insert,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-select-for-insert {\n' +
    '  margin-top: 10px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-left .dropdown {\n' +
    '  margin-left: 15px;\n' +
    '  margin-right: 15px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-select-for-insert > button,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-Calculator-topmost-select-for-insert > button {\n' +
    '  box-sizing: border-box;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-bottom {\n' +
    '  margin-top: 15px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-select-equation {\n' +
    '  margin-left: 30px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-bottom-button {\n' +
    '  margin-left: 30px;\n' +
    '  border-radius: 5px;\n' +
    '  padding: 2px 10px 3px;\n' +
    '  background-color: #C0C0C0;\n' +
    '  border: 2px outset #C0C0C0;\n' +
    '  height: 19px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator-ok-button-inner {\n' +
    '  padding: 0 10px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .dropdown a {\n' +
    '  cursor: pointer;\n' +
    '  margin-left: 3px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .selected a {\n' +
    '  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxzdmcgd2lkdGg9IjE5LjIxMzE1IiBoZWlnaHQ9IjE4LjI5NDk5NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDxtZXRhZGF0YSBpZD0ibWV0YWRhdGE3Ij5pbWFnZS9zdmcreG1sPC9tZXRhZGF0YT4KCiA8Zz4KICA8dGl0bGU+TGF5ZXIgMTwvdGl0bGU+CiAgPGcgaWQ9ImxheWVyMSI+CiAgIDxwYXRoIGQ9Im00Ljc3NDY5LDE4LjI5NDk3OWMtMC4yNzUwMSwtMC4wMDM1NCAtMS40NjE4MSwtMS43Nzg0MzkgLTIuNjM3MzQsLTMuOTQ0MTQ5bC0yLjEzNzM0LC0zLjkzNzgxbDAuNTU0MDIsLTAuNTUzOTZjMC4zMDQ2OSwtMC4zMDQ3NSAxLjEyMzY3LC0wLjU1NDAyIDEuODE5OTUsLTAuNTU0MDJsMS4yNjU5NSwwbDAuNjM2MzgsMi4wMDUwN2wwLjYzNjM4LDIuMDA1MDdsNS4wNjQ0OCwtNS41NDEzMmMyLjc4NTQ1LC0zLjA0NzczIDYuMDAzMDcsLTYuMDQzNjQgNy4xNTAyNDEsLTYuNjU3NTlsMi4wODU3NDksLTEuMTE2MjdsLTQuMjA5NDM5LDQuNzgyMTdjLTIuMzE1MiwyLjYzMDI1IC01LjQ1MTM1LDYuNzQ4MDUgLTYuOTY5MjQsOS4xNTA3NmMtMS41MTc4OCwyLjQwMjcxIC0yLjk4NDc5LDQuMzY1NjYgLTMuMjU5NzgsNC4zNjIwNjFsLTAuMDAwMDEsLTAuMDAwMDExeiIgaWQ9InBhdGgyMjIzIiBmaWxsPSIjMDAwMDAwIi8+CiAgPC9nPgogPC9nPgo8L3N2Zz4=);\n' +
    '  background-repeat: no-repeat;\n' +
    '  background-position: left;\n' +
    '  background-size: 16px 16px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math sup {\n' +
    '  margin-top: 0.5em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math sup {\n' +
    '  margin-top: 0.5em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mathquill-editable.hasCursor {\n' +
    '  box-shadow: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-calculator-edited {\n' +
    '  padding: 5px;\n' +
    '  min-width: 364px;\n' +
    '  min-height: 69px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-calculator-edited .mq-blob > .wsp-ref {\n' +
    '  background-color: rgba(238, 238, 238, 0.8);\n' +
    '  display: inline-block;\n' +
    '  margin: 0px 2px;\n' +
    '  min-width: 0.7em;\n' +
    '  text-align: center;\n' +
    '  padding: 0 1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mathquill-rendered-math .numerator {\n' +
    '  padding: 0.1em 0.1em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator *,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator *:before,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator *:after {\n' +
    '  -webkit-box-sizing: content-box;\n' +
    '  -moz-box-sizing: content-box;\n' +
    '  box-sizing: content-box;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-independent-variable {\n' +
    '  font-style: italic;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-syntax-error-notice {\n' +
    '  display: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-syntax-error-notice:after {\n' +
    "  content: '!';\n" +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator.wsp-syntax-error .wsp-syntax-error-notice {\n' +
    '  color: red;\n' +
    '  background-color: #f8f8f8;\n' +
    '  font-size: 24px;\n' +
    '  display: inline;\n' +
    '  padding: 4px;\n' +
    '  position: absolute;\n' +
    '  right: 20px;\n' +
    '  border: 2px solid red;\n' +
    '  top: 10px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-root-block .mq-hasCursor {\n' +
    '  -webkit-box-shadow: inset #68b4df 0 0 2px 1px;\n' +
    '  -moz-box-shadow: inset #68b4df 0 0 2px 1px;\n' +
    '  box-shadow: inset #68b4df 0 0 2px 1px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-math-mode .mq-editable-field.mq-focused,\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field.mq-focused {\n' +
    '  box-shadow: none;\n' +
    '  border: none;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-math-mode .mq-sqrt-prefix {\n' +
    '  top: .18em;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .dropdown-menu > li > a {\n' +
    '  padding: 3px 19px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .wsp-missing {\n' +
    '  color: red;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field .mq-textarea {\n' +
    '  /* Mathquill sets position to relative, but we were seeing premature\n' +
    '   * scrollbars from IE (WSP-1578) as the selection area grew. This\n' +
    '   * fixes the issue, perhaps because 1) the textarea is filled with\n' +
    '   * increasingly more text as the selection is expanded, and 2)\n' +
    '   * relative positioning inserts the element into the flow for a\n' +
    '   * time, and thus impacts sizing enough to trigger scrolling. */\n' +
    '  position: absolute;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-editable-field .mq-textarea > * {\n' +
    '  z-index: -999;\n' +
    '  /* Mathquill uses a tiny (1px x 1px) textarea for cut/paste event handling, and\n' +
    '  this triggered a bug. Chrome got confused when selecting, then blurring, then\n' +
    '  focusing this textarea whenever it contained any text. Empirically, setting the\n' +
    '  textarea to overflow: hidden fixes the bug; so that is what we do. */\n' +
    '  overflow: hidden;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-Calculator .mq-non-leaf + .mq-sup-only {\n' +
    '  vertical-align: .9em;\n' +
    '  font-size: 85%;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-label-edit {\n' +
    '  border: 1px solid black;\n' +
    '  padding: 3px;\n' +
    '  width: 415px;\n' +
    '  background-color: #fafafa;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-label-edit button {\n' +
    '  float: right;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-label-edit * {\n' +
    '  font-size: 15px;\n' +
    '  margin: 5px;\n' +
    '  padding: 5px;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-text-target-highlight,\n' +
    '.wsp-version-4-8-0 .wsp-text-unmatched-given,\n' +
    '.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n' +
    '  border-style: solid !important;\n' +
    '  border-width: 2px !important;\n' +
    '  border-radius: 5px !important;\n' +
    '  box-shadow: 3px 3px 7px black !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-text-target-highlight,\n' +
    '.wsp-version-4-8-0 .wsp-text-unmatched-given {\n' +
    '  border-color: rgba(255, 0, 0, 0.5) !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n' +
    '  border-color: rgba(255, 215, 0, 0.5) !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-text-unmatched-given {\n' +
    '  -webkit-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n' +
    '  -moz-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n' +
    '  -o-animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n' +
    '  animation: wsp-version-4-8-0FlickerAnimation 0.5s infinite;\n' +
    '}\n' +
    '@keyframes wsp-version-4-8-0FlickerAnimation {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 0, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-o-keyframes wsp-version-4-8-0FlickerAnimation {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 0, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-moz-keyframes wsp-version-4-8-0FlickerAnimation {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 0, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-webkit-keyframes wsp-version-4-8-0FlickerAnimation {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 0, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 0, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-text-fancy-pulse {\n' +
    '  -webkit-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n' +
    '  -moz-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n' +
    '  -o-animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n' +
    '  animation: wsp-version-4-8-0FlickerAnimationGold 2s infinite;\n' +
    '}\n' +
    '@keyframes wsp-version-4-8-0FlickerAnimationGold {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 215, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-o-keyframes wsp-version-4-8-0FlickerAnimationGold {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 215, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-moz-keyframes wsp-version-4-8-0FlickerAnimationGold {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 215, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '@-webkit-keyframes wsp-version-4-8-0FlickerAnimationGold {\n' +
    '  0% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '  40% {\n' +
    '    background-color: rgba(255, 215, 0, 0.5);\n' +
    '  }\n' +
    '  80% {\n' +
    '    background-color: rgba(255, 215, 0, 0);\n' +
    '  }\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-effects {\n' +
    '  border: 4px dashed transparent;\n' +
    '  box-sizing: border-box;\n' +
    '  width: 100%;\n' +
    '  height: 100%;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-drop-target .wsp-effects {\n' +
    '  border-color: blue;\n' +
    '}\n' +
    '.wsp-version-4-8-0 .wsp-parameter-sr-only {\n' +
    '  border: 0;\n' +
    '  width: 100%;\n' +
    '  height: 100%;\n' +
    '  overflow: hidden;\n' +
    '  position: absolute;\n' +
    '  color: transparent;\n' +
    '  background-color: transparent;\n' +
    '}\n' +
    '.wsp-version-4-8-0.keypressed .wsp-Numberpad button:focus {\n' +
    '  outline: 3px solid red !important;\n' +
    '}\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Measure:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Text:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Button:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Expression:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Table:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-Table > div:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container table:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .mfs-input:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .mfs-param:focus,\n' +
    '.wsp-version-4-8-0.keypressed .wsp-sketch-container .wsp-parameter-sr-only:focus {\n' +
    '  outline: 3px solid red;\n' +
    '}\n' +
    '/*\n' +
    ' * MathQuill: http://mathquill.com\n' +
    ' * by Jay and Han (laughinghan@gmail.com)\n' +
    ' *\n' +
    ' * This Source Code Form is subject to the terms of the\n' +
    ' * Mozilla Public License, v. 2.0. If a copy of the MPL\n' +
    ' * was not distributed with this file, You can obtain\n' +
    ' * one at http://mozilla.org/MPL/2.0/.\n' +
    ' */\n' +
    '@font-face {\n' +
    '  font-family: Symbola;\n' +
    '  src: local("Symbola Regular"), local("Symbola");\n' +
    '}\n' +
    '.mq-editable-field {\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-editable-field .mq-root-block {\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '  width: 100%;\n' +
    '  padding: 2px;\n' +
    '  -webkit-box-sizing: border-box;\n' +
    '  -moz-box-sizing: border-box;\n' +
    '  box-sizing: border-box;\n' +
    '  white-space: pre;\n' +
    '  overflow: hidden;\n' +
    '  vertical-align: middle;\n' +
    '}\n' +
    '.mq-editable-field .mq-root-block:after {\n' +
    "  content: '';\n" +
    '}\n' +
    '.mq-editable-field .mq-cursor {\n' +
    '  border-left: 1px solid black;\n' +
    '  margin-left: -1px;\n' +
    '  position: relative;\n' +
    '  z-index: 1;\n' +
    '  padding: 0;\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-editable-field .mq-cursor.mq-blink {\n' +
    '  visibility: hidden;\n' +
    '}\n' +
    '.mq-editable-field,\n' +
    '.mq-math-mode .mq-editable-field {\n' +
    '  border: 1px solid gray;\n' +
    '}\n' +
    '.mq-editable-field.mq-focused,\n' +
    '.mq-math-mode .mq-editable-field.mq-focused {\n' +
    '  -webkit-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n' +
    '  -moz-box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n' +
    '  box-shadow: #8bd 0 0 1px 2px, inset #6ae 0 0 2px 0;\n' +
    '  border-color: #709AC0;\n' +
    '  border-radius: 1px;\n' +
    '}\n' +
    '.mq-math-mode .mq-editable-field {\n' +
    '  margin: 1px;\n' +
    '}\n' +
    '.mq-editable-field .mq-latex-command-input {\n' +
    '  color: inherit;\n' +
    '  font-family: "Courier New", monospace;\n' +
    '  border: 1px solid gray;\n' +
    '  padding-right: 1px;\n' +
    '  margin-right: 1px;\n' +
    '  margin-left: 2px;\n' +
    '}\n' +
    '.mq-editable-field .mq-latex-command-input.mq-empty {\n' +
    '  background: transparent;\n' +
    '}\n' +
    '.mq-editable-field .mq-latex-command-input.mq-hasCursor {\n' +
    '  border-color: ActiveBorder;\n' +
    '}\n' +
    '.mq-editable-field.mq-empty:after,\n' +
    '.mq-editable-field.mq-text-mode:after,\n' +
    '.mq-math-mode .mq-empty:after {\n' +
    '  visibility: hidden;\n' +
    "  content: 'c';\n" +
    '}\n' +
    '.mq-editable-field .mq-cursor:only-child:after,\n' +
    '.mq-editable-field .mq-textarea + .mq-cursor:last-child:after {\n' +
    '  visibility: hidden;\n' +
    "  content: 'c';\n" +
    '}\n' +
    '.mq-editable-field .mq-text-mode .mq-cursor:only-child:after {\n' +
    "  content: '';\n" +
    '}\n' +
    '.mq-editable-field.mq-text-mode {\n' +
    '  overflow-x: auto;\n' +
    '  overflow-y: hidden;\n' +
    '}\n' +
    '.mq-math-mode {\n' +
    '  font-variant: normal;\n' +
    '  font-weight: normal;\n' +
    '  font-style: normal;\n' +
    '  font-size: 115%;\n' +
    '  line-height: 1;\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-math-mode .mq-non-leaf,\n' +
    '.mq-math-mode .mq-scaled {\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-math-mode var,\n' +
    '.mq-math-mode .mq-text-mode,\n' +
    '.mq-math-mode .mq-nonSymbola {\n' +
    '  font-family: "Times New Roman", Symbola, serif;\n' +
    '  line-height: .9;\n' +
    '}\n' +
    '.mq-math-mode * {\n' +
    '  font-size: inherit;\n' +
    '  line-height: inherit;\n' +
    '  margin: 0;\n' +
    '  padding: 0;\n' +
    '  border-color: black;\n' +
    '  -webkit-user-select: none;\n' +
    '  -moz-user-select: none;\n' +
    '  user-select: none;\n' +
    '}\n' +
    '.mq-math-mode .mq-empty {\n' +
    '  background: #ccc;\n' +
    '}\n' +
    '.mq-math-mode .mq-empty.mq-root-block {\n' +
    '  background: transparent;\n' +
    '}\n' +
    '.mq-math-mode.mq-empty {\n' +
    '  background: transparent;\n' +
    '}\n' +
    '.mq-math-mode .mq-text-mode {\n' +
    '  font-size: 87%;\n' +
    '}\n' +
    '.mq-math-mode .mq-font {\n' +
    '  font: 1em "Times New Roman", Symbola, serif;\n' +
    '}\n' +
    '.mq-math-mode .mq-font * {\n' +
    '  font-family: inherit;\n' +
    '  font-style: inherit;\n' +
    '}\n' +
    '.mq-math-mode b,\n' +
    '.mq-math-mode b.mq-font {\n' +
    '  font-weight: bolder;\n' +
    '}\n' +
    '.mq-math-mode var,\n' +
    '.mq-math-mode i,\n' +
    '.mq-math-mode i.mq-font {\n' +
    '  font-style: italic;\n' +
    '}\n' +
    '.mq-math-mode var.mq-florin {\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '  width: .3em;\n' +
    '  position: relative;\n' +
    '  left: -0.1em;\n' +
    '}\n' +
    '.mq-math-mode big {\n' +
    '  font-size: 125%;\n' +
    '}\n' +
    '.mq-math-mode .mq-roman {\n' +
    '  font-style: normal;\n' +
    '}\n' +
    '.mq-math-mode .mq-sans-serif {\n' +
    '  font-family: sans-serif, Symbola, serif;\n' +
    '}\n' +
    '.mq-math-mode .mq-monospace {\n' +
    '  font-family: monospace, Symbola, serif;\n' +
    '}\n' +
    '.mq-math-mode .mq-overline {\n' +
    '  border-top: 1px solid black;\n' +
    '  margin-top: 1px;\n' +
    '}\n' +
    '.mq-math-mode .mq-underline {\n' +
    '  border-bottom: 1px solid black;\n' +
    '  margin-bottom: 1px;\n' +
    '}\n' +
    '.mq-math-mode .mq-binary-operator {\n' +
    '  padding: 0 0.2em;\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub {\n' +
    '  font-size: 90%;\n' +
    '  vertical-align: -0.5em;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub.mq-limit {\n' +
    '  font-size: 80%;\n' +
    '  vertical-align: -0.4em;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub.mq-sup-only {\n' +
    '  vertical-align: .5em;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub.mq-sup-only .mq-sup {\n' +
    '  display: inline-block;\n' +
    '  vertical-align: text-bottom;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub .mq-sup {\n' +
    '  display: block;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub .mq-sub {\n' +
    '  display: block;\n' +
    '  float: left;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub.mq-limit .mq-sub {\n' +
    '  margin-left: -0.25em;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub .mq-binary-operator {\n' +
    '  padding: 0 .1em;\n' +
    '}\n' +
    '.mq-math-mode .mq-supsub .mq-fraction {\n' +
    '  font-size: 70%;\n' +
    '}\n' +
    '.mq-math-mode sup.mq-nthroot {\n' +
    '  font-size: 80%;\n' +
    '  vertical-align: 0.8em;\n' +
    '  margin-right: -0.6em;\n' +
    '  margin-left: .2em;\n' +
    '  min-width: .5em;\n' +
    '}\n' +
    '.mq-math-mode .mq-paren {\n' +
    '  padding: 0 .1em;\n' +
    '  vertical-align: top;\n' +
    '  -webkit-transform-origin: center .06em;\n' +
    '  -moz-transform-origin: center .06em;\n' +
    '  -ms-transform-origin: center .06em;\n' +
    '  -o-transform-origin: center .06em;\n' +
    '  transform-origin: center .06em;\n' +
    '}\n' +
    '.mq-math-mode .mq-paren.mq-ghost {\n' +
    '  color: silver;\n' +
    '}\n' +
    '.mq-math-mode .mq-paren + span {\n' +
    '  margin-top: .1em;\n' +
    '  margin-bottom: .1em;\n' +
    '}\n' +
    '.mq-math-mode .mq-array {\n' +
    '  vertical-align: middle;\n' +
    '  text-align: center;\n' +
    '}\n' +
    '.mq-math-mode .mq-array > span {\n' +
    '  display: block;\n' +
    '}\n' +
    '.mq-math-mode .mq-operator-name {\n' +
    '  font-family: Symbola, "Times New Roman", serif;\n' +
    '  line-height: .9;\n' +
    '  font-style: normal;\n' +
    '}\n' +
    '.mq-math-mode var.mq-operator-name.mq-first {\n' +
    '  padding-left: .2em;\n' +
    '}\n' +
    '.mq-math-mode var.mq-operator-name.mq-last {\n' +
    '  padding-right: .2em;\n' +
    '}\n' +
    '.mq-math-mode .mq-fraction {\n' +
    '  font-size: 90%;\n' +
    '  text-align: center;\n' +
    '  vertical-align: -0.4em;\n' +
    '  padding: 0 .2em;\n' +
    '}\n' +
    '.mq-math-mode .mq-fraction,\n' +
    '.mq-math-mode .mq-large-operator,\n' +
    '.mq-math-mode x:-moz-any-link {\n' +
    '  display: -moz-groupbox;\n' +
    '}\n' +
    '.mq-math-mode .mq-fraction,\n' +
    '.mq-math-mode .mq-large-operator,\n' +
    '.mq-math-mode x:-moz-any-link,\n' +
    '.mq-math-mode x:default {\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-math-mode .mq-numerator,\n' +
    '.mq-math-mode .mq-denominator {\n' +
    '  display: block;\n' +
    '}\n' +
    '.mq-math-mode .mq-numerator {\n' +
    '  padding: 0 0.1em;\n' +
    '}\n' +
    '.mq-math-mode .mq-denominator {\n' +
    '  border-top: 1px solid;\n' +
    '  float: right;\n' +
    '  width: 100%;\n' +
    '  padding: .15em .1em 0 .1em;\n' +
    '  margin-right: -0.1em;\n' +
    '  margin-left: -0.1em;\n' +
    '}\n' +
    '.mq-math-mode .mq-sqrt-prefix {\n' +
    '  padding-top: 0;\n' +
    '  position: relative;\n' +
    '  top: .05em;\n' +
    '  vertical-align: top;\n' +
    '  -webkit-transform-origin: top;\n' +
    '  -moz-transform-origin: top;\n' +
    '  -ms-transform-origin: top;\n' +
    '  -o-transform-origin: top;\n' +
    '  transform-origin: top;\n' +
    '}\n' +
    '.mq-math-mode .mq-sqrt-stem {\n' +
    '  border-top: 1px solid;\n' +
    '  margin-top: 1px;\n' +
    '  padding-left: .15em;\n' +
    '  padding-right: .2em;\n' +
    '  margin-right: .1em;\n' +
    '  padding-top: 1px;\n' +
    '}\n' +
    '.mq-math-mode .mq-vector-prefix {\n' +
    '  display: block;\n' +
    '  text-align: center;\n' +
    '  line-height: .25em;\n' +
    '  margin-bottom: -0.1em;\n' +
    '  font-size: 0.75em;\n' +
    '}\n' +
    '.mq-math-mode .mq-vector-stem {\n' +
    '  display: block;\n' +
    '}\n' +
    '.mq-math-mode .mq-large-operator {\n' +
    '  text-align: center;\n' +
    '}\n' +
    '.mq-math-mode .mq-large-operator .mq-from,\n' +
    '.mq-math-mode .mq-large-operator big,\n' +
    '.mq-math-mode .mq-large-operator .mq-to {\n' +
    '  display: block;\n' +
    '}\n' +
    '.mq-math-mode .mq-large-operator .mq-from,\n' +
    '.mq-math-mode .mq-large-operator .mq-to {\n' +
    '  font-size: 80%;\n' +
    '}\n' +
    '.mq-math-mode .mq-large-operator .mq-from {\n' +
    '  float: right;\n' +
    '  /* take out of normal flow to manipulate baseline */\n' +
    '  width: 100%;\n' +
    '}\n' +
    '.mq-math-mode,\n' +
    '.mq-math-mode .mq-editable-field {\n' +
    '  cursor: text;\n' +
    '  font-family: Symbola, "Times New Roman", serif;\n' +
    '}\n' +
    '.mq-math-mode .mq-selection,\n' +
    '.mq-editable-field .mq-selection,\n' +
    '.mq-math-mode .mq-selection .mq-non-leaf,\n' +
    '.mq-editable-field .mq-selection .mq-non-leaf,\n' +
    '.mq-math-mode .mq-selection .mq-scaled,\n' +
    '.mq-editable-field .mq-selection .mq-scaled {\n' +
    '  background: #B4D5FE !important;\n' +
    '  background: Highlight !important;\n' +
    '  color: HighlightText;\n' +
    '  border-color: HighlightText;\n' +
    '}\n' +
    '.mq-math-mode .mq-selection .mq-matrixed,\n' +
    '.mq-editable-field .mq-selection .mq-matrixed {\n' +
    '  background: #39F !important;\n' +
    '}\n' +
    '.mq-math-mode .mq-selection .mq-matrixed-container,\n' +
    '.mq-editable-field .mq-selection .mq-matrixed-container {\n' +
    "  filter: progid:DXImageTransform.Microsoft.Chroma(color='#3399FF') !important;\n" +
    '}\n' +
    '.mq-math-mode .mq-selection.mq-blur,\n' +
    '.mq-editable-field .mq-selection.mq-blur,\n' +
    '.mq-math-mode .mq-selection.mq-blur .mq-non-leaf,\n' +
    '.mq-editable-field .mq-selection.mq-blur .mq-non-leaf,\n' +
    '.mq-math-mode .mq-selection.mq-blur .mq-scaled,\n' +
    '.mq-editable-field .mq-selection.mq-blur .mq-scaled,\n' +
    '.mq-math-mode .mq-selection.mq-blur .mq-matrixed,\n' +
    '.mq-editable-field .mq-selection.mq-blur .mq-matrixed {\n' +
    '  background: #D4D4D4 !important;\n' +
    '  color: black;\n' +
    '  border-color: black;\n' +
    '}\n' +
    '.mq-math-mode .mq-selection.mq-blur .mq-matrixed-container,\n' +
    '.mq-editable-field .mq-selection.mq-blur .mq-matrixed-container {\n' +
    "  filter: progid:DXImageTransform.Microsoft.Chroma(color='#D4D4D4') !important;\n" +
    '}\n' +
    '.mq-editable-field .mq-textarea,\n' +
    '.mq-math-mode .mq-textarea {\n' +
    '  position: relative;\n' +
    '  -webkit-user-select: text;\n' +
    '  -moz-user-select: text;\n' +
    '  user-select: text;\n' +
    '}\n' +
    '.mq-editable-field .mq-textarea *,\n' +
    '.mq-math-mode .mq-textarea *,\n' +
    '.mq-editable-field .mq-selectable,\n' +
    '.mq-math-mode .mq-selectable {\n' +
    '  -webkit-user-select: text;\n' +
    '  -moz-user-select: text;\n' +
    '  user-select: text;\n' +
    '  position: absolute;\n' +
    '  clip: rect(1em 1em 1em 1em);\n' +
    '  resize: none;\n' +
    '  width: 1px;\n' +
    '  height: 1px;\n' +
    '}\n' +
    '.mq-math-mode .mq-matrixed {\n' +
    '  background: white;\n' +
    '  display: -moz-inline-box;\n' +
    '  display: inline-block;\n' +
    '}\n' +
    '.mq-math-mode .mq-matrixed-container {\n' +
    "  filter: progid:DXImageTransform.Microsoft.Chroma(color='white');\n" +
    '  margin-top: -0.1em;\n' +
    '}\n' +
    '\n' +
    '/* Import only the bits of bootstrap needed for our components. Code\n' +
    'is not generated as css output unless actually referenced. */\n' +
    '/* Components we adopt from bootstrap. */\n' +
    '.caret {\n' +
    '  display: inline-block;\n' +
    '  width: 0;\n' +
    '  height: 0;\n' +
    '  margin-left: 2px;\n' +
    '  vertical-align: middle;\n' +
    '  border-top: 4px solid;\n' +
    '  border-right: 4px solid transparent;\n' +
    '  border-left: 4px solid transparent;\n' +
    '}\n' +
    '.dropdown {\n' +
    '  position: relative;\n' +
    '}\n' +
    '.dropdown-toggle:focus {\n' +
    '  outline: 0;\n' +
    '}\n' +
    '.dropdown-menu {\n' +
    '  position: absolute;\n' +
    '  top: 100%;\n' +
    '  left: 0;\n' +
    '  z-index: 1000;\n' +
    '  display: none;\n' +
    '  float: left;\n' +
    '  min-width: 160px;\n' +
    '  padding: 5px 0;\n' +
    '  margin: 2px 0 0;\n' +
    '  list-style: none;\n' +
    '  font-size: 14px;\n' +
    '  text-align: left;\n' +
    '  background-color: #fff;\n' +
    '  border: 1px solid #ccc;\n' +
    '  border: 1px solid rgba(0, 0, 0, 0.15);\n' +
    '  border-radius: 4px;\n' +
    '  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n' +
    '  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\n' +
    '  background-clip: padding-box;\n' +
    '}\n' +
    '.dropdown-menu.pull-right {\n' +
    '  right: 0;\n' +
    '  left: auto;\n' +
    '}\n' +
    '.dropdown-menu .divider {\n' +
    '  height: 1px;\n' +
    '  margin: 9px 0;\n' +
    '  overflow: hidden;\n' +
    '  background-color: #e5e5e5;\n' +
    '}\n' +
    '.dropdown-menu > li > a {\n' +
    '  display: block;\n' +
    '  padding: 3px 20px;\n' +
    '  clear: both;\n' +
    '  font-weight: normal;\n' +
    '  line-height: 1.42857143;\n' +
    '  color: #333333;\n' +
    '  white-space: nowrap;\n' +
    '}\n' +
    '.dropdown-menu > li > a:hover,\n' +
    '.dropdown-menu > li > a:focus {\n' +
    '  text-decoration: none;\n' +
    '  color: #262626;\n' +
    '  background-color: #f5f5f5;\n' +
    '}\n' +
    '.dropdown-menu > .active > a,\n' +
    '.dropdown-menu > .active > a:hover,\n' +
    '.dropdown-menu > .active > a:focus {\n' +
    '  color: #fff;\n' +
    '  text-decoration: none;\n' +
    '  outline: 0;\n' +
    '  background-color: #337ab7;\n' +
    '}\n' +
    '.dropdown-menu > .disabled > a,\n' +
    '.dropdown-menu > .disabled > a:hover,\n' +
    '.dropdown-menu > .disabled > a:focus {\n' +
    '  color: #777777;\n' +
    '}\n' +
    '.dropdown-menu > .disabled > a:hover,\n' +
    '.dropdown-menu > .disabled > a:focus {\n' +
    '  text-decoration: none;\n' +
    '  background-color: transparent;\n' +
    '  background-image: none;\n' +
    '  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);\n' +
    '  cursor: not-allowed;\n' +
    '}\n' +
    '.open > .dropdown-menu {\n' +
    '  display: block;\n' +
    '}\n' +
    '.open > a {\n' +
    '  outline: 0;\n' +
    '}\n' +
    '.dropdown-menu-right {\n' +
    '  left: auto;\n' +
    '  right: 0;\n' +
    '}\n' +
    '.dropdown-menu-left {\n' +
    '  left: 0;\n' +
    '  right: auto;\n' +
    '}\n' +
    '.dropdown-header {\n' +
    '  display: block;\n' +
    '  padding: 3px 20px;\n' +
    '  font-size: 12px;\n' +
    '  line-height: 1.42857143;\n' +
    '  color: #777777;\n' +
    '  white-space: nowrap;\n' +
    '}\n' +
    '.dropdown-backdrop {\n' +
    '  position: fixed;\n' +
    '  left: 0;\n' +
    '  right: 0;\n' +
    '  bottom: 0;\n' +
    '  top: 0;\n' +
    '  z-index: 990;\n' +
    '}\n' +
    '.pull-right > .dropdown-menu {\n' +
    '  right: 0;\n' +
    '  left: auto;\n' +
    '}\n' +
    '.dropup .caret,\n' +
    '.navbar-fixed-bottom .dropdown .caret {\n' +
    '  border-top: 0;\n' +
    '  border-bottom: 4px solid;\n' +
    '  content: "";\n' +
    '}\n' +
    '.dropup .dropdown-menu,\n' +
    '.navbar-fixed-bottom .dropdown .dropdown-menu {\n' +
    '  top: auto;\n' +
    '  bottom: 100%;\n' +
    '  margin-bottom: 2px;\n' +
    '}\n' +
    '@media (min-width: 768px) {\n' +
    '  .navbar-right .dropdown-menu {\n' +
    '    left: auto;\n' +
    '    right: 0;\n' +
    '  }\n' +
    '  .navbar-right .dropdown-menu-left {\n' +
    '    left: 0;\n' +
    '    right: auto;\n' +
    '  }\n' +
    '}\n' +
    '';

  /**
   * @fileOverview Sketchpad Web Application prototype main namespace.
   * @author <a href="mailto:mlitwin@kcptech.com">Matthew Litwin</a>
   * @version 0.0
   * @preserve Copyright © 2011 KCP Technologies, Inc. All rights reserved.
   */

  /**
   * noConflict similar to the jQuery version of that function
   * Takes GSP out of the global namespace, returning a reference
   * to the current GSP object
   *
   * @return {Object} curent GSP namespace
   *
   */
  GSP.noConflict = function() {
    if (window.GSP === GSP) {
      window.GSP = _GSP; // restore old version (if any).
    }

    return GSP;
  };

  // Add css if it isn't there yet.
  $(function() {
    var id = 'wsp-css-4-8-0';
    if ($('style#' + id).length === 0) {
      $('head').append(
        $('<style>')
          .attr({ id: id })
          .text(GSP.css)
      );
    }
  });

  if (typeof window.GSPConfig === 'undefined') {
    window.GSPConfig = {};
  }

  if (typeof window.GSPConfig.instances === 'undefined') {
    window.GSPConfig.instances = [];
  }

  window.GSPConfig.instances.push(GSP);

  // Last one loaded becomes global
  window.GSP = GSP;
})(window, jQuery /*, undefined */);
