import React from 'react';
import PropTypes from 'prop-types';
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { createMongoId, socket, useAppModal } from 'utils';
import { Room } from 'Model';
import { Button } from 'Components';

const STRATEGY = {
  INDEPENDENT: 'independent',
  DEFAULT: 'default',
};

export const controlStates = {
  NONE: 'NONE',
  ME: 'ME',
  OTHER: 'OTHER',
  REQUESTED: 'REQUESTED',
  CANCELLED_REQUEST: 'CANCELLED_REQUEST',
  SWITCHING_TABS: 'SWITCHING_TABS',
  RECEIVED_REQUEST: 'ME.requested',
  REQUEST_CANCELLED: 'ME.cancelled',
};

export const controlEvents = {
  CLICK: 'CLICK',
  MSG_RECEIVED: 'MSG_RECEIVED',
  MSG_TOOK_CONTROL: 'MSG_TOOK_CONTROL',
  MSG_RELEASED_CONTROL: 'MSG_RELEASED_CONTROL',
  MSG_RECEIVED_REQUEST: 'MSG_RECEIVED_REQUEST',
  MSG_REQUEST_CANCELLED: 'MSG_REQUEST_CANCELLED',
  RESET: 'RESET',
  SWITCH_TAB: 'SWITCH_TAB',
  TAKE_MORE_TIME: 'TAKE_MORE_TIME',
  SWITCH_STRATEGY: 'SWITCH_STRATEGY',
  CHANGE_USERNAME: 'CHANGE_USERNAME',
};

export const buttonConfigs = {
  [controlStates.NONE]: {
    text: 'Take Control',
    disabled: false,
  },
  [controlStates.ME]: {
    text: 'Release Control',
    disabled: false,
  },
  [controlStates.OTHER]: {
    text: 'Request Control',
    disabled: false,
  },
  [controlStates.REQUESTED]: {
    text: 'Cancel Request',
    disabled: false,
  },
  [controlStates.CANCELLED_REQUEST]: {
    text: 'Request Control',
    disabled: true,
  },
};
/** ***************************************************************
 * actions taken when certain events occur
 ***************************************************************** */
const iTakeControl = assign((context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} took control on tab #${event.tabNum}`
      : `${context.username} took control`,
    messageType: 'TOOK_CONTROL',
    autogenerated: true,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'TAKE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
  return { lastMessage: message };
});

const iReleaseControl = assign((context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} released control on tab #${event.tabNum}`
      : `${context.username} released control`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
  return { lastMessage: message };
});

const iTimeOut = assign((context) => {
  // @TODO: At this point, we cannot provide a tab number because that's not kept in the control machine context
  // Note that iTimeOut is called by the control machine, not via a sendEvent, so the 'event' parameter is always empty
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: `${context.username} control was released by system`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: '#f26247',
    timestamp: Date.now(),
  };
  socket.emit('RELEASE_CONTROL', message);
  return { lastMessage: message };
});

const iRequestControl = assign((context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Can I take control on tab #${event.tabNum}?`
      : 'Can I take control?',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'REQUEST_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
  return { lastMessage: message };
});

const otherTakesControl = () => {
  // nothing to do
};

const otherReleasesControl = () => {
  // nothing for me to do
};

const iCancelRequest = assign((context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Nevermind. I don't want control on tab #${event.tabNum}`
      : "Nevermind. I don't want control.",
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'CANCEL_REQUEST',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
  return { lastMessage: message };
});

const iTakeMoreTime = assign((context, event) => {
  const message = {
    _id: createMongoId(),
    text: 'I have requested one more minute to try an idea I have. Thank you.',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
  return { lastMessage: message };
});

const initialState = (context) => {
  // Figure out the initial state
  if (!context.controlledBy) return controlStates.NONE;
  if (context.controlledBy === context.userId) return controlStates.ME;
  return controlStates.OTHER;
};

const mainControlMachineSpec = (context) => {
  const initial = context.strategy;
  const defaultStrategy = defaultControlMachineSpec(context);
  const independentStrategy = independentTabControlMachineSpec(context);
  return [
    {
      predictableActionArguments: true,
      id: 'main',
      initial,
      context,
      on: {
        [controlEvents.CHANGE_USERNAME]: assign((_, event) => ({
          username: event.username,
        })),
      },
      states: {
        [STRATEGY.DEFAULT]: {
          id: STRATEGY.DEFAULT,
          entry: 'switchToDefault',
          initial: defaultStrategy[0].initial,
          on: {
            [controlEvents.SWITCH_STRATEGY]: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
            ...defaultStrategy[0].on,
          },
          states: defaultStrategy[0].states,
        },
        [STRATEGY.INDEPENDENT]: {
          id: STRATEGY.INDEPENDENT,
          entry: 'switchToIndependent',
          initial: independentStrategy[0].initial,
          on: {
            [controlEvents.SWITCH_STRATEGY]: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
            ...independentStrategy[0].on,
          },
          states: independentStrategy[0].states,
        },
      },
    },
    {
      actions: {
        switchToDefault: assign({
          controllers: null,
          strategy: STRATEGY.DEFAULT,
          restrictFlags: null,
        }),
        switchToIndependent: assign({
          controllers: {},
          restrictFlags: {},
          strategy: STRATEGY.INDEPENDENT,
        }),
        ...defaultStrategy[1].actions,
        ...independentStrategy[1].actions,
      },
    },
  ];
};

const defaultControlMachineSpec = (context) => {
  const initial = initialState(context);
  return [
    {
      predictableActionArguments: true,
      id: STRATEGY.DEFAULT,
      initial,
      context: { ...context, controllers: null, strategy: STRATEGY.DEFAULT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: {
          target: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
          actions: 'otherReleasesControl',
        },
        [controlEvents.MSG_TOOK_CONTROL]: {
          target: `#${STRATEGY.DEFAULT}.${controlStates.OTHER}`,
          actions: 'otherTakesControl',
        },
        [controlEvents.SWITCH_TAB]: { actions: 'switchingTabs' },
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.DEFAULT}.${controlStates.ME}`,
              actions: 'iTakeControl',
            },
          },
        },
        [controlStates.ME]: {
          initial: 'normal',
          states: {
            normal: {
              entry: 'controlledByMe',
              on: {
                [controlEvents.CLICK]: {
                  target: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
                  actions: 'iReleaseControl',
                },
                [controlEvents.RESET]: 'normal',
                [controlEvents.MSG_RECEIVED_REQUEST]: 'requested',
              },
              after: {
                60000: {
                  target: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
                  actions: 'iTimeOut',
                },
              },
            },
            requested: {
              on: {
                [controlEvents.CLICK]: {
                  target: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
                  actions: 'iReleaseControl',
                },
                [controlEvents.MSG_REQUEST_CANCELLED]: 'cancelled',
                [controlEvents.TAKE_MORE_TIME]: { actions: 'iTakeMoreTime' },
              },
              after: {
                60000: {
                  target: `#${STRATEGY.DEFAULT}.${controlStates.NONE}`,
                  actions: 'iTimeOut',
                },
              },
            },
            cancelled: {
              after: { 10: 'normal' },
            },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.DEFAULT}.${controlStates.REQUESTED}`,
              actions: 'iRequestControl',
            },
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.DEFAULT}.${controlStates.CANCELLED_REQUEST}`,
              actions: 'iCancelRequest',
            },
          },
          after: {
            60000: `#${STRATEGY.DEFAULT}.${controlStates.OTHER}`,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest',
          after: {
            60000: `#${STRATEGY.DEFAULT}.${controlStates.OTHER}`,
          },
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        iTakeMoreTime,
        controlledByMe: assign({
          inControl: controlStates.ME,
          controlledBy: (c) => c.userId,
          buttonConfig: buttonConfigs[controlStates.ME],
        }),
        controlledByOther: assign({
          inControl: controlStates.OTHER,
          controlledBy: (_, event) => event.id,
          buttonConfig: buttonConfigs[controlStates.OTHER],
        }),
        controlledByNone: assign({
          inControl: controlStates.NONE,
          controlledBy: null,
          buttonConfig: buttonConfigs[controlStates.NONE],
        }),
        controlRequested: assign({
          inControl: controlStates.OTHER,
          buttonConfig: buttonConfigs[controlStates.REQUESTED],
        }),
        cancelledRequest: assign({
          inControl: controlStates.OTHER,
          buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
        }),
        switchingTabs: assign({
          currentTabId: (_, event) => event.tab,
        }),
      },
    },
  ];
};

const independentTabControlMachineSpec = (context) => {
  const initial = initialState(context);
  return [
    {
      predictableActionArguments: true,
      id: STRATEGY.INDEPENDENT,
      initial,
      context: { ...context, strategy: STRATEGY.INDEPENDENT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
            actions: ['otherReleasesControl', 'storeNull'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeNull',
          },
        ],
        [controlEvents.MSG_TOOK_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: `#${STRATEGY.INDEPENDENT}.${controlStates.OTHER}`,
            actions: ['otherTakesControl', 'storeController'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeController',
          },
        ],
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone_ind',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.ME}`,
              actions: 'iTakeControl',
            },
            [controlEvents.SWITCH_TAB]: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
          },
        },
        [controlStates.ME]: {
          initial: 'normal',
          states: {
            normal: {
              entry: 'controlledByMe_ind',
              on: {
                [controlEvents.CLICK]: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
                  actions: 'iReleaseControl',
                },
                [controlEvents.RESET]: 'normal',
                [controlEvents.MSG_RECEIVED_REQUEST]: {
                  cond: (c, event) => c.currentTabId === event.tab,
                  target: 'requested',
                },
                [controlEvents.SWITCH_TAB]: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
                  actions: 'iReleaseControl', // @TODO: potentially different msg if released due to switching
                },
              },
              after: {
                60000: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
                  actions: 'iTimeOut',
                },
              },
            },
            requested: {
              on: {
                [controlEvents.CLICK]: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
                  actions: 'iReleaseControl',
                },
                [controlEvents.SWITCH_TAB]: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
                  actions: 'iReleaseControl', // @TODO: potentially different msg if released due to switching
                },
                [controlEvents.MSG_REQUEST_CANCELLED]: {
                  cond: (c, event) => c.currentTabId === event.tab,
                  target: 'cancelled',
                },
                [controlEvents.TAKE_MORE_TIME]: { actions: 'iTakeMoreTime' },
              },
              after: {
                60000: {
                  target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
                  actions: 'iTimeOut',
                },
              },
            },
            cancelled: {
              after: { 10: 'normal' },
            },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther_ind',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.REQUESTED}`,
              actions: 'iRequestControl',
            },
            [controlEvents.SWITCH_TAB]: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested_ind',
          on: {
            [controlEvents.CLICK]: {
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.CANCELLED_REQUEST}`,
              actions: 'iCancelRequest',
            },
            [controlEvents.SWITCH_TAB]: {
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
              actions: ['iCancelRequest', 'setRestrictFlag'], // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: `#${STRATEGY.INDEPENDENT}.${controlStates.OTHER}`,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest_ind',
          on: {
            [controlEvents.SWITCH_TAB]: {
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.SWITCHING_TABS}`,
              actions: 'setRestrictFlag', // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: `#${STRATEGY.INDEPENDENT}.${controlStates.OTHER}`,
          },
        },
        // Because we are switching tabs, we need to use the controllers
        // and restrictFlags to figure out what state to be in for the new tab
        [controlStates.SWITCHING_TABS]: {
          entry: 'switchingTabs',
          always: [
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                c.restrictFlags[c.currentTabId],
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.CANCELLED_REQUEST}`,
            },
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                !c.restrictFlags[c.currentTabId],
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.OTHER}`,
            },
            {
              cond: (c) => !c.controllers[c.currentTabId],
              target: `#${STRATEGY.INDEPENDENT}.${controlStates.NONE}`,
            },
          ],
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        iTakeMoreTime,
        storeNull: assign({
          controllers: (c, event) => ({
            ...c.controllers,
            [event.tab]: null,
          }),
        }),
        storeController: assign({
          controllers: (c, event) => ({
            ...c.controllers,
            [event.tab]: event.id,
          }),
        }),
        setRestrictFlag: assign({
          restrictFlags: (c) => ({
            ...c.restrictFlags,
            [c.currentTabId]: true,
          }),
        }),
        switchingTabs: assign({
          currentTabId: (_, event) => event.tab,
        }),
        controlledByMe_ind: assign({
          inControl: controlStates.ME,
          controlledBy: (c) => c.userId,
          controllers: (c) => ({
            ...c.controllers,
            [c.currentTabId]: null,
          }),
          buttonConfig: buttonConfigs[controlStates.ME],
        }),
        controlledByOther_ind: assign({
          inControl: controlStates.OTHER,
          controlledBy: (c) => c.controllers[c.currentTabId],
          buttonConfig: buttonConfigs[controlStates.OTHER],
        }),
        controlledByNone_ind: assign({
          inControl: controlStates.NONE,
          controlledBy: null,
          controllers: (c) => ({
            ...c.controllers,
            [c.currentTabId]: null,
          }),
          buttonConfig: buttonConfigs[controlStates.NONE],
        }),
        controlRequested_ind: assign({
          inControl: controlStates.OTHER,
          buttonConfig: buttonConfigs[controlStates.REQUESTED],
        }),
        cancelledRequest_ind: assign({
          inControl: controlStates.OTHER,
          buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
          restrictFlags: (c) => ({
            ...c.restrictFlags,
            [c.currentTabId]: false,
          }),
        }),
      },
    },
  ];
};

/**
 * @returns {Array} [state, send] - 'state' is the current state object. 'send' is a function that receives a control action.
 * Keys parts of state:
 *  - state.meta -- an object that can be handed to controlButton
 *  - state.value -- a string representing the state. Right now, matches with the legacy inControl, so can be used there.
 *
 * Ideally, state would also embed the 'controlledBy' state variable now maintained by Workspace (from the DB). This would allow
 * us to keep the control state in one place (the controlMachine).
 *
 */
export function useControlMachine(context, spec) {
  // use of the Ref prevents the re-creation of the machine, which causes a warning
  const controlMachineRef = React.useRef(null);
  if (!controlMachineRef.current)
    controlMachineRef.current = createMachine(...spec(context));

  const [state, send] = useMachine(controlMachineRef.current);

  const getControlledBy = (tabId) => {
    if (tabId === state.context.currentTabId || !state.context.controllers)
      return state.context.controlledBy;
    return state.context.controllers[tabId];
  };

  const getInControl = (tabId) => {
    if (tabId === state.context.currentTabId || !state.context.controllers)
      return state.context.inControl || controlStates.NONE;
    return state.context.controllers[tabId]
      ? controlStates.OTHER
      : controlStates.NONE;
  };

  return [
    {
      ...state,
      buttonConfig: state.context.buttonConfig,
      controlledBy: state.context.controlledBy,
      currentTabId: state.context.currentTabId,
      lastMessage: state.context.lastMessage,
      getControlledBy,
      getInControl,
    },
    send,
  ];
}

export function withControlMachine(Component) {
  const ControlMachine = (props) => {
    const { populatedRoom, user } = props;
    const strategy = React.useRef(
      Room.getRoomSetting(populatedRoom, Room.TAB_BASED_CONTROL)
        ? STRATEGY.INDEPENDENT
        : STRATEGY.DEFAULT
    );
    const [state, send] = useControlMachine(
      {
        userId: user._id,
        roomId: populatedRoom._id,
        username: user.username,
        controlledBy: populatedRoom.tabs[0].controlledBy,
        currentTabId: populatedRoom.tabs[0]._id,
        controllers: populatedRoom.tabs.reduce(
          (acc, tab) => ({ ...acc, [tab._id]: tab.controlledBy }),
          {}
        ),
        restrictFlags: {},
        lastMessage: null,
        strategy: strategy.current,
      },
      mainControlMachineSpec
    );

    const { hide, show } = useAppModal();

    const handleSettingsChanged = (room) => {
      const newStrategy = Room.getRoomSetting(room, Room.TAB_BASED_CONTROL)
        ? STRATEGY.INDEPENDENT
        : STRATEGY.DEFAULT;
      if (newStrategy !== strategy.current) {
        // Because there are only two strategies currently, we don't use the strategy event info
        send(controlEvents.SWITCH_STRATEGY, { strategy: newStrategy });
        strategy.current = newStrategy;
      }
    };

    React.useEffect(() => {
      socket.on('SETTINGS_CHANGED', handleSettingsChanged);
      return () =>
        socket.removeListener('SETTINGS_CHANGED', handleSettingsChanged);
    }, []);

    React.useEffect(() => {
      const receivedRequestStates = Object.values(STRATEGY).map(
        (strat) => `${strat}.${controlStates.RECEIVED_REQUEST}`
      );
      if (
        receivedRequestStates.some(state.matches) &&
        !receivedRequestStates.some(state.history.matches)
      )
        show(
          <div>
            <div>Control has been requested.</div>
            <br />
            <div>
              <Button
                m={5}
                click={() => {
                  send(controlEvents.CLICK);
                  hide();
                }}
              >
                Release Control
              </Button>
              <Button
                m={5}
                click={() => {
                  send(controlEvents.TAKE_MORE_TIME);
                  hide();
                }}
              >
                One more minute
              </Button>
            </div>
          </div>
        );
      else if (!receivedRequestStates.some(state.matches)) hide();
    }, [state.value]);

    return (
      <Component
        controlState={state}
        sendControlEvent={send}
        {...props}
        lastMessage={state.lastMessage}
      />
    );
  };

  ControlMachine.propTypes = {
    populatedRoom: PropTypes.shape({
      _id: PropTypes.string,
      controlledBy: PropTypes.string,
      tabs: PropTypes.arrayOf(
        PropTypes.shape({
          _id: PropTypes.string,
          controlledBy: PropTypes.string,
        })
      ),
      settings: PropTypes.shape({}),
    }).isRequired,
    user: PropTypes.shape({ _id: PropTypes.string, username: PropTypes.string })
      .isRequired,
  };

  return ControlMachine;
}
