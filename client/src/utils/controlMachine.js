import React from 'react';
import PropTypes from 'prop-types';
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { createMongoId, socket } from 'utils';

const STRATEGY = {
  INDEPENDENT: 'independent',
  DEFAULT: 'default',
};

export const controlStates = {
  NONE: 'NONE',
  ME: 'ME',
  OTHER: 'OTHER',
  REQUESTED: 'REQUESTED',
  CANCELLED_REQUEST: 'CANCELLED_REQUEST',
  RESTRICTED_NONE: 'RESTRICTED_NONE', // for future use
  RESTRICTED_OTHER: 'RESTRICTED_OTHER', // for future use
};

export const controlEvents = {
  CLICK: 'CLICK',
  MSG_RECEIVED: 'MSG_RECEIVED',
  MSG_TOOK_CONTROL: 'MSG_TOOK_CONTROL',
  MSG_RELEASED_CONTROL: 'MSG_RELEASED_CONTROL',
  RESET: 'RESET',
};

export const buttonConfigs = {
  [controlStates.NONE]: {
    text: 'Take Control',
    disabled: false,
  },
  [controlStates.ME]: {
    text: 'Release Control',
    disabled: false,
  },
  [controlStates.OTHER]: {
    text: 'Request Control',
    disabled: false,
  },
  [controlStates.REQUESTED]: {
    text: 'Cancel Request',
    disabled: false,
  },
  [controlStates.CANCELLED_REQUEST]: {
    text: 'Request Control',
    disabled: true,
  },
};
/** ***************************************************************
 * actions taken when certain events occur
 ***************************************************************** */
const iTakeControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} took control on tab #${event.tabNum}`
      : `${context.username} took control`,
    messageType: 'TOOK_CONTROL',
    autogenerated: true,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'TAKE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iReleaseControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} released control on tab #${event.tabNum}`
      : `${context.username} released control`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iTimeOut = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} control was released by system on tab #${event.tabNum}`
      : `${context.username} control was released by system`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iRequestControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Can I take control on tab #${event.tabNum}?`
      : 'Can I take control?',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const otherTakesControl = () => {
  // nothing to do
};

const otherReleasesControl = () => {
  // nothing for me to do
};

const iCancelRequest = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Nevermind. I don't want control on tab #${event.tabNum}`
      : "Nevermind. I don't want control.",
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const defaultControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context: { ...context, strategy: STRATEGY.DEFAULT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: {
          target: controlStates.NONE,
          actions: 'otherReleasesControl',
        },
        [controlEvents.MSG_TOOK_CONTROL]: {
          target: controlStates.OTHER,
          actions: 'otherTakesControl',
        },
        [controlEvents.SWITCH_TAB]: { actions: 'switchingTabs' },
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.ME,
              actions: 'iTakeControl',
            },
          },
        },
        [controlStates.ME]: {
          entry: 'controlledByMe',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.NONE,
              actions: 'iReleaseControl',
            },
            [controlEvents.RESET]: controlStates.ME,
          },
          after: {
            60000: { target: controlStates.NONE, actions: 'iTimeOut' },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.REQUESTED,
              actions: 'iRequestControl',
            },
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.CANCELLED_REQUEST,
              actions: 'iCancelRequest',
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest',
          after: {
            60000: controlStates.OTHER,
          },
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        controlledByMe: assign({
          controlledBy: (c) => c.userId,
          buttonConfig: buttonConfigs[controlStates.ME],
        }),
        controlledByOther: assign({
          controlledBy: (_, event) => event.id,
          buttonConfig: buttonConfigs[controlStates.OTHER],
        }),
        controlledByNone: assign({
          controlledBy: null,
          buttonConfig: buttonConfigs[controlStates.NONE],
        }),
        controlRequested: assign({
          buttonConfig: buttonConfigs[controlStates.REQUESTED],
        }),
        cancelledRequest: assign({
          buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
        }),
        switchingTabs: assign({
          currentTabId: (_, event) => event.tab,
        }),
      },
    },
  ];
};

const independentTabControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context: { ...context, strategy: STRATEGY.INDEPENDENT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: controlStates.NONE,
            actions: 'otherReleasesControl',
          },
          [controlEvents.MSG_TOOK_CONTROL]: {
            target: controlStates.OTHER,
            actions: 'otherTakesControl',
          },
        },
        states: {
          [controlStates.NONE]: {
            entry: 'controlledByNone',
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.ME,
                actions: 'iTakeControl',
              },
            },
          },
          [controlStates.ME]: {
            entry: 'controlledByMe',
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.NONE,
                actions: 'iReleaseControl',
              },
              [controlEvents.RESET]: controlStates.ME,
            },
            after: {
              60000: { target: controlStates.NONE, actions: 'iTimeOut' },
            },
          },
          [controlStates.OTHER]: {
            entry: 'controlledByOther',
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.REQUESTED,
                actions: 'iRequestControl',
              },
            },
          },
          [controlStates.REQUESTED]: {
            entry: 'controlRequested',
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.CANCELLED_REQUEST,
                actions: 'iCancelRequest',
              },
            },
            after: {
              60000: controlStates.OTHER,
            },
          },
          [controlStates.CANCELLED_REQUEST]: {
            entry: 'cancelledRequest',
            after: {
              60000: controlStates.OTHER,
            },
          },
        },
      },
      {
        actions: {
          iTakeControl,
          otherTakesControl,
          iReleaseControl,
          iTimeOut,
          iRequestControl,
          otherReleasesControl,
          iCancelRequest,
          controlledByMe: assign({
            controlledBy: (c) => c.userId,
            buttonConfig: buttonConfigs[controlStates.ME],
          }),
          controlledByOther: assign({
            controlledBy: (_, event) => event.id,
            buttonConfig: buttonConfigs[controlStates.OTHER],
          }),
          controlledByNone: assign({
            controlledBy: null,
            buttonConfig: buttonConfigs[controlStates.NONE],
          }),
          controlRequested: assign({
            buttonConfig: buttonConfigs[controlStates.REQUESTED],
          }),
          cancelledRequest: assign({
            buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
          }),
        },
      }
    );

  const [state, send] = useMachine(controlMachineRef.current);

  return [
    {
      ...state,
      inControl: state.value,
      buttonConfig: state.context.buttonConfig,
      controlledBy: state.context.controlledBy,
      currentTabId: state.context.currentTabId,
      controllers: state.context.controllers,
    },
    send,
  ];
}

export function withControlMachine(Component) {
  const ControlMachine = (props) => {
    const { populatedRoom, user } = props;
    const [state, send] = useControlMachine({
      userId: user._id,
      roomId: populatedRoom._id,
      username: user.username,
      controlledBy: populatedRoom.controlledBy,
    });
    // use context to send the state down to controlwarning
    return (
      <Component controlState={state} sendControlEvent={send} {...props} />
    );
  };

  ControlMachine.propTypes = {
    populatedRoom: PropTypes.shape({
      _id: PropTypes.string,
      controlledBy: PropTypes.string,
    }).isRequired,
    user: PropTypes.shape({ _id: PropTypes.string, username: PropTypes.string })
      .isRequired,
  };

  return ControlMachine;
}
