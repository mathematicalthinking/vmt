import React from 'react';
import PropTypes from 'prop-types';
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { createMongoId, socket } from 'utils';

export const controlStates = {
  NONE: 'NONE',
  ME: 'ME',
  OTHER: 'OTHER',
  REQUESTED: 'REQUESTED',
  RESTRICTED_NONE: 'RESTRICTED_NONE', // for future use
  RESTRICTED_OTHER: 'RESTRICTED_OTHER', // for future use
};

export const controlEvents = {
  CLICK: 'CLICK',
  MSG_RECEIVED: 'MSG_RECEIVED',
  MSG_TOOK_CONTROL: 'MSG_TOOK_CONTROL',
  MSG_RELEASED_CONTROL: 'MSG_RELEASED_CONTROL',
  RESET: 'RESET',
};

export const buttonConfigs = {
  [controlStates.NONE]: {
    text: 'Take Control',
    disabled: false,
  },
  [controlStates.ME]: {
    text: 'Release Control',
    disabled: false,
  },
  [controlStates.OTHER]: {
    text: 'Request Control',
    disabled: false,
  },
  [controlStates.REQUESTED]: {
    text: 'Cancel Request',
    disabled: false,
  },
};

/** ***************************************************************
 * actions taken when certain events occur
 ***************************************************************** */
const iTakeControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    text: `${context.username} took control`,
    messageType: 'TOOK_CONTROL',
    autogenerated: true,
    color: event.myColor || '#f26247',
    timestamp: new Date().getTime(),
  };
  socket.emit(
    'TAKE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iReleaseControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    text: `${context.username} released control`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: new Date().getTime(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iTimeOut = (context, event) => {
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    text: `${context.username} control was released by system`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: new Date().getTime(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iRequestControl = (context, event) => {
  const message = {
    _id: createMongoId(),
    text: 'Can I take control?',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    color: event.myColor || '#f26247',
    timestamp: new Date().getTime(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const otherTakesControl = () => {
  // nothing to do
};

const otherReleasesControl = () => {
  // nothing for me to do
};

const iCancelRequest = (context, event) => {
  const message = {
    _id: createMongoId(),
    text: "Nevermind. I don't want control.",
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    color: event.myColor || '#f26247',
    timestamp: new Date().getTime(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

/**
 * @returns {Array} [state, send] - 'state' is the current state object. 'send' is a function that receives a control action.
 * Keys parts of state:
 *  - state.meta -- an object that can be handed to controlButton
 *  - state.value -- a string representing the state. Right now, matches with the legacy inControl, so can be used there.
 *
 * Ideally, state would also embed the 'controlledBy' state variable now maintained by Workspace (from the DB). This would allow
 * us to keep the control state in one place (the controlMachine).
 *
 */
export function useControlMachine(context) {
  // Figure out the initial state
  let initial = controlStates.NONE;
  if (!context.controlledBy) initial = controlStates.NONE;
  else if (context.controlledBy === context.userId) initial = controlStates.ME;
  else initial = controlStates.OTHER;

  // use of the Ref prevents the re-creation of the machine, which causes a warning
  const controlMachineRef = React.useRef(null);
  if (!controlMachineRef.current)
    controlMachineRef.current = createMachine(
      {
        predictableActionArguments: true,
        id: 'control',
        initial,
        context,
        states: {
          [controlStates.NONE]: {
            entry: ['controlledByNone'],
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.ME,
                actions: 'iTakeControl',
              },
              [controlEvents.MSG_RECEIVED]: {
                target: controlStates.OTHER,
                actions: 'otherTakesControl',
              },
              [controlEvents.MSG_TOOK_CONTROL]: {
                target: controlStates.OTHER,
                actions: 'otherTakesControl',
              },
            },
          },
          [controlStates.ME]: {
            entry: ['controlledByMe'],
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.NONE,
                actions: 'iReleaseControl',
              },
              [controlEvents.RESET]: controlStates.ME,
              // These shouldn't happen, but might if there's a sync error
              [controlEvents.MSG_RELEASED_CONTROL]: {
                target: controlStates.NONE,
                actions: 'otherReleasesControl',
              },
              [controlEvents.MSG_TOOK_CONTROL]: {
                target: controlStates.OTHER,
                actions: 'otherTakesControl',
              },
            },
            after: {
              60000: { target: controlStates.NONE, actions: 'iTimeOut' },
            },
          },
          [controlStates.OTHER]: {
            entry: ['controlledByOther'],
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.REQUESTED,
                actions: 'iRequestControl',
              },
              [controlEvents.MSG_RECEIVED]: {
                target: controlStates.NONE,
                actions: 'otherReleasesControl',
              },
              [controlEvents.MSG_RELEASED_CONTROL]: {
                target: controlStates.NONE,
                actions: 'otherReleasesControl',
              },
              // This shouldn't happen but might if there's a sync error
              [controlEvents.MSG_TOOK_CONTROL]: {
                target: controlStates.OTHER,
                actions: 'otherTakesControl',
              },
            },
          },
          [controlStates.REQUESTED]: {
            entry: ['controlRequested'],
            on: {
              [controlEvents.CLICK]: {
                target: controlStates.OTHER,
                actions: 'iCancelRequest',
              },
              [controlEvents.MSG_RECEIVED]: {
                target: controlStates.NONE,
                actions: 'otherReleasesControl',
              },
              [controlEvents.MSG_RELEASED_CONTROL]: {
                target: controlStates.NONE,
                actions: 'otherReleasesControl',
              },
              // This shouldn't happen but might if there's a sync error
              [controlEvents.MSG_TOOK_CONTROL]: {
                target: controlStates.OTHER,
                actions: 'otherTakesControl',
              },
            },
            after: {
              60000: controlStates.OTHER,
            },
          },
        },
      },
      {
        actions: {
          iTakeControl,
          otherTakesControl,
          iReleaseControl,
          iTimeOut,
          iRequestControl,
          otherReleasesControl,
          iCancelRequest,
          controlledByMe: assign({
            controlledBy: (c) => c.userId,
            buttonConfig: buttonConfigs[controlStates.ME],
          }),
          controlledByOther: assign({
            controlledBy: (_, event) => event.id,
            buttonConfig: buttonConfigs[controlStates.OTHER],
          }),
          controlledByNone: assign({
            controlledBy: null,
            buttonConfig: buttonConfigs[controlStates.NONE],
          }),
          controlRequested: assign({
            buttonConfig: buttonConfigs[controlStates.REQUESTED],
          }),
        },
      }
    );

  const [state, send] = useMachine(controlMachineRef.current);

  return [
    {
      ...state,
      inControl: state.value,
      buttonConfig: state.context.buttonConfig,
      controlledBy: state.context.controlledBy,
    },
    send,
  ];
}

export function withControlMachine(Component) {
  const ControlMachine = (props) => {
    const { populatedRoom, user } = props;
    const [state, send] = useControlMachine({
      userId: user._id,
      roomId: populatedRoom._id,
      username: user.username,
      controlledBy: populatedRoom.controlledBy,
    });
    // use context to send the state down to controlwarning
    return (
      <Component controlState={state} sendControlEvent={send} {...props} />
    );
  };

  ControlMachine.propTypes = {
    populatedRoom: PropTypes.shape({
      _id: PropTypes.string,
      controlledBy: PropTypes.string,
    }).isRequired,
    user: PropTypes.shape({ _id: PropTypes.string, username: PropTypes.string })
      .isRequired,
  };

  return ControlMachine;
}
