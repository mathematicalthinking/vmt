const { ObjectId } = require('mongoose').Types;
// const cookie = require('cookie');
const socketInit = require('./socketInit');
const controllers = require('./controllers');
const Message = require('./models/Message');
const { socketMetricInc } = require('./services/metrics');

module.exports = function() {
  const { io } = socketInit;

  io.use((socket, next) => {
    // const cookief = socket.handshake.headers.cookie;
    // console.log(cookief);
    // const cookies = cookie.parse(cookief);
    // console.log(cookies);
    // @todo middleware after SSO is done

    next();
  });

  io.sockets.on('connection', (socket) => {
    socketMetricInc('connect');

    // io.sockets.adapter.on('join-room', (room, id) => {
    //   console.log('join-room', room, id);
    //   console.log('people in room', io.sockets.adapter.rooms.get(room));
    // });
    // io.sockets.adapter.on('leave-room', (room, id) =>
    //   console.log('leave-room', room, id)
    // );
    // console.log('socket connected: ', socket.id);

    socket.on('ping', (cb) => {
      if (typeof cb === 'function') cb();
    });

    // console.log(socket.getEventNames())

    // if the socket has a jwt cookie find the user and update their socket
    // should we try to detect if the socket is already associated with a user...if so we need to update users on socket disconnect and remove their socket id

    socket.on('JOIN_TEMP', async (data, callback) => {
      // now synchronous?
      socket.join(data.roomId);
      const joinUser = async () => {
        let user;
        const promises = [];
        // If the user is NOT logged in, create a temp user
        if (!data.userId) {
          try {
            user = await controllers.user.post({
              username: data.username,
              accountType: 'temp',
            });
          } catch (err) {
            console.log('Error creating user ', err);
          }
        } else {
          user = { _id: data.userId, username: data.username };
        }
        socket.user_id = user._id; // store the user id on the socket so we can tell who comes and who goes
        socket.username = user.username;
        const message = {
          _id: data._id,
          user: { _id: user._id, username: 'VMTbot' },
          room: data.roomId,
          messageType: 'JOINED_ROOM',
          text: `${data.username} joined ${data.roomName}`,
          color: data.color,
          autogenerated: true,
          timestamp: new Date().getTime(),
        };
        promises.push(controllers.messages.post(message));
        // If this is the user in the room, update the blank room created from "Try out a Workspace"
        // We will use the existance if the creator field to check if this is firstEntry on the front end
        if (data.firstEntry) {
          promises.push(
            controllers.tabs.put(data.tabId, { tabType: data.roomType })
          );
          promises.push(
            controllers.rooms.put(data.roomId, {
              roomType: data.roomType,
              name: data.roomName,
              // members: [{ user: user._id, role: "facilitator" }],
              // currentMembers: [user._id],
              creator: user._id,
            })
          );
        }
        promises.push(
          controllers.rooms.addCurrentUsers(data.roomId, ObjectId(user._id), {
            user: ObjectId(user._id),
            role: data.firstEntry ? 'facilitator' : 'participant',
            color: data.color,
          })
        );
        let results;
        try {
          results = await Promise.all(promises);
          socket.to(data.roomId).emit('USER_JOINED_TEMP', {
            currentMembers: results[results.length - 1].currentMembers,
            members: results[results.length - 1].members,
            message,
          });
          callback({ room: results[results.length - 1], message, user }, null);
        } catch (err) {
          console.log(err);
        }
      };
      joinUser();
    });

    socket.on('JOIN', async (data, cb) => {
      socketMetricInc('roomjoin');

      socket.user_id = data.userId; // store the user id on the socket so we can tell who comes and who goes
      socket.username = data.username;
      const user = { _id: data.userId, username: data.username };

      // tell sockets that this user (via the socket) has joined room roomId
      socket.join(data.roomId);

      // get a list of the users that the socket manager believes is within the room. This list is considered reality;
      // we force the DB to be consistent with whatever users are actually connected via Websockets. As a result,
      // if someone else disconnects due to a network issue (something the socket manager keeps track of), everyone's list
      // of current members will be made correct as soon as someone joins or leaves a room (see the 'leave' function below).
      //
      // NOTE: We do not use the socket manager's disconnect/connect function because sometimes disconnections are temporary.
      // If someone disconnnects and then reconnects quickly, we don't want them to be thrown out of a room. Instead, the DB
      // maintains the users in the room (and who is in control) until a join or leave event. That way, if a disconnection
      // and reconnection occurs quickly, none of the users notice.

      const users = await usersInRoom(data.roomId);

      const message = {
        _id: data._id,
        user: { _id: data.userId, username: 'VMTbot' },
        room: data.roomId,
        text: `${data.username} joined ${data.roomName}`,
        autogenerated: true,
        messageType: 'JOINED_ROOM',
        color: data.color,
        timestamp: new Date().getTime(),
      };
      try {
        const results = await Promise.all([
          controllers.messages.post(message),
          controllers.rooms.setCurrentUsers(data.roomId, users), // update the DB to be consistent with the sockets
        ]);
        socket.to(data.roomId).emit('USER_JOINED', {
          currentMembers: results[1].currentMembers,
          message,
        });
        return cb({ room: results[1], message, user }, null);
      } catch (err) {
        console.log('ERROR JOINING ROOM for user: ', data.userId, err);
        return cb(null, err);
      }
    });

    socket.on('disconnecting', (reason) => {
      socketMetricInc('disconnect');
      console.log(
        'socket disconnect from user: ',
        socket.user_id,
        ', ',
        new Date(),
        ', due to: ',
        reason,
        ', from rooms',
        socket.rooms
      );
    });

    socket.on('SYNC_SOCKET', (_id, cb) => {
      // check user state vs db state in case they were disconnected
      // check if user is still in room and needs to resubscribe to sockets
      socketMetricInc('sync');
      if (!_id) {
        // console.log('unknown user connected: ', socket.id);
        cb(null, 'NO USER');
        return;
      }
      socket.user_id = _id;
      controllers.user
        .put(_id, { socketId: socket.id })
        .then(() => {
          cb(`User socketId updated to ${socket.id}`, null);
        })
        .catch((err) => cb('Error found', err));
    });

    socket.on('SEND_MESSAGE', (data, callback) => {
      socketMetricInc('msgsend');
      const postData = { ...data };
      postData.user = postData.user._id;
      controllers.messages
        .post(postData)
        .then((res) => {
          socket.broadcast
            .to(data.room)
            .emit('RECEIVE_MESSAGE', { ...data, _id: res._id });
          callback(res, null);
        })
        .catch((err) => {
          callback('fail', err);
        });
    });

    socket.on('PENDING_MESSAGE', (data) => {
      socketMetricInc('msgpend');

      socket.broadcast.to(data.room).emit('PENDING_MESSAGE', { ...data });
    });

    socket.on('TAKE_CONTROL', async (data, callback) => {
      socketMetricInc('controltake');

      try {
        await Promise.all([
          controllers.messages.post(data),
          controllers.rooms.put(data.room, { controlledBy: data.user._id }),
        ]);
      } catch (err) {
        callback(err, null);
      }
      socket.to(data.room).emit('TOOK_CONTROL', data);
      controllers.rooms
        .getCurrentState(data.room)
        .then(() => {
          // socket.emit('FORCE_SYNC', room);
        })
        .catch((err) => {
          console.error(err);
          callback(err, null);
        });
    });

    socket.on('RELEASE_CONTROL', (data, callback) => {
      socketMetricInc('controlrelease');

      controllers.messages.post(data);
      controllers.rooms.put(data.room, { controlledBy: null });
      socket.to(data.room).emit('RELEASED_CONTROL', data);
      callback(null, {});
    });

    socket.on('SEND_EVENT', async (data, callback) => {
      socketMetricInc('eventsend');
      try {
        socket.broadcast.to(data.room).emit('RECEIVE_EVENT', data);
        await controllers.events.post(data);
        callback();
      } catch (err) {
        console.log('ERROR SENDING EVENT: ', err);
      }
    });

    socket.on('SWITCH_TAB', (data, callback) => {
      socketMetricInc('tabswitch');

      controllers.messages
        .post(data)
        .then(() => {
          socket.broadcast.to(data.room).emit('RECEIVE_MESSAGE', data);
          callback('success', null);
        })
        .catch((err) => {
          callback(null, err);
        });
    });

    socket.on('NEW_TAB', (data, callback) => {
      socketMetricInc('tabsnew');
      controllers.messages
        .post(data.message)
        .then(() => {
          socket.broadcast.to(data.message.room).emit('CREATED_TAB', data);
          callback('success');
        })
        .catch((err) => callback('fail', err));
    });

    socket.on('UPDATED_REFERENCES', (data) => {
      socketMetricInc('refupdated');
      const { roomId, updatedEvents } = data;
      console.log('emitting updating refs', roomId, updatedEvents);

      socket.broadcast
        .to(roomId)
        .emit('RECEIVED_UPDATED_REFERENCES', updatedEvents);
    });

    socket.on('RESET_ROOM', async (roomId, user) => {
      const message = new Message({
        user: { _id: user._id, username: 'VMTBot' },
        room: roomId,
        // @TODO if socket.username (set during join) is not reliable enough, could do a DB call to get the uername.
        text: `${user.username || 'Someone'} activated the force sync button`,
        autogenerated: true,
        messageType: 'RESET_ROOM',
        timestamp: new Date().getTime(),
      });

      message.save();
      socket.to(roomId).emit('RECEIVE_MESSAGE', message);

      await killZombies(roomId);

      // only emit message to user who did the reset
      socket.emit('RESET_COMPLETE');
    });

    socket.on('LEAVE_ROOM', (roomId, color, cb) => {
      socketMetricInc('roomleave');
      socket.leave(roomId);
      usersInRoom(roomId).then((users) => leaveRoom(roomId, users, color, cb));
    });
  });

  const killZombies = async (roomId) => {
    const roomInDb = await controllers.rooms.getPopulatedById(roomId, {
      events: false,
    });
    const usersInDb = roomInDb.currentMembers;
    const usersInSockets = await usersInRoom(roomId); // socket users
    const room = await controllers.rooms.setCurrentUsers(
      roomId,
      usersInSockets
    );

    // filter any users that are in db but not in sockets into differenceInUsers
    const differenceInUsers = usersInDb.filter(
      (user) =>
        // usersInDb ids are Objects, usersInSockets ids are strings
        !usersInSockets.includes(user._id.toString())
    );

    if (differenceInUsers.length) {
      differenceInUsers.forEach((prevUser) => {
        const message = new Message({
          room: roomId,
          user: { _id: prevUser._id, username: 'VMTBot' },
          text: `${prevUser.username} was removed by the system`,
          messageType: 'LEFT_ROOM',
          autogenerated: true,
          timestamp: new Date().getTime(),
        });

        message.save();

        socket.to(roomId).emit('RECEIVE_MESSAGE', message);
      });
    }

    const releasedControl =
      room.controlledBy &&
      !usersInSockets.includes(room.controlledBy.toString()); // parse to string because it is an objectId

    if (releasedControl) {
      // send message that room.controlledBy changed
      const prevUser = await controllers.user.getById(room.controlledBy);
      const message = new Message({
        room: roomId,
        user: { _id: prevUser._id, username: 'VMTBot' },
        text: `${prevUser.username} has disconnected; system removed control`,
        messageType: 'RELEASED_CONTROL',
        autogenerated: true,
        timestamp: new Date().getTime(),
      });
      message.save();
      socket.to(roomId).emit('RECEIVE_MESSAGE', message);
      controllers.rooms.put(roomId, { controlledBy: null });
    }

    return room;
  };

  const usersInRoom = async (roomId) => {
    const socketsInRoom = await io.in(roomId).fetchSockets();
    return socketsInRoom.map((socket) => socket.user_id).filter((_id) => !!_id); // ocassionally we get null socket.user_ids. Filter these out.
  };

  const leaveRoom = async (room, users, color, cb) => {
    controllers.rooms
      .setCurrentUsers(room, users)
      .then((res) => {
        const message = new Message({
          color,
          room,
          user: { _id: socket.user_id, username: 'VMTBot' },
          text: `${socket.username} left the room`,
          messageType: 'LEFT_ROOM',
          autogenerated: true,
          timestamp: new Date().getTime(),
        });
        // check whether the person alledgly in control is still in the room.
        const releasedControl =
          res.controlledBy && !users.includes(res.controlledBy.toString()); // parse to string because it is an objectId
        if (releasedControl) {
          controllers.rooms.put(room, { controlledBy: null });
        }
        message.save();
        socket.to(room).emit('USER_LEFT', {
          currentMembers: res.currentMembers,
          releasedControl,
          message,
        });
        if (cb) {
          cb('exited!', null);
        }
      })
      .catch((err) => {
        if (socket.user) {
          console.log(
            'ERROR LEAVING ROOM ',
            room,
            ' user: ',
            socket.user_id,
            ' socketid: ',
            socket.id
          );
        } else {
          console.log(
            'ERROR LEAVING ROOM ',
            room,
            ' user not found',
            ' socketid: ',
            socket.id
          );
        }
        if (cb) cb(null, err);
      });
  };
};
