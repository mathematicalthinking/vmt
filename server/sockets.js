const { ObjectId } = require('mongoose').Types;
const { hri } = require('human-readable-ids');
// const cookie = require('cookie');
const socketInit = require('./socketInit');
const controllers = require('./controllers');
const Message = require('./models/Message');
const { socketMetricInc } = require('./services/metrics');
const { findAllMatching } = require('./middleware/utils/helpers');
// const { forceUserLogout } = require('./middleware/admin');
const {
  redisActivityKey,
  redisClient,
  clearStaleSocketEntries,
} = require('./redis');

module.exports = function() {
  const { io } = socketInit;

  io.use((socket, next) => {
    clearStaleSocketEntries();
    next();
  });

  io.sockets.on('connection', (socket) => {
    socketMetricInc('connect');

    socket.on('ping', (cb) => {
      if (typeof cb === 'function') cb();
    });

    // if the socket has a jwt cookie find the user and update their socket
    // should we try to detect if the socket is already associated with a user...if so we need to update users on socket disconnect and remove their socket id

    socket.on('JOIN_TEMP', async (data, callback) => {
      // now synchronous?
      socket.join(data.roomId);
      const joinUser = async () => {
        let user;
        const promises = [];
        // If the user is NOT logged in, create a temp user
        if (!data.userId) {
          try {
            user = await controllers.user.post({
              username: data.username,
              accountType: 'temp',
            });
          } catch (err) {
            // eslint-disable-next-line no-console
            console.log('Error creating user ', err);
          }
        } else {
          user = { _id: data.userId, username: data.username };
        }
        socket.user_id = user._id; // store the user id on the socket so we can tell who comes and who goes
        socket.username = user.username;
        const message = {
          _id: data._id,
          user: { _id: user._id, username: 'VMTbot' },
          room: data.roomId,
          messageType: 'JOINED_ROOM',
          text: `${data.username} joined ${data.roomName}`,
          color: data.color,
          autogenerated: true,
          timestamp: Date.now(),
        };
        promises.push(controllers.messages.post(message));
        // If this is the user in the room, update the blank room created from "Try out a Workspace"
        // We will use the existance if the creator field to check if this is firstEntry on the front end
        if (data.firstEntry) {
          promises.push(
            controllers.tabs.put(data.tabId, { tabType: data.roomType })
          );
          promises.push(
            controllers.rooms.put(data.roomId, {
              roomType: data.roomType,
              name: data.roomName,
              // members: [{ user: user._id, role: "facilitator" }],
              // currentMembers: [user._id],
              creator: user._id,
            })
          );
        }
        promises.push(
          controllers.rooms.addCurrentMember(data.roomId, {
            _id: ObjectId(user._id),
            tab: data.tab,
            username: user.username,
          })
        );
        let results;
        try {
          results = await Promise.all(promises);
          socket.to(data.roomId).emit('USER_JOINED_TEMP', {
            currentMembers: results[results.length - 1].currentMembers,
            members: results[results.length - 1].members,
            message,
          });
          callback({ room: results[results.length - 1], message, user }, null);
        } catch (err) {
          // eslint-disable-next-line no-console
          console.log(err);
        }
      };
      joinUser();
    });

    socket.on('UPDATE_MEMBER', async ({ roomId, updatedMember }, cb) => {
      const room = await controllers.rooms.getById(roomId);
      if (!room) return;
      const { members } = room;
      const memberIndex = members.findIndex(
        (mem) => mem.user._id.toString() === updatedMember.user._id
      );
      if (memberIndex === -1) return; // this should never happen
      members[memberIndex] = updatedMember;

      await controllers.rooms.put(roomId, { members });

      if (cb) cb();
    });

    socket.on('JOIN', async (data, cb) => {
      socketMetricInc('roomjoin');
      const text = `USERNAME joined ${data.roomName}`;
      joinHelper(data, joinText(text), cb);
    });

    socket.on('JOIN_QUICKCHAT', async (data, cb) => {
      socketMetricInc('roomjoin-quickchat');
      const text = `QUICKCHAT: USERNAME joined ${data.roomName}`;
      joinHelper(data, joinText(text), cb);
    });

    const joinText = (text) => {
      return (username) => text.replace('USERNAME', username);
    };

    const joinHelper = async (data, textFcn, cb) => {
      socket.user_id = data.userId; // store the user id on the socket so we can tell who comes and who goes
      socket.username = data.username;

      // tell sockets that this user (via the socket) has joined room roomId
      socket.join(data.roomId);

      // get a list of the users that the socket manager believes is within the room. This list is considered reality;
      // we force the DB to be consistent with whatever users are actually connected via Websockets. As a result,
      // if someone else disconnects due to a network issue (something the socket manager keeps track of), everyone's list
      // of current members will be made correct as soon as someone joins or leaves a room (see the 'leave' function below).
      //
      // NOTE: We do not use the socket manager's disconnect/connect function because sometimes disconnections are temporary.
      // If someone disconnnects and then reconnects quickly, we don't want them to be thrown out of a room. Instead, the DB
      // maintains the users in the room (and who is in control) until a join or leave event. That way, if a disconnection
      // and reconnection occurs quickly, none of the users notice.

      try {
        const { room, releasedControl } = await killZombies(data.roomId);
        const showAliases = room.settings.displayAliasedUsernames || false;
        if (showAliases) {
          const newMembers = createAliases(room.members);
          if (newMembers !== room.members) {
            // if some of the members were assigned new aliases, update the database and
            // alert users already in a room
            room.members = newMembers;
            await controllers.rooms.put(room._id, { members: room.members });
            io.in(data.roomId).emit('RESET_COMPLETE');
          }

          data.username = room.members.find(
            (mem) => mem.user._id.toString() === data.userId.toString()
          ).alias;
        }
        const message = new Message({
          _id: data._id,
          user: { _id: data.userId, username: 'VMTbot' },
          room: data.roomId,
          text: textFcn(data.username),
          autogenerated: true,
          messageType: 'JOINED_ROOM',
          color: data.color,
          timestamp: Date.now(),
        });
        await message.save();

        const dataToReturn = {
          currentMembers: room.currentMembers,
          message,
          releasedControl,
          username: data.username,
          userId: data.userId,
        };
        socket.to(data.roomId).emit('USER_JOINED', dataToReturn);

        return cb(dataToReturn, null);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.log('ERROR JOINING ROOM for user: ', data.userId, err);
        return cb(null, err);
      }
    };

    socket.on('disconnecting', (reason) => {
      socketMetricInc('disconnect');
      socketMetricInc('disconnectionByUser', socket.user_id);
      console.log(
        'socket disconnect from user: ',
        socket.user_id,
        ', ',
        new Date(),
        ', due to: ',
        reason,
        ', from rooms',
        socket.rooms
      );

      if (reason === 'transport close') {
        disconnectFromRoom(socket);
        markSocketAsInactive(socket.user_id, socket.id);
        if (areAllSocketsInactive(socket.user_id)) forceLogout(socket.user_id);
      } else {
        if (socket.timer) clearTimeout(socket.timer);
        socket.timer = setTimeout(() => {
          disconnectFromRoom(socket);
          markSocketAsInactive(socket.user_id, socket.id);
          if (areAllSocketsInactive(socket.user_id))
            forceLogout(socket.user_id);
        }, 15000);
      }
    });

    const forceLogout = async (userId) => {
      try {
        const allSockets = await getAllSocketsForUser(userId);
        io.in(allSockets).emit('FORCED_LOGOUT');
        // forceUserLogout(userId, userId);
      } catch (error) {
        console.error(
          `Error forcing logout by user ${userId}: ${error.message}`
        );
      }
    };

    const getAllSocketsForUser = async (userId) => {
      const socketStates = await redisClient.hgetall(redisActivityKey(userId));
      return Object.keys(socketStates);
    };

    const areAllSocketsInactive = async (userId) => {
      const socketStates = await redisClient.hgetall(redisActivityKey(userId));
      return Object.values(socketStates).every((state) => state === 'inactive');
    };

    const markSocketAsInactive = (userId, socketId) => {
      redisClient.hset(redisActivityKey(userId), socketId, 'inactive');
    };

    const markSocketAsActive = (userId, socketId) => {
      redisClient.hset(redisActivityKey(userId), socketId, 'active');
    };

    socket.on('USER_ACTIVE', (userId) => {
      markSocketAsActive(userId, socket.id);
    });

    socket.on('USER_INACTIVE', async (userId) => {
      markSocketAsInactive(userId, socket.id);
      const areAllInactive = await areAllSocketsInactive(userId);
      if (areAllInactive) forceLogout(userId);
    });

    const disconnectFromRoom = (socket) => {
      const roomNames = Array.from(socket.rooms);

      const objectIdPattern = /^[0-9a-fA-F]{24}$/; // Regular expression for ObjectId

      const roomId = roomNames.find((roomName) =>
        objectIdPattern.test(roomName)
      );
      if (roomId) {
        socket.leave(roomId);
        const messageText = `${socket.username} exited unexpectedly from VMT`;
        leaveRoom(roomId, null, null, messageText);
      }
    };

    socket.on('reconnect', () => {
      if (socket.timer) {
        clearTimeout(socket.timer);
        socket.timer = null;
      }
    });

    socket.on('SYNC_SOCKET', (_id, cb) => {
      // check user state vs db state in case they were disconnected
      // check if user is still in room and needs to resubscribe to sockets
      socketMetricInc('sync');
      if (!_id) {
        // console.log('unknown user connected: ', socket.id);
        cb(null, 'NO USER ID GIVEN TO SYNC_SOCKET');
        return;
      }
      socket.user_id = _id;
      controllers.user
        .put(_id, { socketId: socket.id })
        .then(() => {
          cb(`User socketId updated to ${socket.id}`, null);
        })
        .catch((err) => cb('Error found', err));
      markSocketAsActive(socket.user_id, socket.id);
    });

    socket.on('disconnect', (socket) => {
      // Remove socket ID from Redis
      redisClient.hdel(redisActivityKey(socket.user_id), socket.id);
    });

    socket.on('SEND_MESSAGE', (data, callback) => {
      socketMetricInc('msgsend');
      const postData = { ...data };
      postData.user = postData.user._id;
      controllers.messages
        .post(postData)
        .then((res) => {
          socket.broadcast
            .to(data.room)
            .emit('RECEIVE_MESSAGE', { ...data, _id: res._id });
          callback(res, null);
        })
        .catch((err) => {
          callback('fail', err);
        });
    });

    socket.on('PENDING_MESSAGE', (data) => {
      socketMetricInc('msgpend');

      socket.broadcast.to(data.room).emit('PENDING_MESSAGE', { ...data });
    });

    socket.on('QUERY_CONTROLLERS', async (data) => {
      const room = await controllers.rooms.getById(data.room);
      if (!room) return; // We should alert the client that there is a problem

      const tabs = await Promise.all(
        room.tabs.map((tabId) => controllers.tabs.getById(tabId))
      );

      const tabControllers = tabs.reduce((acc, tab) => {
        acc[tab._id] = tab.controlledBy;
        return acc;
      }, {});

      io.in(data.room).emit('RESET_CONTROLLERS', tabControllers);
    });

    socket.on('TAKE_CONTROL', async (data, callback) => {
      socketMetricInc('controltake');

      try {
        await Promise.all([
          controllers.messages.post(data),
          controllers.tabs.put(data.tab, { controlledBy: data.user._id }),
        ]);
        if (callback) callback(null, 'Success');
      } catch (err) {
        if (callback) callback(err, null);
      }
      socket.to(data.room).emit('TOOK_CONTROL', data);
    });

    socket.on('RELEASE_CONTROL', (data, callback) => {
      socketMetricInc('controlrelease');

      controllers.messages.post(data);
      controllers.tabs.put(data.tab, { controlledBy: null });
      socket.to(data.room).emit('RELEASED_CONTROL', data);
      if (callback) callback(null, {});
    });

    socket.on('REQUEST_CONTROL', (data, callback) => {
      socketMetricInc('requestcontrol');

      controllers.messages.post(data);
      socket.to(data.room).emit('CONTROL_REQUESTED', data);
      if (callback) callback(null, {});
    });

    socket.on('CANCEL_REQUEST', (data, callback) => {
      socketMetricInc('cancelrequest');

      controllers.messages.post(data);
      socket.to(data.room).emit('REQUEST_CANCELLED', data);
      if (callback) callback(null, {});
    });

    socket.on('SEND_EVENT', async (data, lastEventId, callback) => {
      socketMetricInc('eventsend');
      try {
        socket.broadcast.to(data.room).emit('RECEIVE_EVENT', data, lastEventId);
        await controllers.events.post(data);
        if (callback) callback();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.log('ERROR SENDING EVENT: ', err);
      }
    });

    socket.on('SETTINGS_CHANGE', async (roomId, settings, callback) => {
      socketMetricInc('settingsChange');
      try {
        const room = await controllers.rooms.getById(roomId);
        const showAliases = settings.displayAliasedUsernames || false;
        room.members = showAliases ? createAliases(room.members) : room.members;

        const memberIds =
          room.members && room.members.map((mem) => mem.user._id);
        const users = await controllers.user.get({ _id: { $in: memberIds } });
        const message = new Message({
          user: { _id: socket.user_id, username: 'VMTBot' },
          room: roomId,
          text: 'Room settings were changed. All control released.',
          autogenerated: true,
          messageType: 'TEXT',
          timestamp: Date.now(),
        });

        await controllers.rooms.put(roomId, { members: room.members });

        message.save();
        io
          // so that all members get live updates of room settings, whether or not they are in a room
          .in(users.map((user) => user.socketId))
          .emit('SETTINGS_CHANGED', { roomId, settings });
        if (callback) callback();
      } catch (err) {
        // eslint-disable-next-line no-console
        console.log('ERROR CHANGING SETTINGS: ', err);
      }
    });

    socket.on('SWITCH_TAB', async (data, callback) => {
      socketMetricInc('tabswitch');

      const { newTabId, user, room } = data;

      // update the currentMembers array in the db
      // to reflect the new tab that the user is on
      // Room.currentMembers is an array of objects with _ids, usernames and tabIds
      // find the user in the array and update their tabId
      const currentMembersFromDb = await controllers.rooms.updateCurrentMemberTab(
        room,
        user._id,
        newTabId
      );

      data.currentMembers = currentMembersFromDb;

      try {
        await controllers.messages.post(data);
        socket.broadcast.to(room).emit('SWITCHED_TAB', data);
        socket.broadcast.to(room).emit('RECEIVE_MESSAGE', data);
        callback(currentMembersFromDb, null);
      } catch (err) {
        callback(null, err);
      }
    });

    socket.on('NEW_TAB', (data, callback) => {
      socketMetricInc('tabsnew');
      controllers.messages
        .post(data.message)
        .then(() => {
          socket.broadcast.to(data.message.room).emit('CREATED_TAB', data);
          callback('success');
        })
        .catch((err) => callback('fail', err));
    });

    socket.on('UPDATED_REFERENCES', (data) => {
      socketMetricInc('refupdated');
      const { roomId, updatedEvents } = data;

      socket.broadcast
        .to(roomId)
        .emit('RECEIVED_UPDATED_REFERENCES', updatedEvents);
    });

    socket.on('RESET_ROOM', async (roomId, user) => {
      const message = new Message({
        user: { _id: user._id, username: 'VMTBot' },
        room: roomId,
        // @TODO if socket.username (set during join) is not reliable enough, could do a DB call to get the uername.
        text: `${user.username || 'Someone'} activated the force sync button`,
        autogenerated: true,
        messageType: 'RESET_ROOM',
        timestamp: Date.now(),
      });

      message.save();
      socket.to(roomId).emit('RECEIVE_MESSAGE', message);

      await killZombies(roomId);

      // emit message to everyone
      io.in(roomId).emit('RESET_COMPLETE');
    });

    socket.on('LEAVE_ROOM', async (roomId, tabId, color, cb) => {
      socketMetricInc('roomleave');
      socket.leave(roomId);
      const messageText = `${socket.username} left the room`;
      leaveRoom(roomId, tabId, color, messageText, cb);
    });

    socket.on('LEAVE_ROOM_QUICKCHAT', (roomId, color, cb) => {
      socketMetricInc('roomleave_quickchatx');
      socket.leave(roomId);
      const messageText = `QUICKCHAT: ${socket.username} left the room`;
      leaveRoom(roomId, null, color, messageText, cb);
    });

    const killZombies = async (roomId) => {
      const roomInDb = await controllers.rooms.getPopulatedById(roomId, {
        events: false,
      });
      const currMemsInDb = roomInDb.currentMembers;
      const usersInSockets = await usersInRoom(roomId); // socket users

      // used to update the currentMembers array in the db
      // const currentUsers = [];

      const usersInDb = await controllers.user.get({
        _id: { $in: usersInSockets },
      });

      // get usernames for usersInSockets from the database
      // get Room Tab id for usersInSockets from the database
      // set currentUsers to an array of objects with _ids, usernames and tabIds

      const currentUsers = usersInDb.map((usr) => {
        // const usr = await controllers.user.getById(userId);
        const currentMember = roomInDb.currentMembers.find(
          (mem) => mem._id.toString() === usr._id.toString()
        );
        const tab =
          (currentMember && currentMember.tab) || roomInDb.tabs[0]._id;
        return {
          _id: usr._id,
          username: usr.username,
          tab,
        };
      });
      // const resolved = await Promise.all(promises);
      // currentUsers.push(...resolved);

      const room = await controllers.rooms.setCurrentMembers(
        roomId,
        currentUsers
      );

      // filter any users that are in db but not in sockets into differenceInUsers
      const differenceInUsers = currMemsInDb.filter(
        (user) =>
          // currMemsInDb ids are Objects, usersInSockets ids are strings
          user && user._id && !usersInSockets.includes(user._id.toString())
      );

      if (differenceInUsers.length) {
        differenceInUsers.forEach((prevUser) => {
          const username = getUsername(prevUser, roomInDb);
          const message = new Message({
            room: roomId,
            // note: NOT putting tab here because it's misleading; tab should be the current tab of the user when they were removed
            // rather than the current tab of the user leaving a room when another person was detected as a zombie.
            user: { _id: prevUser._id, username: 'VMTBot' },
            text: `${username} was removed by the system`,
            messageType: 'LEFT_ROOM',
            autogenerated: true,
            timestamp: Date.now(),
          });

          message.save();

          socket.to(roomId).emit('RECEIVE_MESSAGE', message);
        });
      }

      const releasedControl = roomInDb.tabs.filter(
        (tab) =>
          // parse to string because it is an objectId)
          tab.controlledBy &&
          !usersInSockets.includes(tab.controlledBy.toString())
      );

      await releasedControl.forEach(async (tab) => {
        const prevUser = await controllers.user.getById(tab.controlledBy);
        const username = getUsername(prevUser, roomInDb);
        const message = new Message({
          room: roomId,
          tab: tab._id,
          user: { _id: prevUser._id, username: 'VMTBot' },
          text: `${username} has disconnected; system removed control`,
          messageType: 'RELEASED_CONTROL',
          autogenerated: true,
          timestamp: Date.now(),
        });
        message.save();
        io.in(roomId).emit('RELEASED_CONTROL', message); // so that the person who does action gets message
        controllers.tabs.put(tab._id, { controlledBy: null });
      });

      return { room, releasedControl: releasedControl.map((tab) => tab._id) };
    };

    const getUsername = (currMember, room) => {
      const allMembers = room.members || [];
      // Note: This requires knowledge of how settings are represented.
      // On the client side, this knowledge has been abstracted by Model>Room.
      const showAliases =
        (room.settings && room.settings.displayAliasedUsernames) || false;
      const member = allMembers.find(
        (mem) => mem.user._id.toString() === currMember._id.toString()
      );
      if (!member) return currMember.username;

      return showAliases ? member.alias : member.user.username;
    };

    // Returns the users that are in roomId (across all nodes if necessary)
    const usersInRoom = async (roomId) => {
      const socketsInRoom = Array.from(await io.in(roomId).allSockets());
      const answer = await findAllMatching(
        controllers.user,
        ['socketId'],
        socketsInRoom
      );
      if (answer.length !== socketsInRoom.length)
        console.log(
          `There are ${socketsInRoom.length -
            answer.length} sockets with unknown users`
        );
      return (answer || []).map((user) => user._id.toString());
    };

    const leaveRoom = async (roomId, tabId, color, messageText, cb) => {
      try {
        // remove user before killing zombies to prevent killZombies from thinking the user to be removed is a zombie
        await controllers.rooms.removeCurrentMember(roomId, socket.user_id);
        const { releasedControl, room } = await killZombies(roomId);
        const message = new Message({
          color,
          room: roomId,
          tab: tabId,
          user: { _id: socket.user_id, username: 'VMTBot' },
          text: messageText,
          messageType: 'LEFT_ROOM',
          autogenerated: true,
          timestamp: Date.now(),
        });
        // check whether the person allegedly in control is still in the room.
        message.save();
        socket.to(roomId).emit('USER_LEFT', {
          currentMembers: room.currentMembers,
          releasedControl,
          message,
        });
        if (cb) {
          cb(
            {
              currentMembers: room.currentMembers,
              message,
              releasedControl,
            },
            null
          );
        }
      } catch (err) {
        console.log(err);
        if (socket.user_id) {
          // eslint-disable-next-line no-console
          console.log(
            'ERROR LEAVING ROOM ',
            roomId,
            ' user: ',
            socket.user_id,
            ' socketid: ',
            socket.id
          );
        } else {
          // eslint-disable-next-line no-console
          console.log(
            'ERROR LEAVING ROOM ',
            roomId,
            ' user not found',
            ' socketid: ',
            socket.id
          );
        }
        if (cb) cb(null, err);
      }
    };

    // hri format: adjective-animal-number
    // alias format: animal-number
    // eslint-disable-next-line class-methods-use-this, react/sort-comp
    const getUniqueAlias = (aliases) => {
      let newAlias = hri
        .random()
        .split('-')
        .splice(1, 2)
        .join('-');
      while (aliases.includes(newAlias)) {
        newAlias = hri
          .random()
          .split('-')
          .splice(1, 2)
          .join('-');
      }
      return newAlias;
    };

    const createAliases = (members) => {
      const membersNeedingAliases = members.filter((mem) => !mem.alias);
      const membersWithAliases = members.filter((mem) => mem.alias);
      if (membersNeedingAliases.length === 0) return members;

      membersNeedingAliases.forEach((member) => {
        member.alias = getUniqueAlias(
          membersWithAliases.map((mem) => mem.alias)
        );
        membersWithAliases.push(member);
      });

      return membersWithAliases;
    };
  });
};
